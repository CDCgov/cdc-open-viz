import { R as n, r as se } from "./storybook-index-45401197.es.js";
import { v as Cp, i as Eg, g as Sg } from "./storybook-getViewport-513ec896.es.js";
import { _ as ea, p as Ap, S as Li, U as qr, W as Wt, X as Lp, Y as Ac, Z as ar, t as Iu, $ as el, a0 as Fd, a1 as Pp, a2 as tr, a3 as Rp, a4 as kg, a5 as wg, l as Np, a6 as Sr, v as il, P as Tg, d as Cg, b as Jo, g as Dp, e as _p, h as Ag, y as Lg, R as Pg, a7 as hr, u as ol, a as Lc, x as Em, a8 as Yu, s as Rg, j as Yf, J as Sm, K as km, O as Gu, N as wm, H as Ng, C as Op, o as Dg, M as Tm, E as _g, q as Og, r as Cm, L as Fg, G as Mg, a9 as Pc, F as zg, B as Bg, I as Fp, D as Ig, z as $g, V as Hg, A as Vg } from "./storybook-InputToggle-1e77d9ab.es.js";
import { L as hf, u as Wg, p as jg, s as Ug, a as Kg, c as Yg } from "./storybook-coveUpdateWorker-4c7dbbf1.es.js";
import { B as Rc } from "./storybook-Button-63da743c.es.js";
import { a as Pn, f as Gf, t as Gg, b as os, L as Mp, S as zp, M as Md, D as Xg } from "./storybook-DataTable-897188ef.es.js";
import { H as Oi, T as qg } from "./storybook-index-3b47b3f7.es.js";
import { a as Va, E as Vr, b as mf, L as Zg } from "./storybook-viewports-5c5d7af1.es.js";
import { p as Qg, P as Me } from "./storybook-index-43433e35.es.js";
import { d as Jg } from "./storybook-debounce-cc216a80.es.js";
import { a as ev } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { _ as Je } from "./storybook-lodash-a4231e1c.es.js";
import { _ as vn } from "./storybook-extends-70f3d2a3.es.js";
import { s as fs, t as Am, a as Lm, b as Pm, B as Rr, d as Ls, c as Vn, C as tv } from "./storybook-linear-bc5fb9aa.es.js";
import { t as nv, u as Bp, G as et, c as Rn, q as Nc, v as rv, w as Rm, x as Ip, y as av, z as iv, A as ov, B as lv } from "./storybook-linear-ef79b404.es.js";
import { R as sv } from "./storybook-index-633d712d.es.js";
import { T as dt } from "./storybook-Text-c19e6344.es.js";
import { t as Nm, m as zd, f as Dm, d as Su, a as ku, b as wu, n as $p, o as uv, p as Hp, c as _m, e as Om } from "./storybook-year-24bd1dc7.es.js";
import { e as Ua, a as Mn, b as zn, c as Bn, d as In, A as Fi, D as Fm } from "./storybook-DataTransform-6163e156.es.js";
import { a as Ge, S as Mm } from "./storybook-Icon-4f5978ba.es.js";
import { B as Vp } from "./storybook-BlurStrokeText-adc27352.es.js";
import { T as ie } from "./storybook-Tooltip-4102bd69.es.js";
import { T as We, S as mt, C as Qe } from "./storybook-Inputs-b80d0cf3.es.js";
import { M as Wp } from "./storybook-MultiSelect-d587cce3.es.js";
import { I as Ka } from "./storybook-InputSelect-20478396.es.js";
import { A as Tu } from "./storybook-Accordion-2501c7d9.es.js";
import { f as Uo, F as jp, a as cv } from "./storybook-Filters-ce4a04a7.es.js";
import { n as Up } from "./storybook-numberFromString-24623c03.es.js";
const yf = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, dv = (e) => {
  const { updateConfig: t, config: r } = e, a = (o) => {
    o && o.preventDefault();
    let d = { ...r };
    delete d.newViz, t(d);
  }, i = {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: i }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ n.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ n.createElement(
    Rc,
    {
      className: "btn btn-primary",
      style: { margin: "1em auto" },
      disabled: yf(r),
      onClick: (o) => a(o)
    },
    "I'm Done"
  )));
}, Bd = ({ errorMessage: e }) => {
  const t = {
    position: "absolute",
    background: "white",
    zIndex: "999",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: t }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ n.createElement("p", null, e)));
}, Xu = Nm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Xu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Nm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : Xu);
Xu.range;
class Kp extends Map {
  constructor(t, r = hv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null)
      for (const [a, i] of t)
        this.set(a, i);
  }
  get(t) {
    return super.get(Yp(this, t));
  }
  has(t) {
    return super.has(Yp(this, t));
  }
  set(t, r) {
    return super.set(fv(this, t), r);
  }
  delete(t) {
    return super.delete(pv(this, t));
  }
}
function Yp({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : r;
}
function fv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : (e.set(a, r), r);
}
function pv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) && (r = e.get(a), e.delete(a)), r;
}
function hv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function mv(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var a = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(i); ++a < i; )
    o[a] = e + a * r;
  return o;
}
function yv(e, t, r, a, i, o) {
  const d = [
    [fs, 1, Su],
    [fs, 5, 5 * Su],
    [fs, 15, 15 * Su],
    [fs, 30, 30 * Su],
    [o, 1, ku],
    [o, 5, 5 * ku],
    [o, 15, 15 * ku],
    [o, 30, 30 * ku],
    [i, 1, wu],
    [i, 3, 3 * wu],
    [i, 6, 6 * wu],
    [i, 12, 12 * wu],
    [a, 1, $p],
    [a, 2, 2 * $p],
    [r, 1, uv],
    [t, 1, Hp],
    [t, 3, 3 * Hp],
    [e, 1, zd]
  ];
  function c(h, y, g) {
    const x = y < h;
    x && ([h, y] = [y, h]);
    const w = g && typeof g.range == "function" ? g : s(h, y, g), S = w ? w.range(h, +y + 1) : [];
    return x ? S.reverse() : S;
  }
  function s(h, y, g) {
    const x = Math.abs(y - h) / g, w = nv(([, , p]) => p).right(d, x);
    if (w === d.length)
      return e.every(Bp(h / zd, y / zd, g));
    if (w === 0)
      return Xu.every(Math.max(Bp(h, y, g), 1));
    const [S, A] = d[x / d[w - 1][2] < d[w][2] / x ? w - 1 : w];
    return S.every(A);
  }
  return [c, s];
}
const [gv, vv] = yv(Dm, Pm, Om, _m, Lm, Am), pt = se.createContext({}), xv = (e) => {
  const { children: t } = e, { config: r, currentViewport: a } = se.useContext(pt), i = () => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: d } = r;
    return (d.position === "bottom" || d.position === "top" || Va(a)) && (o = o.filter((c) => c !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  };
  return /* @__PURE__ */ n.createElement("div", { className: i() }, ...t);
};
var zi = [], bv = function() {
  return zi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Ev = function() {
  return zi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Gp = "ResizeObserver loop completed with undelivered notifications.", Sv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Gp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Gp), window.dispatchEvent(e);
}, Ss;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ss || (Ss = {}));
var Bi = function(e) {
  return Object.freeze(e);
}, zm = function() {
  function e(t, r) {
    this.inlineSize = t, this.blockSize = r, Bi(this);
  }
  return e;
}(), Bm = function() {
  function e(t, r, a, i) {
    return this.x = t, this.y = r, this.width = a, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Bi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, r = t.x, a = t.y, i = t.top, o = t.right, d = t.bottom, c = t.left, s = t.width, h = t.height;
    return { x: r, y: a, top: i, right: o, bottom: d, left: c, width: s, height: h };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Xf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Im = function(e) {
  if (Xf(e)) {
    var t = e.getBBox(), r = t.width, a = t.height;
    return !r && !a;
  }
  var i = e, o = i.offsetWidth, d = i.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, Xp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var r = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(r && e instanceof r.Element);
}, kv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ps = typeof window < "u" ? window : {}, Cu = /* @__PURE__ */ new WeakMap(), qp = /auto|scroll/, wv = /^tb|vertical/, Tv = /msie|trident/i.test(ps.navigator && ps.navigator.userAgent), Zr = function(e) {
  return parseFloat(e || "0");
}, rl = function(e, t, r) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = !1), new zm((r ? t : e) || 0, (r ? e : t) || 0);
}, Zp = Bi({
  devicePixelContentBoxSize: rl(),
  borderBoxSize: rl(),
  contentBoxSize: rl(),
  contentRect: new Bm(0, 0, 0, 0)
}), $m = function(e, t) {
  if (t === void 0 && (t = !1), Cu.has(e) && !t)
    return Cu.get(e);
  if (Im(e))
    return Cu.set(e, Zp), Zp;
  var r = getComputedStyle(e), a = Xf(e) && e.ownerSVGElement && e.getBBox(), i = !Tv && r.boxSizing === "border-box", o = wv.test(r.writingMode || ""), d = !a && qp.test(r.overflowY || ""), c = !a && qp.test(r.overflowX || ""), s = a ? 0 : Zr(r.paddingTop), h = a ? 0 : Zr(r.paddingRight), y = a ? 0 : Zr(r.paddingBottom), g = a ? 0 : Zr(r.paddingLeft), x = a ? 0 : Zr(r.borderTopWidth), w = a ? 0 : Zr(r.borderRightWidth), S = a ? 0 : Zr(r.borderBottomWidth), A = a ? 0 : Zr(r.borderLeftWidth), p = g + h, v = s + y, L = A + w, P = x + S, R = c ? e.offsetHeight - P - e.clientHeight : 0, C = d ? e.offsetWidth - L - e.clientWidth : 0, z = i ? p + L : 0, W = i ? v + P : 0, Z = a ? a.width : Zr(r.width) - z - C, ee = a ? a.height : Zr(r.height) - W - R, K = Z + p + C + L, le = ee + v + R + P, Y = Bi({
    devicePixelContentBoxSize: rl(Math.round(Z * devicePixelRatio), Math.round(ee * devicePixelRatio), o),
    borderBoxSize: rl(K, le, o),
    contentBoxSize: rl(Z, ee, o),
    contentRect: new Bm(g, s, Z, ee)
  });
  return Cu.set(e, Y), Y;
}, Hm = function(e, t, r) {
  var a = $m(e, r), i = a.borderBoxSize, o = a.contentBoxSize, d = a.devicePixelContentBoxSize;
  switch (t) {
    case Ss.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Ss.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, Vm = function() {
  function e(t) {
    var r = $m(t);
    this.target = t, this.contentRect = r.contentRect, this.borderBoxSize = Bi([r.borderBoxSize]), this.contentBoxSize = Bi([r.contentBoxSize]), this.devicePixelContentBoxSize = Bi([r.devicePixelContentBoxSize]);
  }
  return e;
}(), Wm = function(e) {
  if (Im(e))
    return 1 / 0;
  for (var t = 0, r = e.parentNode; r; )
    t += 1, r = r.parentNode;
  return t;
}, Cv = function() {
  var e = 1 / 0, t = [];
  zi.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var c = [];
      d.activeTargets.forEach(function(h) {
        var y = new Vm(h.target), g = Wm(h.target);
        c.push(y), h.lastReportedSize = Hm(h.target, h.observedBox), g < e && (e = g);
      }), t.push(function() {
        d.callback.call(d.observer, c, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var r = 0, a = t; r < a.length; r++) {
    var i = a[r];
    i();
  }
  return e;
}, Qp = function(e) {
  zi.forEach(function(r) {
    r.activeTargets.splice(0, r.activeTargets.length), r.skippedTargets.splice(0, r.skippedTargets.length), r.observationTargets.forEach(function(i) {
      i.isActive() && (Wm(i.target) > e ? r.activeTargets.push(i) : r.skippedTargets.push(i));
    });
  });
}, Av = function() {
  var e = 0;
  for (Qp(e); bv(); )
    e = Cv(), Qp(e);
  return Ev() && Sv(), e > 0;
}, Id, jm = [], Lv = function() {
  return jm.splice(0).forEach(function(e) {
    return e();
  });
}, Pv = function(e) {
  if (!Id) {
    var t = 0, r = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return Lv();
    }).observe(r, a), Id = function() {
      r.textContent = "".concat(t ? t-- : t++);
    };
  }
  jm.push(e), Id();
}, Rv = function(e) {
  Pv(function() {
    requestAnimationFrame(e);
  });
}, $u = 0, Nv = function() {
  return !!$u;
}, Dv = 250, _v = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Jp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], eh = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, $d = !1, Ov = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var r = this;
    if (t === void 0 && (t = Dv), !$d) {
      $d = !0;
      var a = eh(t);
      Rv(function() {
        var i = !1;
        try {
          i = Av();
        } finally {
          if ($d = !1, t = a - eh(), !Nv())
            return;
          i ? r.run(1e3) : t > 0 ? r.run(t) : r.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, r = function() {
      return t.observer && t.observer.observe(document.body, _v);
    };
    document.body ? r() : ps.addEventListener("DOMContentLoaded", r);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Jp.forEach(function(r) {
      return ps.addEventListener(r, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Jp.forEach(function(r) {
      return ps.removeEventListener(r, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), gf = new Ov(), th = function(e) {
  !$u && e > 0 && gf.start(), $u += e, !$u && gf.stop();
}, Fv = function(e) {
  return !Xf(e) && !kv(e) && getComputedStyle(e).display === "inline";
}, Mv = function() {
  function e(t, r) {
    this.target = t, this.observedBox = r || Ss.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Hm(this.target, this.observedBox, !0);
    return Fv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), zv = function() {
  function e(t, r) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = r;
  }
  return e;
}(), Au = /* @__PURE__ */ new WeakMap(), nh = function(e, t) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r].target === t)
      return r;
  return -1;
}, Lu = function() {
  function e() {
  }
  return e.connect = function(t, r) {
    var a = new zv(t, r);
    Au.set(t, a);
  }, e.observe = function(t, r, a) {
    var i = Au.get(t), o = i.observationTargets.length === 0;
    nh(i.observationTargets, r) < 0 && (o && zi.push(i), i.observationTargets.push(new Mv(r, a && a.box)), th(1), gf.schedule());
  }, e.unobserve = function(t, r) {
    var a = Au.get(t), i = nh(a.observationTargets, r), o = a.observationTargets.length === 1;
    i >= 0 && (o && zi.splice(zi.indexOf(a), 1), a.observationTargets.splice(i, 1), th(-1));
  }, e.disconnect = function(t) {
    var r = this, a = Au.get(t);
    a.observationTargets.slice().forEach(function(i) {
      return r.unobserve(t, i.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), Bv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Lu.connect(this, t);
  }
  return e.prototype.observe = function(t, r) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Xp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.observe(this, t, r);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Xp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Lu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Iv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Bv,
  ResizeObserverEntry: Vm,
  ResizeObserverSize: zm
}, Symbol.toStringTag, { value: "Module" })), $v = /* @__PURE__ */ ev(Iv);
var Ko = Ym, Ia = Km(Qg), Hv = Km(Jg), Yo = jv(se), Vv = $v, Wv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Um(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (Um = function(i) {
    return i ? r : t;
  })(e);
}
function jv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = Um(t);
  if (r && r.has(e))
    return r.get(e);
  var a = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(a, o, d) : a[o] = e[o];
    }
  return a.default = e, r && r.set(e, a), a;
}
function Km(e) {
  return e && e.__esModule ? e : { default: e };
}
function qu() {
  return qu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, qu.apply(this, arguments);
}
function Uv(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Kv = [];
function Ym(e) {
  var t = e.className, r = e.children, a = e.debounceTime, i = a === void 0 ? 300 : a, o = e.ignoreDimensions, d = o === void 0 ? Kv : o, c = e.parentSizeStyles, s = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, h = e.enableDebounceLeadingCall, y = h === void 0 ? !0 : h, g = Uv(e, Wv), x = (0, Yo.useRef)(null), w = (0, Yo.useRef)(0), S = (0, Yo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), A = S[0], p = S[1], v = (0, Yo.useMemo)(function() {
    var L = Array.isArray(d) ? d : [d];
    return (0, Hv.default)(function(P) {
      p(function(R) {
        var C = Object.keys(R), z = C.filter(function(Z) {
          return R[Z] !== P[Z];
        }), W = z.every(function(Z) {
          return L.includes(Z);
        });
        return W ? R : P;
      });
    }, i, {
      leading: y
    });
  }, [i, y, d]);
  return (0, Yo.useEffect)(function() {
    var L = new Vv.ResizeObserver(function(P) {
      P === void 0 && (P = []), P.forEach(function(R) {
        var C = R.contentRect, z = C.left, W = C.top, Z = C.width, ee = C.height;
        w.current = window.requestAnimationFrame(function() {
          v({
            width: Z,
            height: ee,
            top: W,
            left: z
          });
        });
      });
    });
    return x.current && L.observe(x.current), function() {
      window.cancelAnimationFrame(w.current), L.disconnect(), v != null && v.cancel && v.cancel();
    };
  }, [v]), /* @__PURE__ */ Yo.default.createElement("div", qu({
    style: s,
    ref: x,
    className: t
  }, g), r(qu({}, A, {
    ref: x.current,
    resize: v
  })));
}
Ym.propTypes = {
  className: Ia.default.string,
  debounceTime: Ia.default.number,
  enableDebounceLeadingCall: Ia.default.bool,
  ignoreDimensions: Ia.default.oneOfType([Ia.default.any, Ia.default.arrayOf(Ia.default.any)]),
  children: Ia.default.func.isRequired
};
var Hd = /* @__PURE__ */ new Date(), Vd = /* @__PURE__ */ new Date();
function va(e, t, r, a) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, i.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, i.round = function(o) {
    var d = i(o), c = i.ceil(o);
    return o - d < c - o ? d : c;
  }, i.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, i.range = function(o, d, c) {
    var s = [], h;
    if (o = i.ceil(o), c = c == null ? 1 : Math.floor(c), !(o < d) || !(c > 0))
      return s;
    do
      s.push(h = /* @__PURE__ */ new Date(+o)), t(o, c), e(o);
    while (h < o && o < d);
    return s;
  }, i.filter = function(o) {
    return va(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, c) {
      if (d >= d)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --c >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, r && (i.count = function(o, d) {
    return Hd.setTime(+o), Vd.setTime(+d), e(Hd), e(Vd), Math.floor(r(Hd, Vd));
  }, i.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(a ? function(d) {
      return a(d) % o === 0;
    } : function(d) {
      return i.count(0, d) % o === 0;
    }) : i;
  }), i;
}
const Yv = 1e3, qf = Yv * 60, Gv = qf * 60, Zf = Gv * 24, Gm = Zf * 7;
var Xm = va(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * qf) / Zf,
  (e) => e.getDate() - 1
);
const qm = Xm;
Xm.range;
function ji(e) {
  return va(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setDate(t.getDate() + r * 7);
  }, function(t, r) {
    return (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * qf) / Gm;
  });
}
var Zm = ji(0), Zu = ji(1), Xv = ji(2), qv = ji(3), ll = ji(4), Zv = ji(5), Qv = ji(6);
Zm.range;
Zu.range;
Xv.range;
qv.range;
ll.range;
Zv.range;
Qv.range;
var Qf = va(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Qf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setFullYear(t.getFullYear() + r * e);
  });
};
const ks = Qf;
Qf.range;
var Qm = va(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / Zf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const Jm = Qm;
Qm.range;
function Ui(e) {
  return va(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, function(t, r) {
    return (r - t) / Gm;
  });
}
var ey = Ui(0), Qu = Ui(1), Jv = Ui(2), ex = Ui(3), sl = Ui(4), tx = Ui(5), nx = Ui(6);
ey.range;
Qu.range;
Jv.range;
ex.range;
sl.range;
tx.range;
nx.range;
var Jf = va(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
Jf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCFullYear(t.getUTCFullYear() + r * e);
  });
};
const ws = Jf;
Jf.range;
function ty(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function rh(e) {
  let t = e, r = e;
  e.length === 1 && (t = (d, c) => e(d) - c, r = rx(e));
  function a(d, c, s, h) {
    for (s == null && (s = 0), h == null && (h = d.length); s < h; ) {
      const y = s + h >>> 1;
      r(d[y], c) < 0 ? s = y + 1 : h = y;
    }
    return s;
  }
  function i(d, c, s, h) {
    for (s == null && (s = 0), h == null && (h = d.length); s < h; ) {
      const y = s + h >>> 1;
      r(d[y], c) > 0 ? h = y : s = y + 1;
    }
    return s;
  }
  function o(d, c, s, h) {
    s == null && (s = 0), h == null && (h = d.length);
    const y = a(d, c, s, h - 1);
    return y > s && t(d[y - 1], c) > -t(d[y], c) ? y - 1 : y;
  }
  return { left: a, center: o, right: i };
}
function rx(e) {
  return (t, r) => ty(e(t), r);
}
function* ax(e, t) {
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (yield r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (a = +a) >= a && (yield a);
  }
}
function ix(e, t) {
  let r = 0, a, i = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (a = d - i, i += a / ++r, o += a * (d - i));
  else {
    let d = -1;
    for (let c of e)
      (c = t(c, ++d, e)) != null && (c = +c) >= c && (a = c - i, i += a / ++r, o += a * (c - i));
  }
  if (r > 1)
    return o / (r - 1);
}
function ox(e, t) {
  const r = ix(e, t);
  return r && Math.sqrt(r);
}
function Ju(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function vf(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function ny(e, t, r = 0, a = e.length - 1, i = ty) {
  for (; a > r; ) {
    if (a - r > 600) {
      const s = a - r + 1, h = t - r + 1, y = Math.log(s), g = 0.5 * Math.exp(2 * y / 3), x = 0.5 * Math.sqrt(y * g * (s - g) / s) * (h - s / 2 < 0 ? -1 : 1), w = Math.max(r, Math.floor(t - h * g / s + x)), S = Math.min(a, Math.floor(t + (s - h) * g / s + x));
      ny(e, t, w, S, i);
    }
    const o = e[t];
    let d = r, c = a;
    for (ls(e, r, t), i(e[a], o) > 0 && ls(e, r, a); d < c; ) {
      for (ls(e, d, c), ++d, --c; i(e[d], o) < 0; )
        ++d;
      for (; i(e[c], o) > 0; )
        --c;
    }
    i(e[r], o) === 0 ? ls(e, r, c) : (++c, ls(e, c, a)), c <= t && (r = c + 1), t <= c && (a = c - 1);
  }
  return e;
}
function ls(e, t, r) {
  const a = e[t];
  e[t] = e[r], e[r] = a;
}
function Ts(e, t, r) {
  if (e = Float64Array.from(ax(e, r)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return vf(e);
    if (t >= 1)
      return Ju(e);
    var a, i = (a - 1) * t, o = Math.floor(i), d = Ju(ny(e, o).subarray(0, o + 1)), c = vf(e.subarray(o + 1));
    return d + (c - d) * (i - o);
  }
}
function lx(e, t) {
  let r = 0, a = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++r, a += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++r, a += o);
  }
  if (r)
    return a / r;
}
function ry(e, t) {
  return Ts(e, 0.5, t);
}
function Wd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function jd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ss(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function sx(e) {
  var t = e.dateTime, r = e.date, a = e.time, i = e.periods, o = e.days, d = e.shortDays, c = e.months, s = e.shortMonths, h = us(i), y = cs(i), g = us(o), x = cs(o), w = us(d), S = cs(d), A = us(c), p = cs(c), v = us(s), L = cs(s), P = {
    a: ne,
    A: Q,
    b: V,
    B: j,
    c: null,
    d: uh,
    e: uh,
    f: Nx,
    g: Hx,
    G: Wx,
    H: Lx,
    I: Px,
    j: Rx,
    L: ay,
    m: Dx,
    M: _x,
    p: te,
    q: U,
    Q: fh,
    s: ph,
    S: Ox,
    u: Fx,
    U: Mx,
    V: zx,
    w: Bx,
    W: Ix,
    x: null,
    X: null,
    y: $x,
    Y: Vx,
    Z: jx,
    "%": dh
  }, R = {
    a: ue,
    A: ke,
    b: xe,
    B: be,
    c: null,
    d: ch,
    e: ch,
    f: Gx,
    g: ab,
    G: ob,
    H: Ux,
    I: Kx,
    j: Yx,
    L: oy,
    m: Xx,
    M: qx,
    p: Ae,
    q: Ye,
    Q: fh,
    s: ph,
    S: Zx,
    u: Qx,
    U: Jx,
    V: eb,
    w: tb,
    W: nb,
    x: null,
    X: null,
    y: rb,
    Y: ib,
    Z: lb,
    "%": dh
  }, C = {
    a: K,
    A: le,
    b: Y,
    B: ae,
    c: B,
    d: lh,
    e: lh,
    f: wx,
    g: oh,
    G: ih,
    H: sh,
    I: sh,
    j: bx,
    L: kx,
    m: xx,
    M: Ex,
    p: ee,
    q: vx,
    Q: Cx,
    s: Ax,
    S: Sx,
    u: px,
    U: hx,
    V: mx,
    w: fx,
    W: yx,
    x: X,
    X: ce,
    y: oh,
    Y: ih,
    Z: gx,
    "%": Tx
  };
  P.x = z(r, P), P.X = z(a, P), P.c = z(t, P), R.x = z(r, R), R.X = z(a, R), R.c = z(t, R);
  function z(Pe, ye) {
    return function(Re) {
      var fe = [], ze = -1, Ne = 0, qe = Pe.length, He, Be, Ze;
      for (Re instanceof Date || (Re = /* @__PURE__ */ new Date(+Re)); ++ze < qe; )
        Pe.charCodeAt(ze) === 37 && (fe.push(Pe.slice(Ne, ze)), (Be = ah[He = Pe.charAt(++ze)]) != null ? He = Pe.charAt(++ze) : Be = He === "e" ? " " : "0", (Ze = ye[He]) && (He = Ze(Re, Be)), fe.push(He), Ne = ze + 1);
      return fe.push(Pe.slice(Ne, ze)), fe.join("");
    };
  }
  function W(Pe, ye) {
    return function(Re) {
      var fe = ss(1900, void 0, 1), ze = Z(fe, Pe, Re += "", 0), Ne, qe;
      if (ze != Re.length)
        return null;
      if ("Q" in fe)
        return new Date(fe.Q);
      if ("s" in fe)
        return new Date(fe.s * 1e3 + ("L" in fe ? fe.L : 0));
      if (ye && !("Z" in fe) && (fe.Z = 0), "p" in fe && (fe.H = fe.H % 12 + fe.p * 12), fe.m === void 0 && (fe.m = "q" in fe ? fe.q : 0), "V" in fe) {
        if (fe.V < 1 || fe.V > 53)
          return null;
        "w" in fe || (fe.w = 1), "Z" in fe ? (Ne = jd(ss(fe.y, 0, 1)), qe = Ne.getUTCDay(), Ne = qe > 4 || qe === 0 ? Qu.ceil(Ne) : Qu(Ne), Ne = Jm.offset(Ne, (fe.V - 1) * 7), fe.y = Ne.getUTCFullYear(), fe.m = Ne.getUTCMonth(), fe.d = Ne.getUTCDate() + (fe.w + 6) % 7) : (Ne = Wd(ss(fe.y, 0, 1)), qe = Ne.getDay(), Ne = qe > 4 || qe === 0 ? Zu.ceil(Ne) : Zu(Ne), Ne = qm.offset(Ne, (fe.V - 1) * 7), fe.y = Ne.getFullYear(), fe.m = Ne.getMonth(), fe.d = Ne.getDate() + (fe.w + 6) % 7);
      } else
        ("W" in fe || "U" in fe) && ("w" in fe || (fe.w = "u" in fe ? fe.u % 7 : "W" in fe ? 1 : 0), qe = "Z" in fe ? jd(ss(fe.y, 0, 1)).getUTCDay() : Wd(ss(fe.y, 0, 1)).getDay(), fe.m = 0, fe.d = "W" in fe ? (fe.w + 6) % 7 + fe.W * 7 - (qe + 5) % 7 : fe.w + fe.U * 7 - (qe + 6) % 7);
      return "Z" in fe ? (fe.H += fe.Z / 100 | 0, fe.M += fe.Z % 100, jd(fe)) : Wd(fe);
    };
  }
  function Z(Pe, ye, Re, fe) {
    for (var ze = 0, Ne = ye.length, qe = Re.length, He, Be; ze < Ne; ) {
      if (fe >= qe)
        return -1;
      if (He = ye.charCodeAt(ze++), He === 37) {
        if (He = ye.charAt(ze++), Be = C[He in ah ? ye.charAt(ze++) : He], !Be || (fe = Be(Pe, Re, fe)) < 0)
          return -1;
      } else if (He != Re.charCodeAt(fe++))
        return -1;
    }
    return fe;
  }
  function ee(Pe, ye, Re) {
    var fe = h.exec(ye.slice(Re));
    return fe ? (Pe.p = y.get(fe[0].toLowerCase()), Re + fe[0].length) : -1;
  }
  function K(Pe, ye, Re) {
    var fe = w.exec(ye.slice(Re));
    return fe ? (Pe.w = S.get(fe[0].toLowerCase()), Re + fe[0].length) : -1;
  }
  function le(Pe, ye, Re) {
    var fe = g.exec(ye.slice(Re));
    return fe ? (Pe.w = x.get(fe[0].toLowerCase()), Re + fe[0].length) : -1;
  }
  function Y(Pe, ye, Re) {
    var fe = v.exec(ye.slice(Re));
    return fe ? (Pe.m = L.get(fe[0].toLowerCase()), Re + fe[0].length) : -1;
  }
  function ae(Pe, ye, Re) {
    var fe = A.exec(ye.slice(Re));
    return fe ? (Pe.m = p.get(fe[0].toLowerCase()), Re + fe[0].length) : -1;
  }
  function B(Pe, ye, Re) {
    return Z(Pe, t, ye, Re);
  }
  function X(Pe, ye, Re) {
    return Z(Pe, r, ye, Re);
  }
  function ce(Pe, ye, Re) {
    return Z(Pe, a, ye, Re);
  }
  function ne(Pe) {
    return d[Pe.getDay()];
  }
  function Q(Pe) {
    return o[Pe.getDay()];
  }
  function V(Pe) {
    return s[Pe.getMonth()];
  }
  function j(Pe) {
    return c[Pe.getMonth()];
  }
  function te(Pe) {
    return i[+(Pe.getHours() >= 12)];
  }
  function U(Pe) {
    return 1 + ~~(Pe.getMonth() / 3);
  }
  function ue(Pe) {
    return d[Pe.getUTCDay()];
  }
  function ke(Pe) {
    return o[Pe.getUTCDay()];
  }
  function xe(Pe) {
    return s[Pe.getUTCMonth()];
  }
  function be(Pe) {
    return c[Pe.getUTCMonth()];
  }
  function Ae(Pe) {
    return i[+(Pe.getUTCHours() >= 12)];
  }
  function Ye(Pe) {
    return 1 + ~~(Pe.getUTCMonth() / 3);
  }
  return {
    format: function(Pe) {
      var ye = z(Pe += "", P);
      return ye.toString = function() {
        return Pe;
      }, ye;
    },
    parse: function(Pe) {
      var ye = W(Pe += "", !1);
      return ye.toString = function() {
        return Pe;
      }, ye;
    },
    utcFormat: function(Pe) {
      var ye = z(Pe += "", R);
      return ye.toString = function() {
        return Pe;
      }, ye;
    },
    utcParse: function(Pe) {
      var ye = W(Pe += "", !0);
      return ye.toString = function() {
        return Pe;
      }, ye;
    }
  };
}
var ah = { "-": "", _: " ", 0: "0" }, Un = /^\s*\d+/, ux = /^%/, cx = /[\\^$*+?|[\]().{}]/g;
function Yt(e, t, r) {
  var a = e < 0 ? "-" : "", i = (a ? -e : e) + "", o = i.length;
  return a + (o < r ? new Array(r - o + 1).join(t) + i : i);
}
function dx(e) {
  return e.replace(cx, "\\$&");
}
function us(e) {
  return new RegExp("^(?:" + e.map(dx).join("|") + ")", "i");
}
function cs(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function fx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.w = +a[0], r + a[0].length) : -1;
}
function px(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.u = +a[0], r + a[0].length) : -1;
}
function hx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.U = +a[0], r + a[0].length) : -1;
}
function mx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.V = +a[0], r + a[0].length) : -1;
}
function yx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.W = +a[0], r + a[0].length) : -1;
}
function ih(e, t, r) {
  var a = Un.exec(t.slice(r, r + 4));
  return a ? (e.y = +a[0], r + a[0].length) : -1;
}
function oh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), r + a[0].length) : -1;
}
function gx(e, t, r) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), r + a[0].length) : -1;
}
function vx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.q = a[0] * 3 - 3, r + a[0].length) : -1;
}
function xx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.m = a[0] - 1, r + a[0].length) : -1;
}
function lh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.d = +a[0], r + a[0].length) : -1;
}
function bx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 3));
  return a ? (e.m = 0, e.d = +a[0], r + a[0].length) : -1;
}
function sh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.H = +a[0], r + a[0].length) : -1;
}
function Ex(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.M = +a[0], r + a[0].length) : -1;
}
function Sx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.S = +a[0], r + a[0].length) : -1;
}
function kx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 3));
  return a ? (e.L = +a[0], r + a[0].length) : -1;
}
function wx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), r + a[0].length) : -1;
}
function Tx(e, t, r) {
  var a = ux.exec(t.slice(r, r + 1));
  return a ? r + a[0].length : -1;
}
function Cx(e, t, r) {
  var a = Un.exec(t.slice(r));
  return a ? (e.Q = +a[0], r + a[0].length) : -1;
}
function Ax(e, t, r) {
  var a = Un.exec(t.slice(r));
  return a ? (e.s = +a[0], r + a[0].length) : -1;
}
function uh(e, t) {
  return Yt(e.getDate(), t, 2);
}
function Lx(e, t) {
  return Yt(e.getHours(), t, 2);
}
function Px(e, t) {
  return Yt(e.getHours() % 12 || 12, t, 2);
}
function Rx(e, t) {
  return Yt(1 + qm.count(ks(e), e), t, 3);
}
function ay(e, t) {
  return Yt(e.getMilliseconds(), t, 3);
}
function Nx(e, t) {
  return ay(e, t) + "000";
}
function Dx(e, t) {
  return Yt(e.getMonth() + 1, t, 2);
}
function _x(e, t) {
  return Yt(e.getMinutes(), t, 2);
}
function Ox(e, t) {
  return Yt(e.getSeconds(), t, 2);
}
function Fx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Mx(e, t) {
  return Yt(Zm.count(ks(e) - 1, e), t, 2);
}
function iy(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ll(e) : ll.ceil(e);
}
function zx(e, t) {
  return e = iy(e), Yt(ll.count(ks(e), e) + (ks(e).getDay() === 4), t, 2);
}
function Bx(e) {
  return e.getDay();
}
function Ix(e, t) {
  return Yt(Zu.count(ks(e) - 1, e), t, 2);
}
function $x(e, t) {
  return Yt(e.getFullYear() % 100, t, 2);
}
function Hx(e, t) {
  return e = iy(e), Yt(e.getFullYear() % 100, t, 2);
}
function Vx(e, t) {
  return Yt(e.getFullYear() % 1e4, t, 4);
}
function Wx(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? ll(e) : ll.ceil(e), Yt(e.getFullYear() % 1e4, t, 4);
}
function jx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Yt(t / 60 | 0, "0", 2) + Yt(t % 60, "0", 2);
}
function ch(e, t) {
  return Yt(e.getUTCDate(), t, 2);
}
function Ux(e, t) {
  return Yt(e.getUTCHours(), t, 2);
}
function Kx(e, t) {
  return Yt(e.getUTCHours() % 12 || 12, t, 2);
}
function Yx(e, t) {
  return Yt(1 + Jm.count(ws(e), e), t, 3);
}
function oy(e, t) {
  return Yt(e.getUTCMilliseconds(), t, 3);
}
function Gx(e, t) {
  return oy(e, t) + "000";
}
function Xx(e, t) {
  return Yt(e.getUTCMonth() + 1, t, 2);
}
function qx(e, t) {
  return Yt(e.getUTCMinutes(), t, 2);
}
function Zx(e, t) {
  return Yt(e.getUTCSeconds(), t, 2);
}
function Qx(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function Jx(e, t) {
  return Yt(ey.count(ws(e) - 1, e), t, 2);
}
function ly(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? sl(e) : sl.ceil(e);
}
function eb(e, t) {
  return e = ly(e), Yt(sl.count(ws(e), e) + (ws(e).getUTCDay() === 4), t, 2);
}
function tb(e) {
  return e.getUTCDay();
}
function nb(e, t) {
  return Yt(Qu.count(ws(e) - 1, e), t, 2);
}
function rb(e, t) {
  return Yt(e.getUTCFullYear() % 100, t, 2);
}
function ab(e, t) {
  return e = ly(e), Yt(e.getUTCFullYear() % 100, t, 2);
}
function ib(e, t) {
  return Yt(e.getUTCFullYear() % 1e4, t, 4);
}
function ob(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? sl(e) : sl.ceil(e), Yt(e.getUTCFullYear() % 1e4, t, 4);
}
function lb() {
  return "+0000";
}
function dh() {
  return "%";
}
function fh(e) {
  return +e;
}
function ph(e) {
  return Math.floor(+e / 1e3);
}
var Go, Hu, sy;
sb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function sb(e) {
  return Go = sx(e), Hu = Go.format, sy = Go.parse, Go.utcFormat, Go.utcParse, Go;
}
const zt = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (zt.str(e) || zt.num(e))
      return e === t;
    if (zt.obj(e) && zt.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let r;
    for (r in e)
      if (!(r in t))
        return !1;
    for (r in t)
      if (e[r] !== t[r])
        return !1;
    return zt.und(r) ? e === t : !0;
  }
};
function ub(e, t) {
  return t === void 0 && (t = !0), (r) => (zt.arr(r) ? r : Object.keys(r)).reduce((a, i) => {
    const o = t ? i[0].toLowerCase() + i.substring(1) : i;
    return a[o] = e(o), a;
  }, e);
}
function uy() {
  const e = se.useState(!1), t = e[1];
  return se.useCallback(() => t((a) => !a), []);
}
function Pi(e, t) {
  return zt.und(e) || zt.nul(e) ? t : e;
}
function tl(e) {
  return zt.und(e) ? [] : zt.arr(e) ? e : [e];
}
function Br(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    r[a - 1] = arguments[a];
  return zt.fun(e) ? e(...r) : e;
}
function cb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, ea(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Ud(e) {
  const t = cb(e);
  if (zt.und(t))
    return vn({
      to: t
    }, e);
  const r = Object.keys(e).reduce((a, i) => zt.und(t[i]) ? vn({}, a, {
    [i]: e[i]
  }) : a, {});
  return vn({
    to: t
  }, r);
}
function db(e, t) {
  return t && (zt.fun(t) ? t(e) : zt.obj(t) && (t.current = e)), e;
}
class Ir {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const r = this.children.indexOf(t);
    this.children.splice(r, 1), this.children.length === 0 && this.detach();
  }
}
class xf extends Ir {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Ir && t.removeChild(this));
  }
}
class cy extends Ir {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const r = {};
    for (const a in this.payload) {
      const i = this.payload[a];
      t && !(i instanceof Ir) || (r[a] = i instanceof Ir ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return r;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let ep;
function fb(e, t) {
  ep = {
    fn: e,
    transform: t
  };
}
let dy;
function pb(e) {
  dy = e;
}
let fy = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, ec;
function hb(e) {
  ec = e;
}
let py = () => Date.now(), mb = (e) => e.current, hy;
function yb(e) {
  hy = e;
}
class gb extends cy {
  constructor(t, r) {
    super(), this.update = void 0, this.payload = t.style ? vn({}, t, {
      style: hy(t.style)
    }) : t, this.update = r, this.attach();
  }
}
const vb = (e) => zt.fun(e) && !(e.prototype instanceof n.Component), xb = (e) => se.forwardRef((r, a) => {
  const i = uy(), o = se.useRef(!0), d = se.useRef(null), c = se.useRef(null), s = se.useCallback((x) => {
    const w = d.current, S = () => {
      let A = !1;
      c.current && (A = ep.fn(c.current, d.current.getAnimatedValue())), (!c.current || A === !1) && i();
    };
    d.current = new gb(x, S), w && w.detach();
  }, []);
  se.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), se.useImperativeHandle(a, () => mb(c)), s(r);
  const h = d.current.getValue();
  h.scrollTop, h.scrollLeft;
  const y = ea(h, ["scrollTop", "scrollLeft"]), g = vb(e) ? void 0 : (x) => c.current = db(x, a);
  return n.createElement(e, vn({}, y, {
    ref: g
  }));
});
let hs = !1;
const Ii = /* @__PURE__ */ new Set(), my = () => {
  if (!hs)
    return !1;
  let e = py();
  for (let t of Ii) {
    let r = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let i = t.configs[a], o, d;
      for (let c = 0; c < i.animatedValues.length; c++) {
        let s = i.animatedValues[c];
        if (s.done)
          continue;
        let h = i.fromValues[c], y = i.toValues[c], g = s.lastPosition, x = y instanceof Ir, w = Array.isArray(i.initialVelocity) ? i.initialVelocity[c] : i.initialVelocity;
        if (x && (y = y.getValue()), i.immediate) {
          s.setValue(y), s.done = !0;
          continue;
        }
        if (typeof h == "string" || typeof y == "string") {
          s.setValue(y), s.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          g = h + i.easing((e - s.startTime) / i.duration) * (y - h), o = e >= s.startTime + i.duration;
        else if (i.decay)
          g = h + w / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - g) < 0.1, o && (y = g);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, w = s.lastVelocity !== void 0 ? s.lastVelocity : i.initialVelocity, e > d + 64 && (d = e);
          let S = Math.floor(e - d);
          for (let L = 0; L < S; ++L) {
            let P = -i.tension * (g - y), R = -i.friction * w, C = (P + R) / i.mass;
            w = w + C * 1 / 1e3, g = g + w * 1 / 1e3;
          }
          let A = i.clamp && i.tension !== 0 ? h < y ? g > y : g < y : !1, p = Math.abs(w) <= i.precision, v = i.tension !== 0 ? Math.abs(y - g) <= i.precision : !0;
          o = A || p && v, s.lastVelocity = w, s.lastTime = e;
        }
        x && !i.toValues[c].done && (o = !1), o ? (s.value !== y && (g = y), s.done = !0) : r = !0, s.setValue(g), s.lastPosition = g;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), r || (Ii.delete(t), t.stop(!0));
  }
  return Ii.size ? fy(my) : hs = !1, hs;
}, bb = (e) => {
  Ii.has(e) || Ii.add(e), hs || (hs = !0, fy(my));
}, Eb = (e) => {
  Ii.has(e) && Ii.delete(e);
};
function tc(e, t, r) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return tc({
      range: e,
      output: t,
      extrapolate: r
    });
  if (ec && typeof e.output[0] == "string")
    return ec(e);
  const a = e, i = a.output, o = a.range || [0, 1], d = a.extrapolateLeft || a.extrapolate || "extend", c = a.extrapolateRight || a.extrapolate || "extend", s = a.easing || ((h) => h);
  return (h) => {
    const y = kb(h, o);
    return Sb(h, o[y], o[y + 1], i[y], i[y + 1], s, d, c, a.map);
  };
}
function Sb(e, t, r, a, i, o, d, c, s) {
  let h = s ? s(e) : e;
  if (h < t) {
    if (d === "identity")
      return h;
    d === "clamp" && (h = t);
  }
  if (h > r) {
    if (c === "identity")
      return h;
    c === "clamp" && (h = r);
  }
  return a === i ? a : t === r ? e <= t ? a : i : (t === -1 / 0 ? h = -h : r === 1 / 0 ? h = h - t : h = (h - t) / (r - t), h = o(h), a === -1 / 0 ? h = -h : i === 1 / 0 ? h = h + a : h = h * (i - a) + a, h);
}
function kb(e, t) {
  for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r)
    ;
  return r - 1;
}
class ul extends xf {
  constructor(t, r, a, i) {
    super(), this.calc = void 0, this.payload = t instanceof xf && !(t instanceof ul) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = tc(r, a, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, r, a) {
    this.calc = tc(t, r, a);
  }
  interpolate(t, r, a) {
    return new ul(this, t, r, a);
  }
}
const wb = (e, t, r) => e && new ul(e, t, r);
function yy(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((r) => yy(r, t));
}
class bf extends Ir {
  constructor(t) {
    var r;
    super(), r = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, i) {
      i === void 0 && (i = !0), r.value = a, i && r.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && yy(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, r, a) {
    return new ul(this, t, r, a);
  }
}
class Tb extends xf {
  constructor(t) {
    super(), this.payload = t.map((r) => new bf(r));
  }
  setValue(t, r) {
    r === void 0 && (r = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, i) => this.payload[i].setValue(a, r)) : this.payload.forEach((a) => a.setValue(t, r));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, r) {
    return new ul(this, t, r);
  }
}
let Cb = 0;
class Ab {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Cb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const r = Ud(t), a = r.delay, i = a === void 0 ? 0 : a, o = r.to, d = ea(r, ["delay", "to"]);
    if (zt.arr(o) || zt.fun(o))
      this.queue.push(vn({}, d, {
        delay: i,
        to: o
      }));
    else if (o) {
      let c = {};
      Object.entries(o).forEach((s) => {
        let h = s[0], y = s[1];
        const g = vn({
          to: {
            [h]: y
          },
          delay: Br(i, h)
        }, d), x = c[g.delay] && c[g.delay].to;
        c[g.delay] = vn({}, c[g.delay], g, {
          to: vn({}, x, g.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, s) => c.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let o = i.from, d = o === void 0 ? {} : o, c = i.to, s = c === void 0 ? {} : c;
        zt.obj(d) && (this.merged = vn({}, d, this.merged)), zt.obj(s) && (this.merged = vn({}, this.merged, s));
      });
      const r = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((i, o) => {
        let d = i.delay, c = ea(i, ["delay"]);
        const s = (y) => {
          o === a.length - 1 && r === this.guid && y && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let h = zt.arr(c.to) || zt.fun(c.to);
        d ? setTimeout(() => {
          r === this.guid && (h ? this.runAsync(c, s) : this.diff(c).start(s));
        }, d) : h ? this.runAsync(c, s) : this.diff(c).start(s);
      });
    } else
      zt.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), bb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((r) => r(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Eb(this), this;
  }
  runAsync(t, r) {
    var a = this;
    t.delay;
    let i = ea(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (zt.arr(i.to))
      for (let c = 0; c < i.to.length; c++) {
        const s = c, h = vn({}, i, Ud(i.to[s]));
        zt.arr(h.config) && (h.config = h.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((y) => this.diff(h).start(y));
        });
      }
    else if (zt.fun(i.to)) {
      let c = 0, s;
      d = d.then(() => i.to(
        // next(props)
        (h) => {
          const y = vn({}, i, Ud(h));
          if (zt.arr(y.config) && (y.config = y.config[c]), c++, o === this.guid)
            return s = new Promise((g) => this.diff(y).start(g));
        },
        // cancel()
        function(h) {
          return h === void 0 && (h = !0), a.stop(h);
        }
      ).then(() => s));
    }
    d.then(r);
  }
  diff(t) {
    this.props = vn({}, this.props, t);
    let r = this.props, a = r.from, i = a === void 0 ? {} : a, o = r.to, d = o === void 0 ? {} : o, c = r.config, s = c === void 0 ? {} : c, h = r.reverse, y = r.attach, g = r.reset, x = r.immediate;
    if (h) {
      var w = [d, i];
      i = w[0], d = w[1];
    }
    this.merged = vn({}, i, this.merged, d), this.hasChanged = !1;
    let S = y && y(this);
    if (this.animations = Object.entries(this.merged).reduce((A, p) => {
      let v = p[0], L = p[1], P = A[v] || {};
      const R = zt.num(L), C = zt.str(L) && !L.startsWith("#") && !/\d/.test(L) && !dy[L], z = zt.arr(L), W = !R && !z && !C;
      let Z = zt.und(i[v]) ? L : i[v], ee = R || z || C ? L : 1, K = Br(s, v);
      S && (ee = S.animations[v].parent);
      let le = P.parent, Y = P.interpolation, ae = tl(S ? ee.getPayload() : ee), B, X = L;
      W && (X = ec({
        range: [0, 1],
        output: [L, L]
      })(1));
      let ce = Y && Y.getValue();
      const Q = !zt.und(le) && P.animatedValues.some((U) => !U.done), V = !zt.equ(X, ce), j = !zt.equ(X, P.previous), te = !zt.equ(K, P.config);
      if (g || j && V || te) {
        if (R || C)
          le = Y = P.parent || new bf(Z);
        else if (z)
          le = Y = P.parent || new Tb(Z);
        else if (W) {
          let U = P.interpolation && P.interpolation.calc(P.parent.value);
          U = U !== void 0 && !g ? U : Z, P.parent ? (le = P.parent, le.setValue(0, !1)) : le = new bf(0);
          const ue = {
            output: [U, L]
          };
          P.interpolation ? (Y = P.interpolation, P.interpolation.updateConfig(ue)) : Y = le.interpolate(ue);
        }
        return ae = tl(S ? ee.getPayload() : ee), B = tl(le.getPayload()), g && !W && le.setValue(Z, !1), this.hasChanged = !0, B.forEach((U) => {
          U.startPosition = U.value, U.lastPosition = U.value, U.lastVelocity = Q ? U.lastVelocity : void 0, U.lastTime = Q ? U.lastTime : void 0, U.startTime = py(), U.done = !1, U.animatedStyles.clear();
        }), Br(x, v) && le.setValue(W ? ee : L, !1), vn({}, A, {
          [v]: vn({}, P, {
            name: v,
            parent: le,
            interpolation: Y,
            animatedValues: B,
            toValues: ae,
            previous: X,
            config: K,
            fromValues: tl(le.getValue()),
            immediate: Br(x, v),
            initialVelocity: Pi(K.velocity, 0),
            clamp: Pi(K.clamp, !1),
            precision: Pi(K.precision, 0.01),
            tension: Pi(K.tension, 170),
            friction: Pi(K.friction, 26),
            mass: Pi(K.mass, 1),
            duration: K.duration,
            easing: Pi(K.easing, (U) => U),
            decay: K.decay
          })
        });
      } else
        return V ? A : (W && (le.setValue(1, !1), Y.updateConfig({
          output: [X, X]
        })), le.done = !0, this.hasChanged = !0, vn({}, A, {
          [v]: vn({}, A[v], {
            previous: X
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let A in this.animations)
        this.interpolations[A] = this.animations[A].interpolation, this.values[A] = this.animations[A].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Lb = 0;
const Vu = "enter", Kd = "leave", Yd = "update", Pb = (e, t) => (typeof t == "function" ? e.map(t) : tl(t)).map(String), Ef = (e) => {
  let t = e.items, r = e.keys, a = r === void 0 ? (o) => o : r, i = ea(e, ["items", "keys"]);
  return t = tl(t !== void 0 ? t : null), vn({
    items: t,
    keys: Pb(t, a)
  }, i);
};
function Rb(e, t, r) {
  const a = vn({
    items: e,
    keys: t || ((L) => L)
  }, r), i = Ef(a), o = i.lazy, d = o === void 0 ? !1 : o;
  i.unique;
  const c = i.reset, s = c === void 0 ? !1 : c;
  i.enter, i.leave, i.update;
  const h = i.onDestroyed;
  i.keys, i.items;
  const y = i.onFrame, g = i.onRest, x = i.onStart, w = i.ref, S = ea(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), A = uy(), p = se.useRef(!1), v = se.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !p.current && /* @__PURE__ */ new Map(),
    forceUpdate: A
  });
  return se.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(v.current.instances).map((L) => {
      let P = L[1];
      return new Promise((R) => P.start(R));
    })),
    stop: (L) => Array.from(v.current.instances).forEach((P) => P[1].stop(L)),
    get controllers() {
      return Array.from(v.current.instances).map((L) => L[1]);
    }
  })), v.current = Nb(v.current, a), v.current.changed && v.current.transitions.forEach((L) => {
    const P = L.slot, R = L.from, C = L.to, z = L.config, W = L.trail, Z = L.key, ee = L.item;
    v.current.instances.has(Z) || v.current.instances.set(Z, new Ab());
    const K = v.current.instances.get(Z), le = vn({}, S, {
      to: C,
      from: R,
      config: z,
      ref: w,
      onRest: (Y) => {
        v.current.mounted && (L.destroyed && (!w && !d && hh(v, Z), h && h(ee)), !Array.from(v.current.instances).some((X) => !X[1].idle) && (w || d) && v.current.deleted.length > 0 && hh(v), g && g(ee, P, Y));
      },
      onStart: x && (() => x(ee, P)),
      onFrame: y && ((Y) => y(ee, P, Y)),
      delay: W,
      reset: s && P === Vu
      // Update controller
    });
    K.update(le), v.current.paused || K.start();
  }), se.useEffect(() => (v.current.mounted = p.current = !0, () => {
    v.current.mounted = p.current = !1, Array.from(v.current.instances).map((L) => L[1].destroy()), v.current.instances.clear();
  }), []), v.current.transitions.map((L) => {
    let P = L.item, R = L.slot, C = L.key;
    return {
      item: P,
      key: C,
      state: R,
      props: v.current.instances.get(C).getValues()
    };
  });
}
function hh(e, t) {
  const r = e.current.deleted;
  for (let a of r) {
    let i = a.key;
    const o = (d) => d.key !== i;
    (zt.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Nb(e, t) {
  let r = e.first, a = e.prevProps, i = ea(e, ["first", "prevProps"]), o = Ef(t), d = o.items, c = o.keys, s = o.initial, h = o.from, y = o.enter, g = o.leave, x = o.update, w = o.trail, S = w === void 0 ? 0 : w, A = o.unique, p = o.config, v = o.order, L = v === void 0 ? [Vu, Kd, Yd] : v, P = Ef(a), R = P.keys, C = P.items, z = vn({}, i.current), W = [...i.deleted], Z = Object.keys(z), ee = new Set(Z), K = new Set(c), le = c.filter((ce) => !ee.has(ce)), Y = i.transitions.filter((ce) => !ce.destroyed && !K.has(ce.originalKey)).map((ce) => ce.originalKey), ae = c.filter((ce) => ee.has(ce)), B = -S;
  for (; L.length; )
    switch (L.shift()) {
      case Vu: {
        le.forEach((ne, Q) => {
          A && W.find((U) => U.originalKey === ne) && (W = W.filter((U) => U.originalKey !== ne));
          const V = c.indexOf(ne), j = d[V], te = r && s !== void 0 ? "initial" : Vu;
          z[ne] = {
            slot: te,
            originalKey: ne,
            key: A ? String(ne) : Lb++,
            item: j,
            trail: B = B + S,
            config: Br(p, j, te),
            from: Br(r && s !== void 0 ? s || {} : h, j),
            to: Br(y, j)
          };
        });
        break;
      }
      case Kd: {
        Y.forEach((ne) => {
          const Q = R.indexOf(ne), V = C[Q], j = Kd;
          W.unshift(vn({}, z[ne], {
            slot: j,
            destroyed: !0,
            left: R[Math.max(0, Q - 1)],
            right: R[Math.min(R.length, Q + 1)],
            trail: B = B + S,
            config: Br(p, V, j),
            to: Br(g, V)
          })), delete z[ne];
        });
        break;
      }
      case Yd: {
        ae.forEach((ne) => {
          const Q = c.indexOf(ne), V = d[Q], j = Yd;
          z[ne] = vn({}, z[ne], {
            item: V,
            slot: j,
            trail: B = B + S,
            config: Br(p, V, j),
            to: Br(x, V)
          });
        });
        break;
      }
    }
  let X = c.map((ce) => z[ce]);
  return W.forEach((ce) => {
    let ne = ce.left;
    ce.right;
    let Q = ea(ce, ["left", "right"]), V;
    (V = X.findIndex((j) => j.originalKey === ne)) !== -1 && (V += 1), V = Math.max(0, V), X = [...X.slice(0, V), Q, ...X.slice(V)];
  }), vn({}, i, {
    changed: le.length || Y.length || ae.length,
    first: r && le.length === 0,
    transitions: X,
    current: z,
    deleted: W,
    prevProps: t
  });
}
class Db extends cy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Ir) && (t = ep.transform(t)), this.payload = t;
  }
}
const nc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, $r = "[-+]?\\d*\\.?\\d+", rc = $r + "%";
function Dc() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const _b = new RegExp("rgb" + Dc($r, $r, $r)), Ob = new RegExp("rgba" + Dc($r, $r, $r, $r)), Fb = new RegExp("hsl" + Dc($r, rc, rc)), Mb = new RegExp("hsla" + Dc($r, rc, rc, $r)), zb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Bb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Ib = /^#([0-9a-fA-F]{6})$/, $b = /^#([0-9a-fA-F]{8})$/;
function Hb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Ib.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : nc.hasOwnProperty(e) ? nc[e] : (t = _b.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = Ob.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  gh(t[4])) >>> // a
  0 : (t = zb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = $b.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Bb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Fb.exec(e)) ? (mh(
    yh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Mb.exec(e)) ? (mh(
    yh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | gh(t[4])) >>> // a
  0 : null;
}
function Gd(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function mh(e, t, r) {
  const a = r < 0.5 ? r * (1 + t) : r + t - r * t, i = 2 * r - a, o = Gd(i, a, e + 1 / 3), d = Gd(i, a, e), c = Gd(i, a, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(c * 255) << 8;
}
function Xo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function yh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function gh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Pu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function vh(e) {
  let t = Hb(e);
  if (t === null)
    return e;
  t = t || 0;
  let r = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${r}, ${a}, ${i}, ${o})`;
}
const Ru = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Vb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Wb = new RegExp(`(${Object.keys(nc).join("|")})`, "g"), jb = (e) => {
  const t = e.output.map((i) => i.replace(Vb, vh)).map((i) => i.replace(Wb, vh)), r = t[0].match(Ru).map(() => []);
  t.forEach((i) => {
    i.match(Ru).forEach((o, d) => r[d].push(+o));
  });
  const a = t[0].match(Ru).map((i, o) => tc(vn({}, e, {
    output: r[o]
  })));
  return (i) => {
    let o = 0;
    return t[0].replace(Ru, () => a[o++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, c, s, h, y) => `rgba(${Math.round(c)}, ${Math.round(s)}, ${Math.round(h)}, ${y})`);
  };
};
let ms = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Ub = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Kb = ["Webkit", "Ms", "Moz", "O"];
ms = Object.keys(ms).reduce((e, t) => (Kb.forEach((r) => e[Ub(r, t)] = e[t]), e), ms);
function Yb(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !r && typeof t == "number" && t !== 0 && !(ms.hasOwnProperty(e) && ms[e]) ? t + "px" : ("" + t).trim();
}
const xh = {};
yb((e) => new Db(e));
hb(jb);
pb(nc);
fb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, o = t.children, d = t.scrollTop, c = t.scrollLeft, s = ea(t, ["style", "children", "scrollTop", "scrollLeft"]), h = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), c !== void 0 && (e.scrollLeft = c), o !== void 0 && (e.textContent = o);
    for (let y in i)
      if (i.hasOwnProperty(y)) {
        var r = y.indexOf("--") === 0, a = Yb(y, i[y], r);
        y === "float" && (y = "cssFloat"), r ? e.style.setProperty(y, a) : e.style[y] = a;
      }
    for (let y in s) {
      const g = h ? y : xh[y] || (xh[y] = y.replace(/([A-Z])/g, (x) => "-" + x.toLowerCase()));
      typeof e.getAttribute(g) < "u" && e.setAttribute(g, s[y]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Gb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Xb = ub(xb, !1), bh = Xb(Gb);
function qb(e) {
  return e.innerRadius;
}
function Zb(e) {
  return e.outerRadius;
}
function Qb(e) {
  return e.startAngle;
}
function Jb(e) {
  return e.endAngle;
}
function e0(e) {
  return e && e.padAngle;
}
function t0(e, t, r, a, i, o, d, c) {
  var s = r - e, h = a - t, y = d - i, g = c - o, x = g * s - y * h;
  if (!(x * x < ar))
    return x = (y * (t - o) - g * (e - i)) / x, [e + x * s, t + x * h];
}
function Nu(e, t, r, a, i, o, d) {
  var c = e - r, s = t - a, h = (d ? o : -o) / el(c * c + s * s), y = h * s, g = -h * c, x = e + y, w = t + g, S = r + y, A = a + g, p = (x + S) / 2, v = (w + A) / 2, L = S - x, P = A - w, R = L * L + P * P, C = i - o, z = x * A - S * w, W = (P < 0 ? -1 : 1) * el(wg(0, C * C * R - z * z)), Z = (z * P - L * W) / R, ee = (-z * L - P * W) / R, K = (z * P + L * W) / R, le = (-z * L + P * W) / R, Y = Z - p, ae = ee - v, B = K - p, X = le - v;
  return Y * Y + ae * ae > B * B + X * X && (Z = K, ee = le), {
    cx: Z,
    cy: ee,
    x01: -y,
    y01: -g,
    x11: Z * (i / C - 1),
    y11: ee * (i / C - 1)
  };
}
function n0() {
  var e = qb, t = Zb, r = Wt(0), a = null, i = Qb, o = Jb, d = e0, c = null;
  function s() {
    var h, y, g = +e.apply(this, arguments), x = +t.apply(this, arguments), w = i.apply(this, arguments) - Lp, S = o.apply(this, arguments) - Lp, A = Pp(S - w), p = S > w;
    if (c || (c = h = Ac()), x < g && (y = x, x = g, g = y), !(x > ar))
      c.moveTo(0, 0);
    else if (A > Iu - ar)
      c.moveTo(x * Li(w), x * qr(w)), c.arc(0, 0, x, w, S, !p), g > ar && (c.moveTo(g * Li(S), g * qr(S)), c.arc(0, 0, g, S, w, p));
    else {
      var v = w, L = S, P = w, R = S, C = A, z = A, W = d.apply(this, arguments) / 2, Z = W > ar && (a ? +a.apply(this, arguments) : el(g * g + x * x)), ee = Fd(Pp(x - g) / 2, +r.apply(this, arguments)), K = ee, le = ee, Y, ae;
      if (Z > ar) {
        var B = Rp(Z / g * qr(W)), X = Rp(Z / x * qr(W));
        (C -= B * 2) > ar ? (B *= p ? 1 : -1, P += B, R -= B) : (C = 0, P = R = (w + S) / 2), (z -= X * 2) > ar ? (X *= p ? 1 : -1, v += X, L -= X) : (z = 0, v = L = (w + S) / 2);
      }
      var ce = x * Li(v), ne = x * qr(v), Q = g * Li(R), V = g * qr(R);
      if (ee > ar) {
        var j = x * Li(L), te = x * qr(L), U = g * Li(P), ue = g * qr(P), ke;
        if (A < Ap && (ke = t0(ce, ne, U, ue, j, te, Q, V))) {
          var xe = ce - ke[0], be = ne - ke[1], Ae = j - ke[0], Ye = te - ke[1], Pe = 1 / qr(kg((xe * Ae + be * Ye) / (el(xe * xe + be * be) * el(Ae * Ae + Ye * Ye))) / 2), ye = el(ke[0] * ke[0] + ke[1] * ke[1]);
          K = Fd(ee, (g - ye) / (Pe - 1)), le = Fd(ee, (x - ye) / (Pe + 1));
        }
      }
      z > ar ? le > ar ? (Y = Nu(U, ue, ce, ne, x, le, p), ae = Nu(j, te, Q, V, x, le, p), c.moveTo(Y.cx + Y.x01, Y.cy + Y.y01), le < ee ? c.arc(Y.cx, Y.cy, le, tr(Y.y01, Y.x01), tr(ae.y01, ae.x01), !p) : (c.arc(Y.cx, Y.cy, le, tr(Y.y01, Y.x01), tr(Y.y11, Y.x11), !p), c.arc(0, 0, x, tr(Y.cy + Y.y11, Y.cx + Y.x11), tr(ae.cy + ae.y11, ae.cx + ae.x11), !p), c.arc(ae.cx, ae.cy, le, tr(ae.y11, ae.x11), tr(ae.y01, ae.x01), !p))) : (c.moveTo(ce, ne), c.arc(0, 0, x, v, L, !p)) : c.moveTo(ce, ne), !(g > ar) || !(C > ar) ? c.lineTo(Q, V) : K > ar ? (Y = Nu(Q, V, j, te, g, -K, p), ae = Nu(ce, ne, U, ue, g, -K, p), c.lineTo(Y.cx + Y.x01, Y.cy + Y.y01), K < ee ? c.arc(Y.cx, Y.cy, K, tr(Y.y01, Y.x01), tr(ae.y01, ae.x01), !p) : (c.arc(Y.cx, Y.cy, K, tr(Y.y01, Y.x01), tr(Y.y11, Y.x11), !p), c.arc(0, 0, g, tr(Y.cy + Y.y11, Y.cx + Y.x11), tr(ae.cy + ae.y11, ae.cx + ae.x11), p), c.arc(ae.cx, ae.cy, K, tr(ae.y11, ae.x11), tr(ae.y01, ae.x01), !p))) : c.arc(0, 0, g, R, P, p);
    }
    if (c.closePath(), h)
      return c = null, h + "" || null;
  }
  return s.centroid = function() {
    var h = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, y = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Ap / 2;
    return [Li(y) * h, qr(y) * h];
  }, s.innerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : Wt(+h), s) : e;
  }, s.outerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : Wt(+h), s) : t;
  }, s.cornerRadius = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : Wt(+h), s) : r;
  }, s.padRadius = function(h) {
    return arguments.length ? (a = h == null ? null : typeof h == "function" ? h : Wt(+h), s) : a;
  }, s.startAngle = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : Wt(+h), s) : i;
  }, s.endAngle = function(h) {
    return arguments.length ? (o = typeof h == "function" ? h : Wt(+h), s) : o;
  }, s.padAngle = function(h) {
    return arguments.length ? (d = typeof h == "function" ? h : Wt(+h), s) : d;
  }, s.context = function(h) {
    return arguments.length ? (c = h ?? null, s) : c;
  }, s;
}
function gy(e) {
  this._context = e;
}
gy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function _c(e) {
  return new gy(e);
}
function tp(e) {
  return e[0];
}
function np(e) {
  return e[1];
}
function vy() {
  var e = tp, t = np, r = Wt(!0), a = null, i = _c, o = null;
  function d(c) {
    var s, h = c.length, y, g = !1, x;
    for (a == null && (o = i(x = Ac())), s = 0; s <= h; ++s)
      !(s < h && r(y = c[s], s, c)) === g && ((g = !g) ? o.lineStart() : o.lineEnd()), g && o.point(+e(y, s, c), +t(y, s, c));
    if (x)
      return o = null, x + "" || null;
  }
  return d.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Wt(+c), d) : e;
  }, d.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Wt(+c), d) : t;
  }, d.defined = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Wt(!!c), d) : r;
  }, d.curve = function(c) {
    return arguments.length ? (i = c, a != null && (o = i(a)), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (c == null ? a = o = null : o = i(a = c), d) : a;
  }, d;
}
function r0() {
  var e = tp, t = null, r = Wt(0), a = np, i = Wt(!0), o = null, d = _c, c = null;
  function s(y) {
    var g, x, w, S = y.length, A, p = !1, v, L = new Array(S), P = new Array(S);
    for (o == null && (c = d(v = Ac())), g = 0; g <= S; ++g) {
      if (!(g < S && i(A = y[g], g, y)) === p)
        if (p = !p)
          x = g, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), w = g - 1; w >= x; --w)
            c.point(L[w], P[w]);
          c.lineEnd(), c.areaEnd();
        }
      p && (L[g] = +e(A, g, y), P[g] = +r(A, g, y), c.point(t ? +t(A, g, y) : L[g], a ? +a(A, g, y) : P[g]));
    }
    if (v)
      return c = null, v + "" || null;
  }
  function h() {
    return vy().defined(i).curve(d).context(o);
  }
  return s.x = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Wt(+y), t = null, s) : e;
  }, s.x0 = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Wt(+y), s) : e;
  }, s.x1 = function(y) {
    return arguments.length ? (t = y == null ? null : typeof y == "function" ? y : Wt(+y), s) : t;
  }, s.y = function(y) {
    return arguments.length ? (r = typeof y == "function" ? y : Wt(+y), a = null, s) : r;
  }, s.y0 = function(y) {
    return arguments.length ? (r = typeof y == "function" ? y : Wt(+y), s) : r;
  }, s.y1 = function(y) {
    return arguments.length ? (a = y == null ? null : typeof y == "function" ? y : Wt(+y), s) : a;
  }, s.lineX0 = s.lineY0 = function() {
    return h().x(e).y(r);
  }, s.lineY1 = function() {
    return h().x(e).y(a);
  }, s.lineX1 = function() {
    return h().x(t).y(r);
  }, s.defined = function(y) {
    return arguments.length ? (i = typeof y == "function" ? y : Wt(!!y), s) : i;
  }, s.curve = function(y) {
    return arguments.length ? (d = y, o != null && (c = d(o)), s) : d;
  }, s.context = function(y) {
    return arguments.length ? (y == null ? o = c = null : c = d(o = y), s) : o;
  }, s;
}
function a0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function i0(e) {
  return e;
}
function o0() {
  var e = i0, t = a0, r = null, a = Wt(0), i = Wt(Iu), o = Wt(0);
  function d(c) {
    var s, h = c.length, y, g, x = 0, w = new Array(h), S = new Array(h), A = +a.apply(this, arguments), p = Math.min(Iu, Math.max(-Iu, i.apply(this, arguments) - A)), v, L = Math.min(Math.abs(p) / h, o.apply(this, arguments)), P = L * (p < 0 ? -1 : 1), R;
    for (s = 0; s < h; ++s)
      (R = S[w[s] = s] = +e(c[s], s, c)) > 0 && (x += R);
    for (t != null ? w.sort(function(C, z) {
      return t(S[C], S[z]);
    }) : r != null && w.sort(function(C, z) {
      return r(c[C], c[z]);
    }), s = 0, g = x ? (p - h * P) / x : 0; s < h; ++s, A = v)
      y = w[s], R = S[y], v = A + (R > 0 ? R * g : 0) + P, S[y] = {
        data: c[y],
        index: s,
        value: R,
        startAngle: A,
        endAngle: v,
        padAngle: L
      };
    return S;
  }
  return d.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Wt(+c), d) : e;
  }, d.sortValues = function(c) {
    return arguments.length ? (t = c, r = null, d) : t;
  }, d.sort = function(c) {
    return arguments.length ? (r = c, t = null, d) : r;
  }, d.startAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : Wt(+c), d) : a;
  }, d.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Wt(+c), d) : i;
  }, d.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : Wt(+c), d) : o;
  }, d;
}
var Sf = Array.prototype.slice;
function l0(e) {
  return e.source;
}
function s0(e) {
  return e.target;
}
function u0(e) {
  var t = l0, r = s0, a = tp, i = np, o = null;
  function d() {
    var c, s = Sf.call(arguments), h = t.apply(this, s), y = r.apply(this, s);
    if (o || (o = c = Ac()), e(o, +a.apply(this, (s[0] = h, s)), +i.apply(this, s), +a.apply(this, (s[0] = y, s)), +i.apply(this, s)), c)
      return o = null, c + "" || null;
  }
  return d.source = function(c) {
    return arguments.length ? (t = c, d) : t;
  }, d.target = function(c) {
    return arguments.length ? (r = c, d) : r;
  }, d.x = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : Wt(+c), d) : a;
  }, d.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Wt(+c), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (o = c ?? null, d) : o;
  }, d;
}
function c0(e, t, r, a, i) {
  e.moveTo(t, r), e.bezierCurveTo(t = (t + a) / 2, r, t, i, a, i);
}
function d0() {
  return u0(c0);
}
const f0 = {
  draw: function(e, t) {
    var r = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * r, -r), e.lineTo(-r, -r), e.lineTo(-r, -3 * r), e.lineTo(r, -3 * r), e.lineTo(r, -r), e.lineTo(3 * r, -r), e.lineTo(3 * r, r), e.lineTo(r, r), e.lineTo(r, 3 * r), e.lineTo(-r, 3 * r), e.lineTo(-r, r), e.lineTo(-3 * r, r), e.closePath();
  }
};
function Ya() {
}
function ac(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function Oc(e) {
  this._context = e;
}
Oc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        ac(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function p0(e) {
  return new Oc(e);
}
function xy(e) {
  this._context = e;
}
xy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function h0(e) {
  return new xy(e);
}
function by(e) {
  this._context = e;
}
by.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, a) : this._context.moveTo(r, a);
        break;
      case 3:
        this._point = 4;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function m0(e) {
  return new by(e);
}
function Ey(e, t) {
  this._basis = new Oc(e), this._beta = t;
}
Ey.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length - 1;
    if (r > 0)
      for (var a = e[0], i = t[0], o = e[r] - a, d = t[r] - i, c = -1, s; ++c <= r; )
        s = c / r, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (a + s * o),
          this._beta * t[c] + (1 - this._beta) * (i + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const y0 = function e(t) {
  function r(a) {
    return t === 1 ? new Oc(a) : new Ey(a, t);
  }
  return r.beta = function(a) {
    return e(+a);
  }, r;
}(0.85);
function ic(e, t, r) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - r),
    e._x2,
    e._y2
  );
}
function rp(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
rp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        ic(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const g0 = function e(t) {
  function r(a) {
    return new rp(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function ap(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ap.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const v0 = function e(t) {
  function r(a) {
    return new ap(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function ip(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ip.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const x0 = function e(t) {
  function r(a) {
    return new ip(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function op(e, t, r) {
  var a = e._x1, i = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > ar) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > ar) {
    var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, y = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * h + e._x1 * e._l23_2a - t * e._l12_2a) / y, d = (d * h + e._y1 * e._l23_2a - r * e._l12_2a) / y;
  }
  e._context.bezierCurveTo(a, i, o, d, e._x2, e._y2);
}
function Sy(e, t) {
  this._context = e, this._alpha = t;
}
Sy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        op(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const b0 = function e(t) {
  function r(a) {
    return t ? new Sy(a, t) : new rp(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function ky(e, t) {
  this._context = e, this._alpha = t;
}
ky.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        op(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const E0 = function e(t) {
  function r(a) {
    return t ? new ky(a, t) : new ap(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function wy(e, t) {
  this._context = e, this._alpha = t;
}
wy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        op(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function r(a) {
    return t ? new wy(a, t) : new ip(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Ty(e) {
  this._context = e;
}
Ty.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function kf(e) {
  return new Ty(e);
}
function Eh(e) {
  return e < 0 ? -1 : 1;
}
function Sh(e, t, r) {
  var a = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (a || i < 0 && -0), d = (r - e._y1) / (i || a < 0 && -0), c = (o * i + d * a) / (a + i);
  return (Eh(o) + Eh(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(c)) || 0;
}
function kh(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function Xd(e, t, r) {
  var a = e._x0, i = e._y0, o = e._x1, d = e._y1, c = (o - a) / 3;
  e._context.bezierCurveTo(a + c, i + c * t, o - c, d - c * r, o, d);
}
function oc(e) {
  this._context = e;
}
oc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Xd(this, this._t0, kh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Xd(this, kh(this, r = Sh(this, e, t)), r);
          break;
        default:
          Xd(this, this._t0, r = Sh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function Cy(e) {
  this._context = new Ay(e);
}
(Cy.prototype = Object.create(oc.prototype)).point = function(e, t) {
  oc.prototype.point.call(this, t, e);
};
function Ay(e) {
  this._context = e;
}
Ay.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, a, i, o) {
    this._context.bezierCurveTo(t, e, a, r, o, i);
  }
};
function Wu(e) {
  return new oc(e);
}
function k0(e) {
  return new Cy(e);
}
function Ly(e) {
  this._context = e;
}
Ly.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = wh(e), i = wh(t), o = 0, d = 1; d < r; ++o, ++d)
          this._context.bezierCurveTo(a[0][o], i[0][o], a[1][o], i[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function wh(e) {
  var t, r = e.length - 1, a, i = new Array(r), o = new Array(r), d = new Array(r);
  for (i[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
    i[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, o[r - 1] = 7, d[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
    a = i[t] / o[t - 1], o[t] -= a, d[t] -= a * d[t - 1];
  for (i[r - 1] = d[r - 1] / o[r - 1], t = r - 2; t >= 0; --t)
    i[t] = (d[t] - i[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function w0(e) {
  return new Ly(e);
}
function Fc(e, t) {
  this._context = e, this._t = t;
}
Fc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function T0(e) {
  return new Fc(e, 0.5);
}
function C0(e) {
  return new Fc(e, 0);
}
function A0(e) {
  return new Fc(e, 1);
}
function cl(e, t) {
  if ((d = e.length) > 1)
    for (var r = 1, a, i, o = e[t[0]], d, c = o.length; r < d; ++r)
      for (i = o, o = e[t[r]], a = 0; a < c; ++a)
        o[a][1] += o[a][0] = isNaN(i[a][1]) ? i[a][0] : i[a][1];
}
function dl(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; )
    r[t] = t;
  return r;
}
function L0(e, t) {
  return e[t];
}
function lp() {
  var e = Wt([]), t = dl, r = cl, a = L0;
  function i(o) {
    var d = e.apply(this, arguments), c, s = o.length, h = d.length, y = new Array(h), g;
    for (c = 0; c < h; ++c) {
      for (var x = d[c], w = y[c] = new Array(s), S = 0, A; S < s; ++S)
        w[S] = A = [0, +a(o[S], x, S, o)], A.data = o[S];
      w.key = x;
    }
    for (c = 0, g = t(y); c < h; ++c)
      y[g[c]].index = c;
    return r(y, g), y;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Wt(Sf.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : Wt(+o), i) : a;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? dl : typeof o == "function" ? o : Wt(Sf.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (r = o ?? cl, i) : r;
  }, i;
}
function P0(e, t) {
  if ((a = e.length) > 0) {
    for (var r, a, i = 0, o = e[0].length, d; i < o; ++i) {
      for (d = r = 0; r < a; ++r)
        d += e[r][i][1] || 0;
      if (d)
        for (r = 0; r < a; ++r)
          e[r][i][1] /= d;
    }
    cl(e, t);
  }
}
function R0(e, t) {
  if ((s = e.length) > 0)
    for (var r, a = 0, i, o, d, c, s, h = e[t[0]].length; a < h; ++a)
      for (d = c = 0, r = 0; r < s; ++r)
        (o = (i = e[t[r]][a])[1] - i[0]) > 0 ? (i[0] = d, i[1] = d += o) : o < 0 ? (i[1] = c, i[0] = c += o) : (i[0] = 0, i[1] = o);
}
function N0(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, a = e[t[0]], i, o = a.length; r < o; ++r) {
      for (var d = 0, c = 0; d < i; ++d)
        c += e[d][r][1] || 0;
      a[r][1] += a[r][0] = -c / 2;
    }
    cl(e, t);
  }
}
function D0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, a = 1, i, o, d; a < o; ++a) {
      for (var c = 0, s = 0, h = 0; c < d; ++c) {
        for (var y = e[t[c]], g = y[a][1] || 0, x = y[a - 1][1] || 0, w = (g - x) / 2, S = 0; S < c; ++S) {
          var A = e[t[S]], p = A[a][1] || 0, v = A[a - 1][1] || 0;
          w += p - v;
        }
        s += g, h += w * g;
      }
      i[a - 1][1] += i[a - 1][0] = r, s && (r -= h / s);
    }
    i[a - 1][1] += i[a - 1][0] = r, cl(e, t);
  }
}
function _0(e) {
  var t = e.map(O0);
  return dl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function O0(e) {
  for (var t = -1, r = 0, a = e.length, i, o = -1 / 0; ++t < a; )
    (i = +e[t][1]) > o && (o = i, r = t);
  return r;
}
function Py(e) {
  var t = e.map(Ry);
  return dl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function Ry(e) {
  for (var t = 0, r = -1, a = e.length, i; ++r < a; )
    (i = +e[r][1]) && (t += i);
  return t;
}
function F0(e) {
  return Py(e).reverse();
}
function M0(e) {
  var t = e.length, r, a, i = e.map(Ry), o = _0(e), d = 0, c = 0, s = [], h = [];
  for (r = 0; r < t; ++r)
    a = o[r], d < c ? (d += i[a], s.push(a)) : (c += i[a], h.push(a));
  return h.reverse().concat(s);
}
function z0(e) {
  return dl(e).reverse();
}
function wn(e, t) {
  e(t);
}
var Th = {
  ascending: Py,
  descending: F0,
  insideout: M0,
  none: dl,
  reverse: z0
};
function sp(e) {
  return e && Th[e] || Th.none;
}
var Ch = {
  expand: P0,
  diverging: R0,
  none: cl,
  silhouette: N0,
  wiggle: D0
};
function up(e) {
  return e && Ch[e] || Ch.none;
}
function B0(e) {
  var t = e === void 0 ? {} : e, r = t.innerRadius, a = t.outerRadius, i = t.cornerRadius, o = t.startAngle, d = t.endAngle, c = t.padAngle, s = t.padRadius, h = n0();
  return r != null && wn(h.innerRadius, r), a != null && wn(h.outerRadius, a), i != null && wn(h.cornerRadius, i), o != null && wn(h.startAngle, o), d != null && wn(h.endAngle, d), c != null && wn(h.padAngle, c), s != null && wn(h.padRadius, s), h;
}
function cp(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.x0, i = t.x1, o = t.y, d = t.y0, c = t.y1, s = t.defined, h = t.curve, y = r0();
  return r && wn(y.x, r), a && wn(y.x0, a), i && wn(y.x1, i), o && wn(y.y, o), d && wn(y.y0, d), c && wn(y.y1, c), s && y.defined(s), h && y.curve(h), y;
}
function Ny(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.y, i = t.defined, o = t.curve, d = vy();
  return r && wn(d.x, r), a && wn(d.y, a), i && d.defined(i), o && d.curve(o), d;
}
function I0(e) {
  var t = e === void 0 ? {} : e, r = t.startAngle, a = t.endAngle, i = t.padAngle, o = t.value, d = t.sort, c = t.sortValues, s = o0();
  return (d === null || d != null) && s.sort(d), (c === null || c != null) && s.sortValues(c), o != null && s.value(o), i != null && wn(s.padAngle, i), r != null && wn(s.startAngle, r), a != null && wn(s.endAngle, a), s;
}
function $0(e) {
  var t = e.keys, r = e.value, a = e.order, i = e.offset, o = lp();
  return t && o.keys(t), r && wn(o.value, r), a && o.order(sp(a)), i && o.offset(up(i)), o;
}
var H0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function wf() {
  return wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, wf.apply(this, arguments);
}
function V0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function W0(e) {
  var t = e.className, r = e.top, a = e.left, i = e.data, o = i === void 0 ? [] : i, d = e.centroid, c = e.innerRadius, s = c === void 0 ? 0 : c, h = e.outerRadius, y = e.cornerRadius, g = e.startAngle, x = e.endAngle, w = e.padAngle, S = e.padRadius, A = e.pieSort, p = e.pieSortValues, v = e.pieValue, L = e.children, P = e.fill, R = P === void 0 ? "" : P, C = V0(e, H0), z = B0({
    innerRadius: s,
    outerRadius: h,
    cornerRadius: y,
    padRadius: S
  }), W = I0({
    startAngle: g,
    endAngle: x,
    padAngle: w,
    value: v,
    sort: A,
    sortValues: p
  }), Z = W(o);
  return L ? /* @__PURE__ */ n.createElement(n.Fragment, null, L({
    arcs: Z,
    path: z,
    pie: W
  })) : /* @__PURE__ */ n.createElement(et, {
    className: "visx-pie-arcs-group",
    top: r,
    left: a
  }, Z.map(function(ee, K) {
    return /* @__PURE__ */ n.createElement("g", {
      key: "pie-arc-" + K
    }, /* @__PURE__ */ n.createElement("path", wf({
      className: Rn("visx-pie-arc", t),
      d: z(ee) || "",
      fill: R == null || typeof R == "string" ? R : R(ee)
    }, C)), d == null ? void 0 : d(z.centroid(ee), ee));
  }));
}
var j0 = ["from", "to", "fill", "className", "innerRef"];
function Tf() {
  return Tf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Tf.apply(this, arguments);
}
function U0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function ln(e) {
  var t = e.from, r = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, i = a === void 0 ? {
    x: 1,
    y: 1
  } : a, o = e.fill, d = o === void 0 ? "transparent" : o, c = e.className, s = e.innerRef, h = U0(e, j0), y = r.x === i.x || r.y === i.y;
  return /* @__PURE__ */ n.createElement("line", Tf({
    ref: s,
    className: Rn("visx-line", c),
    x1: r.x,
    y1: r.y,
    x2: i.x,
    y2: i.y,
    fill: d,
    shapeRendering: y ? "crispEdges" : "auto"
  }, h));
}
var K0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function Y0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Hr(e) {
  var t = e.children, r = e.data, a = r === void 0 ? [] : r, i = e.x, o = e.y, d = e.fill, c = d === void 0 ? "transparent" : d, s = e.className, h = e.curve, y = e.innerRef, g = e.defined, x = g === void 0 ? function() {
    return !0;
  } : g, w = Y0(e, K0), S = Ny({
    x: i,
    y: o,
    defined: x,
    curve: h
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: S
  })) : /* @__PURE__ */ n.createElement("path", Cf({
    ref: y,
    className: Rn("visx-linepath", s),
    d: S(a) || "",
    fill: c,
    strokeLinecap: "round"
  }, w));
}
var G0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function X0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function q0(e) {
  var t = e.children, r = e.x, a = e.x0, i = e.x1, o = e.y, d = e.y0, c = e.y1, s = e.data, h = s === void 0 ? [] : s, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, x = e.className, w = e.curve, S = e.innerRef, A = X0(e, G0), p = cp({
    x: r,
    x0: a,
    x1: i,
    y: o,
    y0: d,
    y1: c,
    defined: g,
    curve: w
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: p
  })) : /* @__PURE__ */ n.createElement("path", Af({
    ref: S,
    className: Rn("visx-area", x),
    d: p(h) || ""
  }, A));
}
var Z0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function Q0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Pf(e) {
  var t = e.x, r = e.x0, a = e.x1, i = e.y, o = e.y1, d = e.y0, c = e.yScale, s = e.data, h = s === void 0 ? [] : s, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, x = e.className, w = e.curve, S = e.innerRef, A = e.children, p = Q0(e, Z0), v = cp({
    x: t,
    x0: r,
    x1: a,
    defined: g,
    curve: w
  });
  return d == null ? v.y0(c.range()[0]) : wn(v.y0, d), i && !o && wn(v.y1, i), o && !i && wn(v.y1, o), A ? /* @__PURE__ */ n.createElement(n.Fragment, null, A({
    path: v
  })) : /* @__PURE__ */ n.createElement("path", Lf({
    ref: S,
    className: Rn("visx-area-closed", x),
    d: v(h) || ""
  }, p));
}
var J0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function eE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function tE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, h = e.x0, y = e.x1, g = e.y0, x = e.y1, w = e.value, S = e.order, A = e.offset, p = e.color, v = e.children, L = eE(e, J0), P = $0({
    keys: i,
    value: w,
    order: S,
    offset: A
  }), R = cp({
    x: s,
    x0: h,
    x1: y,
    y0: g,
    y1: x,
    curve: d,
    defined: c
  }), C = P(o);
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v({
    stacks: C,
    path: R,
    stack: P
  })) : /* @__PURE__ */ n.createElement(et, {
    top: r,
    left: a
  }, C.map(function(z, W) {
    return /* @__PURE__ */ n.createElement("path", Rf({
      className: Rn("visx-stack", t),
      key: "stack-" + W + "-" + (z.key || ""),
      d: R(z) || "",
      fill: p == null ? void 0 : p(z.key, W)
    }, L));
  }));
}
var nE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function rE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function aE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, h = e.x0, y = e.x1, g = e.y0, x = e.y1, w = e.value, S = e.order, A = e.offset, p = e.color, v = e.children, L = rE(e, nE);
  return /* @__PURE__ */ n.createElement(tE, lc({
    className: t,
    top: r,
    left: a,
    keys: i,
    data: o,
    curve: d,
    defined: c,
    x: s,
    x0: h,
    x1: y,
    y0: g,
    y1: x,
    value: w,
    order: S,
    offset: A,
    color: p
  }, L), v || function(P) {
    var R = P.stacks, C = P.path;
    return R.map(function(z, W) {
      return /* @__PURE__ */ n.createElement("path", lc({
        className: Rn("visx-area-stack", t),
        key: "area-stack-" + W + "-" + (z.key || ""),
        d: C(z) || "",
        fill: p == null ? void 0 : p(z.key, W)
      }, L));
    });
  });
}
function dp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), r = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / r.length;
}
var iE = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function oE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Dy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x0, d = e.x0Scale, c = e.x1Scale, s = e.yScale, h = e.color, y = e.keys, g = e.height, x = e.children, w = oE(e, iE), S = dp(c), A = t.map(function(p, v) {
    return {
      index: v,
      x0: d(o(p)),
      bars: y.map(function(L, P) {
        var R = p[L];
        return {
          index: P,
          key: L,
          value: R,
          width: S,
          x: c(L) || 0,
          y: s(R) || 0,
          color: h(L, P),
          height: g - (s(R) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ n.createElement(n.Fragment, null, x(A)) : /* @__PURE__ */ n.createElement(et, {
    className: Rn("visx-bar-group", r),
    top: a,
    left: i
  }, A.map(function(p) {
    return /* @__PURE__ */ n.createElement(et, {
      key: "bar-group-" + p.index + "-" + p.x0,
      left: p.x0
    }, p.bars.map(function(v) {
      return /* @__PURE__ */ n.createElement(Rr, Nf({
        key: "bar-group-bar-" + p.index + "-" + v.index + "-" + v.value + "-" + v.key,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height,
        fill: v.color
      }, w));
    }));
  }));
}
function _y(e) {
  return e == null ? void 0 : e[0];
}
function Oy(e) {
  return e == null ? void 0 : e[1];
}
var lE = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Df.apply(this, arguments);
}
function sE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Fy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x, d = e.y0, c = d === void 0 ? _y : d, s = e.y1, h = s === void 0 ? Oy : s, y = e.xScale, g = e.yScale, x = e.color, w = e.keys, S = e.value, A = e.order, p = e.offset, v = e.children, L = sE(e, lE), P = lp();
  w && P.keys(w), S && wn(P.value, S), A && P.order(sp(A)), p && P.offset(up(p));
  var R = P(t), C = dp(y), z = R.map(function(W, Z) {
    var ee = W.key;
    return {
      index: Z,
      key: ee,
      bars: W.map(function(K, le) {
        var Y = (g(c(K)) || 0) - (g(h(K)) || 0), ae = g(h(K)), B = "bandwidth" in y ? y(o(K.data)) : Math.max((y(o(K.data)) || 0) - C / 2);
        return {
          bar: K,
          key: ee,
          index: le,
          height: Y,
          width: C,
          x: B || 0,
          y: ae || 0,
          color: x(W.key, le)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v(z)) : /* @__PURE__ */ n.createElement(et, {
    className: Rn("visx-bar-stack", r),
    top: a,
    left: i
  }, z.map(function(W) {
    return W.bars.map(function(Z) {
      return /* @__PURE__ */ n.createElement(Rr, Df({
        key: "bar-stack-" + W.index + "-" + Z.index,
        x: Z.x,
        y: Z.y,
        height: Z.height,
        width: Z.width,
        fill: Z.color
      }, L));
    });
  }));
}
var uE = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function cE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function dE(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.y, d = e.x0, c = d === void 0 ? _y : d, s = e.x1, h = s === void 0 ? Oy : s, y = e.xScale, g = e.yScale, x = e.color, w = e.keys, S = e.value, A = e.order, p = e.offset, v = e.children, L = cE(e, uE), P = lp();
  w && P.keys(w), S && wn(P.value, S), A && P.order(sp(A)), p && P.offset(up(p));
  var R = P(t), C = dp(g), z = R.map(function(W, Z) {
    var ee = W.key;
    return {
      index: Z,
      key: ee,
      bars: W.map(function(K, le) {
        var Y = (y(h(K)) || 0) - (y(c(K)) || 0), ae = y(c(K)), B = "bandwidth" in g ? g(o(K.data)) : Math.max((g(o(K.data)) || 0) - Y / 2);
        return {
          bar: K,
          key: ee,
          index: le,
          height: C,
          width: Y,
          x: ae || 0,
          y: B || 0,
          color: x(W.key, le)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v(z)) : /* @__PURE__ */ n.createElement(et, {
    className: Rn("visx-bar-stack-horizontal", r),
    top: a,
    left: i
  }, z.map(function(W) {
    return W.bars.map(function(Z) {
      return /* @__PURE__ */ n.createElement(Rr, _f({
        key: "bar-stack-" + W.index + "-" + Z.index,
        x: Z.x,
        y: Z.y,
        height: Z.height,
        width: Z.width,
        fill: Z.color
      }, L));
    });
  }));
}
var Ah = "http://www.w3.org/2000/svg";
function fE(e) {
  var t = document.getElementById(e);
  if (!t) {
    var r = document.createElementNS(Ah, "svg");
    r.setAttribute("aria-hidden", "true"), r.style.opacity = "0", r.style.width = "0", r.style.height = "0", r.style.position = "absolute", r.style.top = "-100%", r.style.left = "-100%", r.style.pointerEvents = "none", t = document.createElementNS(Ah, "path"), t.setAttribute("id", e), r.appendChild(t), document.body.appendChild(r);
  }
  return t;
}
var pE = "__visx_splitpath_svg_path_measurement_id", Lh = function() {
  return !0;
};
function hE(e) {
  var t = e.path, r = e.pointsInSegments, a = e.segmentation, i = a === void 0 ? "x" : a, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var c = fE(pE);
    c.setAttribute("d", t);
    var s = c.getTotalLength(), h = r.length, y = r.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var g = r.map(function(ae) {
        var B;
        return (B = ae.find(function(X) {
          return typeof X[i] == "number";
        })) == null ? void 0 : B[i];
      }), x = c.getPointAtLength(0), w = c.getPointAtLength(s), S = w[i] > x[i], A = S ? g.map(function(ae) {
        return typeof ae > "u" ? Lh : function(B) {
          return B >= ae;
        };
      }) : g.map(function(ae) {
        return typeof ae > "u" ? Lh : function(B) {
          return B <= ae;
        };
      }), p = 0, v = 0; v <= s; v += d) {
        for (var L = c.getPointAtLength(v), P = L[i]; p < h - 1 && A[p + 1](P); )
          p += 1;
        y[p].push(L);
      }
    else {
      var R = r.map(function(ae) {
        return ae.length;
      }), C = R.reduce(function(ae, B) {
        return ae + B;
      }, 0), z = s / Math.max(1, C - 1), W = R.slice(0, h - 1);
      W.unshift(0);
      for (var Z = 2; Z < h; Z += 1)
        W[Z] += W[Z - 1];
      for (var ee = 0; ee < h; ee += 1)
        W[ee] *= z;
      for (var K = 0, le = 0; le <= s; le += d) {
        for (var Y = c.getPointAtLength(le); K < h - 1 && le >= W[K + 1]; )
          K += 1;
        y[K].push(Y);
      }
    }
    return y;
  } catch {
    return [];
  }
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var mE = function(t) {
  return t.x || 0;
}, yE = function(t) {
  return t.y || 0;
};
function My(e) {
  var t = e.children, r = e.className, a = e.curve, i = e.defined, o = e.segmentation, d = e.sampleRate, c = e.segments, s = e.x, h = e.y, y = e.styles, g = se.useMemo(function() {
    var S = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, A = typeof h == "number" || typeof h > "u" ? function() {
      return h;
    } : h;
    return c.map(function(p) {
      return p.map(function(v, L) {
        return {
          x: S(v, L, p),
          y: A(v, L, p)
        };
      });
    });
  }, [s, h, c]), x = se.useMemo(function() {
    var S = Ny({
      x: s,
      y: h,
      defined: i,
      curve: a
    });
    return S(c.flat()) || "";
  }, [s, h, i, a, c]), w = se.useMemo(function() {
    return hE({
      path: x,
      segmentation: o,
      pointsInSegments: g,
      sampleRate: d
    });
  }, [x, o, g, d]);
  return /* @__PURE__ */ n.createElement("g", null, w.map(function(S, A) {
    return t ? /* @__PURE__ */ n.createElement(n.Fragment, {
      key: A
    }, t({
      index: A,
      segment: S,
      styles: y[A] || y[A % y.length]
    })) : /* @__PURE__ */ n.createElement(Hr, Of({
      key: A,
      className: r,
      data: S,
      x: mE,
      y: yE
    }, y[A] || y[A % y.length]));
  }));
}
My.propTypes = {
  segments: Me.arrayOf(Me.array).isRequired,
  styles: Me.array.isRequired,
  children: Me.func,
  className: Me.string
};
var gE = ["tooltipOpen"];
function vE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function sc() {
  return sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, sc.apply(this, arguments);
}
function zy(e) {
  var t = se.useState(sc({
    tooltipOpen: !1
  }, e)), r = t[0], a = t[1], i = se.useCallback(function(d) {
    return a(typeof d == "function" ? function(c) {
      c.tooltipOpen;
      var s = vE(c, gE);
      return sc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [a]), o = se.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: r.tooltipOpen,
    tooltipLeft: r.tooltipLeft,
    tooltipTop: r.tooltipTop,
    tooltipData: r.tooltipData,
    updateTooltip: a,
    showTooltip: i,
    hideTooltip: o
  };
}
var xE = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function uc() {
  return uc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, uc.apply(this, arguments);
}
function bE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var By = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, fp = /* @__PURE__ */ n.forwardRef(function(e, t) {
  var r = e.className, a = e.top, i = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, c = e.offsetTop, s = c === void 0 ? 10 : c, h = e.style, y = h === void 0 ? By : h, g = e.children, x = e.unstyled, w = x === void 0 ? !1 : x, S = e.applyPositionStyle, A = S === void 0 ? !1 : S, p = bE(e, xE);
  return /* @__PURE__ */ n.createElement("div", uc({
    ref: t,
    className: Rn("visx-tooltip", r),
    style: uc({
      top: a == null || s == null ? a : a + s,
      left: i == null || d == null ? i : i + d
    }, A && {
      position: "absolute"
    }, !w && y)
  }, p), g);
});
fp.propTypes = {
  children: Me.node,
  className: Me.string,
  left: Me.number,
  offsetLeft: Me.number,
  offsetTop: Me.number,
  top: Me.number,
  applyPositionStyle: Me.bool,
  unstyled: Me.bool
};
fp.displayName = "Tooltip";
const EE = fp;
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function SE(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function kE(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Mf(e, t);
}
function Mf(e, t) {
  return Mf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, i) {
    return a.__proto__ = i, a;
  }, Mf(e, t);
}
var Ph = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function wE(e) {
  var t;
  return t = /* @__PURE__ */ function(r) {
    kE(a, r);
    function a(o) {
      var d;
      return d = r.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ n.createRef(), d.getRects = d.getRects.bind(SE(d)), d;
    }
    var i = a.prototype;
    return i.componentDidMount = function() {
      var d, c = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : sv.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, c = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : Ph, h = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : Ph;
      return {
        rect: s,
        parentRect: h
      };
    }, i.render = function() {
      return /* @__PURE__ */ n.createElement(e, Ff({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(n.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Iy = /* @__PURE__ */ se.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), TE = Iy.Provider;
Iy.Consumer;
var CE = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function cc() {
  return cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, cc.apply(this, arguments);
}
function AE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function $y(e) {
  var t = e.children;
  e.getRects;
  var r = e.left, a = r === void 0 ? 0 : r, i = e.offsetLeft, o = i === void 0 ? 10 : i, d = e.offsetTop, c = d === void 0 ? 10 : d, s = e.parentRect, h = e.rect, y = e.style, g = y === void 0 ? By : y, x = e.top, w = x === void 0 ? 0 : x, S = e.unstyled, A = S === void 0 ? !1 : S, p = e.nodeRef, v = AE(e, CE), L, P = !1, R = !1;
  if (h && s) {
    var C = a, z = w;
    if (s.width) {
      var W = C + o + h.width - s.width, Z = h.width - C - o;
      P = W > 0 && W > Z;
    } else {
      var ee = C + o + h.width - window.innerWidth, K = h.width - C - o;
      P = ee > 0 && ee > K;
    }
    if (s.height) {
      var le = z + c + h.height - s.height, Y = h.height - z - c;
      R = le > 0 && le > Y;
    } else
      R = z + c + h.height > window.innerHeight;
    C = P ? C - h.width - o : C + o, z = R ? z - h.height - c : z + c, C = Math.round(C), z = Math.round(z), L = "translate(" + C + "px, " + z + "px)";
  }
  return /* @__PURE__ */ n.createElement(EE, cc({
    ref: p,
    style: cc({
      left: 0,
      top: 0,
      transform: L
    }, !A && g)
  }, v), /* @__PURE__ */ n.createElement(TE, {
    value: {
      isFlippedVertically: !R,
      isFlippedHorizontally: !P
    }
  }, t));
}
$y.propTypes = {
  nodeRef: Me.oneOfType([Me.string, Me.func, Me.object])
};
const Hy = wE($y), Vy = (e) => {
  const {
    tableData: t,
    config: r,
    formatNumber: a,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: d,
    parseDate: c,
    setSharedFilter: s,
    isDraggingAnnotation: h
  } = se.useContext(pt), { xScale: y, yScale: g, showTooltip: x, hideTooltip: w } = e, { xAxis: S, visualizationType: A, orientation: p, yAxis: v, runtime: L } = r, P = (ne, Q) => {
    var ue;
    let V = 0, j = Number(g.invert(ne)), te = null, U = null;
    for (let ke of (ue = r.runtime) == null ? void 0 : ue.seriesKeys)
      if (Q.hasOwnProperty(ke) && (V += Number(Q[ke]), V >= j)) {
        U = Q[ke], te = ke;
        break;
      }
    return [te, U];
  }, R = (ne, Q, V, j) => {
    const te = V.general.showMissingDataLabel && (!Q || Q === "null"), U = ne === V.xAxis.dataKey ? Q : a(Q, j(ne));
    return te ? "N/A" : U;
  }, C = (ne, Q) => {
    const { x: V, y: j } = Q, U = {
      data: ne || {},
      dataXPosition: V + 10,
      dataYPosition: j
    };
    return {
      tooltipLeft: U.dataXPosition,
      tooltipTop: U.dataYPosition,
      tooltipData: U
    };
  }, z = (ne, Q) => {
    if (A === "Bump Chart" || (ne.stopPropagation(), h))
      return;
    const V = Np(ne), { x: j, y: te } = V, { data: U, arc: ue } = Q ?? {}, ke = ee(j - Number(r.yAxis.size || 0)), xe = t.filter((Re) => Re[S.dataKey] === K(te)), be = p === "vertical" ? Y(ke) : xe, Ae = (Re) => {
      const fe = r.runtime.series.filter((Ne) => Ne.dataKey === Re)[0];
      return fe != null && fe.axis ? String(fe.axis).toLowerCase() : "left";
    }, Pe = (() => {
      var qe, He, Be, Ze;
      const Re = r.columns, fe = [], ze = [];
      for (const [Ve, je] of Object.entries(Re)) {
        const Ue = {
          addColPrefix: r.columns[Ve].prefix,
          addColSuffix: r.columns[Ve].suffix,
          addColRoundTo: r.columns[Ve].roundToPlace ? r.columns[Ve].roundToPlace : "",
          addColCommas: r.columns[Ve].commas
        };
        let we = null;
        r.visualizationType === "Pie" ? we = ue == null ? void 0 : ue.data[je.name] : we = (qe = be[0]) == null ? void 0 : qe[je.name];
        const De = Gf(we, "left", !0, r, Ue);
        je.tooltips && fe.push([je.label, De]);
      }
      const Ne = [];
      if (fe.forEach((Ve) => {
        Ne.push([Ve[0], Ve[1]]);
      }), A === "Pie") {
        const Ve = Number(r.dataFormat.roundTo) || 0, we = ((ue.endAngle - ue.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Ve);
        ze.push(
          // ignore
          [r.xAxis.dataKey, U],
          [r.runtime.yAxis.dataKey, a(ue == null ? void 0 : ue.data[r.runtime.yAxis.dataKey])],
          ["Percent", `${we + "%"}`]
        );
      }
      if (A === "Forest Plot" && ze.push([r.xAxis.dataKey, K(te)]), A !== "Pie" && A !== "Forest Plot" && !r.tooltips.singleSeries && (ze.push(
        ...(Be = (He = ae()) == null ? void 0 : He.filter((Ve) => {
          var Ue, we;
          return ((Ue = r.runtime.series) == null ? void 0 : Ue.find(
            (De) => De.dataKey === Ve && (De == null ? void 0 : De.tooltip) && !De.dynamicCategory
          )) || ((we = r.xAxis) == null ? void 0 : we.dataKey) == Ve || A === "Forecasting";
        })) == null ? void 0 : Be.flatMap((Ve) => {
          var we;
          const je = (we = be[0]) == null ? void 0 : we[Ve], Ue = R(Ve, je, r, Ae);
          return (je == null || je === "" || Ue === "N/A") && r.general.hideNullValue ? [] : [[Ve, Ue, Ae(Ve)]];
        })
      ), (Ze = r.runtime.series) == null || Ze.forEach((Ve) => {
        if (Ve != null && Ve.dynamicCategory) {
          const je = Ve.dataKey, Ue = be.find((rt) => rt[Ve.dynamicCategory] === je);
          if (!Ue)
            return;
          const we = Ue[Ve.originalDataKey], De = R(je, we, r, Ae);
          ze.push([je, De, Ae(je)]);
        }
      })), A !== "Pie" && A !== "Forest Plot" && r.tooltips.singleSeries) {
        const [Ve, je] = P(te, be[0]);
        if (Ve && je) {
          ze.push([r.xAxis.dataKey, ke]);
          const Ue = R(Ve, je, r, Ae);
          ze.push([Ve, Ue]);
        }
      }
      return [...ze, ...Ne];
    })();
    if (!Pe)
      return;
    const ye = C(Pe, V);
    x(ye);
  }, W = () => {
    r.visualizationType === "Area Chart" ? setTimeout(() => {
      w();
    }, 3e3) : w();
  }, Z = (ne) => {
    if (r.xAxis.type === "categorical" || r.visualizationType === "Combo") {
      let Q = y.step();
      const j = Math.floor(Number(ne) / Q);
      return y.domain()[j - 1];
    }
    if (Pn(r.xAxis) && r.visualizationType !== "Combo") {
      const Q = rh((U) => c(U[r.xAxis.dataKey])).left, V = y.invert(y(ne)), j = Q(r.data, V, 1);
      return c(r.data[j - 1][r.xAxis.dataKey]);
    }
  }, ee = (ne, Q = !1) => {
    if (A !== "Pie" && p !== "horizontal") {
      if (y.type === "point" || S.type === "continuous" || Pn(S)) {
        let V = null, j = Number.MAX_VALUE, te = ne;
        return t.forEach((U) => {
          const ue = Pn(S) ? y(c(U[S.dataKey])) : y(U[S.dataKey]);
          let ke = r.barHeight;
          const xe = Math.abs(Number(ue - te + (Q ? ke * 2 : 0)));
          xe <= j && (j = xe, V = (Pn(S), U[S.dataKey]));
        }), V;
      }
      if (r.xAxis.type === "categorical" || A === "Combo" && p !== "horizontal" && A !== "Forest Plot") {
        let j = (y.range()[1] - y.range()[0]) / (y.domain().length + 1);
        const U = Math.floor((Number(ne) - j / 2) / j);
        return y.domain()[U];
      }
      if (Pn(S) && A !== "Combo" && p !== "horizontal") {
        const V = rh((ue) => c(ue[r.xAxis.dataKey])).left, j = y.invert(ne), te = V(r.data, j, 1);
        return c(r.data[te - 1][r.xAxis.dataKey]);
      }
    }
  }, K = (ne, Q) => {
    if (A === "Pie")
      return;
    let V = Number.MAX_VALUE, j = null;
    return t.forEach((te, U) => {
      const ue = g(A !== "Forest Plot" ? te[r.xAxis.dataKey] : U), ke = Math.abs(ue - ne);
      ke < V && (V = ke, j = Q ? te[Q] : te[r.xAxis.dataKey]);
    }), j;
  }, le = (ne) => {
    var Q, V;
    try {
      if (r.visualizationType === "Bump Chart")
        return;
      const j = Np(ne), { x: te } = j;
      if (!te)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let U = ee(te, !0), ue = (Q = r.data) == null ? void 0 : Q.filter((ke) => ke[r.xAxis.dataKey] === U);
      if (!U)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Pn(S) && U && (U = new Date(U), U = o(U), ue = (V = r.data) == null ? void 0 : V.filter((ke) => o(new Date(ke[r.xAxis.dataKey])) === U)), !ue[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${U}`);
      s && (r != null && r.uid) && (ue != null && ue[0]) && s(r.uid, ue[0]);
    } catch (j) {
      console.error(j.message);
    }
  }, Y = (ne) => {
    const V = r.runtime.series.filter(
      (U) => A === "Pie" || U.tooltip === !0 && !U.dynamicCategory
    ).map((U) => U.dataKey);
    V.push(r.xAxis.dataKey);
    const j = Je.uniq(
      r.runtime.series.flatMap((U) => {
        if (U.dynamicCategory)
          return [U.dynamicCategory, U.originalDataKey];
      })
    );
    V.push(...j), r.visualizationType === "Forecasting" && r.runtime.series.map((U) => {
      U.confidenceIntervals.map((ue) => {
        ue.showInTooltip && (V.push(ue.high), V.push(ue.low));
      });
    });
    const te = Object.values(r.columns).map((U) => U.name);
    V.push(...te, ...te);
    try {
      const U = t.filter((ke) => ke[S.dataKey] === ne);
      return !U || U.length === 0 ? [] : U.map((ke) => Je.pick(ke, V));
    } catch (U) {
      console.error("COVE", U);
    }
  }, ae = () => {
    var ne;
    try {
      let Q, V = [], j = [];
      if ((ne = r.runtime.series) == null || ne.forEach((te) => {
        te.type === "Forecasting" && (V.push(te.stageColumn), te == null || te.confidenceIntervals.forEach((U) => {
          U.showInTooltip === !0 && (j.push(U.low), j.push(U.high));
        }));
      }), !r.dashboard)
        switch (A) {
          case "Combo":
            Q = [L.xAxis.dataKey, ...L == null ? void 0 : L.seriesKeys, ...j];
            break;
          case "Forecasting":
            Q = [L.xAxis.dataKey, ...V, ...j];
            break;
          case "Line":
            Q = [L.xAxis.dataKey, ...L == null ? void 0 : L.seriesKeys];
            break;
          case "Area Chart":
            Q = [L.xAxis.dataKey, ...L == null ? void 0 : L.seriesKeys];
            break;
          case "Bar":
            Q = p === "vertical" ? [L.xAxis.dataKey, ...L == null ? void 0 : L.seriesKeys] : [L.yAxis.dataKey, ...L == null ? void 0 : L.seriesKeys];
            break;
          case "Pie":
            Q = [L.xAxis.dataKey, ...L == null ? void 0 : L.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return r.dashboard && (Q = [
        L.xAxis.dataKey,
        ...L == null ? void 0 : L.barSeriesKeys,
        ...L == null ? void 0 : L.lineSeriesKeys,
        ...V,
        ...j
      ]), Q;
    } catch (Q) {
      console.error("COVE", Q);
    }
  }, B = (ne) => {
    const { dataXPosition: Q, dataYPosition: V } = ne;
    return {
      opacity: r.tooltips.opacity ? r.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${Q}px, ${Number(V)}px)`
    };
  }, X = (ne) => {
    var V, j;
    let Q = r.runtime.series.filter((te) => te.dataKey === ne);
    return (V = Q[0]) != null && V.name ? (j = Q[0]) == null ? void 0 : j.name : ne;
  };
  return {
    getIncludedTooltipSeries: ae,
    getXValueFromCoordinate: ee,
    getXValueFromCoordinateDate: Z,
    getYScaleValues: Y,
    handleTooltipClick: le,
    handleTooltipMouseOff: W,
    handleTooltipMouseOver: z,
    TooltipListItem: ({ item: ne }) => {
      var Ye;
      const [Q, V] = ne, [j, te, U] = V;
      if (A === "Forest Plot")
        return j === r.xAxis.dataKey ? /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(r.xAxis.dataKey ? `${r.xAxis.dataKey}: ` : "")} ${Pn(v) ? o(c(j, !1)) : te}`) : /* @__PURE__ */ n.createElement("li", { className: "tooltip-body" }, `${X(j)}: ${a(te, "left")}`);
      const ue = r.tooltips.dateDisplayFormat ? d(c(te, !1)) : o(c(te, !1));
      if (A === "Bar" && p === "horizontal" && j === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ` : ""
        )} ${r.xAxis.type === "date" ? ue : te}`);
      if (j === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ` : ""
        )} ${Pn(S) ? ue : te}`);
      const { label: ke, displayGray: xe } = r.visualizationSubType !== "stacked" && r.general.showSuppressedSymbol && ((Ye = r.preliminaryData) == null ? void 0 : Ye.find(
        (Pe) => Pe.label && Pe.type === "suppression" && Pe.displayTooltip && te === Pe.value && (!Pe.column || j === Pe.column)
      )) || {};
      let be = ke || te;
      const Ae = xe ? { color: "#8b8b8a" } : {};
      return Q == 1 && r.dataFormat.onlyShowTopPrefixSuffix && (be = `${r.dataFormat.prefix}${be}${r.dataFormat.suffix}`), /* @__PURE__ */ n.createElement("li", { style: Ae, className: "tooltip-body" }, `${X(j)}: ${be}`);
    },
    tooltipStyles: B
  };
};
function pp(e, { threshold: t = 0, root: r = null, rootMargin: a = "0%", freezeOnceVisible: i = !1 }) {
  const [o, d] = se.useState(), c = (o == null ? void 0 : o.isIntersecting) && i, s = ([h]) => {
    d(h);
  };
  return se.useEffect(() => {
    const h = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || c || !h)
      return;
    const g = { threshold: t, root: r, rootMargin: a }, x = new IntersectionObserver(s, g);
    return x.observe(h), () => x.disconnect();
  }, [e, t, r, a, c]), o;
}
const zf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let r = "";
    return e.visualizationType && (r += `${e.visualizationType} chart`), e.title && e.visualizationType && (r += ` with the title: ${e.title}`), r;
  } catch (r) {
    console.error("COVE: ", r.message);
  }
}, Rh = Symbol("implicit");
function hp() {
  var e = new Kp(), t = [], r = [], a = Rh;
  function i(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (a !== Rh)
        return a;
      e.set(o, d = t.push(o) - 1);
    }
    return r[d % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Kp();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (a = o, i) : a;
  }, i.copy = function() {
    return hp(t, r).unknown(a);
  }, Nc.apply(i, arguments), i;
}
function mp() {
  var e = hp().unknown(void 0), t = e.domain, r = e.range, a = 0, i = 1, o, d, c = !1, s = 0, h = 0, y = 0.5;
  delete e.unknown;
  function g() {
    var x = t().length, w = i < a, S = w ? i : a, A = w ? a : i;
    o = (A - S) / Math.max(1, x - s + h * 2), c && (o = Math.floor(o)), S += (A - S - o * (x - s)) * y, d = o * (1 - s), c && (S = Math.round(S), d = Math.round(d));
    var p = mv(x).map(function(v) {
      return S + o * v;
    });
    return r(w ? p.reverse() : p);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), g()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([a, i] = x, a = +a, i = +i, g()) : [a, i];
  }, e.rangeRound = function(x) {
    return [a, i] = x, a = +a, i = +i, c = !0, g();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(x) {
    return arguments.length ? (c = !!x, g()) : c;
  }, e.padding = function(x) {
    return arguments.length ? (s = Math.min(1, h = +x), g()) : s;
  }, e.paddingInner = function(x) {
    return arguments.length ? (s = Math.min(1, x), g()) : s;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (h = +x, g()) : h;
  }, e.align = function(x) {
    return arguments.length ? (y = Math.max(0, Math.min(1, x)), g()) : y;
  }, e.copy = function() {
    return mp(t(), [a, i]).round(c).paddingInner(s).paddingOuter(h).align(y);
  }, Nc.apply(g(), arguments);
}
function Wy(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Wy(t());
  }, e;
}
function LE() {
  return Wy(mp.apply(null, arguments).paddingInner(1));
}
function jy(e, t) {
  e = e.slice();
  var r = 0, a = e.length - 1, i = e[r], o = e[a], d;
  return o < i && (d = r, r = a, a = d, d = i, i = o, o = d), e[r] = t.floor(i), e[a] = t.ceil(o), e;
}
function Nh(e) {
  return Math.log(e);
}
function Dh(e) {
  return Math.exp(e);
}
function PE(e) {
  return -Math.log(-e);
}
function RE(e) {
  return -Math.exp(-e);
}
function NE(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function DE(e) {
  return e === 10 ? NE : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function _E(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function _h(e) {
  return (t, r) => -e(-t, r);
}
function OE(e) {
  const t = e(Nh, Dh), r = t.domain;
  let a = 10, i, o;
  function d() {
    return i = _E(a), o = DE(a), r()[0] < 0 ? (i = _h(i), o = _h(o), e(PE, RE)) : e(Nh, Dh), t;
  }
  return t.base = function(c) {
    return arguments.length ? (a = +c, d()) : a;
  }, t.domain = function(c) {
    return arguments.length ? (r(c), d()) : r();
  }, t.ticks = (c) => {
    const s = r();
    let h = s[0], y = s[s.length - 1];
    const g = y < h;
    g && ([h, y] = [y, h]);
    let x = i(h), w = i(y), S, A;
    const p = c == null ? 10 : +c;
    let v = [];
    if (!(a % 1) && w - x < p) {
      if (x = Math.floor(x), w = Math.ceil(w), h > 0) {
        for (; x <= w; ++x)
          for (S = 1; S < a; ++S)
            if (A = x < 0 ? S / o(-x) : S * o(x), !(A < h)) {
              if (A > y)
                break;
              v.push(A);
            }
      } else
        for (; x <= w; ++x)
          for (S = a - 1; S >= 1; --S)
            if (A = x > 0 ? S / o(-x) : S * o(x), !(A < h)) {
              if (A > y)
                break;
              v.push(A);
            }
      v.length * 2 < p && (v = Ip(h, y, p));
    } else
      v = Ip(x, w, Math.min(w - x, p)).map(o);
    return g ? v.reverse() : v;
  }, t.tickFormat = (c, s) => {
    if (c == null && (c = 10), s == null && (s = a === 10 ? "s" : ","), typeof s != "function" && (!(a % 1) && (s = av(s)).precision == null && (s.trim = !0), s = iv(s)), c === 1 / 0)
      return s;
    const h = Math.max(1, a * c / t.ticks().length);
    return (y) => {
      let g = y / o(Math.round(i(y)));
      return g * a < a - 0.5 && (g *= a), g <= h ? s(y) : "";
    };
  }, t.nice = () => r(jy(r(), {
    floor: (c) => o(Math.floor(i(c))),
    ceil: (c) => o(Math.ceil(i(c)))
  })), t;
}
function Uy() {
  const e = OE(rv()).domain([1, 10]);
  return e.copy = () => Rm(e, Uy()).base(e.base()), Nc.apply(e, arguments), e;
}
function FE(e) {
  return new Date(e);
}
function ME(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Ky(e, t, r, a, i, o, d, c, s, h) {
  var y = ov(), g = y.invert, x = y.domain, w = h(".%L"), S = h(":%S"), A = h("%I:%M"), p = h("%I %p"), v = h("%a %d"), L = h("%b %d"), P = h("%B"), R = h("%Y");
  function C(z) {
    return (s(z) < z ? w : c(z) < z ? S : d(z) < z ? A : o(z) < z ? p : a(z) < z ? i(z) < z ? v : L : r(z) < z ? P : R)(z);
  }
  return y.invert = function(z) {
    return new Date(g(z));
  }, y.domain = function(z) {
    return arguments.length ? x(Array.from(z, ME)) : x().map(FE);
  }, y.ticks = function(z) {
    var W = x();
    return e(W[0], W[W.length - 1], z ?? 10);
  }, y.tickFormat = function(z, W) {
    return W == null ? C : h(W);
  }, y.nice = function(z) {
    var W = x();
    return (!z || typeof z.range != "function") && (z = t(W[0], W[W.length - 1], z ?? 10)), z ? x(jy(W, z)) : y;
  }, y.copy = function() {
    return Rm(y, Ky(e, t, r, a, i, o, d, c, s, h));
  }, y;
}
function Yy() {
  return Nc.apply(Ky(gv, vv, Dm, Pm, Om, _m, Lm, Am, fs, Gg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var zE = Ls("domain", "range", "reverse", "align", "padding", "round");
function dc(e) {
  return zE(mp(), e);
}
var BE = Ls("domain", "range", "reverse", "align", "padding", "round");
function nl(e) {
  return BE(LE(), e);
}
var IE = Ls("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function $E(e) {
  return IE(Yy(), e);
}
var HE = Ls("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function fc(e) {
  return HE(Uy(), e);
}
var VE = Ls("domain", "range", "reverse", "unknown");
function yp(e) {
  return VE(hp(), e);
}
function WE(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Gy(e, t) {
  var r = e;
  return "ticks" in r ? r.ticks(t) : r.domain().filter(function(a, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function jE(e) {
  return e == null ? void 0 : e.toString();
}
const Du = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), UE = (e) => {
  const {
    transformedData: t,
    config: r,
    colorScale: a,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: d
  } = se.useContext(pt), { tooltipData: c, showTooltip: s, hideTooltip: h, tooltipOpen: y, tooltipLeft: g, tooltipTop: x } = zy(), { handleTooltipMouseOver: w, handleTooltipMouseOff: S, TooltipListItem: A } = Vy({
    xScale: !1,
    yScale: !1,
    showTooltip: s,
    hideTooltip: h
  }), [p, v] = se.useState(void 0), [L, P] = se.useState(!1), R = Object.values(r.columns).filter((j) => j.showInViz), C = R.length > 0, z = C ? "pivotColumn" : void 0, W = se.useMemo(() => {
    if (C) {
      let j = [];
      const te = r.yAxis.dataKey, U = R.map((xe) => xe.name), ue = [te, ...U], ke = r.xAxis.dataKey;
      return t.forEach((xe) => {
        ue.forEach((be) => {
          const Ae = xe[be];
          Ae && j.push({
            [z]: Ae,
            [ke]: `${xe[ke]} - ${be}`
          });
        });
      }), j;
    }
    return t;
  }, [t, C]), Z = se.useMemo(() => {
    if (C) {
      const j = {};
      W.forEach((ue) => {
        j[ue[r.xAxis.dataKey]] || (j[ue[r.xAxis.dataKey]] = !0);
      });
      const te = Object.entries(j).length;
      let U = r.customColors || Sr[r.palette];
      return U = U.slice(0, te), yp({
        domain: Object.keys(j),
        range: U,
        unknown: null
      });
    }
    return a;
  }, [a, C]), ee = se.useRef(), K = pp(ee, {
    freezeOnceVisible: !1
  });
  se.useEffect(() => {
    document.querySelector(".isEditor") && P((te) => !0);
  }), se.useEffect(() => {
    K != null && K.isIntersecting && r.animate && !L && setTimeout(() => {
      P(!0);
    }, 500);
  }, [K == null ? void 0 : K.isIntersecting, r.animate]);
  const le = ({ arcs: j, path: te, getKey: U }) => {
    const ue = Rb(j, U, {
      from: Du,
      enter: Du,
      update: Du,
      leave: Du
    });
    return se.useEffect(() => {
      const ke = setTimeout(() => {
        h();
      }, 500);
      return () => {
        clearTimeout(ke);
      };
    }, [c]), /* @__PURE__ */ n.createElement(n.Fragment, null, ue.map(({ item: ke, props: xe, key: be }, Ae) => /* @__PURE__ */ n.createElement(
      et,
      {
        className: ke.data[r.xAxis.dataKey],
        key: `${be}-${Ae}`,
        style: {
          opacity: r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ke.data[r.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
        }
      },
      /* @__PURE__ */ n.createElement(
        bh.path,
        {
          d: wb(
            [xe.startAngle, xe.endAngle],
            (Ye, Pe) => te({
              ...ke,
              startAngle: Ye,
              endAngle: Pe
            })
          ),
          fill: Z(ke.data[r.runtime.xAxis.dataKey]),
          onMouseEnter: (Ye) => w(Ye, { data: ke.data[r.runtime.xAxis.dataKey], arc: ke }),
          onMouseLeave: (Ye) => S()
        }
      )
    )), ue.map(({ item: ke, key: xe }, be) => {
      const Ae = Number(r.dataFormat.roundTo) || 0, [Ye, Pe] = te.centroid(ke), ye = ke.endAngle - ke.startAngle >= 0.1;
      let Re = "#FFF";
      Z(ke.data[r.runtime.xAxis.dataKey]) && (Re = il(Re, Z(ke.data[r.runtime.xAxis.dataKey])));
      const Ne = ((ke.endAngle - ke.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Ae);
      return /* @__PURE__ */ n.createElement(bh.g, { key: `${xe}${be}` }, ye && /* @__PURE__ */ n.createElement(
        dt,
        {
          style: { fill: Re },
          x: Ye,
          y: Pe,
          dy: ".33em",
          textAnchor: "middle",
          pointerEvents: "none"
        },
        Ne + "%"
      ));
    }));
  };
  let Y = e.parentWidth, ae = e.parentWidth;
  r && r.legend && !r.legend.hide && i === "lg" && (ae = Number(Y) * 0.73);
  const B = r.heights.vertical, X = Math.min(ae, B) / 2, ce = B / 2, ne = e.parentWidth / 2, Q = r.pieType === "Donut" ? 75 : X;
  se.useEffect(() => {
    if (o.length > 0 && r.legend.behavior !== "highlight") {
      let j = [];
      W.forEach((te) => {
        o.indexOf(te[r.runtime.xAxis.dataKey]) !== -1 && j.push(te);
      }), v(j);
    } else
      v(void 0);
  }, [o]);
  const V = () => {
    let j = ["animated-pie", "group"];
    return (r.animate === !1 || L) && j.push("animated"), j.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Vr, { component: "PieChart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      width: X * 2,
      height: B,
      className: V(),
      role: "img",
      "aria-label": zf(r)
    },
    /* @__PURE__ */ n.createElement(et, { top: ce, left: X }, /* @__PURE__ */ n.createElement(
      W0,
      {
        data: p || W,
        pieValue: (j) => j[z || r.runtime.yAxis.dataKey],
        pieSortValues: () => -1,
        innerRadius: X - Q,
        outerRadius: X
      },
      (j) => /* @__PURE__ */ n.createElement(le, { ...j, getKey: (te) => te.data[r.runtime.xAxis.dataKey] })
    ))
  ), /* @__PURE__ */ n.createElement("div", { ref: ee }), !d && c && Object.entries(c.data).length > 0 && y && s && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important`), /* @__PURE__ */ n.createElement(
    Hy,
    {
      key: Math.random(),
      className: "tooltip cdc-open-viz-module",
      left: g + ne - X,
      top: x
    },
    /* @__PURE__ */ n.createElement("ul", null, typeof c == "object" && Object.entries(c.data).map((j, te) => /* @__PURE__ */ n.createElement(A, { item: j, key: te })))
  ))));
};
function Ps(e) {
  return e.split("-")[1];
}
function gp(e) {
  return e === "y" ? "height" : "width";
}
function $i(e) {
  return e.split("-")[0];
}
function Rs(e) {
  return ["top", "bottom"].includes($i(e)) ? "x" : "y";
}
function Oh(e, t, r) {
  let { reference: a, floating: i } = e;
  const o = a.x + a.width / 2 - i.width / 2, d = a.y + a.height / 2 - i.height / 2, c = Rs(t), s = gp(c), h = a[s] / 2 - i[s] / 2, y = c === "x";
  let g;
  switch ($i(t)) {
    case "top":
      g = { x: o, y: a.y - i.height };
      break;
    case "bottom":
      g = { x: o, y: a.y + a.height };
      break;
    case "right":
      g = { x: a.x + a.width, y: d };
      break;
    case "left":
      g = { x: a.x - i.width, y: d };
      break;
    default:
      g = { x: a.x, y: a.y };
  }
  switch (Ps(t)) {
    case "start":
      g[c] -= h * (r && y ? -1 : 1);
      break;
    case "end":
      g[c] += h * (r && y ? -1 : 1);
  }
  return g;
}
function Xy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ys(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function qy(e, t) {
  var r;
  t === void 0 && (t = {});
  const { x: a, y: i, platform: o, rects: d, elements: c, strategy: s } = e, { boundary: h = "clippingAncestors", rootBoundary: y = "viewport", elementContext: g = "floating", altBoundary: x = !1, padding: w = 0 } = t, S = Xy(w), A = c[x ? g === "floating" ? "reference" : "floating" : g], p = ys(await o.getClippingRect({ element: (r = await (o.isElement == null ? void 0 : o.isElement(A))) == null || r ? A : A.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)), boundary: h, rootBoundary: y, strategy: s })), v = g === "floating" ? { ...d.floating, x: a, y: i } : d.reference, L = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), P = await (o.isElement == null ? void 0 : o.isElement(L)) && await (o.getScale == null ? void 0 : o.getScale(L)) || { x: 1, y: 1 }, R = ys(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: L, strategy: s }) : v);
  return { top: (p.top - R.top + S.top) / P.y, bottom: (R.bottom - p.bottom + S.bottom) / P.y, left: (p.left - R.left + S.left) / P.x, right: (R.right - p.right + S.right) / P.x };
}
const KE = Math.min, YE = Math.max;
function Bf(e, t, r) {
  return YE(e, KE(t, r));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const GE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function pc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => GE[t]);
}
function XE(e, t, r) {
  r === void 0 && (r = !1);
  const a = Ps(e), i = Rs(e), o = gp(i);
  let d = i === "x" ? a === (r ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = pc(d)), { main: d, cross: pc(d) };
}
const qE = { start: "end", end: "start" };
function qd(e) {
  return e.replace(/start|end/g, (t) => qE[t]);
}
const ZE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var r;
    const { placement: a, middlewareData: i, rects: o, initialPlacement: d, platform: c, elements: s } = t, { mainAxis: h = !0, crossAxis: y = !0, fallbackPlacements: g, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: S = !0, ...A } = e, p = $i(a), v = $i(d) === d, L = await (c.isRTL == null ? void 0 : c.isRTL(s.floating)), P = g || (v || !S ? [pc(d)] : function(le) {
      const Y = pc(le);
      return [qd(le), Y, qd(Y)];
    }(d));
    g || w === "none" || P.push(...function(le, Y, ae, B) {
      const X = Ps(le);
      let ce = function(ne, Q, V) {
        const j = ["left", "right"], te = ["right", "left"], U = ["top", "bottom"], ue = ["bottom", "top"];
        switch (ne) {
          case "top":
          case "bottom":
            return V ? Q ? te : j : Q ? j : te;
          case "left":
          case "right":
            return Q ? U : ue;
          default:
            return [];
        }
      }($i(le), ae === "start", B);
      return X && (ce = ce.map((ne) => ne + "-" + X), Y && (ce = ce.concat(ce.map(qd)))), ce;
    }(d, S, w, L));
    const R = [d, ...P], C = await qy(t, A), z = [];
    let W = ((r = i.flip) == null ? void 0 : r.overflows) || [];
    if (h && z.push(C[p]), y) {
      const { main: le, cross: Y } = XE(a, o, L);
      z.push(C[le], C[Y]);
    }
    if (W = [...W, { placement: a, overflows: z }], !z.every((le) => le <= 0)) {
      var Z, ee;
      const le = (((Z = i.flip) == null ? void 0 : Z.index) || 0) + 1, Y = R[le];
      if (Y)
        return { data: { index: le, overflows: W }, reset: { placement: Y } };
      let ae = (ee = W.find((B) => B.overflows[0] <= 0)) == null ? void 0 : ee.placement;
      if (!ae)
        switch (x) {
          case "bestFit": {
            var K;
            const B = (K = W.map((X) => [X.placement, X.overflows.filter((ce) => ce > 0).reduce((ce, ne) => ce + ne, 0)]).sort((X, ce) => X[1] - ce[1])[0]) == null ? void 0 : K[0];
            B && (ae = B);
            break;
          }
          case "initialPlacement":
            ae = d;
        }
      if (a !== ae)
        return { reset: { placement: ae } };
    }
    return {};
  } };
}, QE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: r, y: a } = t, i = await async function(o, d) {
      const { placement: c, platform: s, elements: h } = o, y = await (s.isRTL == null ? void 0 : s.isRTL(h.floating)), g = $i(c), x = Ps(c), w = Rs(c) === "x", S = ["left", "top"].includes(g) ? -1 : 1, A = y && w ? -1 : 1, p = typeof d == "function" ? d(o) : d;
      let { mainAxis: v, crossAxis: L, alignmentAxis: P } = typeof p == "number" ? { mainAxis: p, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...p };
      return x && typeof P == "number" && (L = x === "end" ? -1 * P : P), w ? { x: L * A, y: v * S } : { x: v * S, y: L * A };
    }(t, e);
    return { x: r + i.x, y: a + i.y, data: i };
  } };
}, JE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: r, y: a, placement: i } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: c = { fn: (p) => {
      let { x: v, y: L } = p;
      return { x: v, y: L };
    } }, ...s } = e, h = { x: r, y: a }, y = await qy(t, s), g = Rs($i(i)), x = g === "x" ? "y" : "x";
    let w = h[g], S = h[x];
    if (o) {
      const p = g === "y" ? "bottom" : "right";
      w = Bf(w + y[g === "y" ? "top" : "left"], w, w - y[p]);
    }
    if (d) {
      const p = x === "y" ? "bottom" : "right";
      S = Bf(S + y[x === "y" ? "top" : "left"], S, S - y[p]);
    }
    const A = c.fn({ ...t, [g]: w, [x]: S });
    return { ...A, data: { x: A.x - r, y: A.y - a } };
  } };
};
function Pr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ta(e) {
  return Pr(e).getComputedStyle(e);
}
const Fh = Math.min, gs = Math.max, hc = Math.round;
function Zy(e) {
  const t = ta(e);
  let r = parseFloat(t.width), a = parseFloat(t.height);
  const i = e.offsetWidth, o = e.offsetHeight, d = hc(r) !== i || hc(a) !== o;
  return d && (r = i, a = o), { width: r, height: a, fallback: d };
}
function Ga(e) {
  return Jy(e) ? (e.nodeName || "").toLowerCase() : "";
}
let _u;
function Qy() {
  if (_u)
    return _u;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (_u = e.brands.map((t) => t.brand + "/" + t.version).join(" "), _u) : navigator.userAgent;
}
function na(e) {
  return e instanceof Pr(e).HTMLElement;
}
function Wa(e) {
  return e instanceof Pr(e).Element;
}
function Jy(e) {
  return e instanceof Pr(e).Node;
}
function Mh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Pr(e).ShadowRoot || e instanceof ShadowRoot;
}
function Mc(e) {
  const { overflow: t, overflowX: r, overflowY: a, display: i } = ta(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + r) && !["inline", "contents"].includes(i);
}
function eS(e) {
  return ["table", "td", "th"].includes(Ga(e));
}
function If(e) {
  const t = /firefox/i.test(Qy()), r = ta(e), a = r.backdropFilter || r.WebkitBackdropFilter;
  return r.transform !== "none" || r.perspective !== "none" || !!a && a !== "none" || t && r.willChange === "filter" || t && !!r.filter && r.filter !== "none" || ["transform", "perspective"].some((i) => r.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const o = r.contain;
    return o != null && o.includes(i);
  });
}
function eg() {
  return !/^((?!chrome|android).)*safari/i.test(Qy());
}
function vp(e) {
  return ["html", "body", "#document"].includes(Ga(e));
}
function tg(e) {
  return Wa(e) ? e : e.contextElement;
}
const ng = { x: 1, y: 1 };
function al(e) {
  const t = tg(e);
  if (!na(t))
    return ng;
  const r = t.getBoundingClientRect(), { width: a, height: i, fallback: o } = Zy(t);
  let d = (o ? hc(r.width) : r.width) / a, c = (o ? hc(r.height) : r.height) / i;
  return d && Number.isFinite(d) || (d = 1), c && Number.isFinite(c) || (c = 1), { x: d, y: c };
}
function Cs(e, t, r, a) {
  var i, o;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const d = e.getBoundingClientRect(), c = tg(e);
  let s = ng;
  t && (a ? Wa(a) && (s = al(a)) : s = al(e));
  const h = c ? Pr(c) : window, y = !eg() && r;
  let g = (d.left + (y && ((i = h.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / s.x, x = (d.top + (y && ((o = h.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, w = d.width / s.x, S = d.height / s.y;
  if (c) {
    const A = Pr(c), p = a && Wa(a) ? Pr(a) : a;
    let v = A.frameElement;
    for (; v && a && p !== A; ) {
      const L = al(v), P = v.getBoundingClientRect(), R = getComputedStyle(v);
      P.x += (v.clientLeft + parseFloat(R.paddingLeft)) * L.x, P.y += (v.clientTop + parseFloat(R.paddingTop)) * L.y, g *= L.x, x *= L.y, w *= L.x, S *= L.y, g += P.x, x += P.y, v = Pr(v).frameElement;
    }
  }
  return { width: w, height: S, top: x, right: g + w, bottom: x + S, left: g, x: g, y: x };
}
function ja(e) {
  return ((Jy(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function zc(e) {
  return Wa(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function rg(e) {
  return Cs(ja(e)).left + zc(e).scrollLeft;
}
function As(e) {
  if (Ga(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Mh(e) && e.host || ja(e);
  return Mh(t) ? t.host : t;
}
function ag(e) {
  const t = As(e);
  return vp(t) ? t.ownerDocument.body : na(t) && Mc(t) ? t : ag(t);
}
function ig(e, t) {
  var r;
  t === void 0 && (t = []);
  const a = ag(e), i = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Pr(a);
  return i ? t.concat(o, o.visualViewport || [], Mc(a) ? a : []) : t.concat(a, ig(a));
}
function zh(e, t, r) {
  return t === "viewport" ? ys(function(a, i) {
    const o = Pr(a), d = ja(a), c = o.visualViewport;
    let s = d.clientWidth, h = d.clientHeight, y = 0, g = 0;
    if (c) {
      s = c.width, h = c.height;
      const x = eg();
      (x || !x && i === "fixed") && (y = c.offsetLeft, g = c.offsetTop);
    }
    return { width: s, height: h, x: y, y: g };
  }(e, r)) : Wa(t) ? ys(function(a, i) {
    const o = Cs(a, !0, i === "fixed"), d = o.top + a.clientTop, c = o.left + a.clientLeft, s = na(a) ? al(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * s.x, height: a.clientHeight * s.y, x: c * s.x, y: d * s.y };
  }(t, r)) : ys(function(a) {
    const i = ja(a), o = zc(a), d = a.ownerDocument.body, c = gs(i.scrollWidth, i.clientWidth, d.scrollWidth, d.clientWidth), s = gs(i.scrollHeight, i.clientHeight, d.scrollHeight, d.clientHeight);
    let h = -o.scrollLeft + rg(a);
    const y = -o.scrollTop;
    return ta(d).direction === "rtl" && (h += gs(i.clientWidth, d.clientWidth) - c), { width: c, height: s, x: h, y };
  }(ja(e)));
}
function Bh(e) {
  return na(e) && ta(e).position !== "fixed" ? e.offsetParent : null;
}
function Ih(e) {
  const t = Pr(e);
  let r = Bh(e);
  for (; r && eS(r) && ta(r).position === "static"; )
    r = Bh(r);
  return r && (Ga(r) === "html" || Ga(r) === "body" && ta(r).position === "static" && !If(r)) ? t : r || function(a) {
    let i = As(a);
    for (; na(i) && !vp(i); ) {
      if (If(i))
        return i;
      i = As(i);
    }
    return null;
  }(e) || t;
}
function tS(e, t, r) {
  const a = na(t), i = ja(t), o = Cs(e, !0, r === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (a || !a && r !== "fixed")
    if ((Ga(t) !== "body" || Mc(i)) && (d = zc(t)), na(t)) {
      const s = Cs(t, !0);
      c.x = s.x + t.clientLeft, c.y = s.y + t.clientTop;
    } else
      i && (c.x = rg(i));
  return { x: o.left + d.scrollLeft - c.x, y: o.top + d.scrollTop - c.y, width: o.width, height: o.height };
}
const nS = { getClippingRect: function(e) {
  let { element: t, boundary: r, rootBoundary: a, strategy: i } = e;
  const o = r === "clippingAncestors" ? function(h, y) {
    const g = y.get(h);
    if (g)
      return g;
    let x = ig(h).filter((p) => Wa(p) && Ga(p) !== "body"), w = null;
    const S = ta(h).position === "fixed";
    let A = S ? As(h) : h;
    for (; Wa(A) && !vp(A); ) {
      const p = ta(A), v = If(A);
      (S ? v || w : v || p.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = p : x = x.filter((L) => L !== A), A = As(A);
    }
    return y.set(h, x), x;
  }(t, this._c) : [].concat(r), d = [...o, a], c = d[0], s = d.reduce((h, y) => {
    const g = zh(t, y, i);
    return h.top = gs(g.top, h.top), h.right = Fh(g.right, h.right), h.bottom = Fh(g.bottom, h.bottom), h.left = gs(g.left, h.left), h;
  }, zh(t, c, i));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: r, strategy: a } = e;
  const i = na(r), o = ja(r);
  if (r === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((i || !i && a !== "fixed") && ((Ga(r) !== "body" || Mc(o)) && (d = zc(r)), na(r))) {
    const h = Cs(r);
    c = al(r), s.x = h.x + r.clientLeft, s.y = h.y + r.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - d.scrollLeft * c.x + s.x, y: t.y * c.y - d.scrollTop * c.y + s.y };
}, isElement: Wa, getDimensions: function(e) {
  return na(e) ? Zy(e) : e.getBoundingClientRect();
}, getOffsetParent: Ih, getDocumentElement: ja, getScale: al, async getElementRects(e) {
  let { reference: t, floating: r, strategy: a } = e;
  const i = this.getOffsetParent || Ih, o = this.getDimensions;
  return { reference: tS(t, await i(r), a), floating: { x: 0, y: 0, ...await o(r) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => ta(e).direction === "rtl" }, $h = (e, t, r) => {
  const a = /* @__PURE__ */ new Map(), i = { platform: nS, ...r }, o = { ...i.platform, _c: a };
  return (async (d, c, s) => {
    const { placement: h = "bottom", strategy: y = "absolute", middleware: g = [], platform: x } = s, w = g.filter(Boolean), S = await (x.isRTL == null ? void 0 : x.isRTL(c));
    if (x == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), w.filter((C) => {
      let { name: z } = C;
      return z === "autoPlacement" || z === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let A = await x.getElementRects({ reference: d, floating: c, strategy: y }), { x: p, y: v } = Oh(A, h, S), L = h, P = {}, R = 0;
    for (let C = 0; C < w.length; C++) {
      const { name: z, fn: W } = w[C], { x: Z, y: ee, data: K, reset: le } = await W({ x: p, y: v, initialPlacement: h, placement: L, strategy: y, middlewareData: P, rects: A, platform: x, elements: { reference: d, floating: c } });
      p = Z ?? p, v = ee ?? v, P = { ...P, [z]: { ...P[z], ...K } }, R > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), le && R <= 50 && (R++, typeof le == "object" && (le.placement && (L = le.placement), le.rects && (A = le.rects === !0 ? await x.getElementRects({ reference: d, floating: c, strategy: y }) : le.rects), { x: p, y: v } = Oh(A, L, S)), C = -1);
    }
    return { x: p, y: v, placement: L, strategy: y, middlewareData: P };
  })(e, t, { ...i, platform: o });
};
var $a, Hi = { exports: {} }, Hh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
$a = Hh, function() {
  var e = n, t = 60103, r = 60106;
  $a.Fragment = 60107;
  var a = 60108, i = 60114, o = 60109, d = 60110, c = 60112, s = 60113, h = 60120, y = 60115, g = 60116, x = 60121, w = 60122, S = 60117, A = 60129, p = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var v = Symbol.for;
    t = v("react.element"), r = v("react.portal"), $a.Fragment = v("react.fragment"), a = v("react.strict_mode"), i = v("react.profiler"), o = v("react.provider"), d = v("react.context"), c = v("react.forward_ref"), s = v("react.suspense"), h = v("react.suspense_list"), y = v("react.memo"), g = v("react.lazy"), x = v("react.block"), w = v("react.server.block"), S = v("react.fundamental"), v("react.scope"), v("react.opaque.id"), A = v("react.debug_trace_mode"), v("react.offscreen"), p = v("react.legacy_hidden");
  }
  var L = typeof Symbol == "function" && Symbol.iterator, P = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function R(ye) {
    for (var Re = arguments.length, fe = new Array(Re > 1 ? Re - 1 : 0), ze = 1; ze < Re; ze++)
      fe[ze - 1] = arguments[ze];
    C("error", ye, fe);
  }
  function C(ye, Re, fe) {
    var ze = P.ReactDebugCurrentFrame, Ne = "";
    if (ee) {
      var qe = W(ee.type), He = ee._owner;
      Ne += function(Ze, Ve, je) {
        var Ue = "";
        if (Ve) {
          var we = Ve.fileName, De = we.replace(z, "");
          if (/^index\./.test(De)) {
            var rt = we.match(z);
            if (rt) {
              var ge = rt[1];
              ge && (De = ge.replace(z, "") + "/" + De);
            }
          }
          Ue = " (at " + De + ":" + Ve.lineNumber + ")";
        } else
          je && (Ue = " (created by " + je + ")");
        return `
    in ` + (Ze || "Unknown") + Ue;
      }(qe, ee._source, He && W(He.type));
    }
    (Ne += ze.getStackAddendum()) !== "" && (Re += "%s", fe = fe.concat([Ne]));
    var Be = fe.map(function(Ze) {
      return "" + Ze;
    });
    Be.unshift("Warning: " + Re), Function.prototype.apply.call(console[ye], console, Be);
  }
  var z = /^(.*)[\\\/]/;
  function W(ye) {
    if (ye == null)
      return null;
    if (typeof ye.tag == "number" && R("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
      return ye.displayName || ye.name || null;
    if (typeof ye == "string")
      return ye;
    switch (ye) {
      case $a.Fragment:
        return "Fragment";
      case r:
        return "Portal";
      case i:
        return "Profiler";
      case a:
        return "StrictMode";
      case s:
        return "Suspense";
      case h:
        return "SuspenseList";
    }
    if (typeof ye == "object")
      switch (ye.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case c:
          return ze = ye, Ne = ye.render, qe = "ForwardRef", He = Ne.displayName || Ne.name || "", ze.displayName || (He !== "" ? qe + "(" + He + ")" : qe);
        case y:
          return W(ye.type);
        case x:
          return W(ye.render);
        case g:
          var Re = (fe = ye)._status === 1 ? fe._result : null;
          if (Re)
            return W(Re);
      }
    var fe, ze, Ne, qe, He;
    return null;
  }
  var Z = {};
  P.ReactDebugCurrentFrame;
  var ee = null;
  function K(ye) {
    ee = ye;
  }
  var le, Y, ae, B = P.ReactCurrentOwner, X = Object.prototype.hasOwnProperty, ce = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ne(ye, Re, fe, ze, Ne) {
    var qe, He = {}, Be = null, Ze = null;
    for (qe in fe !== void 0 && (Be = "" + fe), function(Ue) {
      if (X.call(Ue, "key")) {
        var we = Object.getOwnPropertyDescriptor(Ue, "key").get;
        if (we && we.isReactWarning)
          return !1;
      }
      return Ue.key !== void 0;
    }(Re) && (Be = "" + Re.key), function(Ue) {
      if (X.call(Ue, "ref")) {
        var we = Object.getOwnPropertyDescriptor(Ue, "ref").get;
        if (we && we.isReactWarning)
          return !1;
      }
      return Ue.ref !== void 0;
    }(Re) && (Ze = Re.ref, function(Ue, we) {
      if (typeof Ue.ref == "string" && B.current && we && B.current.stateNode !== we) {
        var De = W(B.current.type);
        ae[De] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(B.current.type), Ue.ref), ae[De] = !0);
      }
    }(Re, Ne)), Re)
      X.call(Re, qe) && !ce.hasOwnProperty(qe) && (He[qe] = Re[qe]);
    if (ye && ye.defaultProps) {
      var Ve = ye.defaultProps;
      for (qe in Ve)
        He[qe] === void 0 && (He[qe] = Ve[qe]);
    }
    if (Be || Ze) {
      var je = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
      Be && function(Ue, we) {
        var De = function() {
          le || (le = !0, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", we));
        };
        De.isReactWarning = !0, Object.defineProperty(Ue, "key", { get: De, configurable: !0 });
      }(He, je), Ze && function(Ue, we) {
        var De = function() {
          Y || (Y = !0, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", we));
        };
        De.isReactWarning = !0, Object.defineProperty(Ue, "ref", { get: De, configurable: !0 });
      }(He, je);
    }
    return function(Ue, we, De, rt, ge, ut, at) {
      var it = { $$typeof: t, type: Ue, key: we, ref: De, props: at, _owner: ut, _store: {} };
      return Object.defineProperty(it._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(it, "_self", { configurable: !1, enumerable: !1, writable: !1, value: rt }), Object.defineProperty(it, "_source", { configurable: !1, enumerable: !1, writable: !1, value: ge }), Object.freeze && (Object.freeze(it.props), Object.freeze(it)), it;
    }(ye, Be, Ze, Ne, ze, B.current, He);
  }
  ae = {};
  var Q, V = P.ReactCurrentOwner;
  function j(ye) {
    ee = ye;
  }
  function te(ye) {
    return typeof ye == "object" && ye !== null && ye.$$typeof === t;
  }
  function U() {
    if (V.current) {
      var ye = W(V.current.type);
      if (ye)
        return `

Check the render method of \`` + ye + "`.";
    }
    return "";
  }
  P.ReactDebugCurrentFrame, Q = !1;
  var ue = {};
  function ke(ye, Re) {
    if (ye._store && !ye._store.validated && ye.key == null) {
      ye._store.validated = !0;
      var fe = function(Ne) {
        var qe = U();
        if (!qe) {
          var He = typeof Ne == "string" ? Ne : Ne.displayName || Ne.name;
          He && (qe = `

Check the top-level render call using <` + He + ">.");
        }
        return qe;
      }(Re);
      if (!ue[fe]) {
        ue[fe] = !0;
        var ze = "";
        ye && ye._owner && ye._owner !== V.current && (ze = " It was passed a child from " + W(ye._owner.type) + "."), j(ye), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', fe, ze), j(null);
      }
    }
  }
  function xe(ye, Re) {
    if (typeof ye == "object") {
      if (Array.isArray(ye))
        for (var fe = 0; fe < ye.length; fe++) {
          var ze = ye[fe];
          te(ze) && ke(ze, Re);
        }
      else if (te(ye))
        ye._store && (ye._store.validated = !0);
      else if (ye) {
        var Ne = function(Be) {
          if (Be === null || typeof Be != "object")
            return null;
          var Ze = L && Be[L] || Be["@@iterator"];
          return typeof Ze == "function" ? Ze : null;
        }(ye);
        if (typeof Ne == "function" && Ne !== ye.entries)
          for (var qe, He = Ne.call(ye); !(qe = He.next()).done; )
            te(qe.value) && ke(qe.value, Re);
      }
    }
  }
  function be(ye) {
    var Re, fe = ye.type;
    if (fe != null && typeof fe != "string") {
      if (typeof fe == "function")
        Re = fe.propTypes;
      else {
        if (typeof fe != "object" || fe.$$typeof !== c && fe.$$typeof !== y)
          return;
        Re = fe.propTypes;
      }
      if (Re) {
        var ze = W(fe);
        (function(Ne, qe, He, Be, Ze) {
          var Ve = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var je in Ne)
            if (Ve(Ne, je)) {
              var Ue = void 0;
              try {
                if (typeof Ne[je] != "function") {
                  var we = Error((Be || "React class") + ": " + He + " type `" + je + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ne[je] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw we.name = "Invariant Violation", we;
                }
                Ue = Ne[je](qe, je, Be, He, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (De) {
                Ue = De;
              }
              !Ue || Ue instanceof Error || (K(Ze), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Be || "React class", He, je, typeof Ue), K(null)), Ue instanceof Error && !(Ue.message in Z) && (Z[Ue.message] = !0, K(Ze), R("Failed %s type: %s", He, Ue.message), K(null));
            }
        })(Re, ye.props, "prop", ze, ye);
      } else
        fe.PropTypes === void 0 || Q || (Q = !0, R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", W(fe) || "Unknown"));
      typeof fe.getDefaultProps != "function" || fe.getDefaultProps.isReactClassApproved || R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Ae(ye, Re, fe, ze, Ne, qe) {
    var He = function(De) {
      return typeof De == "string" || typeof De == "function" || De === $a.Fragment || De === i || De === A || De === a || De === s || De === h || De === p || typeof De == "object" && De !== null && (De.$$typeof === g || De.$$typeof === y || De.$$typeof === o || De.$$typeof === d || De.$$typeof === c || De.$$typeof === S || De.$$typeof === x || De[0] === w);
    }(ye);
    if (!He) {
      var Be = "";
      (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (Be += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Ze, Ve = function(De) {
        return De !== void 0 ? `

Check your code at ` + De.fileName.replace(/^.*[\\\/]/, "") + ":" + De.lineNumber + "." : "";
      }(Ne);
      Be += Ve || U(), ye === null ? Ze = "null" : Array.isArray(ye) ? Ze = "array" : ye !== void 0 && ye.$$typeof === t ? (Ze = "<" + (W(ye.type) || "Unknown") + " />", Be = " Did you accidentally export a JSX literal instead of a component?") : Ze = typeof ye, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ze, Be);
    }
    var je = ne(ye, Re, fe, Ne, qe);
    if (je == null)
      return je;
    if (He) {
      var Ue = Re.children;
      if (Ue !== void 0)
        if (ze)
          if (Array.isArray(Ue)) {
            for (var we = 0; we < Ue.length; we++)
              xe(Ue[we], ye);
            Object.freeze && Object.freeze(Ue);
          } else
            R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          xe(Ue, ye);
    }
    return ye === $a.Fragment ? function(De) {
      for (var rt = Object.keys(De.props), ge = 0; ge < rt.length; ge++) {
        var ut = rt[ge];
        if (ut !== "children" && ut !== "key") {
          j(De), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ut), j(null);
          break;
        }
      }
      De.ref !== null && (j(De), R("Invalid attribute `ref` supplied to `React.Fragment`."), j(null));
    }(je) : be(je), je;
  }
  var Ye = function(ye, Re, fe) {
    return Ae(ye, Re, fe, !1);
  }, Pe = function(ye, Re, fe) {
    return Ae(ye, Re, fe, !0);
  };
  $a.jsx = Ye, $a.jsxs = Pe;
}(), Hi.exports = Hh;
var Zd, og = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Zd = og, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var r = [], a = 0; a < arguments.length; a++) {
      var i = arguments[a];
      if (i) {
        var o = typeof i;
        if (o === "string" || o === "number")
          r.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var d = t.apply(null, i);
            d && r.push(d);
          }
        } else if (o === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            r.push(i.toString());
            continue;
          }
          for (var c in i)
            e.call(i, c) && i[c] && r.push(c);
        }
      }
    }
    return r.join(" ");
  }
  Zd.exports ? (t.default = t, Zd.exports = t) : window.classNames = t;
}();
var Vh = og.exports;
const Wh = (e, t, r) => {
  let a = null;
  return function(...i) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, r || e.apply(this, i);
    }, t);
  };
}, rS = ({ content: e }) => Hi.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), aS = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, iS = se.createContext({ getTooltipData: () => aS });
function lg(e = "DEFAULT_TOOLTIP_ID") {
  return se.useContext(iS).getTooltipData(e);
}
const jh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: r = null, place: a = "top", offset: i = 10, strategy: o = "absolute", middlewares: d = [QE(Number(i)), ZE(), JE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = d;
  return r ? (c.push({ name: "arrow", options: s = { element: r, padding: 5 }, async fn(h) {
    const { element: y, padding: g = 0 } = s || {}, { x, y: w, placement: S, rects: A, platform: p } = h;
    if (y == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const v = Xy(g), L = { x, y: w }, P = Rs(S), R = gp(P), C = await p.getDimensions(y), z = P === "y" ? "top" : "left", W = P === "y" ? "bottom" : "right", Z = A.reference[R] + A.reference[P] - L[P] - A.floating[R], ee = L[P] - A.reference[P], K = await (p.getOffsetParent == null ? void 0 : p.getOffsetParent(y));
    let le = K ? P === "y" ? K.clientHeight || 0 : K.clientWidth || 0 : 0;
    le === 0 && (le = A.floating[R]);
    const Y = Z / 2 - ee / 2, ae = v[z], B = le - C[R] - v[W], X = le / 2 - C[R] / 2 + Y, ce = Bf(ae, X, B), ne = Ps(S) != null && X != ce && A.reference[R] / 2 - (X < ae ? v[z] : v[W]) - C[R] / 2 < 0;
    return { [P]: L[P] - (ne ? X < ae ? ae - X : B - X : 0), data: { [P]: ce, centerOffset: X - ce } };
  } }), $h(e, t, { placement: a, strategy: o, middleware: c }).then(({ x: h, y, placement: g, middlewareData: x }) => {
    var w, S;
    const A = { left: `${h}px`, top: `${y}px` }, { x: p, y: v } = (w = x.arrow) !== null && w !== void 0 ? w : { x: 0, y: 0 };
    return { tooltipStyles: A, tooltipArrowStyles: { left: p != null ? `${p}px` : "", top: v != null ? `${v}px` : "", right: "", bottom: "", [(S = { top: "bottom", right: "left", bottom: "top", left: "right" }[g.split("-")[0]]) !== null && S !== void 0 ? S : "bottom"]: "-4px" } };
  })) : $h(e, t, { placement: "bottom", strategy: o, middleware: c }).then(({ x: h, y }) => ({ tooltipStyles: { left: `${h}px`, top: `${y}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Ri = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Uh = ({ id: e, className: t, classNameArrow: r, variant: a = "dark", anchorId: i, anchorSelect: o, place: d = "top", offset: c = 10, events: s = ["hover"], positionStrategy: h = "absolute", middlewares: y, wrapper: g, children: x = null, delayShow: w = 0, delayHide: S = 0, float: A = !1, noArrow: p = !1, clickable: v = !1, closeOnEsc: L = !1, style: P, position: R, afterShow: C, afterHide: z, content: W, html: Z, isOpen: ee, setIsOpen: K, activeAnchor: le, setActiveAnchor: Y }) => {
  const ae = se.useRef(null), B = se.useRef(null), X = se.useRef(null), ce = se.useRef(null), [ne, Q] = se.useState({}), [V, j] = se.useState({}), [te, U] = se.useState(!1), [ue, ke] = se.useState(!1), xe = se.useRef(!1), be = se.useRef(null), { anchorRefs: Ae, setActiveAnchor: Ye } = lg(e), Pe = se.useRef(!1), [ye, Re] = se.useState([]), fe = se.useRef(!1);
  se.useLayoutEffect(() => (fe.current = !0, () => {
    fe.current = !1;
  }), []), se.useEffect(() => {
    if (!te) {
      const ge = setTimeout(() => {
        ke(!1);
      }, 150);
      return () => {
        clearTimeout(ge);
      };
    }
    return () => null;
  }, [te]);
  const ze = (ge) => {
    fe.current && (ge && ke(!0), setTimeout(() => {
      fe.current && (K == null || K(ge), ee === void 0 && U(ge));
    }, 10));
  };
  se.useEffect(() => {
    if (ee === void 0)
      return () => null;
    ee && ke(!0);
    const ge = setTimeout(() => {
      U(ee);
    }, 10);
    return () => {
      clearTimeout(ge);
    };
  }, [ee]), se.useEffect(() => {
    te !== xe.current && (xe.current = te, te ? C == null || C() : z == null || z());
  }, [te]);
  const Ne = (ge = S) => {
    ce.current && clearTimeout(ce.current), ce.current = setTimeout(() => {
      Pe.current || ze(!1);
    }, ge);
  }, qe = (ge) => {
    var ut;
    if (!ge)
      return;
    w ? (X.current && clearTimeout(X.current), X.current = setTimeout(() => {
      ze(!0);
    }, w)) : ze(!0);
    const at = (ut = ge.currentTarget) !== null && ut !== void 0 ? ut : ge.target;
    Y(at), Ye({ current: at }), ce.current && clearTimeout(ce.current);
  }, He = () => {
    v ? Ne(S || 100) : S ? Ne() : ze(!1), X.current && clearTimeout(X.current);
  }, Be = ({ x: ge, y: ut }) => {
    jh({ place: d, offset: c, elementReference: { getBoundingClientRect: () => ({ x: ge, y: ut, width: 0, height: 0, top: ut, left: ge, right: ge, bottom: ut }) }, tooltipReference: ae.current, tooltipArrowReference: B.current, strategy: h, middlewares: y }).then((at) => {
      Object.keys(at.tooltipStyles).length && Q(at.tooltipStyles), Object.keys(at.tooltipArrowStyles).length && j(at.tooltipArrowStyles);
    });
  }, Ze = (ge) => {
    if (!ge)
      return;
    const ut = ge, at = { x: ut.clientX, y: ut.clientY };
    Be(at), be.current = at;
  }, Ve = (ge) => {
    qe(ge), S && Ne();
  }, je = (ge) => {
    const ut = document.querySelector(`[id='${i}']`);
    ut != null && ut.contains(ge.target) || ye.some((at) => at.contains(ge.target)) || ze(!1);
  }, Ue = (ge) => {
    ge.key === "Escape" && ze(!1);
  }, we = Wh(qe, 50), De = Wh(He, 50);
  se.useEffect(() => {
    var ge, ut;
    const at = new Set(Ae);
    ye.forEach((Nt) => {
      at.add({ current: Nt });
    });
    const it = document.querySelector(`[id='${i}']`);
    it && at.add({ current: it }), L && window.addEventListener("keydown", Ue);
    const St = [];
    s.find((Nt) => Nt === "click") && (window.addEventListener("click", je), St.push({ event: "click", listener: Ve })), s.find((Nt) => Nt === "hover") && (St.push({ event: "mouseenter", listener: we }, { event: "mouseleave", listener: De }, { event: "focus", listener: we }, { event: "blur", listener: De }), A && St.push({ event: "mousemove", listener: Ze }));
    const jt = () => {
      Pe.current = !0;
    }, Bt = () => {
      Pe.current = !1, He();
    };
    return v && ((ge = ae.current) === null || ge === void 0 || ge.addEventListener("mouseenter", jt), (ut = ae.current) === null || ut === void 0 || ut.addEventListener("mouseleave", Bt)), St.forEach(({ event: Nt, listener: sn }) => {
      at.forEach((gt) => {
        var Dt;
        (Dt = gt.current) === null || Dt === void 0 || Dt.addEventListener(Nt, sn);
      });
    }), () => {
      var Nt, sn;
      s.find((gt) => gt === "click") && window.removeEventListener("click", je), L && window.removeEventListener("keydown", Ue), v && ((Nt = ae.current) === null || Nt === void 0 || Nt.removeEventListener("mouseenter", jt), (sn = ae.current) === null || sn === void 0 || sn.removeEventListener("mouseleave", Bt)), St.forEach(({ event: gt, listener: Dt }) => {
        at.forEach((_t) => {
          var un;
          (un = _t.current) === null || un === void 0 || un.removeEventListener(gt, Dt);
        });
      });
    };
  }, [ue, Ae, ye, L, s]), se.useEffect(() => {
    let ge = o ?? "";
    !ge && e && (ge = `[data-tooltip-id='${e}']`);
    const ut = new MutationObserver((at) => {
      const it = [];
      at.forEach((St) => {
        if (St.type === "attributes" && St.attributeName === "data-tooltip-id" && St.target.getAttribute("data-tooltip-id") === e && it.push(St.target), St.type === "childList" && (le && [...St.removedNodes].some((jt) => !!jt.contains(le) && (ke(!1), ze(!1), Y(null), !0)), ge))
          try {
            const jt = [...St.addedNodes].filter((Bt) => Bt.nodeType === 1);
            it.push(...jt.filter((Bt) => Bt.matches(ge))), it.push(...jt.flatMap((Bt) => [...Bt.querySelectorAll(ge)]));
          } catch {
          }
      }), it.length && Re((St) => [...St, ...it]);
    });
    return ut.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      ut.disconnect();
    };
  }, [e, o, le]), se.useEffect(() => {
    R ? Be(R) : A ? be.current && Be(be.current) : jh({ place: d, offset: c, elementReference: le, tooltipReference: ae.current, tooltipArrowReference: B.current, strategy: h, middlewares: y }).then((ge) => {
      fe.current && (Object.keys(ge.tooltipStyles).length && Q(ge.tooltipStyles), Object.keys(ge.tooltipArrowStyles).length && j(ge.tooltipArrowStyles));
    });
  }, [te, le, W, Z, d, c, h, R]), se.useEffect(() => {
    var ge;
    const ut = document.querySelector(`[id='${i}']`), at = [...ye, ut];
    le && at.includes(le) || Y((ge = ye[0]) !== null && ge !== void 0 ? ge : ut);
  }, [i, ye, le]), se.useEffect(() => () => {
    X.current && clearTimeout(X.current), ce.current && clearTimeout(ce.current);
  }, []), se.useEffect(() => {
    let ge = o;
    if (!ge && e && (ge = `[data-tooltip-id='${e}']`), ge)
      try {
        const ut = Array.from(document.querySelectorAll(ge));
        Re(ut);
      } catch {
        Re([]);
      }
  }, [e, o]);
  const rt = !!(Z || W || x) && te && Object.keys(ne).length > 0;
  return ue ? Hi.exports.jsxs(g, { id: e, role: "tooltip", className: Vh("react-tooltip", Ri.tooltip, Ri[a], t, { [Ri.show]: rt, [Ri.fixed]: h === "fixed", [Ri.clickable]: v }), style: { ...P, ...ne }, ref: ae, children: [Z && Hi.exports.jsx(rS, { content: Z }) || W || x, Hi.exports.jsx(g, { className: Vh("react-tooltip-arrow", Ri.arrow, r, { [Ri["no-arrow"]]: p }), style: V, ref: B })] }) : null;
}, mc = ({ id: e, anchorId: t, anchorSelect: r, content: a, html: i, className: o, classNameArrow: d, variant: c = "dark", place: s = "top", offset: h = 10, wrapper: y = "div", children: g = null, events: x = ["hover"], positionStrategy: w = "absolute", middlewares: S, delayShow: A = 0, delayHide: p = 0, float: v = !1, noArrow: L = !1, clickable: P = !1, closeOnEsc: R = !1, style: C, position: z, isOpen: W, setIsOpen: Z, afterShow: ee, afterHide: K }) => {
  const [le, Y] = se.useState(a), [ae, B] = se.useState(i), [X, ce] = se.useState(s), [ne, Q] = se.useState(c), [V, j] = se.useState(h), [te, U] = se.useState(A), [ue, ke] = se.useState(p), [xe, be] = se.useState(v), [Ae, Ye] = se.useState(y), [Pe, ye] = se.useState(x), [Re, fe] = se.useState(w), [ze, Ne] = se.useState(null), { anchorRefs: qe, activeAnchor: He } = lg(e), Be = (je) => je == null ? void 0 : je.getAttributeNames().reduce((Ue, we) => {
    var De;
    return we.startsWith("data-tooltip-") && (Ue[we.replace(/^data-tooltip-/, "")] = (De = je == null ? void 0 : je.getAttribute(we)) !== null && De !== void 0 ? De : null), Ue;
  }, {}), Ze = (je) => {
    const Ue = { place: (we) => {
      var De;
      ce((De = we) !== null && De !== void 0 ? De : s);
    }, content: (we) => {
      Y(we ?? a);
    }, html: (we) => {
      B(we ?? i);
    }, variant: (we) => {
      var De;
      Q((De = we) !== null && De !== void 0 ? De : c);
    }, offset: (we) => {
      j(we === null ? h : Number(we));
    }, wrapper: (we) => {
      var De;
      Ye((De = we) !== null && De !== void 0 ? De : y);
    }, events: (we) => {
      const De = we == null ? void 0 : we.split(" ");
      ye(De ?? x);
    }, "position-strategy": (we) => {
      var De;
      fe((De = we) !== null && De !== void 0 ? De : w);
    }, "delay-show": (we) => {
      U(we === null ? A : Number(we));
    }, "delay-hide": (we) => {
      ke(we === null ? p : Number(we));
    }, float: (we) => {
      be(we === null ? v : !!we);
    } };
    Object.values(Ue).forEach((we) => we(null)), Object.entries(je).forEach(([we, De]) => {
      var rt;
      (rt = Ue[we]) === null || rt === void 0 || rt.call(Ue, De);
    });
  };
  se.useEffect(() => {
    Y(a);
  }, [a]), se.useEffect(() => {
    B(i);
  }, [i]), se.useEffect(() => {
    ce(s);
  }, [s]), se.useEffect(() => {
    var je;
    const Ue = new Set(qe);
    let we = r;
    if (!we && e && (we = `[data-tooltip-id='${e}']`), we)
      try {
        document.querySelectorAll(we).forEach((at) => {
          Ue.add({ current: at });
        });
      } catch {
        console.warn(`[react-tooltip] "${r}" is not a valid CSS selector`);
      }
    const De = document.querySelector(`[id='${t}']`);
    if (De && Ue.add({ current: De }), !Ue.size)
      return () => null;
    const rt = (je = ze ?? De) !== null && je !== void 0 ? je : He.current, ge = new MutationObserver((at) => {
      at.forEach((it) => {
        var St;
        if (!rt || it.type !== "attributes" || !(!((St = it.attributeName) === null || St === void 0) && St.startsWith("data-tooltip-")))
          return;
        const jt = Be(rt);
        Ze(jt);
      });
    }), ut = { attributes: !0, childList: !1, subtree: !1 };
    if (rt) {
      const at = Be(rt);
      Ze(at), ge.observe(rt, ut);
    }
    return () => {
      ge.disconnect();
    };
  }, [qe, He, ze, t, r]);
  const Ve = { id: e, anchorId: t, anchorSelect: r, className: o, classNameArrow: d, content: le, html: ae, place: X, variant: ne, offset: V, wrapper: Ae, events: Pe, positionStrategy: Re, middlewares: S, delayShow: te, delayHide: ue, float: xe, noArrow: L, clickable: P, closeOnEsc: R, style: C, position: z, isOpen: W, setIsOpen: Z, afterShow: ee, afterHide: K, activeAnchor: ze, setActiveAnchor: (je) => Ne(je) };
  return g ? Hi.exports.jsx(Uh, { ...Ve, children: g }) : Hi.exports.jsx(Uh, { ...Ve });
};
function Kh(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function oS(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Qd(e, t) {
  let r = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (r += a);
  else {
    let a = -1;
    for (let i of e)
      (i = +t(i, ++a, e)) && (r += i);
  }
  return r;
}
function lS(e) {
  return e.depth;
}
function sS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Ou(e) {
  return function() {
    return e;
  };
}
function Yh(e, t) {
  return yc(e.source, t.source) || e.index - t.index;
}
function Gh(e, t) {
  return yc(e.target, t.target) || e.index - t.index;
}
function yc(e, t) {
  return e.y0 - t.y0;
}
function Jd(e) {
  return e.value;
}
function uS(e) {
  return e.index;
}
function cS(e) {
  return e.nodes;
}
function dS(e) {
  return e.links;
}
function Xh(e, t) {
  const r = e.get(t);
  if (!r)
    throw new Error("missing: " + t);
  return r;
}
function qh({ nodes: e }) {
  for (const t of e) {
    let r = t.y0, a = r;
    for (const i of t.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of t.targetLinks)
      i.y1 = a + i.width / 2, a += i.width;
  }
}
function fS() {
  let e = 0, t = 0, r = 1, a = 1, i = 24, o = 8, d, c = uS, s = sS, h, y, g = cS, x = dS, w = 6;
  function S() {
    const X = { nodes: g.apply(null, arguments), links: x.apply(null, arguments) };
    return A(X), p(X), v(X), L(X), C(X), qh(X), X;
  }
  S.update = function(X) {
    return qh(X), X;
  }, S.nodeId = function(X) {
    return arguments.length ? (c = typeof X == "function" ? X : Ou(X), S) : c;
  }, S.nodeAlign = function(X) {
    return arguments.length ? (s = typeof X == "function" ? X : Ou(X), S) : s;
  }, S.nodeSort = function(X) {
    return arguments.length ? (h = X, S) : h;
  }, S.nodeWidth = function(X) {
    return arguments.length ? (i = +X, S) : i;
  }, S.nodePadding = function(X) {
    return arguments.length ? (o = d = +X, S) : o;
  }, S.nodes = function(X) {
    return arguments.length ? (g = typeof X == "function" ? X : Ou(X), S) : g;
  }, S.links = function(X) {
    return arguments.length ? (x = typeof X == "function" ? X : Ou(X), S) : x;
  }, S.linkSort = function(X) {
    return arguments.length ? (y = X, S) : y;
  }, S.size = function(X) {
    return arguments.length ? (e = t = 0, r = +X[0], a = +X[1], S) : [r - e, a - t];
  }, S.extent = function(X) {
    return arguments.length ? (e = +X[0][0], r = +X[1][0], t = +X[0][1], a = +X[1][1], S) : [[e, t], [r, a]];
  }, S.iterations = function(X) {
    return arguments.length ? (w = +X, S) : w;
  };
  function A({ nodes: X, links: ce }) {
    for (const [Q, V] of X.entries())
      V.index = Q, V.sourceLinks = [], V.targetLinks = [];
    const ne = new Map(X.map((Q, V) => [c(Q, V, X), Q]));
    for (const [Q, V] of ce.entries()) {
      V.index = Q;
      let { source: j, target: te } = V;
      typeof j != "object" && (j = V.source = Xh(ne, j)), typeof te != "object" && (te = V.target = Xh(ne, te)), j.sourceLinks.push(V), te.targetLinks.push(V);
    }
    if (y != null)
      for (const { sourceLinks: Q, targetLinks: V } of X)
        Q.sort(y), V.sort(y);
  }
  function p({ nodes: X }) {
    for (const ce of X)
      ce.value = ce.fixedValue === void 0 ? Math.max(Qd(ce.sourceLinks, Jd), Qd(ce.targetLinks, Jd)) : ce.fixedValue;
  }
  function v({ nodes: X }) {
    const ce = X.length;
    let ne = new Set(X), Q = /* @__PURE__ */ new Set(), V = 0;
    for (; ne.size; ) {
      for (const j of ne) {
        j.depth = V;
        for (const { target: te } of j.sourceLinks)
          Q.add(te);
      }
      if (++V > ce)
        throw new Error("circular link");
      ne = Q, Q = /* @__PURE__ */ new Set();
    }
  }
  function L({ nodes: X }) {
    const ce = X.length;
    let ne = new Set(X), Q = /* @__PURE__ */ new Set(), V = 0;
    for (; ne.size; ) {
      for (const j of ne) {
        j.height = V;
        for (const { source: te } of j.targetLinks)
          Q.add(te);
      }
      if (++V > ce)
        throw new Error("circular link");
      ne = Q, Q = /* @__PURE__ */ new Set();
    }
  }
  function P({ nodes: X }) {
    const ce = Kh(X, (V) => V.depth) + 1, ne = (r - e - i) / (ce - 1), Q = new Array(ce);
    for (const V of X) {
      const j = Math.max(0, Math.min(ce - 1, Math.floor(s.call(null, V, ce))));
      V.layer = j, V.x0 = e + j * ne, V.x1 = V.x0 + i, Q[j] ? Q[j].push(V) : Q[j] = [V];
    }
    if (h)
      for (const V of Q)
        V.sort(h);
    return Q;
  }
  function R(X) {
    const ce = oS(X, (ne) => (a - t - (ne.length - 1) * d) / Qd(ne, Jd));
    for (const ne of X) {
      let Q = t;
      for (const V of ne) {
        V.y0 = Q, V.y1 = Q + V.value * ce, Q = V.y1 + d;
        for (const j of V.sourceLinks)
          j.width = j.value * ce;
      }
      Q = (a - Q + d) / (ne.length + 1);
      for (let V = 0; V < ne.length; ++V) {
        const j = ne[V];
        j.y0 += Q * (V + 1), j.y1 += Q * (V + 1);
      }
      Y(ne);
    }
  }
  function C(X) {
    const ce = P(X);
    d = Math.min(o, (a - t) / (Kh(ce, (ne) => ne.length) - 1)), R(ce);
    for (let ne = 0; ne < w; ++ne) {
      const Q = Math.pow(0.99, ne), V = Math.max(1 - Q, (ne + 1) / w);
      W(ce, Q, V), z(ce, Q, V);
    }
  }
  function z(X, ce, ne) {
    for (let Q = 1, V = X.length; Q < V; ++Q) {
      const j = X[Q];
      for (const te of j) {
        let U = 0, ue = 0;
        for (const { source: xe, value: be } of te.targetLinks) {
          let Ae = be * (te.layer - xe.layer);
          U += ae(xe, te) * Ae, ue += Ae;
        }
        if (!(ue > 0))
          continue;
        let ke = (U / ue - te.y0) * ce;
        te.y0 += ke, te.y1 += ke, le(te);
      }
      h === void 0 && j.sort(yc), Z(j, ne);
    }
  }
  function W(X, ce, ne) {
    for (let Q = X.length, V = Q - 2; V >= 0; --V) {
      const j = X[V];
      for (const te of j) {
        let U = 0, ue = 0;
        for (const { target: xe, value: be } of te.sourceLinks) {
          let Ae = be * (xe.layer - te.layer);
          U += B(te, xe) * Ae, ue += Ae;
        }
        if (!(ue > 0))
          continue;
        let ke = (U / ue - te.y0) * ce;
        te.y0 += ke, te.y1 += ke, le(te);
      }
      h === void 0 && j.sort(yc), Z(j, ne);
    }
  }
  function Z(X, ce) {
    const ne = X.length >> 1, Q = X[ne];
    K(X, Q.y0 - d, ne - 1, ce), ee(X, Q.y1 + d, ne + 1, ce), K(X, a, X.length - 1, ce), ee(X, t, 0, ce);
  }
  function ee(X, ce, ne, Q) {
    for (; ne < X.length; ++ne) {
      const V = X[ne], j = (ce - V.y0) * Q;
      j > 1e-6 && (V.y0 += j, V.y1 += j), ce = V.y1 + d;
    }
  }
  function K(X, ce, ne, Q) {
    for (; ne >= 0; --ne) {
      const V = X[ne], j = (V.y1 - ce) * Q;
      j > 1e-6 && (V.y0 -= j, V.y1 -= j), ce = V.y0 - d;
    }
  }
  function le({ sourceLinks: X, targetLinks: ce }) {
    if (y === void 0) {
      for (const { source: { sourceLinks: ne } } of ce)
        ne.sort(Gh);
      for (const { target: { targetLinks: ne } } of X)
        ne.sort(Yh);
    }
  }
  function Y(X) {
    if (y === void 0)
      for (const { sourceLinks: ce, targetLinks: ne } of X)
        ce.sort(Gh), ne.sort(Yh);
  }
  function ae(X, ce) {
    let ne = X.y0 - (X.sourceLinks.length - 1) * d / 2;
    for (const { target: Q, width: V } of X.sourceLinks) {
      if (Q === ce)
        break;
      ne += V + d;
    }
    for (const { source: Q, width: V } of ce.targetLinks) {
      if (Q === X)
        break;
      ne -= V;
    }
    return ne;
  }
  function B(X, ce) {
    let ne = ce.y0 - (ce.targetLinks.length - 1) * d / 2;
    for (const { source: Q, width: V } of ce.targetLinks) {
      if (Q === X)
        break;
      ne += V + d;
    }
    for (const { target: Q, width: V } of X.sourceLinks) {
      if (Q === ce)
        break;
      ne -= V;
    }
    return ne;
  }
  return S;
}
function pS(e) {
  return [e.source.x1, e.y0];
}
function hS(e) {
  return [e.target.x0, e.y1];
}
function mS() {
  return d0().source(pS).target(hS);
}
const yS = () => {
  const { config: e, handleChartTabbing: t, legendId: r } = se.useContext(pt), [a, i] = se.useState(!1), o = /* @__PURE__ */ n.createElement(n.Fragment, null, "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ", /* @__PURE__ */ n.createElement("a", { href: `#${t(e, r)}` }, "data table"), " below.", " ", /* @__PURE__ */ n.createElement("a", { onClick: () => i(!1), href: "#!" }, "Close this alert"), " ", "to continue viewing the chart."), d = () => {
    i(!1);
  }, c = a ? /* @__PURE__ */ n.createElement("div", { className: "alert alert-warning alert-dismissible", role: "alert" }, /* @__PURE__ */ n.createElement("p", { style: { padding: "35px" } }, o), /* @__PURE__ */ n.createElement("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: d }, /* @__PURE__ */ n.createElement("span", { "aria-hidden": "true" }, ""))) : null;
  return se.useEffect(() => {
    const s = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", s), s(), () => {
      window.removeEventListener("resize", s);
    };
  }, []), {
    setShowAlert: i,
    showAlert: a,
    handleCloseModal: d,
    alertMessage: o,
    alert: c
  };
};
var Xa = {}, Ni = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zh;
function gS() {
  if (Zh)
    return Ni;
  Zh = 1;
  var e = se;
  function t(b) {
    for (var _ = "https://reactjs.org/docs/error-decoder.html?invariant=" + b, D = 1; D < arguments.length; D++)
      _ += "&args[]=" + encodeURIComponent(arguments[D]);
    return "Minified React error #" + b + "; visit " + _ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function d(b) {
    return r.call(o, b) ? !0 : r.call(i, b) ? !1 : a.test(b) ? o[b] = !0 : (i[b] = !0, !1);
  }
  function c(b, _, D, G, pe, O, I) {
    this.acceptsBooleans = _ === 2 || _ === 3 || _ === 4, this.attributeName = G, this.attributeNamespace = pe, this.mustUseProperty = D, this.propertyName = b, this.type = _, this.sanitizeURL = O, this.removeEmptyString = I;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(b) {
    s[b] = new c(b, 0, !1, b, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(b) {
    var _ = b[0];
    s[_] = new c(_, 1, !1, b[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(b) {
    s[b] = new c(b, 2, !1, b.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(b) {
    s[b] = new c(b, 2, !1, b, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(b) {
    s[b] = new c(b, 3, !1, b.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(b) {
    s[b] = new c(b, 3, !0, b, null, !1, !1);
  }), ["capture", "download"].forEach(function(b) {
    s[b] = new c(b, 4, !1, b, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(b) {
    s[b] = new c(b, 6, !1, b, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(b) {
    s[b] = new c(b, 5, !1, b.toLowerCase(), null, !1, !1);
  });
  var h = /[\-:]([a-z])/g;
  function y(b) {
    return b[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(b) {
    var _ = b.replace(
      h,
      y
    );
    s[_] = new c(_, 1, !1, b, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(b) {
    var _ = b.replace(h, y);
    s[_] = new c(_, 1, !1, b, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(b) {
    var _ = b.replace(h, y);
    s[_] = new c(_, 1, !1, b, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(b) {
    s[b] = new c(b, 1, !1, b.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(b) {
    s[b] = new c(b, 1, !1, b.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(b) {
    x.forEach(function(_) {
      _ = _ + b.charAt(0).toUpperCase() + b.substring(1), g[_] = g[b];
    });
  });
  var w = /["'&<>]/;
  function S(b) {
    if (typeof b == "boolean" || typeof b == "number")
      return "" + b;
    b = "" + b;
    var _ = w.exec(b);
    if (_) {
      var D = "", G, pe = 0;
      for (G = _.index; G < b.length; G++) {
        switch (b.charCodeAt(G)) {
          case 34:
            _ = "&quot;";
            break;
          case 38:
            _ = "&amp;";
            break;
          case 39:
            _ = "&#x27;";
            break;
          case 60:
            _ = "&lt;";
            break;
          case 62:
            _ = "&gt;";
            break;
          default:
            continue;
        }
        pe !== G && (D += b.substring(pe, G)), pe = G + 1, D += _;
      }
      b = pe !== G ? D + b.substring(pe, G) : D;
    }
    return b;
  }
  var A = /([A-Z])/g, p = /^ms-/, v = Array.isArray;
  function L(b, _) {
    return { insertionMode: b, selectedValue: _ };
  }
  function P(b, _, D) {
    switch (_) {
      case "select":
        return L(1, D.value != null ? D.value : D.defaultValue);
      case "svg":
        return L(2, null);
      case "math":
        return L(3, null);
      case "foreignObject":
        return L(1, null);
      case "table":
        return L(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return L(5, null);
      case "colgroup":
        return L(7, null);
      case "tr":
        return L(6, null);
    }
    return 4 <= b.insertionMode || b.insertionMode === 0 ? L(1, null) : b;
  }
  var R = /* @__PURE__ */ new Map();
  function C(b, _, D) {
    if (typeof D != "object")
      throw Error(t(62));
    _ = !0;
    for (var G in D)
      if (r.call(D, G)) {
        var pe = D[G];
        if (pe != null && typeof pe != "boolean" && pe !== "") {
          if (G.indexOf("--") === 0) {
            var O = S(G);
            pe = S(("" + pe).trim());
          } else {
            O = G;
            var I = R.get(O);
            I !== void 0 || (I = S(O.replace(A, "-$1").toLowerCase().replace(p, "-ms-")), R.set(O, I)), O = I, pe = typeof pe == "number" ? pe === 0 || r.call(g, G) ? "" + pe : pe + "px" : S(("" + pe).trim());
          }
          _ ? (_ = !1, b.push(' style="', O, ":", pe)) : b.push(";", O, ":", pe);
        }
      }
    _ || b.push('"');
  }
  function z(b, _, D, G) {
    switch (D) {
      case "style":
        C(b, _, G);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < D.length) || D[0] !== "o" && D[0] !== "O" || D[1] !== "n" && D[1] !== "N") {
      if (_ = s.hasOwnProperty(D) ? s[D] : null, _ !== null) {
        switch (typeof G) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!_.acceptsBooleans)
              return;
        }
        switch (D = _.attributeName, _.type) {
          case 3:
            G && b.push(" ", D, '=""');
            break;
          case 4:
            G === !0 ? b.push(" ", D, '=""') : G !== !1 && b.push(" ", D, '="', S(G), '"');
            break;
          case 5:
            isNaN(G) || b.push(" ", D, '="', S(G), '"');
            break;
          case 6:
            !isNaN(G) && 1 <= G && b.push(" ", D, '="', S(G), '"');
            break;
          default:
            _.sanitizeURL && (G = "" + G), b.push(" ", D, '="', S(G), '"');
        }
      } else if (d(D)) {
        switch (typeof G) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (_ = D.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-")
              return;
        }
        b.push(" ", D, '="', S(G), '"');
      }
    }
  }
  function W(b, _, D) {
    if (_ != null) {
      if (D != null)
        throw Error(t(60));
      if (typeof _ != "object" || !("__html" in _))
        throw Error(t(61));
      _ = _.__html, _ != null && b.push("" + _);
    }
  }
  function Z(b) {
    var _ = "";
    return e.Children.forEach(b, function(D) {
      D != null && (_ += D);
    }), _;
  }
  function ee(b, _, D, G) {
    b.push(Y(D));
    var pe = D = null, O;
    for (O in _)
      if (r.call(_, O)) {
        var I = _[O];
        if (I != null)
          switch (O) {
            case "children":
              D = I;
              break;
            case "dangerouslySetInnerHTML":
              pe = I;
              break;
            default:
              z(b, G, O, I);
          }
      }
    return b.push(">"), W(b, pe, D), typeof D == "string" ? (b.push(S(D)), null) : D;
  }
  var K = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, le = /* @__PURE__ */ new Map();
  function Y(b) {
    var _ = le.get(b);
    if (_ === void 0) {
      if (!K.test(b))
        throw Error(t(65, b));
      _ = "<" + b, le.set(b, _);
    }
    return _;
  }
  function ae(b, _, D, G, pe) {
    switch (_) {
      case "select":
        b.push(Y("select"));
        var O = null, I = null;
        for (Xe in D)
          if (r.call(D, Xe)) {
            var J = D[Xe];
            if (J != null)
              switch (Xe) {
                case "children":
                  O = J;
                  break;
                case "dangerouslySetInnerHTML":
                  I = J;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  z(b, G, Xe, J);
              }
          }
        return b.push(">"), W(b, I, O), O;
      case "option":
        I = pe.selectedValue, b.push(Y("option"));
        var ve = J = null, Ie = null, Xe = null;
        for (O in D)
          if (r.call(D, O)) {
            var lt = D[O];
            if (lt != null)
              switch (O) {
                case "children":
                  J = lt;
                  break;
                case "selected":
                  Ie = lt;
                  break;
                case "dangerouslySetInnerHTML":
                  Xe = lt;
                  break;
                case "value":
                  ve = lt;
                default:
                  z(b, G, O, lt);
              }
          }
        if (I != null)
          if (D = ve !== null ? "" + ve : Z(J), v(I)) {
            for (G = 0; G < I.length; G++)
              if ("" + I[G] === D) {
                b.push(' selected=""');
                break;
              }
          } else
            "" + I === D && b.push(' selected=""');
        else
          Ie && b.push(' selected=""');
        return b.push(">"), W(b, Xe, J), J;
      case "textarea":
        b.push(Y("textarea")), Xe = I = O = null;
        for (J in D)
          if (r.call(D, J) && (ve = D[J], ve != null))
            switch (J) {
              case "children":
                Xe = ve;
                break;
              case "value":
                O = ve;
                break;
              case "defaultValue":
                I = ve;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                z(
                  b,
                  G,
                  J,
                  ve
                );
            }
        if (O === null && I !== null && (O = I), b.push(">"), Xe != null) {
          if (O != null)
            throw Error(t(92));
          if (v(Xe) && 1 < Xe.length)
            throw Error(t(93));
          O = "" + Xe;
        }
        return typeof O == "string" && O[0] === `
` && b.push(`
`), O !== null && b.push(S("" + O)), null;
      case "input":
        b.push(Y("input")), ve = Xe = J = O = null;
        for (I in D)
          if (r.call(D, I) && (Ie = D[I], Ie != null))
            switch (I) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                ve = Ie;
                break;
              case "defaultValue":
                J = Ie;
                break;
              case "checked":
                Xe = Ie;
                break;
              case "value":
                O = Ie;
                break;
              default:
                z(b, G, I, Ie);
            }
        return Xe !== null ? z(b, G, "checked", Xe) : ve !== null && z(b, G, "checked", ve), O !== null ? z(b, G, "value", O) : J !== null && z(b, G, "value", J), b.push("/>"), null;
      case "menuitem":
        b.push(Y("menuitem"));
        for (var Ut in D)
          if (r.call(D, Ut) && (O = D[Ut], O != null))
            switch (Ut) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                z(b, G, Ut, O);
            }
        return b.push(">"), null;
      case "title":
        b.push(Y("title")), O = null;
        for (lt in D)
          if (r.call(D, lt) && (I = D[lt], I != null))
            switch (lt) {
              case "children":
                O = I;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                z(b, G, lt, I);
            }
        return b.push(">"), O;
      case "listing":
      case "pre":
        b.push(Y(_)), I = O = null;
        for (ve in D)
          if (r.call(D, ve) && (J = D[ve], J != null))
            switch (ve) {
              case "children":
                O = J;
                break;
              case "dangerouslySetInnerHTML":
                I = J;
                break;
              default:
                z(b, G, ve, J);
            }
        if (b.push(">"), I != null) {
          if (O != null)
            throw Error(t(60));
          if (typeof I != "object" || !("__html" in I))
            throw Error(t(61));
          D = I.__html, D != null && (typeof D == "string" && 0 < D.length && D[0] === `
` ? b.push(`
`, D) : b.push("" + D));
        }
        return typeof O == "string" && O[0] === `
` && b.push(`
`), O;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        b.push(Y(_));
        for (var Ht in D)
          if (r.call(D, Ht) && (O = D[Ht], O != null))
            switch (Ht) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, _));
              default:
                z(b, G, Ht, O);
            }
        return b.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ee(
          b,
          D,
          _,
          G
        );
      case "html":
        return pe.insertionMode === 0 && b.push("<!DOCTYPE html>"), ee(b, D, _, G);
      default:
        if (_.indexOf("-") === -1 && typeof D.is != "string")
          return ee(b, D, _, G);
        b.push(Y(_)), I = O = null;
        for (Ie in D)
          if (r.call(D, Ie) && (J = D[Ie], J != null))
            switch (Ie) {
              case "children":
                O = J;
                break;
              case "dangerouslySetInnerHTML":
                I = J;
                break;
              case "style":
                C(b, G, J);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(Ie) && typeof J != "function" && typeof J != "symbol" && b.push(" ", Ie, '="', S(J), '"');
            }
        return b.push(">"), W(b, I, O), O;
    }
  }
  function B(b, _, D) {
    if (b.push('<!--$?--><template id="'), D === null)
      throw Error(t(395));
    return b.push(D), b.push('"></template>');
  }
  function X(b, _, D, G) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return b.push('<div hidden id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 2:
        return b.push('<svg aria-hidden="true" style="display:none" id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 3:
        return b.push('<math aria-hidden="true" style="display:none" id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 4:
        return b.push('<table hidden id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 5:
        return b.push('<table hidden><tbody id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 6:
        return b.push('<table hidden><tr id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      case 7:
        return b.push('<table hidden><colgroup id="'), b.push(_.segmentPrefix), _ = G.toString(16), b.push(_), b.push('">');
      default:
        throw Error(t(397));
    }
  }
  function ce(b, _) {
    switch (_.insertionMode) {
      case 0:
      case 1:
        return b.push("</div>");
      case 2:
        return b.push("</svg>");
      case 3:
        return b.push("</math>");
      case 4:
        return b.push("</table>");
      case 5:
        return b.push("</tbody></table>");
      case 6:
        return b.push("</tr></table>");
      case 7:
        return b.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var ne = /[<\u2028\u2029]/g;
  function Q(b) {
    return JSON.stringify(b).replace(ne, function(_) {
      switch (_) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function V(b, _) {
    return _ = _ === void 0 ? "" : _, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: _ + "P:", segmentPrefix: _ + "S:", boundaryPrefix: _ + "B:", idPrefix: _, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: b };
  }
  function j(b, _, D, G) {
    return D.generateStaticMarkup ? (b.push(S(_)), !1) : (_ === "" ? b = G : (G && b.push("<!-- -->"), b.push(S(_)), b = !0), b);
  }
  var te = Object.assign, U = Symbol.for("react.element"), ue = Symbol.for("react.portal"), ke = Symbol.for("react.fragment"), xe = Symbol.for("react.strict_mode"), be = Symbol.for("react.profiler"), Ae = Symbol.for("react.provider"), Ye = Symbol.for("react.context"), Pe = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), Re = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), Ne = Symbol.for("react.scope"), qe = Symbol.for("react.debug_trace_mode"), He = Symbol.for("react.legacy_hidden"), Be = Symbol.for("react.default_value"), Ze = Symbol.iterator;
  function Ve(b) {
    if (b == null)
      return null;
    if (typeof b == "function")
      return b.displayName || b.name || null;
    if (typeof b == "string")
      return b;
    switch (b) {
      case ke:
        return "Fragment";
      case ue:
        return "Portal";
      case be:
        return "Profiler";
      case xe:
        return "StrictMode";
      case ye:
        return "Suspense";
      case Re:
        return "SuspenseList";
    }
    if (typeof b == "object")
      switch (b.$$typeof) {
        case Ye:
          return (b.displayName || "Context") + ".Consumer";
        case Ae:
          return (b._context.displayName || "Context") + ".Provider";
        case Pe:
          var _ = b.render;
          return b = b.displayName, b || (b = _.displayName || _.name || "", b = b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef"), b;
        case fe:
          return _ = b.displayName || null, _ !== null ? _ : Ve(b.type) || "Memo";
        case ze:
          _ = b._payload, b = b._init;
          try {
            return Ve(b(_));
          } catch {
          }
      }
    return null;
  }
  var je = {};
  function Ue(b, _) {
    if (b = b.contextTypes, !b)
      return je;
    var D = {}, G;
    for (G in b)
      D[G] = _[G];
    return D;
  }
  var we = null;
  function De(b, _) {
    if (b !== _) {
      b.context._currentValue2 = b.parentValue, b = b.parent;
      var D = _.parent;
      if (b === null) {
        if (D !== null)
          throw Error(t(401));
      } else {
        if (D === null)
          throw Error(t(401));
        De(b, D);
      }
      _.context._currentValue2 = _.value;
    }
  }
  function rt(b) {
    b.context._currentValue2 = b.parentValue, b = b.parent, b !== null && rt(b);
  }
  function ge(b) {
    var _ = b.parent;
    _ !== null && ge(_), b.context._currentValue2 = b.value;
  }
  function ut(b, _) {
    if (b.context._currentValue2 = b.parentValue, b = b.parent, b === null)
      throw Error(t(402));
    b.depth === _.depth ? De(b, _) : ut(b, _);
  }
  function at(b, _) {
    var D = _.parent;
    if (D === null)
      throw Error(t(402));
    b.depth === D.depth ? De(b, D) : at(b, D), _.context._currentValue2 = _.value;
  }
  function it(b) {
    var _ = we;
    _ !== b && (_ === null ? ge(b) : b === null ? rt(_) : _.depth === b.depth ? De(_, b) : _.depth > b.depth ? ut(_, b) : at(_, b), we = b);
  }
  var St = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(b, _) {
    b = b._reactInternals, b.queue !== null && b.queue.push(_);
  }, enqueueReplaceState: function(b, _) {
    b = b._reactInternals, b.replace = !0, b.queue = [_];
  }, enqueueForceUpdate: function() {
  } };
  function jt(b, _, D, G) {
    var pe = b.state !== void 0 ? b.state : null;
    b.updater = St, b.props = D, b.state = pe;
    var O = { queue: [], replace: !1 };
    b._reactInternals = O;
    var I = _.contextType;
    if (b.context = typeof I == "object" && I !== null ? I._currentValue2 : G, I = _.getDerivedStateFromProps, typeof I == "function" && (I = I(D, pe), pe = I == null ? pe : te({}, pe, I), b.state = pe), typeof _.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function"))
      if (_ = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), _ !== b.state && St.enqueueReplaceState(b, b.state, null), O.queue !== null && 0 < O.queue.length)
        if (_ = O.queue, I = O.replace, O.queue = null, O.replace = !1, I && _.length === 1)
          b.state = _[0];
        else {
          for (O = I ? _[0] : b.state, pe = !0, I = I ? 1 : 0; I < _.length; I++) {
            var J = _[I];
            J = typeof J == "function" ? J.call(b, O, D, G) : J, J != null && (pe ? (pe = !1, O = te({}, O, J)) : te(O, J));
          }
          b.state = O;
        }
      else
        O.queue = null;
  }
  var Bt = { id: 1, overflow: "" };
  function Nt(b, _, D) {
    var G = b.id;
    b = b.overflow;
    var pe = 32 - sn(G) - 1;
    G &= ~(1 << pe), D += 1;
    var O = 32 - sn(_) + pe;
    if (30 < O) {
      var I = pe - pe % 5;
      return O = (G & (1 << I) - 1).toString(32), G >>= I, pe -= I, { id: 1 << 32 - sn(_) + pe | D << pe | G, overflow: O + b };
    }
    return { id: 1 << O | D << pe | G, overflow: b };
  }
  var sn = Math.clz32 ? Math.clz32 : _t, gt = Math.log, Dt = Math.LN2;
  function _t(b) {
    return b >>>= 0, b === 0 ? 32 : 31 - (gt(b) / Dt | 0) | 0;
  }
  function un(b, _) {
    return b === _ && (b !== 0 || 1 / b === 1 / _) || b !== b && _ !== _;
  }
  var En = typeof Object.is == "function" ? Object.is : un, $t = null, It = null, fn = null, tt = null, st = !1, Tn = !1, tn = 0, cn = null, pn = 0;
  function ft() {
    if ($t === null)
      throw Error(t(321));
    return $t;
  }
  function Pt() {
    if (0 < pn)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ot() {
    return tt === null ? fn === null ? (st = !1, fn = tt = Pt()) : (st = !0, tt = fn) : tt.next === null ? (st = !1, tt = tt.next = Pt()) : (st = !0, tt = tt.next), tt;
  }
  function hn() {
    It = $t = null, Tn = !1, fn = null, pn = 0, tt = cn = null;
  }
  function Tt(b, _) {
    return typeof _ == "function" ? _(b) : _;
  }
  function Ct(b, _, D) {
    if ($t = ft(), tt = Ot(), st) {
      var G = tt.queue;
      if (_ = G.dispatch, cn !== null && (D = cn.get(G), D !== void 0)) {
        cn.delete(G), G = tt.memoizedState;
        do
          G = b(G, D.action), D = D.next;
        while (D !== null);
        return tt.memoizedState = G, [G, _];
      }
      return [tt.memoizedState, _];
    }
    return b = b === Tt ? typeof _ == "function" ? _() : _ : D !== void 0 ? D(_) : _, tt.memoizedState = b, b = tt.queue = { last: null, dispatch: null }, b = b.dispatch = Nn.bind(null, $t, b), [tt.memoizedState, b];
  }
  function nn(b, _) {
    if ($t = ft(), tt = Ot(), _ = _ === void 0 ? null : _, tt !== null) {
      var D = tt.memoizedState;
      if (D !== null && _ !== null) {
        var G = D[1];
        e:
          if (G === null)
            G = !1;
          else {
            for (var pe = 0; pe < G.length && pe < _.length; pe++)
              if (!En(_[pe], G[pe])) {
                G = !1;
                break e;
              }
            G = !0;
          }
        if (G)
          return D[0];
      }
    }
    return b = b(), tt.memoizedState = [b, _], b;
  }
  function Nn(b, _, D) {
    if (25 <= pn)
      throw Error(t(301));
    if (b === $t)
      if (Tn = !0, b = { action: D, next: null }, cn === null && (cn = /* @__PURE__ */ new Map()), D = cn.get(_), D === void 0)
        cn.set(_, b);
      else {
        for (_ = D; _.next !== null; )
          _ = _.next;
        _.next = b;
      }
  }
  function At() {
    throw Error(t(394));
  }
  function xt() {
  }
  var Dn = { readContext: function(b) {
    return b._currentValue2;
  }, useContext: function(b) {
    return ft(), b._currentValue2;
  }, useMemo: nn, useReducer: Ct, useRef: function(b) {
    $t = ft(), tt = Ot();
    var _ = tt.memoizedState;
    return _ === null ? (b = { current: b }, tt.memoizedState = b) : _;
  }, useState: function(b) {
    return Ct(Tt, b);
  }, useInsertionEffect: xt, useLayoutEffect: function() {
  }, useCallback: function(b, _) {
    return nn(function() {
      return b;
    }, _);
  }, useImperativeHandle: xt, useEffect: xt, useDebugValue: xt, useDeferredValue: function(b) {
    return ft(), b;
  }, useTransition: function() {
    return ft(), [
      !1,
      At
    ];
  }, useId: function() {
    var b = It.treeContext, _ = b.overflow;
    b = b.id, b = (b & ~(1 << 32 - sn(b) - 1)).toString(32) + _;
    var D = Oe;
    if (D === null)
      throw Error(t(404));
    return _ = tn++, b = ":" + D.idPrefix + "R" + b, 0 < _ && (b += "H" + _.toString(32)), b + ":";
  }, useMutableSource: function(b, _) {
    return ft(), _(b._source);
  }, useSyncExternalStore: function(b, _, D) {
    if (D === void 0)
      throw Error(t(407));
    return D();
  } }, Oe = null, _e = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Ee(b) {
    return console.error(b), null;
  }
  function ct() {
  }
  function qt(b, _, D, G, pe, O, I, J, ve) {
    var Ie = [], Xe = /* @__PURE__ */ new Set();
    return _ = { destination: null, responseState: _, progressiveChunkSize: G === void 0 ? 12800 : G, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Xe, pingedTasks: Ie, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: pe === void 0 ? Ee : pe, onAllReady: O === void 0 ? ct : O, onShellReady: I === void 0 ? ct : I, onShellError: J === void 0 ? ct : J, onFatalError: ve === void 0 ? ct : ve }, D = Ft(_, 0, null, D, !1, !1), D.parentFlushed = !0, b = Kt(_, b, null, D, Xe, je, null, Bt), Ie.push(b), _;
  }
  function Kt(b, _, D, G, pe, O, I, J) {
    b.allPendingTasks++, D === null ? b.pendingRootTasks++ : D.pendingTasks++;
    var ve = { node: _, ping: function() {
      var Ie = b.pingedTasks;
      Ie.push(ve), Ie.length === 1 && mn(b);
    }, blockedBoundary: D, blockedSegment: G, abortSet: pe, legacyContext: O, context: I, treeContext: J };
    return pe.add(ve), ve;
  }
  function Ft(b, _, D, G, pe, O) {
    return { status: 0, id: -1, index: _, parentFlushed: !1, chunks: [], children: [], formatContext: G, boundary: D, lastPushedText: pe, textEmbedded: O };
  }
  function kt(b, _) {
    if (b = b.onError(_), b != null && typeof b != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b;
  }
  function ht(b, _) {
    var D = b.onShellError;
    D(_), D = b.onFatalError, D(_), b.destination !== null ? (b.status = 2, b.destination.destroy(_)) : (b.status = 1, b.fatalError = _);
  }
  function Et(b, _, D, G, pe) {
    for ($t = {}, It = _, tn = 0, b = D(G, pe); Tn; )
      Tn = !1, tn = 0, pn += 1, tt = null, b = D(G, pe);
    return hn(), b;
  }
  function An(b, _, D, G) {
    var pe = D.render(), O = G.childContextTypes;
    if (O != null) {
      var I = _.legacyContext;
      if (typeof D.getChildContext != "function")
        G = I;
      else {
        D = D.getChildContext();
        for (var J in D)
          if (!(J in O))
            throw Error(t(108, Ve(G) || "Unknown", J));
        G = te({}, I, D);
      }
      _.legacyContext = G, Rt(b, _, pe), _.legacyContext = I;
    } else
      Rt(b, _, pe);
  }
  function Zt(b, _) {
    if (b && b.defaultProps) {
      _ = te({}, _), b = b.defaultProps;
      for (var D in b)
        _[D] === void 0 && (_[D] = b[D]);
      return _;
    }
    return _;
  }
  function kn(b, _, D, G, pe) {
    if (typeof D == "function")
      if (D.prototype && D.prototype.isReactComponent) {
        pe = Ue(D, _.legacyContext);
        var O = D.contextType;
        O = new D(G, typeof O == "object" && O !== null ? O._currentValue2 : pe), jt(O, D, G, pe), An(b, _, O, D);
      } else {
        O = Ue(D, _.legacyContext), pe = Et(b, _, D, G, O);
        var I = tn !== 0;
        if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0)
          jt(pe, D, G, O), An(b, _, pe, D);
        else if (I) {
          G = _.treeContext, _.treeContext = Nt(G, 1, 0);
          try {
            Rt(b, _, pe);
          } finally {
            _.treeContext = G;
          }
        } else
          Rt(b, _, pe);
      }
    else if (typeof D == "string") {
      switch (pe = _.blockedSegment, O = ae(pe.chunks, D, G, b.responseState, pe.formatContext), pe.lastPushedText = !1, I = pe.formatContext, pe.formatContext = P(I, D, G), Gt(b, _, O), pe.formatContext = I, D) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          pe.chunks.push("</", D, ">");
      }
      pe.lastPushedText = !1;
    } else {
      switch (D) {
        case He:
        case qe:
        case xe:
        case be:
        case ke:
          Rt(b, _, G.children);
          return;
        case Re:
          Rt(b, _, G.children);
          return;
        case Ne:
          throw Error(t(343));
        case ye:
          e: {
            D = _.blockedBoundary, pe = _.blockedSegment, O = G.fallback, G = G.children, I = /* @__PURE__ */ new Set();
            var J = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: I, errorDigest: null }, ve = Ft(b, pe.chunks.length, J, pe.formatContext, !1, !1);
            pe.children.push(ve), pe.lastPushedText = !1;
            var Ie = Ft(b, 0, null, pe.formatContext, !1, !1);
            Ie.parentFlushed = !0, _.blockedBoundary = J, _.blockedSegment = Ie;
            try {
              if (Gt(
                b,
                _,
                G
              ), b.responseState.generateStaticMarkup || Ie.lastPushedText && Ie.textEmbedded && Ie.chunks.push("<!-- -->"), Ie.status = 1, Ln(J, Ie), J.pendingTasks === 0)
                break e;
            } catch (Xe) {
              Ie.status = 4, J.forceClientRender = !0, J.errorDigest = kt(b, Xe);
            } finally {
              _.blockedBoundary = D, _.blockedSegment = pe;
            }
            _ = Kt(b, O, D, ve, I, _.legacyContext, _.context, _.treeContext), b.pingedTasks.push(_);
          }
          return;
      }
      if (typeof D == "object" && D !== null)
        switch (D.$$typeof) {
          case Pe:
            if (G = Et(b, _, D.render, G, pe), tn !== 0) {
              D = _.treeContext, _.treeContext = Nt(D, 1, 0);
              try {
                Rt(b, _, G);
              } finally {
                _.treeContext = D;
              }
            } else
              Rt(b, _, G);
            return;
          case fe:
            D = D.type, G = Zt(D, G), kn(b, _, D, G, pe);
            return;
          case Ae:
            if (pe = G.children, D = D._context, G = G.value, O = D._currentValue2, D._currentValue2 = G, I = we, we = G = { parent: I, depth: I === null ? 0 : I.depth + 1, context: D, parentValue: O, value: G }, _.context = G, Rt(b, _, pe), b = we, b === null)
              throw Error(t(403));
            G = b.parentValue, b.context._currentValue2 = G === Be ? b.context._defaultValue : G, b = we = b.parent, _.context = b;
            return;
          case Ye:
            G = G.children, G = G(D._currentValue2), Rt(b, _, G);
            return;
          case ze:
            pe = D._init, D = pe(D._payload), G = Zt(D, G), kn(
              b,
              _,
              D,
              G,
              void 0
            );
            return;
        }
      throw Error(t(130, D == null ? D : typeof D, ""));
    }
  }
  function Rt(b, _, D) {
    if (_.node = D, typeof D == "object" && D !== null) {
      switch (D.$$typeof) {
        case U:
          kn(b, _, D.type, D.props, D.ref);
          return;
        case ue:
          throw Error(t(257));
        case ze:
          var G = D._init;
          D = G(D._payload), Rt(b, _, D);
          return;
      }
      if (v(D)) {
        dn(b, _, D);
        return;
      }
      if (D === null || typeof D != "object" ? G = null : (G = Ze && D[Ze] || D["@@iterator"], G = typeof G == "function" ? G : null), G && (G = G.call(D))) {
        if (D = G.next(), !D.done) {
          var pe = [];
          do
            pe.push(D.value), D = G.next();
          while (!D.done);
          dn(b, _, pe);
        }
        return;
      }
      throw b = Object.prototype.toString.call(D), Error(t(31, b === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : b));
    }
    typeof D == "string" ? (G = _.blockedSegment, G.lastPushedText = j(_.blockedSegment.chunks, D, b.responseState, G.lastPushedText)) : typeof D == "number" && (G = _.blockedSegment, G.lastPushedText = j(_.blockedSegment.chunks, "" + D, b.responseState, G.lastPushedText));
  }
  function dn(b, _, D) {
    for (var G = D.length, pe = 0; pe < G; pe++) {
      var O = _.treeContext;
      _.treeContext = Nt(O, G, pe);
      try {
        Gt(b, _, D[pe]);
      } finally {
        _.treeContext = O;
      }
    }
  }
  function Gt(b, _, D) {
    var G = _.blockedSegment.formatContext, pe = _.legacyContext, O = _.context;
    try {
      return Rt(b, _, D);
    } catch (ve) {
      if (hn(), typeof ve == "object" && ve !== null && typeof ve.then == "function") {
        D = ve;
        var I = _.blockedSegment, J = Ft(b, I.chunks.length, null, I.formatContext, I.lastPushedText, !0);
        I.children.push(J), I.lastPushedText = !1, b = Kt(b, _.node, _.blockedBoundary, J, _.abortSet, _.legacyContext, _.context, _.treeContext).ping, D.then(b, b), _.blockedSegment.formatContext = G, _.legacyContext = pe, _.context = O, it(O);
      } else
        throw _.blockedSegment.formatContext = G, _.legacyContext = pe, _.context = O, it(O), ve;
    }
  }
  function rn(b) {
    var _ = b.blockedBoundary;
    b = b.blockedSegment, b.status = 3, Cn(this, _, b);
  }
  function Wn(b, _, D) {
    var G = b.blockedBoundary;
    b.blockedSegment.status = 3, G === null ? (_.allPendingTasks--, _.status !== 2 && (_.status = 2, _.destination !== null && _.destination.push(null))) : (G.pendingTasks--, G.forceClientRender || (G.forceClientRender = !0, b = D === void 0 ? Error(t(432)) : D, G.errorDigest = _.onError(b), G.parentFlushed && _.clientRenderedBoundaries.push(G)), G.fallbackAbortableTasks.forEach(function(pe) {
      return Wn(pe, _, D);
    }), G.fallbackAbortableTasks.clear(), _.allPendingTasks--, _.allPendingTasks === 0 && (G = _.onAllReady, G()));
  }
  function Ln(b, _) {
    if (_.chunks.length === 0 && _.children.length === 1 && _.children[0].boundary === null) {
      var D = _.children[0];
      D.id = _.id, D.parentFlushed = !0, D.status === 1 && Ln(b, D);
    } else
      b.completedSegments.push(_);
  }
  function Cn(b, _, D) {
    if (_ === null) {
      if (D.parentFlushed) {
        if (b.completedRootSegment !== null)
          throw Error(t(389));
        b.completedRootSegment = D;
      }
      b.pendingRootTasks--, b.pendingRootTasks === 0 && (b.onShellError = ct, _ = b.onShellReady, _());
    } else
      _.pendingTasks--, _.forceClientRender || (_.pendingTasks === 0 ? (D.parentFlushed && D.status === 1 && Ln(_, D), _.parentFlushed && b.completedBoundaries.push(_), _.fallbackAbortableTasks.forEach(rn, b), _.fallbackAbortableTasks.clear()) : D.parentFlushed && D.status === 1 && (Ln(_, D), _.completedSegments.length === 1 && _.parentFlushed && b.partialBoundaries.push(_)));
    b.allPendingTasks--, b.allPendingTasks === 0 && (b = b.onAllReady, b());
  }
  function mn(b) {
    if (b.status !== 2) {
      var _ = we, D = _e.current;
      _e.current = Dn;
      var G = Oe;
      Oe = b.responseState;
      try {
        var pe = b.pingedTasks, O;
        for (O = 0; O < pe.length; O++) {
          var I = pe[O], J = b, ve = I.blockedSegment;
          if (ve.status === 0) {
            it(I.context);
            try {
              Rt(J, I, I.node), J.responseState.generateStaticMarkup || ve.lastPushedText && ve.textEmbedded && ve.chunks.push("<!-- -->"), I.abortSet.delete(I), ve.status = 1, Cn(J, I.blockedBoundary, ve);
            } catch (Qt) {
              if (hn(), typeof Qt == "object" && Qt !== null && typeof Qt.then == "function") {
                var Ie = I.ping;
                Qt.then(Ie, Ie);
              } else {
                I.abortSet.delete(I), ve.status = 4;
                var Xe = I.blockedBoundary, lt = Qt, Ut = kt(J, lt);
                if (Xe === null ? ht(J, lt) : (Xe.pendingTasks--, Xe.forceClientRender || (Xe.forceClientRender = !0, Xe.errorDigest = Ut, Xe.parentFlushed && J.clientRenderedBoundaries.push(Xe))), J.allPendingTasks--, J.allPendingTasks === 0) {
                  var Ht = J.onAllReady;
                  Ht();
                }
              }
            } finally {
            }
          }
        }
        pe.splice(0, O), b.destination !== null && yn(b, b.destination);
      } catch (Qt) {
        kt(b, Qt), ht(b, Qt);
      } finally {
        Oe = G, _e.current = D, D === Dn && it(_);
      }
    }
  }
  function _n(b, _, D) {
    switch (D.parentFlushed = !0, D.status) {
      case 0:
        var G = D.id = b.nextSegmentId++;
        return D.lastPushedText = !1, D.textEmbedded = !1, b = b.responseState, _.push('<template id="'), _.push(b.placeholderPrefix), b = G.toString(16), _.push(b), _.push('"></template>');
      case 1:
        D.status = 2;
        var pe = !0;
        G = D.chunks;
        var O = 0;
        D = D.children;
        for (var I = 0; I < D.length; I++) {
          for (pe = D[I]; O < pe.index; O++)
            _.push(G[O]);
          pe = On(b, _, pe);
        }
        for (; O < G.length - 1; O++)
          _.push(G[O]);
        return O < G.length && (pe = _.push(G[O])), pe;
      default:
        throw Error(t(390));
    }
  }
  function On(b, _, D) {
    var G = D.boundary;
    if (G === null)
      return _n(b, _, D);
    if (G.parentFlushed = !0, G.forceClientRender)
      return b.responseState.generateStaticMarkup || (G = G.errorDigest, _.push("<!--$!-->"), _.push("<template"), G && (_.push(' data-dgst="'), G = S(G), _.push(G), _.push('"')), _.push("></template>")), _n(b, _, D), b = b.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), b;
    if (0 < G.pendingTasks) {
      G.rootSegmentID = b.nextSegmentId++, 0 < G.completedSegments.length && b.partialBoundaries.push(G);
      var pe = b.responseState, O = pe.nextSuspenseID++;
      return pe = pe.boundaryPrefix + O.toString(16), G = G.id = pe, B(_, b.responseState, G), _n(b, _, D), _.push("<!--/$-->");
    }
    if (G.byteSize > b.progressiveChunkSize)
      return G.rootSegmentID = b.nextSegmentId++, b.completedBoundaries.push(G), B(_, b.responseState, G.id), _n(b, _, D), _.push("<!--/$-->");
    if (b.responseState.generateStaticMarkup || _.push("<!--$-->"), D = G.completedSegments, D.length !== 1)
      throw Error(t(391));
    return On(b, _, D[0]), b = b.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), b;
  }
  function Fn(b, _, D) {
    return X(_, b.responseState, D.formatContext, D.id), On(b, _, D), ce(_, D.formatContext);
  }
  function Kn(b, _, D) {
    for (var G = D.completedSegments, pe = 0; pe < G.length; pe++)
      an(b, _, D, G[pe]);
    if (G.length = 0, b = b.responseState, G = D.id, D = D.rootSegmentID, _.push(b.startInlineScript), b.sentCompleteBoundaryFunction ? _.push('$RC("') : (b.sentCompleteBoundaryFunction = !0, _.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), G === null)
      throw Error(t(395));
    return D = D.toString(16), _.push(G), _.push('","'), _.push(b.segmentPrefix), _.push(D), _.push('")<\/script>');
  }
  function an(b, _, D, G) {
    if (G.status === 2)
      return !0;
    var pe = G.id;
    if (pe === -1) {
      if ((G.id = D.rootSegmentID) === -1)
        throw Error(t(392));
      return Fn(b, _, G);
    }
    return Fn(b, _, G), b = b.responseState, _.push(b.startInlineScript), b.sentCompleteSegmentFunction ? _.push('$RS("') : (b.sentCompleteSegmentFunction = !0, _.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), _.push(b.segmentPrefix), pe = pe.toString(16), _.push(pe), _.push('","'), _.push(b.placeholderPrefix), _.push(pe), _.push('")<\/script>');
  }
  function yn(b, _) {
    try {
      var D = b.completedRootSegment;
      if (D !== null && b.pendingRootTasks === 0) {
        On(b, _, D), b.completedRootSegment = null;
        var G = b.responseState.bootstrapChunks;
        for (D = 0; D < G.length - 1; D++)
          _.push(G[D]);
        D < G.length && _.push(G[D]);
      }
      var pe = b.clientRenderedBoundaries, O;
      for (O = 0; O < pe.length; O++) {
        var I = pe[O];
        G = _;
        var J = b.responseState, ve = I.id, Ie = I.errorDigest, Xe = I.errorMessage, lt = I.errorComponentStack;
        if (G.push(J.startInlineScript), J.sentClientRenderFunction ? G.push('$RX("') : (J.sentClientRenderFunction = !0, G.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), ve === null)
          throw Error(t(395));
        if (G.push(ve), G.push('"'), Ie || Xe || lt) {
          G.push(",");
          var Ut = Q(Ie || "");
          G.push(Ut);
        }
        if (Xe || lt) {
          G.push(",");
          var Ht = Q(Xe || "");
          G.push(Ht);
        }
        if (lt) {
          G.push(",");
          var Qt = Q(lt);
          G.push(Qt);
        }
        if (!G.push(")<\/script>")) {
          b.destination = null, O++, pe.splice(0, O);
          return;
        }
      }
      pe.splice(0, O);
      var Jt = b.completedBoundaries;
      for (O = 0; O < Jt.length; O++)
        if (!Kn(b, _, Jt[O])) {
          b.destination = null, O++, Jt.splice(0, O);
          return;
        }
      Jt.splice(0, O);
      var en = b.partialBoundaries;
      for (O = 0; O < en.length; O++) {
        var jn = en[O];
        e: {
          pe = b, I = _;
          var Jn = jn.completedSegments;
          for (J = 0; J < Jn.length; J++)
            if (!an(pe, I, jn, Jn[J])) {
              J++, Jn.splice(0, J);
              var er = !1;
              break e;
            }
          Jn.splice(0, J), er = !0;
        }
        if (!er) {
          b.destination = null, O++, en.splice(0, O);
          return;
        }
      }
      en.splice(0, O);
      var Yn = b.completedBoundaries;
      for (O = 0; O < Yn.length; O++)
        if (!Kn(b, _, Yn[O])) {
          b.destination = null, O++, Yn.splice(0, O);
          return;
        }
      Yn.splice(0, O);
    } finally {
      b.allPendingTasks === 0 && b.pingedTasks.length === 0 && b.clientRenderedBoundaries.length === 0 && b.completedBoundaries.length === 0 && _.push(null);
    }
  }
  function ir(b, _) {
    try {
      var D = b.abortableTasks;
      D.forEach(function(G) {
        return Wn(G, b, _);
      }), D.clear(), b.destination !== null && yn(b, b.destination);
    } catch (G) {
      kt(b, G), ht(b, G);
    }
  }
  function Zn() {
  }
  function Qn(b, _, D, G) {
    var pe = !1, O = null, I = "", J = { push: function(Ie) {
      return Ie !== null && (I += Ie), !0;
    }, destroy: function(Ie) {
      pe = !0, O = Ie;
    } }, ve = !1;
    if (b = qt(b, V(D, _ ? _.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Zn, void 0, function() {
      ve = !0;
    }, void 0, void 0), mn(b), ir(b, G), b.status === 1)
      b.status = 2, J.destroy(b.fatalError);
    else if (b.status !== 2 && b.destination === null) {
      b.destination = J;
      try {
        yn(b, J);
      } catch (Ie) {
        kt(b, Ie), ht(b, Ie);
      }
    }
    if (pe)
      throw O;
    if (!ve)
      throw Error(t(426));
    return I;
  }
  return Ni.renderToNodeStream = function() {
    throw Error(t(207));
  }, Ni.renderToStaticMarkup = function(b, _) {
    return Qn(b, _, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ni.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Ni.renderToString = function(b, _) {
    return Qn(b, _, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ni.version = "18.2.0", Ni;
}
var Fu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qh;
function vS() {
  if (Qh)
    return Fu;
  Qh = 1;
  var e = se;
  function t(E) {
    for (var F = "https://reactjs.org/docs/error-decoder.html?invariant=" + E, H = 1; H < arguments.length; H++)
      F += "&args[]=" + encodeURIComponent(arguments[H]);
    return "Minified React error #" + E + "; visit " + F + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = null, a = 0;
  function i(E, F) {
    if (F.length !== 0)
      if (512 < F.length)
        0 < a && (E.enqueue(new Uint8Array(r.buffer, 0, a)), r = new Uint8Array(512), a = 0), E.enqueue(F);
      else {
        var H = r.length - a;
        H < F.length && (H === 0 ? E.enqueue(r) : (r.set(F.subarray(0, H), a), E.enqueue(r), F = F.subarray(H)), r = new Uint8Array(512), a = 0), r.set(F, a), a += F.length;
      }
  }
  function o(E, F) {
    return i(E, F), !0;
  }
  function d(E) {
    r && 0 < a && (E.enqueue(new Uint8Array(r.buffer, 0, a)), r = null, a = 0);
  }
  var c = new TextEncoder();
  function s(E) {
    return c.encode(E);
  }
  function h(E) {
    return c.encode(E);
  }
  function y(E, F) {
    typeof E.error == "function" ? E.error(F) : E.close();
  }
  var g = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, S = {};
  function A(E) {
    return g.call(S, E) ? !0 : g.call(w, E) ? !1 : x.test(E) ? S[E] = !0 : (w[E] = !0, !1);
  }
  function p(E, F, H, re, Te, Se, Fe) {
    this.acceptsBooleans = F === 2 || F === 3 || F === 4, this.attributeName = re, this.attributeNamespace = Te, this.mustUseProperty = H, this.propertyName = E, this.type = F, this.sanitizeURL = Se, this.removeEmptyString = Fe;
  }
  var v = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(E) {
    v[E] = new p(E, 0, !1, E, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(E) {
    var F = E[0];
    v[F] = new p(F, 1, !1, E[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(E) {
    v[E] = new p(E, 2, !1, E.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(E) {
    v[E] = new p(E, 2, !1, E, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(E) {
    v[E] = new p(E, 3, !1, E.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(E) {
    v[E] = new p(E, 3, !0, E, null, !1, !1);
  }), ["capture", "download"].forEach(function(E) {
    v[E] = new p(E, 4, !1, E, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(E) {
    v[E] = new p(E, 6, !1, E, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(E) {
    v[E] = new p(E, 5, !1, E.toLowerCase(), null, !1, !1);
  });
  var L = /[\-:]([a-z])/g;
  function P(E) {
    return E[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(E) {
    var F = E.replace(
      L,
      P
    );
    v[F] = new p(F, 1, !1, E, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(E) {
    var F = E.replace(L, P);
    v[F] = new p(F, 1, !1, E, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(E) {
    var F = E.replace(L, P);
    v[F] = new p(F, 1, !1, E, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(E) {
    v[E] = new p(E, 1, !1, E.toLowerCase(), null, !1, !1);
  }), v.xlinkHref = new p("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(E) {
    v[E] = new p(E, 1, !1, E.toLowerCase(), null, !0, !0);
  });
  var R = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, C = ["Webkit", "ms", "Moz", "O"];
  Object.keys(R).forEach(function(E) {
    C.forEach(function(F) {
      F = F + E.charAt(0).toUpperCase() + E.substring(1), R[F] = R[E];
    });
  });
  var z = /["'&<>]/;
  function W(E) {
    if (typeof E == "boolean" || typeof E == "number")
      return "" + E;
    E = "" + E;
    var F = z.exec(E);
    if (F) {
      var H = "", re, Te = 0;
      for (re = F.index; re < E.length; re++) {
        switch (E.charCodeAt(re)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        Te !== re && (H += E.substring(Te, re)), Te = re + 1, H += F;
      }
      E = Te !== re ? H + E.substring(Te, re) : H;
    }
    return E;
  }
  var Z = /([A-Z])/g, ee = /^ms-/, K = Array.isArray, le = h("<script>"), Y = h("<\/script>"), ae = h('<script src="'), B = h('<script type="module" src="'), X = h('" async=""><\/script>'), ce = /(<\/|<)(s)(cript)/gi;
  function ne(E, F, H, re) {
    return "" + F + (H === "s" ? "\\u0073" : "\\u0053") + re;
  }
  function Q(E, F, H, re, Te) {
    E = E === void 0 ? "" : E, F = F === void 0 ? le : h('<script nonce="' + W(F) + '">');
    var Se = [];
    if (H !== void 0 && Se.push(F, s(("" + H).replace(ce, ne)), Y), re !== void 0)
      for (H = 0; H < re.length; H++)
        Se.push(ae, s(W(re[H])), X);
    if (Te !== void 0)
      for (re = 0; re < Te.length; re++)
        Se.push(B, s(W(Te[re])), X);
    return { bootstrapChunks: Se, startInlineScript: F, placeholderPrefix: h(E + "P:"), segmentPrefix: h(E + "S:"), boundaryPrefix: E + "B:", idPrefix: E, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function V(E, F) {
    return { insertionMode: E, selectedValue: F };
  }
  function j(E) {
    return V(E === "http://www.w3.org/2000/svg" ? 2 : E === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function te(E, F, H) {
    switch (F) {
      case "select":
        return V(1, H.value != null ? H.value : H.defaultValue);
      case "svg":
        return V(2, null);
      case "math":
        return V(3, null);
      case "foreignObject":
        return V(1, null);
      case "table":
        return V(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return V(5, null);
      case "colgroup":
        return V(7, null);
      case "tr":
        return V(6, null);
    }
    return 4 <= E.insertionMode || E.insertionMode === 0 ? V(1, null) : E;
  }
  var U = h("<!-- -->");
  function ue(E, F, H, re) {
    return F === "" ? re : (re && E.push(U), E.push(s(W(F))), !0);
  }
  var ke = /* @__PURE__ */ new Map(), xe = h(' style="'), be = h(":"), Ae = h(";");
  function Ye(E, F, H) {
    if (typeof H != "object")
      throw Error(t(62));
    F = !0;
    for (var re in H)
      if (g.call(H, re)) {
        var Te = H[re];
        if (Te != null && typeof Te != "boolean" && Te !== "") {
          if (re.indexOf("--") === 0) {
            var Se = s(W(re));
            Te = s(W(("" + Te).trim()));
          } else {
            Se = re;
            var Fe = ke.get(Se);
            Fe !== void 0 || (Fe = h(W(Se.replace(Z, "-$1").toLowerCase().replace(ee, "-ms-"))), ke.set(Se, Fe)), Se = Fe, Te = typeof Te == "number" ? Te === 0 || g.call(R, re) ? s("" + Te) : s(Te + "px") : s(W(("" + Te).trim()));
          }
          F ? (F = !1, E.push(xe, Se, be, Te)) : E.push(Ae, Se, be, Te);
        }
      }
    F || E.push(Re);
  }
  var Pe = h(" "), ye = h('="'), Re = h('"'), fe = h('=""');
  function ze(E, F, H, re) {
    switch (H) {
      case "style":
        Ye(E, F, re);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < H.length) || H[0] !== "o" && H[0] !== "O" || H[1] !== "n" && H[1] !== "N") {
      if (F = v.hasOwnProperty(H) ? v[H] : null, F !== null) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!F.acceptsBooleans)
              return;
        }
        switch (H = s(F.attributeName), F.type) {
          case 3:
            re && E.push(Pe, H, fe);
            break;
          case 4:
            re === !0 ? E.push(Pe, H, fe) : re !== !1 && E.push(Pe, H, ye, s(W(re)), Re);
            break;
          case 5:
            isNaN(re) || E.push(Pe, H, ye, s(W(re)), Re);
            break;
          case 6:
            !isNaN(re) && 1 <= re && E.push(Pe, H, ye, s(W(re)), Re);
            break;
          default:
            F.sanitizeURL && (re = "" + re), E.push(Pe, H, ye, s(W(re)), Re);
        }
      } else if (A(H)) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (F = H.toLowerCase().slice(0, 5), F !== "data-" && F !== "aria-")
              return;
        }
        E.push(Pe, s(H), ye, s(W(re)), Re);
      }
    }
  }
  var Ne = h(">"), qe = h("/>");
  function He(E, F, H) {
    if (F != null) {
      if (H != null)
        throw Error(t(60));
      if (typeof F != "object" || !("__html" in F))
        throw Error(t(61));
      F = F.__html, F != null && E.push(s("" + F));
    }
  }
  function Be(E) {
    var F = "";
    return e.Children.forEach(E, function(H) {
      H != null && (F += H);
    }), F;
  }
  var Ze = h(' selected=""');
  function Ve(E, F, H, re) {
    E.push(De(H));
    var Te = H = null, Se;
    for (Se in F)
      if (g.call(F, Se)) {
        var Fe = F[Se];
        if (Fe != null)
          switch (Se) {
            case "children":
              H = Fe;
              break;
            case "dangerouslySetInnerHTML":
              Te = Fe;
              break;
            default:
              ze(E, re, Se, Fe);
          }
      }
    return E.push(Ne), He(E, Te, H), typeof H == "string" ? (E.push(s(W(H))), null) : H;
  }
  var je = h(`
`), Ue = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, we = /* @__PURE__ */ new Map();
  function De(E) {
    var F = we.get(E);
    if (F === void 0) {
      if (!Ue.test(E))
        throw Error(t(65, E));
      F = h("<" + E), we.set(E, F);
    }
    return F;
  }
  var rt = h("<!DOCTYPE html>");
  function ge(E, F, H, re, Te) {
    switch (F) {
      case "select":
        E.push(De("select"));
        var Se = null, Fe = null;
        for (bt in H)
          if (g.call(H, bt)) {
            var Ke = H[bt];
            if (Ke != null)
              switch (bt) {
                case "children":
                  Se = Ke;
                  break;
                case "dangerouslySetInnerHTML":
                  Fe = Ke;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  ze(E, re, bt, Ke);
              }
          }
        return E.push(Ne), He(E, Fe, Se), Se;
      case "option":
        Fe = Te.selectedValue, E.push(De("option"));
        var yt = Ke = null, wt = null, bt = null;
        for (Se in H)
          if (g.call(H, Se)) {
            var on = H[Se];
            if (on != null)
              switch (Se) {
                case "children":
                  Ke = on;
                  break;
                case "selected":
                  wt = on;
                  break;
                case "dangerouslySetInnerHTML":
                  bt = on;
                  break;
                case "value":
                  yt = on;
                default:
                  ze(E, re, Se, on);
              }
          }
        if (Fe != null)
          if (H = yt !== null ? "" + yt : Be(Ke), K(Fe)) {
            for (re = 0; re < Fe.length; re++)
              if ("" + Fe[re] === H) {
                E.push(Ze);
                break;
              }
          } else
            "" + Fe === H && E.push(Ze);
        else
          wt && E.push(Ze);
        return E.push(Ne), He(E, bt, Ke), Ke;
      case "textarea":
        E.push(De("textarea")), bt = Fe = Se = null;
        for (Ke in H)
          if (g.call(H, Ke) && (yt = H[Ke], yt != null))
            switch (Ke) {
              case "children":
                bt = yt;
                break;
              case "value":
                Se = yt;
                break;
              case "defaultValue":
                Fe = yt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                ze(E, re, Ke, yt);
            }
        if (Se === null && Fe !== null && (Se = Fe), E.push(Ne), bt != null) {
          if (Se != null)
            throw Error(t(92));
          if (K(bt) && 1 < bt.length)
            throw Error(t(93));
          Se = "" + bt;
        }
        return typeof Se == "string" && Se[0] === `
` && E.push(je), Se !== null && E.push(s(W("" + Se))), null;
      case "input":
        E.push(De("input")), yt = bt = Ke = Se = null;
        for (Fe in H)
          if (g.call(H, Fe) && (wt = H[Fe], wt != null))
            switch (Fe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                yt = wt;
                break;
              case "defaultValue":
                Ke = wt;
                break;
              case "checked":
                bt = wt;
                break;
              case "value":
                Se = wt;
                break;
              default:
                ze(E, re, Fe, wt);
            }
        return bt !== null ? ze(
          E,
          re,
          "checked",
          bt
        ) : yt !== null && ze(E, re, "checked", yt), Se !== null ? ze(E, re, "value", Se) : Ke !== null && ze(E, re, "value", Ke), E.push(qe), null;
      case "menuitem":
        E.push(De("menuitem"));
        for (var qn in H)
          if (g.call(H, qn) && (Se = H[qn], Se != null))
            switch (qn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                ze(E, re, qn, Se);
            }
        return E.push(Ne), null;
      case "title":
        E.push(De("title")), Se = null;
        for (on in H)
          if (g.call(H, on) && (Fe = H[on], Fe != null))
            switch (on) {
              case "children":
                Se = Fe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                ze(E, re, on, Fe);
            }
        return E.push(Ne), Se;
      case "listing":
      case "pre":
        E.push(De(F)), Fe = Se = null;
        for (yt in H)
          if (g.call(H, yt) && (Ke = H[yt], Ke != null))
            switch (yt) {
              case "children":
                Se = Ke;
                break;
              case "dangerouslySetInnerHTML":
                Fe = Ke;
                break;
              default:
                ze(E, re, yt, Ke);
            }
        if (E.push(Ne), Fe != null) {
          if (Se != null)
            throw Error(t(60));
          if (typeof Fe != "object" || !("__html" in Fe))
            throw Error(t(61));
          H = Fe.__html, H != null && (typeof H == "string" && 0 < H.length && H[0] === `
` ? E.push(je, s(H)) : E.push(s("" + H)));
        }
        return typeof Se == "string" && Se[0] === `
` && E.push(je), Se;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        E.push(De(F));
        for (var sr in H)
          if (g.call(H, sr) && (Se = H[sr], Se != null))
            switch (sr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, F));
              default:
                ze(E, re, sr, Se);
            }
        return E.push(qe), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Ve(E, H, F, re);
      case "html":
        return Te.insertionMode === 0 && E.push(rt), Ve(E, H, F, re);
      default:
        if (F.indexOf("-") === -1 && typeof H.is != "string")
          return Ve(E, H, F, re);
        E.push(De(F)), Fe = Se = null;
        for (wt in H)
          if (g.call(H, wt) && (Ke = H[wt], Ke != null))
            switch (wt) {
              case "children":
                Se = Ke;
                break;
              case "dangerouslySetInnerHTML":
                Fe = Ke;
                break;
              case "style":
                Ye(E, re, Ke);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                A(wt) && typeof Ke != "function" && typeof Ke != "symbol" && E.push(Pe, s(wt), ye, s(W(Ke)), Re);
            }
        return E.push(Ne), He(E, Fe, Se), Se;
    }
  }
  var ut = h("</"), at = h(">"), it = h('<template id="'), St = h('"></template>'), jt = h("<!--$-->"), Bt = h('<!--$?--><template id="'), Nt = h('"></template>'), sn = h("<!--$!-->"), gt = h("<!--/$-->"), Dt = h("<template"), _t = h('"'), un = h(' data-dgst="');
  h(' data-msg="'), h(' data-stck="');
  var En = h("></template>");
  function $t(E, F, H) {
    if (i(E, Bt), H === null)
      throw Error(t(395));
    return i(E, H), o(E, Nt);
  }
  var It = h('<div hidden id="'), fn = h('">'), tt = h("</div>"), st = h('<svg aria-hidden="true" style="display:none" id="'), Tn = h('">'), tn = h("</svg>"), cn = h('<math aria-hidden="true" style="display:none" id="'), pn = h('">'), ft = h("</math>"), Pt = h('<table hidden id="'), Ot = h('">'), hn = h("</table>"), Tt = h('<table hidden><tbody id="'), Ct = h('">'), nn = h("</tbody></table>"), Nn = h('<table hidden><tr id="'), At = h('">'), xt = h("</tr></table>"), Dn = h('<table hidden><colgroup id="'), Oe = h('">'), _e = h("</colgroup></table>");
  function Ee(E, F, H, re) {
    switch (H.insertionMode) {
      case 0:
      case 1:
        return i(E, It), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, fn);
      case 2:
        return i(E, st), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, Tn);
      case 3:
        return i(E, cn), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, pn);
      case 4:
        return i(E, Pt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, Ot);
      case 5:
        return i(E, Tt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, Ct);
      case 6:
        return i(E, Nn), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, At);
      case 7:
        return i(
          E,
          Dn
        ), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, Oe);
      default:
        throw Error(t(397));
    }
  }
  function ct(E, F) {
    switch (F.insertionMode) {
      case 0:
      case 1:
        return o(E, tt);
      case 2:
        return o(E, tn);
      case 3:
        return o(E, ft);
      case 4:
        return o(E, hn);
      case 5:
        return o(E, nn);
      case 6:
        return o(E, xt);
      case 7:
        return o(E, _e);
      default:
        throw Error(t(397));
    }
  }
  var qt = h('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Kt = h('$RS("'), Ft = h('","'), kt = h('")<\/script>'), ht = h('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Et = h('$RC("'), An = h('","'), Zt = h('")<\/script>'), kn = h('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Rt = h('$RX("'), dn = h('"'), Gt = h(")<\/script>"), rn = h(","), Wn = /[<\u2028\u2029]/g;
  function Ln(E) {
    return JSON.stringify(E).replace(Wn, function(F) {
      switch (F) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Cn = Object.assign, mn = Symbol.for("react.element"), _n = Symbol.for("react.portal"), On = Symbol.for("react.fragment"), Fn = Symbol.for("react.strict_mode"), Kn = Symbol.for("react.profiler"), an = Symbol.for("react.provider"), yn = Symbol.for("react.context"), ir = Symbol.for("react.forward_ref"), Zn = Symbol.for("react.suspense"), Qn = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), D = Symbol.for("react.scope"), G = Symbol.for("react.debug_trace_mode"), pe = Symbol.for("react.legacy_hidden"), O = Symbol.for("react.default_value"), I = Symbol.iterator;
  function J(E) {
    if (E == null)
      return null;
    if (typeof E == "function")
      return E.displayName || E.name || null;
    if (typeof E == "string")
      return E;
    switch (E) {
      case On:
        return "Fragment";
      case _n:
        return "Portal";
      case Kn:
        return "Profiler";
      case Fn:
        return "StrictMode";
      case Zn:
        return "Suspense";
      case Qn:
        return "SuspenseList";
    }
    if (typeof E == "object")
      switch (E.$$typeof) {
        case yn:
          return (E.displayName || "Context") + ".Consumer";
        case an:
          return (E._context.displayName || "Context") + ".Provider";
        case ir:
          var F = E.render;
          return E = E.displayName, E || (E = F.displayName || F.name || "", E = E !== "" ? "ForwardRef(" + E + ")" : "ForwardRef"), E;
        case b:
          return F = E.displayName || null, F !== null ? F : J(E.type) || "Memo";
        case _:
          F = E._payload, E = E._init;
          try {
            return J(E(F));
          } catch {
          }
      }
    return null;
  }
  var ve = {};
  function Ie(E, F) {
    if (E = E.contextTypes, !E)
      return ve;
    var H = {}, re;
    for (re in E)
      H[re] = F[re];
    return H;
  }
  var Xe = null;
  function lt(E, F) {
    if (E !== F) {
      E.context._currentValue = E.parentValue, E = E.parent;
      var H = F.parent;
      if (E === null) {
        if (H !== null)
          throw Error(t(401));
      } else {
        if (H === null)
          throw Error(t(401));
        lt(E, H);
      }
      F.context._currentValue = F.value;
    }
  }
  function Ut(E) {
    E.context._currentValue = E.parentValue, E = E.parent, E !== null && Ut(E);
  }
  function Ht(E) {
    var F = E.parent;
    F !== null && Ht(F), E.context._currentValue = E.value;
  }
  function Qt(E, F) {
    if (E.context._currentValue = E.parentValue, E = E.parent, E === null)
      throw Error(t(402));
    E.depth === F.depth ? lt(E, F) : Qt(E, F);
  }
  function Jt(E, F) {
    var H = F.parent;
    if (H === null)
      throw Error(t(402));
    E.depth === H.depth ? lt(E, H) : Jt(E, H), F.context._currentValue = F.value;
  }
  function en(E) {
    var F = Xe;
    F !== E && (F === null ? Ht(E) : E === null ? Ut(F) : F.depth === E.depth ? lt(F, E) : F.depth > E.depth ? Qt(F, E) : Jt(F, E), Xe = E);
  }
  var jn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(E, F) {
    E = E._reactInternals, E.queue !== null && E.queue.push(F);
  }, enqueueReplaceState: function(E, F) {
    E = E._reactInternals, E.replace = !0, E.queue = [F];
  }, enqueueForceUpdate: function() {
  } };
  function Jn(E, F, H, re) {
    var Te = E.state !== void 0 ? E.state : null;
    E.updater = jn, E.props = H, E.state = Te;
    var Se = { queue: [], replace: !1 };
    E._reactInternals = Se;
    var Fe = F.contextType;
    if (E.context = typeof Fe == "object" && Fe !== null ? Fe._currentValue : re, Fe = F.getDerivedStateFromProps, typeof Fe == "function" && (Fe = Fe(H, Te), Te = Fe == null ? Te : Cn({}, Te, Fe), E.state = Te), typeof F.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function"))
      if (F = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), F !== E.state && jn.enqueueReplaceState(E, E.state, null), Se.queue !== null && 0 < Se.queue.length)
        if (F = Se.queue, Fe = Se.replace, Se.queue = null, Se.replace = !1, Fe && F.length === 1)
          E.state = F[0];
        else {
          for (Se = Fe ? F[0] : E.state, Te = !0, Fe = Fe ? 1 : 0; Fe < F.length; Fe++) {
            var Ke = F[Fe];
            Ke = typeof Ke == "function" ? Ke.call(E, Se, H, re) : Ke, Ke != null && (Te ? (Te = !1, Se = Cn({}, Se, Ke)) : Cn(Se, Ke));
          }
          E.state = Se;
        }
      else
        Se.queue = null;
  }
  var er = { id: 1, overflow: "" };
  function Yn(E, F, H) {
    var re = E.id;
    E = E.overflow;
    var Te = 32 - Er(re) - 1;
    re &= ~(1 << Te), H += 1;
    var Se = 32 - Er(F) + Te;
    if (30 < Se) {
      var Fe = Te - Te % 5;
      return Se = (re & (1 << Fe) - 1).toString(32), re >>= Fe, Te -= Fe, { id: 1 << 32 - Er(F) + Te | H << Te | re, overflow: Se + E };
    }
    return { id: 1 << Se | H << Te | re, overflow: E };
  }
  var Er = Math.clz32 ? Math.clz32 : xn, xa = Math.log, Lt = Math.LN2;
  function xn(E) {
    return E >>>= 0, E === 0 ? 32 : 31 - (xa(E) / Lt | 0) | 0;
  }
  function ra(E, F) {
    return E === F && (E !== 0 || 1 / E === 1 / F) || E !== E && F !== F;
  }
  var Nr = typeof Object.is == "function" ? Object.is : ra, or = null, Dr = null, Wr = null, Vt = null, mr = !1, Gn = !1, _r = 0, kr = null, ba = 0;
  function wr() {
    if (or === null)
      throw Error(t(321));
    return or;
  }
  function lr() {
    if (0 < ba)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function qa() {
    return Vt === null ? Wr === null ? (mr = !1, Wr = Vt = lr()) : (mr = !0, Vt = Wr) : Vt.next === null ? (mr = !1, Vt = Vt.next = lr()) : (mr = !0, Vt = Vt.next), Vt;
  }
  function Za() {
    Dr = or = null, Gn = !1, Wr = null, ba = 0, Vt = kr = null;
  }
  function Yi(E, F) {
    return typeof F == "function" ? F(E) : F;
  }
  function Gi(E, F, H) {
    if (or = wr(), Vt = qa(), mr) {
      var re = Vt.queue;
      if (F = re.dispatch, kr !== null && (H = kr.get(re), H !== void 0)) {
        kr.delete(re), re = Vt.memoizedState;
        do
          re = E(re, H.action), H = H.next;
        while (H !== null);
        return Vt.memoizedState = re, [re, F];
      }
      return [Vt.memoizedState, F];
    }
    return E = E === Yi ? typeof F == "function" ? F() : F : H !== void 0 ? H(F) : F, Vt.memoizedState = E, E = Vt.queue = { last: null, dispatch: null }, E = E.dispatch = fl.bind(null, or, E), [Vt.memoizedState, E];
  }
  function Xi(E, F) {
    if (or = wr(), Vt = qa(), F = F === void 0 ? null : F, Vt !== null) {
      var H = Vt.memoizedState;
      if (H !== null && F !== null) {
        var re = H[1];
        e:
          if (re === null)
            re = !1;
          else {
            for (var Te = 0; Te < re.length && Te < F.length; Te++)
              if (!Nr(F[Te], re[Te])) {
                re = !1;
                break e;
              }
            re = !0;
          }
        if (re)
          return H[0];
      }
    }
    return E = E(), Vt.memoizedState = [E, F], E;
  }
  function fl(E, F, H) {
    if (25 <= ba)
      throw Error(t(301));
    if (E === or)
      if (Gn = !0, E = { action: H, next: null }, kr === null && (kr = /* @__PURE__ */ new Map()), H = kr.get(F), H === void 0)
        kr.set(F, E);
      else {
        for (F = H; F.next !== null; )
          F = F.next;
        F.next = E;
      }
  }
  function pl() {
    throw Error(t(394));
  }
  function Ea() {
  }
  var Sa = { readContext: function(E) {
    return E._currentValue;
  }, useContext: function(E) {
    return wr(), E._currentValue;
  }, useMemo: Xi, useReducer: Gi, useRef: function(E) {
    or = wr(), Vt = qa();
    var F = Vt.memoizedState;
    return F === null ? (E = { current: E }, Vt.memoizedState = E) : F;
  }, useState: function(E) {
    return Gi(Yi, E);
  }, useInsertionEffect: Ea, useLayoutEffect: function() {
  }, useCallback: function(E, F) {
    return Xi(function() {
      return E;
    }, F);
  }, useImperativeHandle: Ea, useEffect: Ea, useDebugValue: Ea, useDeferredValue: function(E) {
    return wr(), E;
  }, useTransition: function() {
    return wr(), [!1, pl];
  }, useId: function() {
    var E = Dr.treeContext, F = E.overflow;
    E = E.id, E = (E & ~(1 << 32 - Er(E) - 1)).toString(32) + F;
    var H = ka;
    if (H === null)
      throw Error(t(404));
    return F = _r++, E = ":" + H.idPrefix + "R" + E, 0 < F && (E += "H" + F.toString(32)), E + ":";
  }, useMutableSource: function(E, F) {
    return wr(), F(E._source);
  }, useSyncExternalStore: function(E, F, H) {
    if (H === void 0)
      throw Error(t(407));
    return H();
  } }, ka = null, aa = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function hl(E) {
    return console.error(E), null;
  }
  function ia() {
  }
  function Qa(E, F, H, re, Te, Se, Fe, Ke, yt) {
    var wt = [], bt = /* @__PURE__ */ new Set();
    return F = { destination: null, responseState: F, progressiveChunkSize: re === void 0 ? 12800 : re, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: bt, pingedTasks: wt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Te === void 0 ? hl : Te, onAllReady: Se === void 0 ? ia : Se, onShellReady: Fe === void 0 ? ia : Fe, onShellError: Ke === void 0 ? ia : Ke, onFatalError: yt === void 0 ? ia : yt }, H = jr(F, 0, null, H, !1, !1), H.parentFlushed = !0, E = Ja(F, E, null, H, bt, ve, null, er), wt.push(E), F;
  }
  function Ja(E, F, H, re, Te, Se, Fe, Ke) {
    E.allPendingTasks++, H === null ? E.pendingRootTasks++ : H.pendingTasks++;
    var yt = { node: F, ping: function() {
      var wt = E.pingedTasks;
      wt.push(yt), wt.length === 1 && to(E);
    }, blockedBoundary: H, blockedSegment: re, abortSet: Te, legacyContext: Se, context: Fe, treeContext: Ke };
    return Te.add(yt), yt;
  }
  function jr(E, F, H, re, Te, Se) {
    return { status: 0, id: -1, index: F, parentFlushed: !1, chunks: [], children: [], formatContext: re, boundary: H, lastPushedText: Te, textEmbedded: Se };
  }
  function Ur(E, F) {
    if (E = E.onError(F), E != null && typeof E != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof E + '" instead');
    return E;
  }
  function wa(E, F) {
    var H = E.onShellError;
    H(F), H = E.onFatalError, H(F), E.destination !== null ? (E.status = 2, y(E.destination, F)) : (E.status = 1, E.fatalError = F);
  }
  function qi(E, F, H, re, Te) {
    for (or = {}, Dr = F, _r = 0, E = H(re, Te); Gn; )
      Gn = !1, _r = 0, ba += 1, Vt = null, E = H(re, Te);
    return Za(), E;
  }
  function ei(E, F, H, re) {
    var Te = H.render(), Se = re.childContextTypes;
    if (Se != null) {
      var Fe = F.legacyContext;
      if (typeof H.getChildContext != "function")
        re = Fe;
      else {
        H = H.getChildContext();
        for (var Ke in H)
          if (!(Ke in Se))
            throw Error(t(108, J(re) || "Unknown", Ke));
        re = Cn({}, Fe, H);
      }
      F.legacyContext = re, Xn(E, F, Te), F.legacyContext = Fe;
    } else
      Xn(E, F, Te);
  }
  function Zi(E, F) {
    if (E && E.defaultProps) {
      F = Cn({}, F), E = E.defaultProps;
      for (var H in E)
        F[H] === void 0 && (F[H] = E[H]);
      return F;
    }
    return F;
  }
  function Ta(E, F, H, re, Te) {
    if (typeof H == "function")
      if (H.prototype && H.prototype.isReactComponent) {
        Te = Ie(H, F.legacyContext);
        var Se = H.contextType;
        Se = new H(re, typeof Se == "object" && Se !== null ? Se._currentValue : Te), Jn(Se, H, re, Te), ei(E, F, Se, H);
      } else {
        Se = Ie(H, F.legacyContext), Te = qi(E, F, H, re, Se);
        var Fe = _r !== 0;
        if (typeof Te == "object" && Te !== null && typeof Te.render == "function" && Te.$$typeof === void 0)
          Jn(Te, H, re, Se), ei(E, F, Te, H);
        else if (Fe) {
          re = F.treeContext, F.treeContext = Yn(re, 1, 0);
          try {
            Xn(E, F, Te);
          } finally {
            F.treeContext = re;
          }
        } else
          Xn(E, F, Te);
      }
    else if (typeof H == "string") {
      switch (Te = F.blockedSegment, Se = ge(Te.chunks, H, re, E.responseState, Te.formatContext), Te.lastPushedText = !1, Fe = Te.formatContext, Te.formatContext = te(Fe, H, re), Ca(E, F, Se), Te.formatContext = Fe, H) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Te.chunks.push(ut, s(H), at);
      }
      Te.lastPushedText = !1;
    } else {
      switch (H) {
        case pe:
        case G:
        case Fn:
        case Kn:
        case On:
          Xn(E, F, re.children);
          return;
        case Qn:
          Xn(E, F, re.children);
          return;
        case D:
          throw Error(t(343));
        case Zn:
          e: {
            H = F.blockedBoundary, Te = F.blockedSegment, Se = re.fallback, re = re.children, Fe = /* @__PURE__ */ new Set();
            var Ke = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Fe, errorDigest: null }, yt = jr(E, Te.chunks.length, Ke, Te.formatContext, !1, !1);
            Te.children.push(yt), Te.lastPushedText = !1;
            var wt = jr(E, 0, null, Te.formatContext, !1, !1);
            wt.parentFlushed = !0, F.blockedBoundary = Ke, F.blockedSegment = wt;
            try {
              if (Ca(
                E,
                F,
                re
              ), wt.lastPushedText && wt.textEmbedded && wt.chunks.push(U), wt.status = 1, Aa(Ke, wt), Ke.pendingTasks === 0)
                break e;
            } catch (bt) {
              wt.status = 4, Ke.forceClientRender = !0, Ke.errorDigest = Ur(E, bt);
            } finally {
              F.blockedBoundary = H, F.blockedSegment = Te;
            }
            F = Ja(E, Se, H, yt, Fe, F.legacyContext, F.context, F.treeContext), E.pingedTasks.push(F);
          }
          return;
      }
      if (typeof H == "object" && H !== null)
        switch (H.$$typeof) {
          case ir:
            if (re = qi(E, F, H.render, re, Te), _r !== 0) {
              H = F.treeContext, F.treeContext = Yn(H, 1, 0);
              try {
                Xn(E, F, re);
              } finally {
                F.treeContext = H;
              }
            } else
              Xn(E, F, re);
            return;
          case b:
            H = H.type, re = Zi(H, re), Ta(E, F, H, re, Te);
            return;
          case an:
            if (Te = re.children, H = H._context, re = re.value, Se = H._currentValue, H._currentValue = re, Fe = Xe, Xe = re = { parent: Fe, depth: Fe === null ? 0 : Fe.depth + 1, context: H, parentValue: Se, value: re }, F.context = re, Xn(E, F, Te), E = Xe, E === null)
              throw Error(t(403));
            re = E.parentValue, E.context._currentValue = re === O ? E.context._defaultValue : re, E = Xe = E.parent, F.context = E;
            return;
          case yn:
            re = re.children, re = re(H._currentValue), Xn(E, F, re);
            return;
          case _:
            Te = H._init, H = Te(H._payload), re = Zi(H, re), Ta(E, F, H, re, void 0);
            return;
        }
      throw Error(t(
        130,
        H == null ? H : typeof H,
        ""
      ));
    }
  }
  function Xn(E, F, H) {
    if (F.node = H, typeof H == "object" && H !== null) {
      switch (H.$$typeof) {
        case mn:
          Ta(E, F, H.type, H.props, H.ref);
          return;
        case _n:
          throw Error(t(257));
        case _:
          var re = H._init;
          H = re(H._payload), Xn(E, F, H);
          return;
      }
      if (K(H)) {
        Qi(E, F, H);
        return;
      }
      if (H === null || typeof H != "object" ? re = null : (re = I && H[I] || H["@@iterator"], re = typeof re == "function" ? re : null), re && (re = re.call(H))) {
        if (H = re.next(), !H.done) {
          var Te = [];
          do
            Te.push(H.value), H = re.next();
          while (!H.done);
          Qi(E, F, Te);
        }
        return;
      }
      throw E = Object.prototype.toString.call(H), Error(t(31, E === "[object Object]" ? "object with keys {" + Object.keys(H).join(", ") + "}" : E));
    }
    typeof H == "string" ? (re = F.blockedSegment, re.lastPushedText = ue(F.blockedSegment.chunks, H, E.responseState, re.lastPushedText)) : typeof H == "number" && (re = F.blockedSegment, re.lastPushedText = ue(F.blockedSegment.chunks, "" + H, E.responseState, re.lastPushedText));
  }
  function Qi(E, F, H) {
    for (var re = H.length, Te = 0; Te < re; Te++) {
      var Se = F.treeContext;
      F.treeContext = Yn(Se, re, Te);
      try {
        Ca(E, F, H[Te]);
      } finally {
        F.treeContext = Se;
      }
    }
  }
  function Ca(E, F, H) {
    var re = F.blockedSegment.formatContext, Te = F.legacyContext, Se = F.context;
    try {
      return Xn(E, F, H);
    } catch (yt) {
      if (Za(), typeof yt == "object" && yt !== null && typeof yt.then == "function") {
        H = yt;
        var Fe = F.blockedSegment, Ke = jr(E, Fe.chunks.length, null, Fe.formatContext, Fe.lastPushedText, !0);
        Fe.children.push(Ke), Fe.lastPushedText = !1, E = Ja(E, F.node, F.blockedBoundary, Ke, F.abortSet, F.legacyContext, F.context, F.treeContext).ping, H.then(E, E), F.blockedSegment.formatContext = re, F.legacyContext = Te, F.context = Se, en(Se);
      } else
        throw F.blockedSegment.formatContext = re, F.legacyContext = Te, F.context = Se, en(Se), yt;
    }
  }
  function ml(E) {
    var F = E.blockedBoundary;
    E = E.blockedSegment, E.status = 3, eo(this, F, E);
  }
  function Ji(E, F, H) {
    var re = E.blockedBoundary;
    E.blockedSegment.status = 3, re === null ? (F.allPendingTasks--, F.status !== 2 && (F.status = 2, F.destination !== null && F.destination.close())) : (re.pendingTasks--, re.forceClientRender || (re.forceClientRender = !0, E = H === void 0 ? Error(t(432)) : H, re.errorDigest = F.onError(E), re.parentFlushed && F.clientRenderedBoundaries.push(re)), re.fallbackAbortableTasks.forEach(function(Te) {
      return Ji(Te, F, H);
    }), re.fallbackAbortableTasks.clear(), F.allPendingTasks--, F.allPendingTasks === 0 && (re = F.onAllReady, re()));
  }
  function Aa(E, F) {
    if (F.chunks.length === 0 && F.children.length === 1 && F.children[0].boundary === null) {
      var H = F.children[0];
      H.id = F.id, H.parentFlushed = !0, H.status === 1 && Aa(E, H);
    } else
      E.completedSegments.push(F);
  }
  function eo(E, F, H) {
    if (F === null) {
      if (H.parentFlushed) {
        if (E.completedRootSegment !== null)
          throw Error(t(389));
        E.completedRootSegment = H;
      }
      E.pendingRootTasks--, E.pendingRootTasks === 0 && (E.onShellError = ia, F = E.onShellReady, F());
    } else
      F.pendingTasks--, F.forceClientRender || (F.pendingTasks === 0 ? (H.parentFlushed && H.status === 1 && Aa(F, H), F.parentFlushed && E.completedBoundaries.push(F), F.fallbackAbortableTasks.forEach(ml, E), F.fallbackAbortableTasks.clear()) : H.parentFlushed && H.status === 1 && (Aa(F, H), F.completedSegments.length === 1 && F.parentFlushed && E.partialBoundaries.push(F)));
    E.allPendingTasks--, E.allPendingTasks === 0 && (E = E.onAllReady, E());
  }
  function to(E) {
    if (E.status !== 2) {
      var F = Xe, H = aa.current;
      aa.current = Sa;
      var re = ka;
      ka = E.responseState;
      try {
        var Te = E.pingedTasks, Se;
        for (Se = 0; Se < Te.length; Se++) {
          var Fe = Te[Se], Ke = E, yt = Fe.blockedSegment;
          if (yt.status === 0) {
            en(Fe.context);
            try {
              Xn(Ke, Fe, Fe.node), yt.lastPushedText && yt.textEmbedded && yt.chunks.push(U), Fe.abortSet.delete(Fe), yt.status = 1, eo(Ke, Fe.blockedBoundary, yt);
            } catch (ur) {
              if (Za(), typeof ur == "object" && ur !== null && typeof ur.then == "function") {
                var wt = Fe.ping;
                ur.then(wt, wt);
              } else {
                Fe.abortSet.delete(Fe), yt.status = 4;
                var bt = Fe.blockedBoundary, on = ur, qn = Ur(Ke, on);
                if (bt === null ? wa(Ke, on) : (bt.pendingTasks--, bt.forceClientRender || (bt.forceClientRender = !0, bt.errorDigest = qn, bt.parentFlushed && Ke.clientRenderedBoundaries.push(bt))), Ke.allPendingTasks--, Ke.allPendingTasks === 0) {
                  var sr = Ke.onAllReady;
                  sr();
                }
              }
            } finally {
            }
          }
        }
        Te.splice(0, Se), E.destination !== null && ti(E, E.destination);
      } catch (ur) {
        Ur(E, ur), wa(E, ur);
      } finally {
        ka = re, aa.current = H, H === Sa && en(F);
      }
    }
  }
  function La(E, F, H) {
    switch (H.parentFlushed = !0, H.status) {
      case 0:
        var re = H.id = E.nextSegmentId++;
        return H.lastPushedText = !1, H.textEmbedded = !1, E = E.responseState, i(F, it), i(F, E.placeholderPrefix), E = s(re.toString(16)), i(F, E), o(F, St);
      case 1:
        H.status = 2;
        var Te = !0;
        re = H.chunks;
        var Se = 0;
        H = H.children;
        for (var Fe = 0; Fe < H.length; Fe++) {
          for (Te = H[Fe]; Se < Te.index; Se++)
            i(F, re[Se]);
          Te = Pa(E, F, Te);
        }
        for (; Se < re.length - 1; Se++)
          i(F, re[Se]);
        return Se < re.length && (Te = o(F, re[Se])), Te;
      default:
        throw Error(t(390));
    }
  }
  function Pa(E, F, H) {
    var re = H.boundary;
    if (re === null)
      return La(E, F, H);
    if (re.parentFlushed = !0, re.forceClientRender)
      re = re.errorDigest, o(F, sn), i(F, Dt), re && (i(F, un), i(F, s(W(re))), i(F, _t)), o(F, En), La(E, F, H);
    else if (0 < re.pendingTasks) {
      re.rootSegmentID = E.nextSegmentId++, 0 < re.completedSegments.length && E.partialBoundaries.push(re);
      var Te = E.responseState, Se = Te.nextSuspenseID++;
      Te = h(Te.boundaryPrefix + Se.toString(16)), re = re.id = Te, $t(F, E.responseState, re), La(E, F, H);
    } else if (re.byteSize > E.progressiveChunkSize)
      re.rootSegmentID = E.nextSegmentId++, E.completedBoundaries.push(re), $t(F, E.responseState, re.id), La(E, F, H);
    else {
      if (o(F, jt), H = re.completedSegments, H.length !== 1)
        throw Error(t(391));
      Pa(E, F, H[0]);
    }
    return o(F, gt);
  }
  function no(E, F, H) {
    return Ee(F, E.responseState, H.formatContext, H.id), Pa(E, F, H), ct(F, H.formatContext);
  }
  function ro(E, F, H) {
    for (var re = H.completedSegments, Te = 0; Te < re.length; Te++)
      ao(E, F, H, re[Te]);
    if (re.length = 0, E = E.responseState, re = H.id, H = H.rootSegmentID, i(F, E.startInlineScript), E.sentCompleteBoundaryFunction ? i(F, Et) : (E.sentCompleteBoundaryFunction = !0, i(F, ht)), re === null)
      throw Error(t(395));
    return H = s(H.toString(16)), i(F, re), i(F, An), i(F, E.segmentPrefix), i(F, H), o(F, Zt);
  }
  function ao(E, F, H, re) {
    if (re.status === 2)
      return !0;
    var Te = re.id;
    if (Te === -1) {
      if ((re.id = H.rootSegmentID) === -1)
        throw Error(t(392));
      return no(E, F, re);
    }
    return no(E, F, re), E = E.responseState, i(F, E.startInlineScript), E.sentCompleteSegmentFunction ? i(F, Kt) : (E.sentCompleteSegmentFunction = !0, i(F, qt)), i(F, E.segmentPrefix), Te = s(Te.toString(16)), i(F, Te), i(F, Ft), i(F, E.placeholderPrefix), i(F, Te), o(F, kt);
  }
  function ti(E, F) {
    r = new Uint8Array(512), a = 0;
    try {
      var H = E.completedRootSegment;
      if (H !== null && E.pendingRootTasks === 0) {
        Pa(E, F, H), E.completedRootSegment = null;
        var re = E.responseState.bootstrapChunks;
        for (H = 0; H < re.length - 1; H++)
          i(F, re[H]);
        H < re.length && o(F, re[H]);
      }
      var Te = E.clientRenderedBoundaries, Se;
      for (Se = 0; Se < Te.length; Se++) {
        var Fe = Te[Se];
        re = F;
        var Ke = E.responseState, yt = Fe.id, wt = Fe.errorDigest, bt = Fe.errorMessage, on = Fe.errorComponentStack;
        if (i(re, Ke.startInlineScript), Ke.sentClientRenderFunction ? i(re, Rt) : (Ke.sentClientRenderFunction = !0, i(
          re,
          kn
        )), yt === null)
          throw Error(t(395));
        i(re, yt), i(re, dn), (wt || bt || on) && (i(re, rn), i(re, s(Ln(wt || "")))), (bt || on) && (i(re, rn), i(re, s(Ln(bt || "")))), on && (i(re, rn), i(re, s(Ln(on)))), o(re, Gt);
      }
      Te.splice(0, Se);
      var qn = E.completedBoundaries;
      for (Se = 0; Se < qn.length; Se++)
        ro(E, F, qn[Se]);
      qn.splice(0, Se), d(F), r = new Uint8Array(512), a = 0;
      var sr = E.partialBoundaries;
      for (Se = 0; Se < sr.length; Se++) {
        var ur = sr[Se];
        e: {
          Te = E, Fe = F;
          var Ra = ur.completedSegments;
          for (Ke = 0; Ke < Ra.length; Ke++)
            if (!ao(
              Te,
              Fe,
              ur,
              Ra[Ke]
            )) {
              Ke++, Ra.splice(0, Ke);
              var oo = !1;
              break e;
            }
          Ra.splice(0, Ke), oo = !0;
        }
        if (!oo) {
          E.destination = null, Se++, sr.splice(0, Se);
          return;
        }
      }
      sr.splice(0, Se);
      var ni = E.completedBoundaries;
      for (Se = 0; Se < ni.length; Se++)
        ro(E, F, ni[Se]);
      ni.splice(0, Se);
    } finally {
      d(F), E.allPendingTasks === 0 && E.pingedTasks.length === 0 && E.clientRenderedBoundaries.length === 0 && E.completedBoundaries.length === 0 && F.close();
    }
  }
  function io(E, F) {
    try {
      var H = E.abortableTasks;
      H.forEach(function(re) {
        return Ji(re, E, F);
      }), H.clear(), E.destination !== null && ti(E, E.destination);
    } catch (re) {
      Ur(E, re), wa(E, re);
    }
  }
  return Fu.renderToReadableStream = function(E, F) {
    return new Promise(function(H, re) {
      var Te, Se, Fe = new Promise(function(bt, on) {
        Se = bt, Te = on;
      }), Ke = Qa(E, Q(F ? F.identifierPrefix : void 0, F ? F.nonce : void 0, F ? F.bootstrapScriptContent : void 0, F ? F.bootstrapScripts : void 0, F ? F.bootstrapModules : void 0), j(F ? F.namespaceURI : void 0), F ? F.progressiveChunkSize : void 0, F ? F.onError : void 0, Se, function() {
        var bt = new ReadableStream({ type: "bytes", pull: function(on) {
          if (Ke.status === 1)
            Ke.status = 2, y(on, Ke.fatalError);
          else if (Ke.status !== 2 && Ke.destination === null) {
            Ke.destination = on;
            try {
              ti(Ke, on);
            } catch (qn) {
              Ur(Ke, qn), wa(Ke, qn);
            }
          }
        }, cancel: function() {
          io(Ke);
        } }, { highWaterMark: 0 });
        bt.allReady = Fe, H(bt);
      }, function(bt) {
        Fe.catch(function() {
        }), re(bt);
      }, Te);
      if (F && F.signal) {
        var yt = F.signal, wt = function() {
          io(Ke, yt.reason), yt.removeEventListener("abort", wt);
        };
        yt.addEventListener("abort", wt);
      }
      to(Ke);
    });
  }, Fu.version = "18.2.0", Fu;
}
var Di = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jh;
function xS() {
  return Jh || (Jh = 1, process.env.NODE_ENV !== "production" && function() {
    var e = se, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), N = 1; N < f; N++)
          k[N - 1] = arguments[N];
        o("warn", l, k);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), N = 1; N < f; N++)
          k[N - 1] = arguments[N];
        o("error", l, k);
      }
    }
    function o(l, f, k) {
      {
        var N = r.ReactDebugCurrentFrame, $ = N.getStackAddendum();
        $ !== "" && (f += "%s", k = k.concat([$]));
        var oe = k.map(function(he) {
          return String(he);
        });
        oe.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, oe);
      }
    }
    function d(l) {
      l();
    }
    function c(l) {
    }
    function s(l, f) {
      h(l, f);
    }
    function h(l, f) {
      return l.push(f);
    }
    function y(l) {
    }
    function g(l) {
      l.push(null);
    }
    function x(l) {
      return l;
    }
    function w(l) {
      return l;
    }
    function S(l, f) {
      l.destroy(f);
    }
    function A(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, k = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return k;
      }
    }
    function p(l) {
      try {
        return v(l), !1;
      } catch {
        return !0;
      }
    }
    function v(l) {
      return "" + l;
    }
    function L(l, f) {
      if (p(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), v(l);
    }
    function P(l, f) {
      if (p(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), v(l);
    }
    function R(l) {
      if (p(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", A(l)), v(l);
    }
    var C = Object.prototype.hasOwnProperty, z = 0, W = 1, Z = 2, ee = 3, K = 4, le = 5, Y = 6, ae = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", B = ae + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", X = new RegExp("^[" + ae + "][" + B + "]*$"), ce = {}, ne = {};
    function Q(l) {
      return C.call(ne, l) ? !0 : C.call(ce, l) ? !1 : X.test(l) ? (ne[l] = !0, !0) : (ce[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function V(l, f, k, N) {
      if (k !== null && k.type === z)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (N)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var $ = l.toLowerCase().slice(0, 5);
          return $ !== "data-" && $ !== "aria-";
        }
        default:
          return !1;
      }
    }
    function j(l) {
      return U.hasOwnProperty(l) ? U[l] : null;
    }
    function te(l, f, k, N, $, oe, he) {
      this.acceptsBooleans = f === Z || f === ee || f === K, this.attributeName = N, this.attributeNamespace = $, this.mustUseProperty = k, this.propertyName = l, this.type = f, this.sanitizeURL = oe, this.removeEmptyString = he;
    }
    var U = {}, ue = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ue.forEach(function(l) {
      U[l] = new te(
        l,
        z,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], k = l[1];
      U[f] = new te(
        f,
        W,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      U[l] = new te(
        l,
        Z,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      U[l] = new te(
        l,
        Z,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      U[l] = new te(
        l,
        ee,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      U[l] = new te(
        l,
        ee,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      U[l] = new te(
        l,
        K,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      U[l] = new te(
        l,
        Y,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      U[l] = new te(
        l,
        le,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ke = /[\-\:]([a-z])/g, xe = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, xe);
      U[f] = new te(
        f,
        W,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, xe);
      U[f] = new te(
        f,
        W,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, xe);
      U[f] = new te(
        f,
        W,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      U[l] = new te(
        l,
        W,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var be = "xlinkHref";
    U[be] = new te(
      "xlinkHref",
      W,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      U[l] = new te(
        l,
        W,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ae = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ye(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Pe = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ae).forEach(function(l) {
      Pe.forEach(function(f) {
        Ae[Ye(f, l)] = Ae[l];
      });
    });
    var ye = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Re(l, f) {
      ye[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function fe(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ze = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ne = {}, qe = new RegExp("^(aria)-[" + B + "]*$"), He = new RegExp("^(aria)[A-Z][" + B + "]*$");
    function Be(l, f) {
      {
        if (C.call(Ne, f) && Ne[f])
          return !0;
        if (He.test(f)) {
          var k = "aria-" + f.slice(4).toLowerCase(), N = ze.hasOwnProperty(k) ? k : null;
          if (N == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), Ne[f] = !0, !0;
          if (f !== N)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, N), Ne[f] = !0, !0;
        }
        if (qe.test(f)) {
          var $ = f.toLowerCase(), oe = ze.hasOwnProperty($) ? $ : null;
          if (oe == null)
            return Ne[f] = !0, !1;
          if (f !== oe)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, oe), Ne[f] = !0, !0;
        }
      }
      return !0;
    }
    function Ze(l, f) {
      {
        var k = [];
        for (var N in f) {
          var $ = Be(l, N);
          $ || k.push(N);
        }
        var oe = k.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        k.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, l) : k.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, l);
      }
    }
    function Ve(l, f) {
      fe(l, f) || Ze(l, f);
    }
    var je = !1;
    function Ue(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !je && (je = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var we = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, De = function() {
    };
    {
      var rt = {}, ge = /^on./, ut = /^on[^A-Z]/, at = new RegExp("^(aria)-[" + B + "]*$"), it = new RegExp("^(aria)[A-Z][" + B + "]*$");
      De = function(l, f, k, N) {
        if (C.call(rt, f) && rt[f])
          return !0;
        var $ = f.toLowerCase();
        if ($ === "onfocusin" || $ === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), rt[f] = !0, !0;
        if (N != null) {
          var oe = N.registrationNameDependencies, he = N.possibleRegistrationNames;
          if (oe.hasOwnProperty(f))
            return !0;
          var Ce = he.hasOwnProperty($) ? he[$] : null;
          if (Ce != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Ce), rt[f] = !0, !0;
          if (ge.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), rt[f] = !0, !0;
        } else if (ge.test(f))
          return ut.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), rt[f] = !0, !0;
        if (at.test(f) || it.test(f))
          return !0;
        if ($ === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), rt[f] = !0, !0;
        if ($ === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), rt[f] = !0, !0;
        if ($ === "is" && k !== null && k !== void 0 && typeof k != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), rt[f] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), rt[f] = !0, !0;
        var $e = j(f), nt = $e !== null && $e.type === z;
        if (we.hasOwnProperty($)) {
          var ot = we[$];
          if (ot !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, ot), rt[f] = !0, !0;
        } else if (!nt && f !== $)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, $), rt[f] = !0, !0;
        return typeof k == "boolean" && V(f, k, $e, !1) ? (k ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, f, f, k, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, f, f, k, f, f, f), rt[f] = !0, !0) : nt ? !0 : V(f, k, $e, !1) ? (rt[f] = !0, !1) : ((k === "false" || k === "true") && $e !== null && $e.type === ee && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, f, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, k), rt[f] = !0), !0);
      };
    }
    var St = function(l, f, k) {
      {
        var N = [];
        for (var $ in f) {
          var oe = De(l, $, f[$], k);
          oe || N.push($);
        }
        var he = N.map(function(Ce) {
          return "`" + Ce + "`";
        }).join(", ");
        N.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l) : N.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l);
      }
    };
    function jt(l, f, k) {
      fe(l, f) || St(l, f, k);
    }
    var Bt = function() {
    };
    {
      var Nt = /^(?:webkit|moz|o)[A-Z]/, sn = /^-ms-/, gt = /-(.)/g, Dt = /;\s*$/, _t = {}, un = {}, En = !1, $t = !1, It = function(l) {
        return l.replace(gt, function(f, k) {
          return k.toUpperCase();
        });
      }, fn = function(l) {
        _t.hasOwnProperty(l) && _t[l] || (_t[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          It(l.replace(sn, "ms-"))
        ));
      }, tt = function(l) {
        _t.hasOwnProperty(l) && _t[l] || (_t[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, st = function(l, f) {
        un.hasOwnProperty(f) && un[f] || (un[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(Dt, "")));
      }, Tn = function(l, f) {
        En || (En = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, tn = function(l, f) {
        $t || ($t = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Bt = function(l, f) {
        l.indexOf("-") > -1 ? fn(l) : Nt.test(l) ? tt(l) : Dt.test(f) && st(l, f), typeof f == "number" && (isNaN(f) ? Tn(l, f) : isFinite(f) || tn(l, f));
      };
    }
    var cn = Bt, pn = /["'&<>]/;
    function ft(l) {
      R(l);
      var f = "" + l, k = pn.exec(f);
      if (!k)
        return f;
      var N, $ = "", oe, he = 0;
      for (oe = k.index; oe < f.length; oe++) {
        switch (f.charCodeAt(oe)) {
          case 34:
            N = "&quot;";
            break;
          case 38:
            N = "&amp;";
            break;
          case 39:
            N = "&#x27;";
            break;
          case 60:
            N = "&lt;";
            break;
          case 62:
            N = "&gt;";
            break;
          default:
            continue;
        }
        he !== oe && ($ += f.substring(he, oe)), he = oe + 1, $ += N;
      }
      return he !== oe ? $ + f.substring(he, oe) : $;
    }
    function Pt(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : ft(l);
    }
    var Ot = /([A-Z])/g, hn = /^ms-/;
    function Tt(l) {
      return l.replace(Ot, "-$1").toLowerCase().replace(hn, "-ms-");
    }
    var Ct = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, nn = !1;
    function Nn(l) {
      !nn && Ct.test(l) && (nn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var At = Array.isArray;
    function xt(l) {
      return At(l);
    }
    var Dn = "<script>", Oe = "<\/script>", _e = '<script src="', Ee = '<script type="module" src="', ct = '" async=""><\/script>';
    function qt(l) {
      return R(l), ("" + l).replace(Kt, Ft);
    }
    var Kt = /(<\/|<)(s)(cript)/gi, Ft = function(l, f, k, N) {
      return "" + f + (k === "s" ? "\\u0073" : "\\u0053") + N;
    };
    function kt(l, f, k, N, $) {
      var oe = l === void 0 ? "" : l, he = f === void 0 ? Dn : '<script nonce="' + Pt(f) + '">', Ce = [];
      if (k !== void 0 && Ce.push(he, qt(k), Oe), N !== void 0)
        for (var $e = 0; $e < N.length; $e++)
          Ce.push(_e, Pt(N[$e]), ct);
      if ($ !== void 0)
        for (var nt = 0; nt < $.length; nt++)
          Ce.push(Ee, Pt($[nt]), ct);
      return {
        bootstrapChunks: Ce,
        startInlineScript: he,
        placeholderPrefix: oe + "P:",
        segmentPrefix: oe + "S:",
        boundaryPrefix: oe + "B:",
        idPrefix: oe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var ht = 0, Et = 1, An = 2, Zt = 3, kn = 4, Rt = 5, dn = 6, Gt = 7;
    function rn(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Wn(l, f, k) {
      switch (f) {
        case "select":
          return rn(Et, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return rn(An, null);
        case "math":
          return rn(Zt, null);
        case "foreignObject":
          return rn(Et, null);
        case "table":
          return rn(kn, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return rn(Rt, null);
        case "colgroup":
          return rn(Gt, null);
        case "tr":
          return rn(dn, null);
      }
      return l.insertionMode >= kn || l.insertionMode === ht ? rn(Et, null) : l;
    }
    var Ln = null;
    function Cn(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function mn(l, f, k) {
      var N = l.idPrefix, $ = ":" + N + "R" + f;
      return k > 0 && ($ += "H" + k.toString(32)), $ + ":";
    }
    function _n(l) {
      return Pt(l);
    }
    var On = "<!-- -->";
    function Fn(l, f, k, N) {
      return f === "" ? N : (N && l.push(On), l.push(_n(f)), !0);
    }
    function Kn(l, f, k, N) {
      k && N && l.push(On);
    }
    var an = /* @__PURE__ */ new Map();
    function yn(l) {
      var f = an.get(l);
      if (f !== void 0)
        return f;
      var k = Pt(Tt(l));
      return an.set(l, k), k;
    }
    var ir = ' style="', Zn = ":", Qn = ";";
    function b(l, f, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var N = !0;
      for (var $ in k)
        if (C.call(k, $)) {
          var oe = k[$];
          if (!(oe == null || typeof oe == "boolean" || oe === "")) {
            var he = void 0, Ce = void 0, $e = $.indexOf("--") === 0;
            $e ? (he = Pt($), P(oe, $), Ce = Pt(("" + oe).trim())) : (cn($, oe), he = yn($), typeof oe == "number" ? oe !== 0 && !C.call(Ae, $) ? Ce = oe + "px" : Ce = "" + oe : (P(oe, $), Ce = Pt(("" + oe).trim()))), N ? (N = !1, l.push(ir, he, Zn, Ce)) : l.push(Qn, he, Zn, Ce);
          }
        }
      N || l.push(G);
    }
    var _ = " ", D = '="', G = '"', pe = '=""';
    function O(l, f, k, N) {
      switch (k) {
        case "style": {
          b(l, f, N);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var $ = j(k);
        if ($ !== null) {
          switch (typeof N) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!$.acceptsBooleans)
                return;
          }
          var oe = $.attributeName, he = oe;
          switch ($.type) {
            case ee:
              N && l.push(_, he, pe);
              return;
            case K:
              N === !0 ? l.push(_, he, pe) : N === !1 || l.push(_, he, D, Pt(N), G);
              return;
            case le:
              isNaN(N) || l.push(_, he, D, Pt(N), G);
              break;
            case Y:
              !isNaN(N) && N >= 1 && l.push(_, he, D, Pt(N), G);
              break;
            default:
              $.sanitizeURL && (L(N, oe), N = "" + N, Nn(N)), l.push(_, he, D, Pt(N), G);
          }
        } else if (Q(k)) {
          switch (typeof N) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ce = k.toLowerCase().slice(0, 5);
              if (Ce !== "data-" && Ce !== "aria-")
                return;
            }
          }
          l.push(_, k, D, Pt(N), G);
        }
      }
    }
    var I = ">", J = "/>";
    function ve(l, f, k) {
      if (f != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var N = f.__html;
        N != null && (R(N), l.push("" + N));
      }
    }
    var Ie = !1, Xe = !1, lt = !1, Ut = !1, Ht = !1, Qt = !1, Jt = !1;
    function en(l, f) {
      {
        var k = l[f];
        if (k != null) {
          var N = xt(k);
          l.multiple && !N ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && N && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function jn(l, f, k) {
      Re("select", f), en(f, "value"), en(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !lt && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), lt = !0), l.push(Gn("select"));
      var N = null, $ = null;
      for (var oe in f)
        if (C.call(f, oe)) {
          var he = f[oe];
          if (he == null)
            continue;
          switch (oe) {
            case "children":
              N = he;
              break;
            case "dangerouslySetInnerHTML":
              $ = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              O(l, k, oe, he);
              break;
          }
        }
      return l.push(I), ve(l, $, N), N;
    }
    function Jn(l) {
      var f = "";
      return e.Children.forEach(l, function(k) {
        k != null && (f += k, !Ht && typeof k != "string" && typeof k != "number" && (Ht = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var er = ' selected=""';
    function Yn(l, f, k, N) {
      var $ = N.selectedValue;
      l.push(Gn("option"));
      var oe = null, he = null, Ce = null, $e = null;
      for (var nt in f)
        if (C.call(f, nt)) {
          var ot = f[nt];
          if (ot == null)
            continue;
          switch (nt) {
            case "children":
              oe = ot;
              break;
            case "selected":
              Ce = ot, Jt || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Jt = !0);
              break;
            case "dangerouslySetInnerHTML":
              $e = ot;
              break;
            case "value":
              he = ot;
            default:
              O(l, k, nt, ot);
              break;
          }
        }
      if ($ != null) {
        var vt;
        if (he !== null ? (L(he, "value"), vt = "" + he) : ($e !== null && (Qt || (Qt = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), vt = Jn(oe)), xt($))
          for (var gn = 0; gn < $.length; gn++) {
            L($[gn], "value");
            var Hn = "" + $[gn];
            if (Hn === vt) {
              l.push(er);
              break;
            }
          }
        else
          L($, "select.value"), "" + $ === vt && l.push(er);
      } else
        Ce && l.push(er);
      return l.push(I), ve(l, $e, oe), oe;
    }
    function Er(l, f, k) {
      Re("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Xe && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Xe = !0), f.value !== void 0 && f.defaultValue !== void 0 && !Ie && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Ie = !0), l.push(Gn("input"));
      var N = null, $ = null, oe = null, he = null;
      for (var Ce in f)
        if (C.call(f, Ce)) {
          var $e = f[Ce];
          if ($e == null)
            continue;
          switch (Ce) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = $e;
              break;
            case "defaultValue":
              $ = $e;
              break;
            case "checked":
              oe = $e;
              break;
            case "value":
              N = $e;
              break;
            default:
              O(l, k, Ce, $e);
              break;
          }
        }
      return oe !== null ? O(l, k, "checked", oe) : he !== null && O(l, k, "checked", he), N !== null ? O(l, k, "value", N) : $ !== null && O(l, k, "value", $), l.push(J), null;
    }
    function xa(l, f, k) {
      Re("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Ut && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ut = !0), l.push(Gn("textarea"));
      var N = null, $ = null, oe = null;
      for (var he in f)
        if (C.call(f, he)) {
          var Ce = f[he];
          if (Ce == null)
            continue;
          switch (he) {
            case "children":
              oe = Ce;
              break;
            case "value":
              N = Ce;
              break;
            case "defaultValue":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              O(l, k, he, Ce);
              break;
          }
        }
      if (N === null && $ !== null && (N = $), l.push(I), oe != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), N != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (xt(oe)) {
          if (oe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          R(oe[0]), N = "" + oe[0];
        }
        R(oe), N = "" + oe;
      }
      return typeof N == "string" && N[0] === `
` && l.push(Dr), N !== null && (L(N, "value"), l.push(_n("" + N))), null;
    }
    function Lt(l, f, k, N) {
      l.push(Gn(k));
      for (var $ in f)
        if (C.call(f, $)) {
          var oe = f[$];
          if (oe == null)
            continue;
          switch ($) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              O(l, N, $, oe);
              break;
          }
        }
      return l.push(J), null;
    }
    function xn(l, f, k) {
      l.push(Gn("menuitem"));
      for (var N in f)
        if (C.call(f, N)) {
          var $ = f[N];
          if ($ == null)
            continue;
          switch (N) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              O(l, k, N, $);
              break;
          }
        }
      return l.push(I), null;
    }
    function ra(l, f, k) {
      l.push(Gn("title"));
      var N = null;
      for (var $ in f)
        if (C.call(f, $)) {
          var oe = f[$];
          if (oe == null)
            continue;
          switch ($) {
            case "children":
              N = oe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              O(l, k, $, oe);
              break;
          }
        }
      l.push(I);
      {
        var he = Array.isArray(N) && N.length < 2 ? N[0] || null : N;
        Array.isArray(N) && N.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return N;
    }
    function Nr(l, f, k, N) {
      l.push(Gn(k));
      var $ = null, oe = null;
      for (var he in f)
        if (C.call(f, he)) {
          var Ce = f[he];
          if (Ce == null)
            continue;
          switch (he) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ce;
              break;
            default:
              O(l, N, he, Ce);
              break;
          }
        }
      return l.push(I), ve(l, oe, $), typeof $ == "string" ? (l.push(_n($)), null) : $;
    }
    function or(l, f, k, N) {
      l.push(Gn(k));
      var $ = null, oe = null;
      for (var he in f)
        if (C.call(f, he)) {
          var Ce = f[he];
          if (Ce == null)
            continue;
          switch (he) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ce;
              break;
            case "style":
              b(l, N, Ce);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              Q(he) && typeof Ce != "function" && typeof Ce != "symbol" && l.push(_, he, D, Pt(Ce), G);
              break;
          }
        }
      return l.push(I), ve(l, oe, $), $;
    }
    var Dr = `
`;
    function Wr(l, f, k, N) {
      l.push(Gn(k));
      var $ = null, oe = null;
      for (var he in f)
        if (C.call(f, he)) {
          var Ce = f[he];
          if (Ce == null)
            continue;
          switch (he) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ce;
              break;
            default:
              O(l, N, he, Ce);
              break;
          }
        }
      if (l.push(I), oe != null) {
        if ($ != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof oe != "object" || !("__html" in oe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var $e = oe.__html;
        $e != null && (typeof $e == "string" && $e.length > 0 && $e[0] === `
` ? l.push(Dr, $e) : (R($e), l.push("" + $e)));
      }
      return typeof $ == "string" && $[0] === `
` && l.push(Dr), $;
    }
    var Vt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, mr = /* @__PURE__ */ new Map();
    function Gn(l) {
      var f = mr.get(l);
      if (f === void 0) {
        if (!Vt.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, mr.set(l, f);
      }
      return f;
    }
    var _r = "<!DOCTYPE html>";
    function kr(l, f, k, N, $) {
      switch (Ve(f, k), Ue(f, k), jt(f, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), $.insertionMode !== An && $.insertionMode !== Zt && f.indexOf("-") === -1 && typeof k.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return jn(l, k, N);
        case "option":
          return Yn(l, k, N, $);
        case "textarea":
          return xa(l, k, N);
        case "input":
          return Er(l, k, N);
        case "menuitem":
          return xn(l, k, N);
        case "title":
          return ra(l, k, N);
        case "listing":
        case "pre":
          return Wr(l, k, f, N);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Lt(l, k, f, N);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Nr(l, k, f, N);
        case "html":
          return $.insertionMode === ht && l.push(_r), Nr(l, k, f, N);
        default:
          return f.indexOf("-") === -1 && typeof k.is != "string" ? Nr(l, k, f, N) : or(l, k, f, N);
      }
    }
    var ba = "</", wr = ">";
    function lr(l, f, k) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ba, f, wr);
      }
    }
    function qa(l, f) {
      for (var k = f.bootstrapChunks, N = 0; N < k.length - 1; N++)
        s(l, k[N]);
      return N < k.length ? h(l, k[N]) : !0;
    }
    var Za = '<template id="', Yi = '"></template>';
    function Gi(l, f, k) {
      s(l, Za), s(l, f.placeholderPrefix);
      var N = k.toString(16);
      return s(l, N), h(l, Yi);
    }
    var Xi = "<!--$-->", fl = '<!--$?--><template id="', pl = '"></template>', Ea = "<!--$!-->", Sa = "<!--/$-->", ka = "<template", aa = '"', hl = ' data-dgst="', ia = ' data-msg="', Qa = ' data-stck="', Ja = "></template>";
    function jr(l, f) {
      return h(l, Xi);
    }
    function Ur(l, f, k) {
      if (s(l, fl), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), h(l, pl);
    }
    function wa(l, f, k, N, $) {
      var oe;
      return oe = h(l, Ea), s(l, ka), k && (s(l, hl), s(l, Pt(k)), s(l, aa)), N && (s(l, ia), s(l, Pt(N)), s(l, aa)), $ && (s(l, Qa), s(l, Pt($)), s(l, aa)), oe = h(l, Ja), oe;
    }
    function qi(l, f) {
      return h(l, Sa);
    }
    function ei(l, f) {
      return h(l, Sa);
    }
    function Zi(l, f) {
      return h(l, Sa);
    }
    var Ta = '<div hidden id="', Xn = '">', Qi = "</div>", Ca = '<svg aria-hidden="true" style="display:none" id="', ml = '">', Ji = "</svg>", Aa = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", La = '<table hidden id="', Pa = '">', no = "</table>", ro = '<table hidden><tbody id="', ao = '">', ti = "</tbody></table>", io = '<table hidden><tr id="', E = '">', F = "</tr></table>", H = '<table hidden><colgroup id="', re = '">', Te = "</colgroup></table>";
    function Se(l, f, k, N) {
      switch (k.insertionMode) {
        case ht:
        case Et:
          return s(l, Ta), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, Xn);
        case An:
          return s(l, Ca), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, ml);
        case Zt:
          return s(l, Aa), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, eo);
        case kn:
          return s(l, La), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, Pa);
        case Rt:
          return s(l, ro), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, ao);
        case dn:
          return s(l, io), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, E);
        case Gt:
          return s(l, H), s(l, f.segmentPrefix), s(l, N.toString(16)), h(l, re);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Fe(l, f) {
      switch (f.insertionMode) {
        case ht:
        case Et:
          return h(l, Qi);
        case An:
          return h(l, Ji);
        case Zt:
          return h(l, to);
        case kn:
          return h(l, no);
        case Rt:
          return h(l, ti);
        case dn:
          return h(l, F);
        case Gt:
          return h(l, Te);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ke = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", yt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', wt = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', bt = Ke + ';$RS("', on = '$RS("', qn = '","', sr = '")<\/script>';
    function ur(l, f, k) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, on) : (f.sentCompleteSegmentFunction = !0, s(l, bt)), s(l, f.segmentPrefix);
      var N = k.toString(16);
      return s(l, N), s(l, qn), s(l, f.placeholderPrefix), s(l, N), h(l, sr);
    }
    var Ra = yt + ';$RC("', oo = '$RC("', ni = '","', Vc = '")<\/script>';
    function Wc(l, f, k, N) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, oo) : (f.sentCompleteBoundaryFunction = !0, s(l, Ra)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var $ = N.toString(16);
      return s(l, k), s(l, ni), s(l, f.segmentPrefix), s(l, $), h(l, Vc);
    }
    var jc = wt + ';$RX("', Uc = '$RX("', Kc = '"', Yc = ")<\/script>", yl = ",";
    function Gc(l, f, k, N, $, oe) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Uc) : (f.sentClientRenderFunction = !0, s(l, jc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), s(l, Kc), (N || $ || oe) && (s(l, yl), s(l, gl(N || ""))), ($ || oe) && (s(l, yl), s(l, gl($ || ""))), oe && (s(l, yl), s(l, gl(oe))), h(l, Yc);
    }
    var Xc = /[<\u2028\u2029]/g;
    function gl(l) {
      var f = JSON.stringify(l);
      return f.replace(Xc, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function qc(l, f) {
      var k = kt(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: k.bootstrapChunks,
        startInlineScript: k.startInlineScript,
        placeholderPrefix: k.placeholderPrefix,
        segmentPrefix: k.segmentPrefix,
        boundaryPrefix: k.boundaryPrefix,
        idPrefix: k.idPrefix,
        nextSuspenseID: k.nextSuspenseID,
        sentCompleteSegmentFunction: k.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: k.sentCompleteBoundaryFunction,
        sentClientRenderFunction: k.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function vl() {
      return {
        insertionMode: Et,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Os(l, f, k, N) {
      return k.generateStaticMarkup ? (l.push(Pt(f)), !1) : Fn(l, f, k, N);
    }
    function Fs(l, f, k, N) {
      if (!f.generateStaticMarkup)
        return Kn(l, f, k, N);
    }
    function xl(l, f) {
      return f.generateStaticMarkup ? !0 : jr(l);
    }
    function yr(l, f, k, N, $) {
      return f.generateStaticMarkup ? !0 : wa(l, f, k, N, $);
    }
    function Zc(l, f) {
      return f.generateStaticMarkup ? !0 : qi(l);
    }
    function Ms(l, f) {
      return f.generateStaticMarkup ? !0 : Zi(l);
    }
    var cr = Object.assign, zs = Symbol.for("react.element"), bl = Symbol.for("react.portal"), lo = Symbol.for("react.fragment"), so = Symbol.for("react.strict_mode"), uo = Symbol.for("react.profiler"), ri = Symbol.for("react.provider"), ai = Symbol.for("react.context"), ii = Symbol.for("react.forward_ref"), Na = Symbol.for("react.suspense"), El = Symbol.for("react.suspense_list"), Sl = Symbol.for("react.memo"), co = Symbol.for("react.lazy"), Qc = Symbol.for("react.scope"), Bs = Symbol.for("react.debug_trace_mode"), Jc = Symbol.for("react.legacy_hidden"), ed = Symbol.for("react.default_value"), Is = Symbol.iterator, $s = "@@iterator";
    function Sn(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Is && l[Is] || l[$s];
      return typeof f == "function" ? f : null;
    }
    function oi(l, f, k) {
      var N = l.displayName;
      if (N)
        return N;
      var $ = f.displayName || f.name || "";
      return $ !== "" ? k + "(" + $ + ")" : k;
    }
    function kl(l) {
      return l.displayName || "Context";
    }
    function bn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case lo:
          return "Fragment";
        case bl:
          return "Portal";
        case uo:
          return "Profiler";
        case so:
          return "StrictMode";
        case Na:
          return "Suspense";
        case El:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ai:
            var f = l;
            return kl(f) + ".Consumer";
          case ri:
            var k = l;
            return kl(k._context) + ".Provider";
          case ii:
            return oi(l, l.render, "ForwardRef");
          case Sl:
            var N = l.displayName || null;
            return N !== null ? N : bn(l.type) || "Memo";
          case co: {
            var $ = l, oe = $._payload, he = $._init;
            try {
              return bn(he(oe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Da = 0, wl, Tl, Cl, Al, Ll, Hs, Vs;
    function fo() {
    }
    fo.__reactDisabledLog = !0;
    function Pl() {
      {
        if (Da === 0) {
          wl = console.log, Tl = console.info, Cl = console.warn, Al = console.error, Ll = console.group, Hs = console.groupCollapsed, Vs = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: fo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Da++;
      }
    }
    function li() {
      {
        if (Da--, Da === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, l, {
              value: wl
            }),
            info: cr({}, l, {
              value: Tl
            }),
            warn: cr({}, l, {
              value: Cl
            }),
            error: cr({}, l, {
              value: Al
            }),
            group: cr({}, l, {
              value: Ll
            }),
            groupCollapsed: cr({}, l, {
              value: Hs
            }),
            groupEnd: cr({}, l, {
              value: Vs
            })
          });
        }
        Da < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var si = r.ReactCurrentDispatcher, _a;
    function ui(l, f, k) {
      {
        if (_a === void 0)
          try {
            throw Error();
          } catch ($) {
            var N = $.stack.trim().match(/\n( *(at )?)/);
            _a = N && N[1] || "";
          }
        return `
` + _a + l;
      }
    }
    var ci = !1, po;
    {
      var Ws = typeof WeakMap == "function" ? WeakMap : Map;
      po = new Ws();
    }
    function Rl(l, f) {
      if (!l || ci)
        return "";
      {
        var k = po.get(l);
        if (k !== void 0)
          return k;
      }
      var N;
      ci = !0;
      var $ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var oe;
      oe = si.current, si.current = null, Pl();
      try {
        if (f) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (br) {
              N = br;
            }
            Reflect.construct(l, [], he);
          } else {
            try {
              he.call();
            } catch (br) {
              N = br;
            }
            l.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (br) {
            N = br;
          }
          l();
        }
      } catch (br) {
        if (br && N && typeof br.stack == "string") {
          for (var Ce = br.stack.split(`
`), $e = N.stack.split(`
`), nt = Ce.length - 1, ot = $e.length - 1; nt >= 1 && ot >= 0 && Ce[nt] !== $e[ot]; )
            ot--;
          for (; nt >= 1 && ot >= 0; nt--, ot--)
            if (Ce[nt] !== $e[ot]) {
              if (nt !== 1 || ot !== 1)
                do
                  if (nt--, ot--, ot < 0 || Ce[nt] !== $e[ot]) {
                    var vt = `
` + Ce[nt].replace(" at new ", " at ");
                    return l.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", l.displayName)), typeof l == "function" && po.set(l, vt), vt;
                  }
                while (nt >= 1 && ot >= 0);
              break;
            }
        }
      } finally {
        ci = !1, si.current = oe, li(), Error.prepareStackTrace = $;
      }
      var gn = l ? l.displayName || l.name : "", Hn = gn ? ui(gn) : "";
      return typeof l == "function" && po.set(l, Hn), Hn;
    }
    function Nl(l, f, k) {
      return Rl(l, !0);
    }
    function Dl(l, f, k) {
      return Rl(l, !1);
    }
    function js(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function Oa(l, f, k) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Rl(l, js(l));
      if (typeof l == "string")
        return ui(l);
      switch (l) {
        case Na:
          return ui("Suspense");
        case El:
          return ui("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ii:
            return Dl(l.render);
          case Sl:
            return Oa(l.type, f, k);
          case co: {
            var N = l, $ = N._payload, oe = N._init;
            try {
              return Oa(oe($), f, k);
            } catch {
            }
          }
        }
      return "";
    }
    var _l = {}, ho = r.ReactDebugCurrentFrame;
    function oa(l) {
      if (l) {
        var f = l._owner, k = Oa(l.type, l._source, f ? f.type : null);
        ho.setExtraStackFrame(k);
      } else
        ho.setExtraStackFrame(null);
    }
    function Ol(l, f, k, N, $) {
      {
        var oe = Function.call.bind(C);
        for (var he in l)
          if (oe(l, he)) {
            var Ce = void 0;
            try {
              if (typeof l[he] != "function") {
                var $e = Error((N || "React class") + ": " + k + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $e.name = "Invariant Violation", $e;
              }
              Ce = l[he](f, he, N, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (nt) {
              Ce = nt;
            }
            Ce && !(Ce instanceof Error) && (oa($), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", N || "React class", k, he, typeof Ce), oa(null)), Ce instanceof Error && !(Ce.message in _l) && (_l[Ce.message] = !0, oa($), i("Failed %s type: %s", k, Ce.message), oa(null));
          }
      }
    }
    var Fl;
    Fl = {};
    var Kr = {};
    Object.freeze(Kr);
    function Us(l, f) {
      {
        var k = l.contextTypes;
        if (!k)
          return Kr;
        var N = {};
        for (var $ in k)
          N[$] = f[$];
        {
          var oe = bn(l) || "Unknown";
          Ol(k, N, "context", oe);
        }
        return N;
      }
    }
    function la(l, f, k, N) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var $ = bn(f) || "Unknown";
            Fl[$] || (Fl[$] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", $, $));
          }
          return k;
        }
        var oe = l.getChildContext();
        for (var he in oe)
          if (!(he in N))
            throw new Error((bn(f) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Ce = bn(f) || "Unknown";
          Ol(N, oe, "child context", Ce);
        }
        return cr({}, k, oe);
      }
    }
    var sa;
    sa = {};
    var Ml = null, Tr = null;
    function mo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function yo(l) {
      l.context._currentValue2 = l.value;
    }
    function di(l, f) {
      if (l !== f) {
        mo(l);
        var k = l.parent, N = f.parent;
        if (k === null) {
          if (N !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (N === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          di(k, N);
        }
        yo(f);
      }
    }
    function zl(l) {
      mo(l);
      var f = l.parent;
      f !== null && zl(f);
    }
    function fi(l) {
      var f = l.parent;
      f !== null && fi(f), yo(l);
    }
    function Ks(l, f) {
      mo(l);
      var k = l.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === f.depth ? di(k, f) : Ks(k, f);
    }
    function Ys(l, f) {
      var k = f.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === k.depth ? di(l, k) : Ys(l, k), yo(f);
    }
    function go(l) {
      var f = Tr, k = l;
      f !== k && (f === null ? fi(k) : k === null ? zl(f) : f.depth === k.depth ? di(f, k) : f.depth > k.depth ? Ks(f, k) : Ys(f, k), Tr = k);
    }
    function pi(l, f) {
      var k;
      k = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== sa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = sa;
      var N = Tr, $ = {
        parent: N,
        depth: N === null ? 0 : N.depth + 1,
        context: l,
        parentValue: k,
        value: f
      };
      return Tr = $, $;
    }
    function Bl(l) {
      var f = Tr;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = f.parentValue;
        k === ed ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = k, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== sa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = sa;
      }
      return Tr = f.parent;
    }
    function td() {
      return Tr;
    }
    function Fa(l) {
      var f = l._currentValue2;
      return f;
    }
    function vo(l) {
      return l._reactInternals;
    }
    function Il(l, f) {
      l._reactInternals = f;
    }
    var xo = {}, bo = {}, hi, Eo, Ma, mi, So, za, ko, wo, To;
    {
      hi = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set(), Ma = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set();
      var Gs = /* @__PURE__ */ new Set();
      za = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var k = f + "_" + l;
          Gs.has(k) || (Gs.add(k), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, So = function(l, f) {
        if (f === void 0) {
          var k = bn(l) || "Component";
          mi.has(k) || (mi.add(k), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function Xs(l, f) {
      {
        var k = l.constructor, N = k && bn(k) || "ReactClass", $ = N + "." + f;
        if (xo[$])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, N), xo[$] = !0;
      }
    }
    var qs = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, k) {
        var N = vo(l);
        N.queue === null ? Xs(l, "setState") : (N.queue.push(f), k != null && za(k, "setState"));
      },
      enqueueReplaceState: function(l, f, k) {
        var N = vo(l);
        N.replace = !0, N.queue = [f], k != null && za(k, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var k = vo(l);
        k.queue === null ? Xs(l, "forceUpdate") : f != null && za(f, "setState");
      }
    };
    function nd(l, f, k, N, $) {
      var oe = k($, N);
      So(f, oe);
      var he = oe == null ? N : cr({}, N, oe);
      return he;
    }
    function rd(l, f, k) {
      var N = Kr, $ = l.contextType;
      if ("contextType" in l) {
        var oe = (
          // Allow null for conditional declaration
          $ === null || $ !== void 0 && $.$$typeof === ai && $._context === void 0
        );
        if (!oe && !To.has(l)) {
          To.add(l);
          var he = "";
          $ === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof $ != "object" ? he = " However, it is set to a " + typeof $ + "." : $.$$typeof === ri ? he = " Did you accidentally pass the Context.Provider instead?" : $._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys($).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", bn(l) || "Component", he);
        }
      }
      typeof $ == "object" && $ !== null ? N = Fa($) : N = k;
      var Ce = new l(f, N);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Ce.state === null || Ce.state === void 0)) {
          var $e = bn(l) || "Component";
          hi.has($e) || (hi.add($e), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $e, Ce.state === null ? "null" : "undefined", $e));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Ce.getSnapshotBeforeUpdate == "function") {
          var nt = null, ot = null, vt = null;
          if (typeof Ce.componentWillMount == "function" && Ce.componentWillMount.__suppressDeprecationWarning !== !0 ? nt = "componentWillMount" : typeof Ce.UNSAFE_componentWillMount == "function" && (nt = "UNSAFE_componentWillMount"), typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ot = "componentWillReceiveProps" : typeof Ce.UNSAFE_componentWillReceiveProps == "function" && (ot = "UNSAFE_componentWillReceiveProps"), typeof Ce.componentWillUpdate == "function" && Ce.componentWillUpdate.__suppressDeprecationWarning !== !0 ? vt = "componentWillUpdate" : typeof Ce.UNSAFE_componentWillUpdate == "function" && (vt = "UNSAFE_componentWillUpdate"), nt !== null || ot !== null || vt !== null) {
            var gn = bn(l) || "Component", Hn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Ma.has(gn) || (Ma.add(gn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, gn, Hn, nt !== null ? `
  ` + nt : "", ot !== null ? `
  ` + ot : "", vt !== null ? `
  ` + vt : ""));
          }
        }
      }
      return Ce;
    }
    function Zs(l, f, k) {
      {
        var N = bn(f) || "Component", $ = l.render;
        $ || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", N) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", N)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", N), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", N), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", N), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", N), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", N), f.contextType && f.contextTypes && !wo.has(f) && (wo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", N)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", N), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", bn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", N), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", N), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", N), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", N);
        var oe = l.props !== k;
        l.props !== void 0 && oe && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", N, N), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", N, N), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !Eo.has(f) && (Eo.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", bn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", N), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", N), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", N);
        var he = l.state;
        he && (typeof he != "object" || xt(he)) && i("%s.state: must be set to an object or null", N), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", N);
      }
    }
    function ad(l, f) {
      var k = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var N = bn(l) || "Unknown";
          bo[N] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            N
          ), bo[N] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), k !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", bn(l) || "Component"), qs.enqueueReplaceState(f, f.state, null));
    }
    function id(l, f, k, N) {
      if (l.queue !== null && l.queue.length > 0) {
        var $ = l.queue, oe = l.replace;
        if (l.queue = null, l.replace = !1, oe && $.length === 1)
          f.state = $[0];
        else {
          for (var he = oe ? $[0] : f.state, Ce = !0, $e = oe ? 1 : 0; $e < $.length; $e++) {
            var nt = $[$e], ot = typeof nt == "function" ? nt.call(f, he, k, N) : nt;
            ot != null && (Ce ? (Ce = !1, he = cr({}, he, ot)) : cr(he, ot));
          }
          f.state = he;
        }
      } else
        l.queue = null;
    }
    function Co(l, f, k, N) {
      Zs(l, f, k);
      var $ = l.state !== void 0 ? l.state : null;
      l.updater = qs, l.props = k, l.state = $;
      var oe = {
        queue: [],
        replace: !1
      };
      Il(l, oe);
      var he = f.contextType;
      if (typeof he == "object" && he !== null ? l.context = Fa(he) : l.context = N, l.state === k) {
        var Ce = bn(f) || "Component";
        ko.has(Ce) || (ko.add(Ce), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ce));
      }
      var $e = f.getDerivedStateFromProps;
      typeof $e == "function" && (l.state = nd(l, f, $e, $, k)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (ad(f, l), id(oe, l, k, N));
    }
    var Ao = {
      id: 1,
      overflow: ""
    };
    function od(l) {
      var f = l.overflow, k = l.id, N = k & ~ld(k);
      return N.toString(32) + f;
    }
    function $l(l, f, k) {
      var N = l.id, $ = l.overflow, oe = Lo(N) - 1, he = N & ~(1 << oe), Ce = k + 1, $e = Lo(f) + oe;
      if ($e > 30) {
        var nt = oe - oe % 5, ot = (1 << nt) - 1, vt = (he & ot).toString(32), gn = he >> nt, Hn = oe - nt, br = Lo(f) + Hn, xu = Ce << Hn, bu = xu | gn, Eu = vt + $;
        return {
          id: 1 << br | bu,
          overflow: Eu
        };
      } else {
        var jo = Ce << oe, xg = jo | he, bg = $;
        return {
          id: 1 << $e | xg,
          overflow: bg
        };
      }
    }
    function Lo(l) {
      return 32 - sd(l);
    }
    function ld(l) {
      return 1 << Lo(l) - 1;
    }
    var sd = Math.clz32 ? Math.clz32 : Or, ud = Math.log, cd = Math.LN2;
    function Or(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (ud(f) / cd | 0) | 0;
    }
    function Hl(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Po = typeof Object.is == "function" ? Object.is : Hl, Mt = null, ua = null, ca = null, Xt = null, gr = !1, da = !1, Ro = 0, $n = null, Fr = 0, fa = 25, Cr = !1, pa;
    function Mr() {
      if (Mt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Cr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Mt;
    }
    function dd(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pa), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pa, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var k = 0; k < f.length && k < l.length; k++)
        if (!Po(l[k], f[k]))
          return !1;
      return !0;
    }
    function Qs() {
      if (Fr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function No() {
      return Xt === null ? ca === null ? (gr = !1, ca = Xt = Qs()) : (gr = !0, Xt = ca) : Xt.next === null ? (gr = !1, Xt = Xt.next = Qs()) : (gr = !0, Xt = Xt.next), Xt;
    }
    function Vl(l, f) {
      Mt = f, ua = l, Cr = !1, Ro = 0;
    }
    function fd(l, f, k, N) {
      for (; da; )
        da = !1, Ro = 0, Fr += 1, Xt = null, k = l(f, N);
      return yi(), k;
    }
    function Js() {
      var l = Ro !== 0;
      return l;
    }
    function yi() {
      Cr = !1, Mt = null, ua = null, da = !1, ca = null, Fr = 0, $n = null, Xt = null;
    }
    function pd(l) {
      return Cr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Fa(l);
    }
    function eu(l) {
      return pa = "useContext", Mr(), Fa(l);
    }
    function Do(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function hd(l) {
      return pa = "useState", tu(
        Do,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function tu(l, f, k) {
      if (l !== Do && (pa = "useReducer"), Mt = Mr(), Xt = No(), gr) {
        var N = Xt.queue, $ = N.dispatch;
        if ($n !== null) {
          var oe = $n.get(N);
          if (oe !== void 0) {
            $n.delete(N);
            var he = Xt.memoizedState, Ce = oe;
            do {
              var $e = Ce.action;
              Cr = !0, he = l(he, $e), Cr = !1, Ce = Ce.next;
            } while (Ce !== null);
            return Xt.memoizedState = he, [he, $];
          }
        }
        return [Xt.memoizedState, $];
      } else {
        Cr = !0;
        var nt;
        l === Do ? nt = typeof f == "function" ? f() : f : nt = k !== void 0 ? k(f) : f, Cr = !1, Xt.memoizedState = nt;
        var ot = Xt.queue = {
          last: null,
          dispatch: null
        }, vt = ot.dispatch = gd.bind(null, Mt, ot);
        return [Xt.memoizedState, vt];
      }
    }
    function nu(l, f) {
      Mt = Mr(), Xt = No();
      var k = f === void 0 ? null : f;
      if (Xt !== null) {
        var N = Xt.memoizedState;
        if (N !== null && k !== null) {
          var $ = N[1];
          if (dd(k, $))
            return N[0];
        }
      }
      Cr = !0;
      var oe = l();
      return Cr = !1, Xt.memoizedState = [oe, k], oe;
    }
    function md(l) {
      Mt = Mr(), Xt = No();
      var f = Xt.memoizedState;
      if (f === null) {
        var k = {
          current: l
        };
        return Object.seal(k), Xt.memoizedState = k, k;
      } else
        return f;
    }
    function yd(l, f) {
      pa = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function gd(l, f, k) {
      if (Fr >= fa)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Mt) {
        da = !0;
        var N = {
          action: k,
          next: null
        };
        $n === null && ($n = /* @__PURE__ */ new Map());
        var $ = $n.get(f);
        if ($ === void 0)
          $n.set(f, N);
        else {
          for (var oe = $; oe.next !== null; )
            oe = oe.next;
          oe.next = N;
        }
      }
    }
    function vd(l, f) {
      return nu(function() {
        return l;
      }, f);
    }
    function xd(l, f, k) {
      return Mr(), f(l._source);
    }
    function bd(l, f, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function Ed(l) {
      return Mr(), l;
    }
    function _o() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ru() {
      return Mr(), [!1, _o];
    }
    function Wl() {
      var l = ua, f = od(l.treeContext), k = vi;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var N = Ro++;
      return mn(k, f, N);
    }
    function gi() {
    }
    var au = {
      readContext: pd,
      useContext: eu,
      useMemo: nu,
      useReducer: tu,
      useRef: md,
      useState: hd,
      useInsertionEffect: gi,
      useLayoutEffect: yd,
      useCallback: vd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: gi,
      // Effects are not run in the server environment.
      useEffect: gi,
      // Debugging effect
      useDebugValue: gi,
      useDeferredValue: Ed,
      useTransition: ru,
      useId: Wl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: xd,
      useSyncExternalStore: bd
    }, vi = null;
    function Oo(l) {
      vi = l;
    }
    function jl(l) {
      try {
        var f = "", k = l;
        do {
          switch (k.tag) {
            case 0:
              f += ui(k.type, null, null);
              break;
            case 1:
              f += Dl(k.type, null, null);
              break;
            case 2:
              f += Nl(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return f;
      } catch (N) {
        return `
Error generating stack: ` + N.message + `
` + N.stack;
      }
    }
    var Yr = r.ReactCurrentDispatcher, Fo = r.ReactDebugCurrentFrame, Mo = 0, ha = 1, iu = 2, Ul = 3, ma = 4, Sd = 0, ou = 1, Ar = 2, kd = 12800;
    function wd(l) {
      return console.error(l), null;
    }
    function xi() {
    }
    function Kl(l, f, k, N, $, oe, he, Ce, $e) {
      var nt = [], ot = /* @__PURE__ */ new Set(), vt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: N === void 0 ? kd : N,
        status: Sd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: ot,
        pingedTasks: nt,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: $ === void 0 ? wd : $,
        onAllReady: oe === void 0 ? xi : oe,
        onShellReady: he === void 0 ? xi : he,
        onShellError: Ce === void 0 ? xi : Ce,
        onFatalError: $e === void 0 ? xi : $e
      }, gn = Gr(
        vt,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      gn.parentFlushed = !0;
      var Hn = bi(vt, l, null, gn, ot, Kr, Ml, Ao);
      return nt.push(Hn), vt;
    }
    function zo(l, f) {
      var k = l.pingedTasks;
      k.push(f), k.length === 1 && d(function() {
        return gu(l);
      });
    }
    function zr(l, f) {
      return {
        id: Ln,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function bi(l, f, k, N, $, oe, he, Ce) {
      l.allPendingTasks++, k === null ? l.pendingRootTasks++ : k.pendingTasks++;
      var $e = {
        node: f,
        ping: function() {
          return zo(l, $e);
        },
        blockedBoundary: k,
        blockedSegment: N,
        abortSet: $,
        legacyContext: oe,
        context: he,
        treeContext: Ce
      };
      return $e.componentStack = null, $.add($e), $e;
    }
    function Gr(l, f, k, N, $, oe) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: N,
        boundary: k,
        lastPushedText: $,
        textEmbedded: oe
      };
    }
    var Lr = null;
    function Yl() {
      return Lr === null || Lr.componentStack === null ? "" : jl(Lr.componentStack);
    }
    function vr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Ba(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Gl(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function xr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Xr = null;
    function Xl(l, f) {
      {
        var k;
        typeof f == "string" ? k = f : f && typeof f.message == "string" ? k = f.message : k = String(f);
        var N = Xr || Yl();
        Xr = null, l.errorMessage = k, l.errorComponentStack = N;
      }
    }
    function Ei(l, f) {
      var k = l.onError(f);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Bo(l, f) {
      var k = l.onShellError;
      k(f);
      var N = l.onFatalError;
      N(f), l.destination !== null ? (l.status = Ar, S(l.destination, f)) : (l.status = ou, l.fatalError = f);
    }
    function lu(l, f, k) {
      vr(f, "Suspense");
      var N = f.blockedBoundary, $ = f.blockedSegment, oe = k.fallback, he = k.children, Ce = /* @__PURE__ */ new Set(), $e = zr(l, Ce), nt = $.chunks.length, ot = Gr(
        l,
        nt,
        $e,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      $.children.push(ot), $.lastPushedText = !1;
      var vt = Gr(
        l,
        0,
        null,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      vt.parentFlushed = !0, f.blockedBoundary = $e, f.blockedSegment = vt;
      try {
        if (Io(l, f, he), Fs(vt.chunks, l.responseState, vt.lastPushedText, vt.textEmbedded), vt.status = ha, wi($e, vt), $e.pendingTasks === 0) {
          xr(f);
          return;
        }
      } catch (Hn) {
        vt.status = ma, $e.forceClientRender = !0, $e.errorDigest = Ei(l, Hn), Xl($e, Hn);
      } finally {
        f.blockedBoundary = N, f.blockedSegment = $;
      }
      var gn = bi(l, oe, N, ot, Ce, f.legacyContext, f.context, f.treeContext);
      gn.componentStack = f.componentStack, l.pingedTasks.push(gn), xr(f);
    }
    function su(l, f, k, N) {
      vr(f, k);
      var $ = f.blockedSegment, oe = kr($.chunks, k, N, l.responseState, $.formatContext);
      $.lastPushedText = !1;
      var he = $.formatContext;
      $.formatContext = Wn(he, k, N), Io(l, f, oe), $.formatContext = he, lr($.chunks, k), $.lastPushedText = !1, xr(f);
    }
    function Td(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function ql(l, f, k, N, $) {
      var oe = {};
      Vl(f, oe);
      var he = k(N, $);
      return fd(k, N, he, $);
    }
    function Si(l, f, k, N, $) {
      var oe = k.render();
      k.props !== $ && (es || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", bn(N) || "a component"), es = !0);
      {
        var he = N.childContextTypes;
        if (he != null) {
          var Ce = f.legacyContext, $e = la(k, N, Ce, he);
          f.legacyContext = $e, fr(l, f, oe), f.legacyContext = Ce;
          return;
        }
      }
      fr(l, f, oe);
    }
    function uu(l, f, k, N) {
      Gl(f, k);
      var $ = Us(k, f.legacyContext), oe = rd(k, N, $);
      Co(oe, k, N, $), Si(l, f, oe, k, N), xr(f);
    }
    var Zl = {}, ki = {}, Ql = {}, Jl = {}, es = !1, cu = !1, du = !1, ts = !1;
    function Cd(l, f, k, N) {
      var $;
      if ($ = Us(k, f.legacyContext), Ba(f, k), k.prototype && typeof k.prototype.render == "function") {
        var oe = bn(k) || "Unknown";
        Zl[oe] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", oe, oe), Zl[oe] = !0);
      }
      var he = ql(l, f, k, N, $), Ce = Js();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var $e = bn(k) || "Unknown";
        ki[$e] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", $e, $e, $e), ki[$e] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var nt = bn(k) || "Unknown";
          ki[nt] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", nt, nt, nt), ki[nt] = !0);
        }
        Co(he, k, N, $), Si(l, f, he, k, N);
      } else if (Ad(k), Ce) {
        var ot = f.treeContext, vt = 1, gn = 0;
        f.treeContext = $l(ot, vt, gn);
        try {
          fr(l, f, he);
        } finally {
          f.treeContext = ot;
        }
      } else
        fr(l, f, he);
      xr(f);
    }
    function Ad(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = bn(l) || "Unknown";
          Jl[f] || (i("%s: Function components do not support getDerivedStateFromProps.", f), Jl[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var k = bn(l) || "Unknown";
          Ql[k] || (i("%s: Function components do not support contextType.", k), Ql[k] = !0);
        }
      }
    }
    function fu(l, f) {
      if (l && l.defaultProps) {
        var k = cr({}, f), N = l.defaultProps;
        for (var $ in N)
          k[$] === void 0 && (k[$] = N[$]);
        return k;
      }
      return f;
    }
    function Ld(l, f, k, N, $) {
      Ba(f, k.render);
      var oe = ql(l, f, k.render, N, $), he = Js();
      if (he) {
        var Ce = f.treeContext, $e = 1, nt = 0;
        f.treeContext = $l(Ce, $e, nt);
        try {
          fr(l, f, oe);
        } finally {
          f.treeContext = Ce;
        }
      } else
        fr(l, f, oe);
      xr(f);
    }
    function Pd(l, f, k, N, $) {
      var oe = k.type, he = fu(oe, N);
      rs(l, f, oe, he, $);
    }
    function ns(l, f, k, N) {
      k._context === void 0 ? k !== k.Consumer && (ts || (ts = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var $ = N.children;
      typeof $ != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var oe = Fa(k), he = $(oe);
      fr(l, f, he);
    }
    function Rd(l, f, k, N) {
      var $ = k._context, oe = N.value, he = N.children, Ce;
      Ce = f.context, f.context = pi($, oe), fr(l, f, he), f.context = Bl($), Ce !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function dr(l, f, k, N, $) {
      vr(f, "Lazy");
      var oe = k._payload, he = k._init, Ce = he(oe), $e = fu(Ce, N);
      rs(l, f, Ce, $e, $), xr(f);
    }
    function rs(l, f, k, N, $) {
      if (typeof k == "function")
        if (Td(k)) {
          uu(l, f, k, N);
          return;
        } else {
          Cd(l, f, k, N);
          return;
        }
      if (typeof k == "string") {
        su(l, f, k, N);
        return;
      }
      switch (k) {
        case Jc:
        case Bs:
        case so:
        case uo:
        case lo: {
          fr(l, f, N.children);
          return;
        }
        case El: {
          vr(f, "SuspenseList"), fr(l, f, N.children), xr(f);
          return;
        }
        case Qc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Na: {
          lu(l, f, N);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case ii: {
            Ld(l, f, k, N, $);
            return;
          }
          case Sl: {
            Pd(l, f, k, N, $);
            return;
          }
          case ri: {
            Rd(l, f, k, N);
            return;
          }
          case ai: {
            ns(l, f, k, N);
            return;
          }
          case co: {
            dr(l, f, k, N);
            return;
          }
        }
      var oe = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + oe));
    }
    function pu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (cu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), cu = !0), l.entries === f && (du || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), du = !0);
    }
    function fr(l, f, k) {
      try {
        return as(l, f, k);
      } catch (N) {
        throw typeof N == "object" && N !== null && typeof N.then == "function" || (Xr = Xr !== null ? Xr : Yl()), N;
      }
    }
    function as(l, f, k) {
      if (f.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case zs: {
            var N = k, $ = N.type, oe = N.props, he = N.ref;
            rs(l, f, $, oe, he);
            return;
          }
          case bl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case co: {
            var Ce = k, $e = Ce._payload, nt = Ce._init, ot;
            try {
              ot = nt($e);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && vr(f, "Lazy"), jo;
            }
            fr(l, f, ot);
            return;
          }
        }
        if (xt(k)) {
          hu(l, f, k);
          return;
        }
        var vt = Sn(k);
        if (vt) {
          pu(k, vt);
          var gn = vt.call(k);
          if (gn) {
            var Hn = gn.next();
            if (!Hn.done) {
              var br = [];
              do
                br.push(Hn.value), Hn = gn.next();
              while (!Hn.done);
              hu(l, f, br);
              return;
            }
            return;
          }
        }
        var xu = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (xu === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : xu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var bu = f.blockedSegment;
        bu.lastPushedText = Os(f.blockedSegment.chunks, k, l.responseState, bu.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var Eu = f.blockedSegment;
        Eu.lastPushedText = Os(f.blockedSegment.chunks, "" + k, l.responseState, Eu.lastPushedText);
        return;
      }
      typeof k == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hu(l, f, k) {
      for (var N = k.length, $ = 0; $ < N; $++) {
        var oe = f.treeContext;
        f.treeContext = $l(oe, N, $);
        try {
          Io(l, f, k[$]);
        } finally {
          f.treeContext = oe;
        }
      }
    }
    function Nd(l, f, k) {
      var N = f.blockedSegment, $ = N.chunks.length, oe = Gr(
        l,
        $,
        null,
        N.formatContext,
        // Adopt the parent segment's leading text embed
        N.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      N.children.push(oe), N.lastPushedText = !1;
      var he = bi(l, f.node, f.blockedBoundary, oe, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (he.componentStack = f.componentStack.parent);
      var Ce = he.ping;
      k.then(Ce, Ce);
    }
    function Io(l, f, k) {
      var N = f.blockedSegment.formatContext, $ = f.legacyContext, oe = f.context, he = null;
      he = f.componentStack;
      try {
        return fr(l, f, k);
      } catch (Ce) {
        if (yi(), typeof Ce == "object" && Ce !== null && typeof Ce.then == "function") {
          Nd(l, f, Ce), f.blockedSegment.formatContext = N, f.legacyContext = $, f.context = oe, go(oe), f.componentStack = he;
          return;
        } else
          throw f.blockedSegment.formatContext = N, f.legacyContext = $, f.context = oe, go(oe), f.componentStack = he, Ce;
      }
    }
    function $o(l, f, k, N) {
      var $ = Ei(l, N);
      if (f === null ? Bo(l, N) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = $, Xl(f, N), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var oe = l.onAllReady;
        oe();
      }
    }
    function mu(l) {
      var f = this, k = l.blockedBoundary, N = l.blockedSegment;
      N.status = Ul, Ti(f, k, N);
    }
    function yu(l, f, k) {
      var N = l.blockedBoundary, $ = l.blockedSegment;
      if ($.status = Ul, N === null)
        f.allPendingTasks--, f.status !== Ar && (f.status = Ar, f.destination !== null && g(f.destination));
      else {
        if (N.pendingTasks--, !N.forceClientRender) {
          N.forceClientRender = !0;
          var oe = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          N.errorDigest = f.onError(oe);
          {
            var he = "The server did not finish this Suspense boundary: ";
            oe && typeof oe.message == "string" ? oe = he + oe.message : oe = he + String(oe);
            var Ce = Lr;
            Lr = l;
            try {
              Xl(N, oe);
            } finally {
              Lr = Ce;
            }
          }
          N.parentFlushed && f.clientRenderedBoundaries.push(N);
        }
        if (N.fallbackAbortableTasks.forEach(function(nt) {
          return yu(nt, f, k);
        }), N.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var $e = f.onAllReady;
          $e();
        }
      }
    }
    function wi(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var k = f.children[0];
        k.id = f.id, k.parentFlushed = !0, k.status === ha && wi(l, k);
      } else {
        var N = l.completedSegments;
        N.push(f);
      }
    }
    function Ti(l, f, k) {
      if (f === null) {
        if (k.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = k;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = xi;
          var N = l.onShellReady;
          N();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          k.parentFlushed && k.status === ha && wi(f, k), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(mu, l), f.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === ha) {
          wi(f, k);
          var $ = f.completedSegments;
          $.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var oe = l.onAllReady;
        oe();
      }
    }
    function Ho(l, f) {
      var k = f.blockedSegment;
      if (k.status === Mo) {
        go(f.context);
        var N = null;
        N = Lr, Lr = f;
        try {
          fr(l, f, f.node), Fs(k.chunks, l.responseState, k.lastPushedText, k.textEmbedded), f.abortSet.delete(f), k.status = ha, Ti(l, f.blockedBoundary, k);
        } catch (oe) {
          if (yi(), typeof oe == "object" && oe !== null && typeof oe.then == "function") {
            var $ = f.ping;
            oe.then($, $);
          } else
            f.abortSet.delete(f), k.status = ma, $o(l, f.blockedBoundary, k, oe);
        } finally {
          Lr = N;
        }
      }
    }
    function gu(l) {
      if (l.status !== Ar) {
        var f = td(), k = Yr.current;
        Yr.current = au;
        var N;
        N = Fo.getCurrentStack, Fo.getCurrentStack = Yl;
        var $ = vi;
        Oo(l.responseState);
        try {
          var oe = l.pingedTasks, he;
          for (he = 0; he < oe.length; he++) {
            var Ce = oe[he];
            Ho(l, Ce);
          }
          oe.splice(0, he), l.destination !== null && Wo(l, l.destination);
        } catch ($e) {
          Ei(l, $e), Bo(l, $e);
        } finally {
          Oo($), Yr.current = k, Fo.getCurrentStack = N, k === au && go(f);
        }
      }
    }
    function Ci(l, f, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Mo: {
          var N = k.id = l.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, Gi(f, l.responseState, N);
        }
        case ha: {
          k.status = iu;
          for (var $ = !0, oe = k.chunks, he = 0, Ce = k.children, $e = 0; $e < Ce.length; $e++) {
            for (var nt = Ce[$e]; he < nt.index; he++)
              s(f, oe[he]);
            $ = Ai(l, f, nt);
          }
          for (; he < oe.length - 1; he++)
            s(f, oe[he]);
          return he < oe.length && ($ = h(f, oe[he])), $;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ai(l, f, k) {
      var N = k.boundary;
      if (N === null)
        return Ci(l, f, k);
      if (N.parentFlushed = !0, N.forceClientRender)
        return yr(f, l.responseState, N.errorDigest, N.errorMessage, N.errorComponentStack), Ci(l, f, k), Ms(f, l.responseState);
      if (N.pendingTasks > 0) {
        N.rootSegmentID = l.nextSegmentId++, N.completedSegments.length > 0 && l.partialBoundaries.push(N);
        var $ = N.id = Cn(l.responseState);
        return Ur(f, l.responseState, $), Ci(l, f, k), ei(f, l.responseState);
      } else {
        if (N.byteSize > l.progressiveChunkSize)
          return N.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(N), Ur(f, l.responseState, N.id), Ci(l, f, k), ei(f, l.responseState);
        xl(f, l.responseState);
        var oe = N.completedSegments;
        if (oe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = oe[0];
        return Ai(l, f, he), Zc(f, l.responseState);
      }
    }
    function Dd(l, f, k) {
      return Gc(f, l.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function is(l, f, k) {
      return Se(f, l.responseState, k.formatContext, k.id), Ai(l, f, k), Fe(f, k.formatContext);
    }
    function Vo(l, f, k) {
      for (var N = k.completedSegments, $ = 0; $ < N.length; $++) {
        var oe = N[$];
        vu(l, f, k, oe);
      }
      return N.length = 0, Wc(f, l.responseState, k.id, k.rootSegmentID);
    }
    function _d(l, f, k) {
      for (var N = k.completedSegments, $ = 0; $ < N.length; $++) {
        var oe = N[$];
        if (!vu(l, f, k, oe))
          return $++, N.splice(0, $), !1;
      }
      return N.splice(0, $), !0;
    }
    function vu(l, f, k, N) {
      if (N.status === iu)
        return !0;
      var $ = N.id;
      if ($ === -1) {
        var oe = N.id = k.rootSegmentID;
        if (oe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return is(l, f, N);
      } else
        return is(l, f, N), ur(f, l.responseState, $);
    }
    function Wo(l, f) {
      try {
        var k = l.completedRootSegment;
        k !== null && l.pendingRootTasks === 0 && (Ai(l, f, k), l.completedRootSegment = null, qa(f, l.responseState));
        var N = l.clientRenderedBoundaries, $;
        for ($ = 0; $ < N.length; $++) {
          var oe = N[$];
          if (!Dd(l, f, oe)) {
            l.destination = null, $++, N.splice(0, $);
            return;
          }
        }
        N.splice(0, $);
        var he = l.completedBoundaries;
        for ($ = 0; $ < he.length; $++) {
          var Ce = he[$];
          if (!Vo(l, f, Ce)) {
            l.destination = null, $++, he.splice(0, $);
            return;
          }
        }
        he.splice(0, $);
        var $e = l.partialBoundaries;
        for ($ = 0; $ < $e.length; $++) {
          var nt = $e[$];
          if (!_d(l, f, nt)) {
            l.destination = null, $++, $e.splice(0, $);
            return;
          }
        }
        $e.splice(0, $);
        var ot = l.completedBoundaries;
        for ($ = 0; $ < ot.length; $++) {
          var vt = ot[$];
          if (!Vo(l, f, vt)) {
            l.destination = null, $++, ot.splice(0, $);
            return;
          }
        }
        ot.splice(0, $);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), g(f));
      }
    }
    function Od(l) {
      d(function() {
        return gu(l);
      });
    }
    function u(l, f) {
      if (l.status === ou) {
        l.status = Ar, S(f, l.fatalError);
        return;
      }
      if (l.status !== Ar && l.destination === null) {
        l.destination = f;
        try {
          Wo(l, f);
        } catch (k) {
          Ei(l, k), Bo(l, k);
        }
      }
    }
    function m(l, f) {
      try {
        var k = l.abortableTasks;
        k.forEach(function(N) {
          return yu(N, l, f);
        }), k.clear(), l.destination !== null && Wo(l, l.destination);
      } catch (N) {
        Ei(l, N), Bo(l, N);
      }
    }
    function T() {
    }
    function M(l, f, k, N) {
      var $ = !1, oe = null, he = "", Ce = {
        push: function(vt) {
          return vt !== null && (he += vt), !0;
        },
        destroy: function(vt) {
          $ = !0, oe = vt;
        }
      }, $e = !1;
      function nt() {
        $e = !0;
      }
      var ot = Kl(l, qc(k, f ? f.identifierPrefix : void 0), vl(), 1 / 0, T, void 0, nt, void 0, void 0);
      if (Od(ot), m(ot, N), u(ot, Ce), $)
        throw oe;
      if (!$e)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return he;
    }
    function q(l, f) {
      return M(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function de(l, f) {
      return M(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function me() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Le() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Di.renderToNodeStream = me, Di.renderToStaticMarkup = de, Di.renderToStaticNodeStream = Le, Di.renderToString = q, Di.version = t;
  }()), Di;
}
var Mu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var em;
function bS() {
  return em || (em = 1, process.env.NODE_ENV !== "production" && function() {
    var e = se, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(u) {
      {
        for (var m = arguments.length, T = new Array(m > 1 ? m - 1 : 0), M = 1; M < m; M++)
          T[M - 1] = arguments[M];
        o("warn", u, T);
      }
    }
    function i(u) {
      {
        for (var m = arguments.length, T = new Array(m > 1 ? m - 1 : 0), M = 1; M < m; M++)
          T[M - 1] = arguments[M];
        o("error", u, T);
      }
    }
    function o(u, m, T) {
      {
        var M = r.ReactDebugCurrentFrame, q = M.getStackAddendum();
        q !== "" && (m += "%s", T = T.concat([q]));
        var de = T.map(function(me) {
          return String(me);
        });
        de.unshift("Warning: " + m), Function.prototype.apply.call(console[u], console, de);
      }
    }
    function d(u) {
      u();
    }
    var c = 512, s = null, h = 0;
    function y(u) {
      s = new Uint8Array(c), h = 0;
    }
    function g(u, m) {
      if (m.length !== 0) {
        if (m.length > c) {
          h > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, h)), s = new Uint8Array(c), h = 0), u.enqueue(m);
          return;
        }
        var T = m, M = s.length - h;
        M < T.length && (M === 0 ? u.enqueue(s) : (s.set(T.subarray(0, M), h), u.enqueue(s), T = T.subarray(M)), s = new Uint8Array(c), h = 0), s.set(T, h), h += T.length;
      }
    }
    function x(u, m) {
      return g(u, m), !0;
    }
    function w(u) {
      s && h > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, h)), s = null, h = 0);
    }
    function S(u) {
      u.close();
    }
    var A = new TextEncoder();
    function p(u) {
      return A.encode(u);
    }
    function v(u) {
      return A.encode(u);
    }
    function L(u, m) {
      typeof u.error == "function" ? u.error(m) : u.close();
    }
    function P(u) {
      {
        var m = typeof Symbol == "function" && Symbol.toStringTag, T = m && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return T;
      }
    }
    function R(u) {
      try {
        return C(u), !1;
      } catch {
        return !0;
      }
    }
    function C(u) {
      return "" + u;
    }
    function z(u, m) {
      if (R(u))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", m, P(u)), C(u);
    }
    function W(u, m) {
      if (R(u))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", m, P(u)), C(u);
    }
    function Z(u) {
      if (R(u))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", P(u)), C(u);
    }
    var ee = Object.prototype.hasOwnProperty, K = 0, le = 1, Y = 2, ae = 3, B = 4, X = 5, ce = 6, ne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Q = ne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", V = new RegExp("^[" + ne + "][" + Q + "]*$"), j = {}, te = {};
    function U(u) {
      return ee.call(te, u) ? !0 : ee.call(j, u) ? !1 : V.test(u) ? (te[u] = !0, !0) : (j[u] = !0, i("Invalid attribute name: `%s`", u), !1);
    }
    function ue(u, m, T, M) {
      if (T !== null && T.type === K)
        return !1;
      switch (typeof m) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (M)
            return !1;
          if (T !== null)
            return !T.acceptsBooleans;
          var q = u.toLowerCase().slice(0, 5);
          return q !== "data-" && q !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ke(u) {
      return be.hasOwnProperty(u) ? be[u] : null;
    }
    function xe(u, m, T, M, q, de, me) {
      this.acceptsBooleans = m === Y || m === ae || m === B, this.attributeName = M, this.attributeNamespace = q, this.mustUseProperty = T, this.propertyName = u, this.type = m, this.sanitizeURL = de, this.removeEmptyString = me;
    }
    var be = {}, Ae = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ae.forEach(function(u) {
      be[u] = new xe(
        u,
        K,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
      var m = u[0], T = u[1];
      be[m] = new xe(
        m,
        le,
        !1,
        // mustUseProperty
        T,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
      be[u] = new xe(
        u,
        Y,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
      be[u] = new xe(
        u,
        Y,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(u) {
      be[u] = new xe(
        u,
        ae,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      be[u] = new xe(
        u,
        ae,
        !0,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      be[u] = new xe(
        u,
        B,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      be[u] = new xe(
        u,
        ce,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(u) {
      be[u] = new xe(
        u,
        X,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ye = /[\-\:]([a-z])/g, Pe = function(u) {
      return u[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var m = u.replace(Ye, Pe);
      be[m] = new xe(
        m,
        le,
        !1,
        // mustUseProperty
        u,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var m = u.replace(Ye, Pe);
      be[m] = new xe(
        m,
        le,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var m = u.replace(Ye, Pe);
      be[m] = new xe(
        m,
        le,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(u) {
      be[u] = new xe(
        u,
        le,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = "xlinkHref";
    be[ye] = new xe(
      "xlinkHref",
      le,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(u) {
      be[u] = new xe(
        u,
        le,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Re = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function fe(u, m) {
      return u + m.charAt(0).toUpperCase() + m.substring(1);
    }
    var ze = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Re).forEach(function(u) {
      ze.forEach(function(m) {
        Re[fe(m, u)] = Re[u];
      });
    });
    var Ne = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function qe(u, m) {
      Ne[m.type] || m.onChange || m.onInput || m.readOnly || m.disabled || m.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), m.onChange || m.readOnly || m.disabled || m.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function He(u, m) {
      if (u.indexOf("-") === -1)
        return typeof m.is == "string";
      switch (u) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Be = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ze = {}, Ve = new RegExp("^(aria)-[" + Q + "]*$"), je = new RegExp("^(aria)[A-Z][" + Q + "]*$");
    function Ue(u, m) {
      {
        if (ee.call(Ze, m) && Ze[m])
          return !0;
        if (je.test(m)) {
          var T = "aria-" + m.slice(4).toLowerCase(), M = Be.hasOwnProperty(T) ? T : null;
          if (M == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", m), Ze[m] = !0, !0;
          if (m !== M)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", m, M), Ze[m] = !0, !0;
        }
        if (Ve.test(m)) {
          var q = m.toLowerCase(), de = Be.hasOwnProperty(q) ? q : null;
          if (de == null)
            return Ze[m] = !0, !1;
          if (m !== de)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", m, de), Ze[m] = !0, !0;
        }
      }
      return !0;
    }
    function we(u, m) {
      {
        var T = [];
        for (var M in m) {
          var q = Ue(u, M);
          q || T.push(M);
        }
        var de = T.map(function(me) {
          return "`" + me + "`";
        }).join(", ");
        T.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, u) : T.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, u);
      }
    }
    function De(u, m) {
      He(u, m) || we(u, m);
    }
    var rt = !1;
    function ge(u, m) {
      {
        if (u !== "input" && u !== "textarea" && u !== "select")
          return;
        m != null && m.value === null && !rt && (rt = !0, u === "select" && m.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", u) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", u));
      }
    }
    var ut = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, at = function() {
    };
    {
      var it = {}, St = /^on./, jt = /^on[^A-Z]/, Bt = new RegExp("^(aria)-[" + Q + "]*$"), Nt = new RegExp("^(aria)[A-Z][" + Q + "]*$");
      at = function(u, m, T, M) {
        if (ee.call(it, m) && it[m])
          return !0;
        var q = m.toLowerCase();
        if (q === "onfocusin" || q === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), it[m] = !0, !0;
        if (M != null) {
          var de = M.registrationNameDependencies, me = M.possibleRegistrationNames;
          if (de.hasOwnProperty(m))
            return !0;
          var Le = me.hasOwnProperty(q) ? me[q] : null;
          if (Le != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", m, Le), it[m] = !0, !0;
          if (St.test(m))
            return i("Unknown event handler property `%s`. It will be ignored.", m), it[m] = !0, !0;
        } else if (St.test(m))
          return jt.test(m) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", m), it[m] = !0, !0;
        if (Bt.test(m) || Nt.test(m))
          return !0;
        if (q === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), it[m] = !0, !0;
        if (q === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), it[m] = !0, !0;
        if (q === "is" && T !== null && T !== void 0 && typeof T != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof T), it[m] = !0, !0;
        if (typeof T == "number" && isNaN(T))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", m), it[m] = !0, !0;
        var l = ke(m), f = l !== null && l.type === K;
        if (ut.hasOwnProperty(q)) {
          var k = ut[q];
          if (k !== m)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", m, k), it[m] = !0, !0;
        } else if (!f && m !== q)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", m, q), it[m] = !0, !0;
        return typeof T == "boolean" && ue(m, T, l, !1) ? (T ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', T, m, m, T, m) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', T, m, m, T, m, m, m), it[m] = !0, !0) : f ? !0 : ue(m, T, l, !1) ? (it[m] = !0, !1) : ((T === "false" || T === "true") && l !== null && l.type === ae && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", T, m, T === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', m, T), it[m] = !0), !0);
      };
    }
    var sn = function(u, m, T) {
      {
        var M = [];
        for (var q in m) {
          var de = at(u, q, m[q], T);
          de || M.push(q);
        }
        var me = M.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        M.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, u) : M.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, u);
      }
    };
    function gt(u, m, T) {
      He(u, m) || sn(u, m, T);
    }
    var Dt = function() {
    };
    {
      var _t = /^(?:webkit|moz|o)[A-Z]/, un = /^-ms-/, En = /-(.)/g, $t = /;\s*$/, It = {}, fn = {}, tt = !1, st = !1, Tn = function(u) {
        return u.replace(En, function(m, T) {
          return T.toUpperCase();
        });
      }, tn = function(u) {
        It.hasOwnProperty(u) && It[u] || (It[u] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          u,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Tn(u.replace(un, "ms-"))
        ));
      }, cn = function(u) {
        It.hasOwnProperty(u) && It[u] || (It[u] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", u, u.charAt(0).toUpperCase() + u.slice(1)));
      }, pn = function(u, m) {
        fn.hasOwnProperty(m) && fn[m] || (fn[m] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, u, m.replace($t, "")));
      }, ft = function(u, m) {
        tt || (tt = !0, i("`NaN` is an invalid value for the `%s` css style property.", u));
      }, Pt = function(u, m) {
        st || (st = !0, i("`Infinity` is an invalid value for the `%s` css style property.", u));
      };
      Dt = function(u, m) {
        u.indexOf("-") > -1 ? tn(u) : _t.test(u) ? cn(u) : $t.test(m) && pn(u, m), typeof m == "number" && (isNaN(m) ? ft(u, m) : isFinite(m) || Pt(u, m));
      };
    }
    var Ot = Dt, hn = /["'&<>]/;
    function Tt(u) {
      Z(u);
      var m = "" + u, T = hn.exec(m);
      if (!T)
        return m;
      var M, q = "", de, me = 0;
      for (de = T.index; de < m.length; de++) {
        switch (m.charCodeAt(de)) {
          case 34:
            M = "&quot;";
            break;
          case 38:
            M = "&amp;";
            break;
          case 39:
            M = "&#x27;";
            break;
          case 60:
            M = "&lt;";
            break;
          case 62:
            M = "&gt;";
            break;
          default:
            continue;
        }
        me !== de && (q += m.substring(me, de)), me = de + 1, q += M;
      }
      return me !== de ? q + m.substring(me, de) : q;
    }
    function Ct(u) {
      return typeof u == "boolean" || typeof u == "number" ? "" + u : Tt(u);
    }
    var nn = /([A-Z])/g, Nn = /^ms-/;
    function At(u) {
      return u.replace(nn, "-$1").toLowerCase().replace(Nn, "-ms-");
    }
    var xt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Dn = !1;
    function Oe(u) {
      !Dn && xt.test(u) && (Dn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(u)));
    }
    var _e = Array.isArray;
    function Ee(u) {
      return _e(u);
    }
    var ct = v("<script>"), qt = v("<\/script>"), Kt = v('<script src="'), Ft = v('<script type="module" src="'), kt = v('" async=""><\/script>');
    function ht(u) {
      return Z(u), ("" + u).replace(Et, An);
    }
    var Et = /(<\/|<)(s)(cript)/gi, An = function(u, m, T, M) {
      return "" + m + (T === "s" ? "\\u0073" : "\\u0053") + M;
    };
    function Zt(u, m, T, M, q) {
      var de = u === void 0 ? "" : u, me = m === void 0 ? ct : v('<script nonce="' + Ct(m) + '">'), Le = [];
      if (T !== void 0 && Le.push(me, p(ht(T)), qt), M !== void 0)
        for (var l = 0; l < M.length; l++)
          Le.push(Kt, p(Ct(M[l])), kt);
      if (q !== void 0)
        for (var f = 0; f < q.length; f++)
          Le.push(Ft, p(Ct(q[f])), kt);
      return {
        bootstrapChunks: Le,
        startInlineScript: me,
        placeholderPrefix: v(de + "P:"),
        segmentPrefix: v(de + "S:"),
        boundaryPrefix: de + "B:",
        idPrefix: de,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var kn = 0, Rt = 1, dn = 2, Gt = 3, rn = 4, Wn = 5, Ln = 6, Cn = 7;
    function mn(u, m) {
      return {
        insertionMode: u,
        selectedValue: m
      };
    }
    function _n(u) {
      var m = u === "http://www.w3.org/2000/svg" ? dn : u === "http://www.w3.org/1998/Math/MathML" ? Gt : kn;
      return mn(m, null);
    }
    function On(u, m, T) {
      switch (m) {
        case "select":
          return mn(Rt, T.value != null ? T.value : T.defaultValue);
        case "svg":
          return mn(dn, null);
        case "math":
          return mn(Gt, null);
        case "foreignObject":
          return mn(Rt, null);
        case "table":
          return mn(rn, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return mn(Wn, null);
        case "colgroup":
          return mn(Cn, null);
        case "tr":
          return mn(Ln, null);
      }
      return u.insertionMode >= rn || u.insertionMode === kn ? mn(Rt, null) : u;
    }
    var Fn = null;
    function Kn(u) {
      var m = u.nextSuspenseID++;
      return v(u.boundaryPrefix + m.toString(16));
    }
    function an(u, m, T) {
      var M = u.idPrefix, q = ":" + M + "R" + m;
      return T > 0 && (q += "H" + T.toString(32)), q + ":";
    }
    function yn(u) {
      return Ct(u);
    }
    var ir = v("<!-- -->");
    function Zn(u, m, T, M) {
      return m === "" ? M : (M && u.push(ir), u.push(p(yn(m))), !0);
    }
    function Qn(u, m, T, M) {
      T && M && u.push(ir);
    }
    var b = /* @__PURE__ */ new Map();
    function _(u) {
      var m = b.get(u);
      if (m !== void 0)
        return m;
      var T = v(Ct(At(u)));
      return b.set(u, T), T;
    }
    var D = v(' style="'), G = v(":"), pe = v(";");
    function O(u, m, T) {
      if (typeof T != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var M = !0;
      for (var q in T)
        if (ee.call(T, q)) {
          var de = T[q];
          if (!(de == null || typeof de == "boolean" || de === "")) {
            var me = void 0, Le = void 0, l = q.indexOf("--") === 0;
            l ? (me = p(Ct(q)), W(de, q), Le = p(Ct(("" + de).trim()))) : (Ot(q, de), me = _(q), typeof de == "number" ? de !== 0 && !ee.call(Re, q) ? Le = p(de + "px") : Le = p("" + de) : (W(de, q), Le = p(Ct(("" + de).trim())))), M ? (M = !1, u.push(D, me, G, Le)) : u.push(pe, me, G, Le);
          }
        }
      M || u.push(ve);
    }
    var I = v(" "), J = v('="'), ve = v('"'), Ie = v('=""');
    function Xe(u, m, T, M) {
      switch (T) {
        case "style": {
          O(u, m, M);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(T.length > 2 && (T[0] === "o" || T[0] === "O") && (T[1] === "n" || T[1] === "N"))
      ) {
        var q = ke(T);
        if (q !== null) {
          switch (typeof M) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!q.acceptsBooleans)
                return;
          }
          var de = q.attributeName, me = p(de);
          switch (q.type) {
            case ae:
              M && u.push(I, me, Ie);
              return;
            case B:
              M === !0 ? u.push(I, me, Ie) : M === !1 || u.push(I, me, J, p(Ct(M)), ve);
              return;
            case X:
              isNaN(M) || u.push(I, me, J, p(Ct(M)), ve);
              break;
            case ce:
              !isNaN(M) && M >= 1 && u.push(I, me, J, p(Ct(M)), ve);
              break;
            default:
              q.sanitizeURL && (z(M, de), M = "" + M, Oe(M)), u.push(I, me, J, p(Ct(M)), ve);
          }
        } else if (U(T)) {
          switch (typeof M) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = T.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          u.push(I, p(T), J, p(Ct(M)), ve);
        }
      }
    }
    var lt = v(">"), Ut = v("/>");
    function Ht(u, m, T) {
      if (m != null) {
        if (T != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof m != "object" || !("__html" in m))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var M = m.__html;
        M != null && (Z(M), u.push(p("" + M)));
      }
    }
    var Qt = !1, Jt = !1, en = !1, jn = !1, Jn = !1, er = !1, Yn = !1;
    function Er(u, m) {
      {
        var T = u[m];
        if (T != null) {
          var M = Ee(T);
          u.multiple && !M ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", m) : !u.multiple && M && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", m);
        }
      }
    }
    function xa(u, m, T) {
      qe("select", m), Er(m, "value"), Er(m, "defaultValue"), m.value !== void 0 && m.defaultValue !== void 0 && !en && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), en = !0), u.push(lr("select"));
      var M = null, q = null;
      for (var de in m)
        if (ee.call(m, de)) {
          var me = m[de];
          if (me == null)
            continue;
          switch (de) {
            case "children":
              M = me;
              break;
            case "dangerouslySetInnerHTML":
              q = me;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Xe(u, T, de, me);
              break;
          }
        }
      return u.push(lt), Ht(u, q, M), M;
    }
    function Lt(u) {
      var m = "";
      return e.Children.forEach(u, function(T) {
        T != null && (m += T, !Jn && typeof T != "string" && typeof T != "number" && (Jn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), m;
    }
    var xn = v(' selected=""');
    function ra(u, m, T, M) {
      var q = M.selectedValue;
      u.push(lr("option"));
      var de = null, me = null, Le = null, l = null;
      for (var f in m)
        if (ee.call(m, f)) {
          var k = m[f];
          if (k == null)
            continue;
          switch (f) {
            case "children":
              de = k;
              break;
            case "selected":
              Le = k, Yn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Yn = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = k;
              break;
            case "value":
              me = k;
            default:
              Xe(u, T, f, k);
              break;
          }
        }
      if (q != null) {
        var N;
        if (me !== null ? (z(me, "value"), N = "" + me) : (l !== null && (er || (er = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), N = Lt(de)), Ee(q))
          for (var $ = 0; $ < q.length; $++) {
            z(q[$], "value");
            var oe = "" + q[$];
            if (oe === N) {
              u.push(xn);
              break;
            }
          }
        else
          z(q, "select.value"), "" + q === N && u.push(xn);
      } else
        Le && u.push(xn);
      return u.push(lt), Ht(u, l, de), de;
    }
    function Nr(u, m, T) {
      qe("input", m), m.checked !== void 0 && m.defaultChecked !== void 0 && !Jt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", m.type), Jt = !0), m.value !== void 0 && m.defaultValue !== void 0 && !Qt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", m.type), Qt = !0), u.push(lr("input"));
      var M = null, q = null, de = null, me = null;
      for (var Le in m)
        if (ee.call(m, Le)) {
          var l = m[Le];
          if (l == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              me = l;
              break;
            case "defaultValue":
              q = l;
              break;
            case "checked":
              de = l;
              break;
            case "value":
              M = l;
              break;
            default:
              Xe(u, T, Le, l);
              break;
          }
        }
      return de !== null ? Xe(u, T, "checked", de) : me !== null && Xe(u, T, "checked", me), M !== null ? Xe(u, T, "value", M) : q !== null && Xe(u, T, "value", q), u.push(Ut), null;
    }
    function or(u, m, T) {
      qe("textarea", m), m.value !== void 0 && m.defaultValue !== void 0 && !jn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), jn = !0), u.push(lr("textarea"));
      var M = null, q = null, de = null;
      for (var me in m)
        if (ee.call(m, me)) {
          var Le = m[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              de = Le;
              break;
            case "value":
              M = Le;
              break;
            case "defaultValue":
              q = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Xe(u, T, me, Le);
              break;
          }
        }
      if (M === null && q !== null && (M = q), u.push(lt), de != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), M != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Ee(de)) {
          if (de.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          Z(de[0]), M = "" + de[0];
        }
        Z(de), M = "" + de;
      }
      return typeof M == "string" && M[0] === `
` && u.push(_r), M !== null && (z(M, "value"), u.push(p(yn("" + M)))), null;
    }
    function Dr(u, m, T, M) {
      u.push(lr(T));
      for (var q in m)
        if (ee.call(m, q)) {
          var de = m[q];
          if (de == null)
            continue;
          switch (q) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(T + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Xe(u, M, q, de);
              break;
          }
        }
      return u.push(Ut), null;
    }
    function Wr(u, m, T) {
      u.push(lr("menuitem"));
      for (var M in m)
        if (ee.call(m, M)) {
          var q = m[M];
          if (q == null)
            continue;
          switch (M) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Xe(u, T, M, q);
              break;
          }
        }
      return u.push(lt), null;
    }
    function Vt(u, m, T) {
      u.push(lr("title"));
      var M = null;
      for (var q in m)
        if (ee.call(m, q)) {
          var de = m[q];
          if (de == null)
            continue;
          switch (q) {
            case "children":
              M = de;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Xe(u, T, q, de);
              break;
          }
        }
      u.push(lt);
      {
        var me = Array.isArray(M) && M.length < 2 ? M[0] || null : M;
        Array.isArray(M) && M.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && me.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && typeof me != "string" && typeof me != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return M;
    }
    function mr(u, m, T, M) {
      u.push(lr(T));
      var q = null, de = null;
      for (var me in m)
        if (ee.call(m, me)) {
          var Le = m[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              q = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            default:
              Xe(u, M, me, Le);
              break;
          }
        }
      return u.push(lt), Ht(u, de, q), typeof q == "string" ? (u.push(p(yn(q))), null) : q;
    }
    function Gn(u, m, T, M) {
      u.push(lr(T));
      var q = null, de = null;
      for (var me in m)
        if (ee.call(m, me)) {
          var Le = m[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              q = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            case "style":
              O(u, M, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              U(me) && typeof Le != "function" && typeof Le != "symbol" && u.push(I, p(me), J, p(Ct(Le)), ve);
              break;
          }
        }
      return u.push(lt), Ht(u, de, q), q;
    }
    var _r = v(`
`);
    function kr(u, m, T, M) {
      u.push(lr(T));
      var q = null, de = null;
      for (var me in m)
        if (ee.call(m, me)) {
          var Le = m[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              q = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            default:
              Xe(u, M, me, Le);
              break;
          }
        }
      if (u.push(lt), de != null) {
        if (q != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof de != "object" || !("__html" in de))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = de.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? u.push(_r, p(l)) : (Z(l), u.push(p("" + l))));
      }
      return typeof q == "string" && q[0] === `
` && u.push(_r), q;
    }
    var ba = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, wr = /* @__PURE__ */ new Map();
    function lr(u) {
      var m = wr.get(u);
      if (m === void 0) {
        if (!ba.test(u))
          throw new Error("Invalid tag: " + u);
        m = v("<" + u), wr.set(u, m);
      }
      return m;
    }
    var qa = v("<!DOCTYPE html>");
    function Za(u, m, T, M, q) {
      switch (De(m, T), ge(m, T), gt(m, T, null), !T.suppressContentEditableWarning && T.contentEditable && T.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), q.insertionMode !== dn && q.insertionMode !== Gt && m.indexOf("-") === -1 && typeof T.is != "string" && m.toLowerCase() !== m && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", m), m) {
        case "select":
          return xa(u, T, M);
        case "option":
          return ra(u, T, M, q);
        case "textarea":
          return or(u, T, M);
        case "input":
          return Nr(u, T, M);
        case "menuitem":
          return Wr(u, T, M);
        case "title":
          return Vt(u, T, M);
        case "listing":
        case "pre":
          return kr(u, T, m, M);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Dr(u, T, m, M);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return mr(u, T, m, M);
        case "html":
          return q.insertionMode === kn && u.push(qa), mr(u, T, m, M);
        default:
          return m.indexOf("-") === -1 && typeof T.is != "string" ? mr(u, T, m, M) : Gn(u, T, m, M);
      }
    }
    var Yi = v("</"), Gi = v(">");
    function Xi(u, m, T) {
      switch (m) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          u.push(Yi, p(m), Gi);
      }
    }
    function fl(u, m) {
      for (var T = m.bootstrapChunks, M = 0; M < T.length - 1; M++)
        g(u, T[M]);
      return M < T.length ? x(u, T[M]) : !0;
    }
    var pl = v('<template id="'), Ea = v('"></template>');
    function Sa(u, m, T) {
      g(u, pl), g(u, m.placeholderPrefix);
      var M = p(T.toString(16));
      return g(u, M), x(u, Ea);
    }
    var ka = v("<!--$-->"), aa = v('<!--$?--><template id="'), hl = v('"></template>'), ia = v("<!--$!-->"), Qa = v("<!--/$-->"), Ja = v("<template"), jr = v('"'), Ur = v(' data-dgst="'), wa = v(' data-msg="'), qi = v(' data-stck="'), ei = v("></template>");
    function Zi(u, m) {
      return x(u, ka);
    }
    function Ta(u, m, T) {
      if (g(u, aa), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, T), x(u, hl);
    }
    function Xn(u, m, T, M, q) {
      var de;
      return de = x(u, ia), g(u, Ja), T && (g(u, Ur), g(u, p(Ct(T))), g(u, jr)), M && (g(u, wa), g(u, p(Ct(M))), g(u, jr)), q && (g(u, qi), g(u, p(Ct(q))), g(u, jr)), de = x(u, ei), de;
    }
    function Qi(u, m) {
      return x(u, Qa);
    }
    function Ca(u, m) {
      return x(u, Qa);
    }
    function ml(u, m) {
      return x(u, Qa);
    }
    var Ji = v('<div hidden id="'), Aa = v('">'), eo = v("</div>"), to = v('<svg aria-hidden="true" style="display:none" id="'), La = v('">'), Pa = v("</svg>"), no = v('<math aria-hidden="true" style="display:none" id="'), ro = v('">'), ao = v("</math>"), ti = v('<table hidden id="'), io = v('">'), E = v("</table>"), F = v('<table hidden><tbody id="'), H = v('">'), re = v("</tbody></table>"), Te = v('<table hidden><tr id="'), Se = v('">'), Fe = v("</tr></table>"), Ke = v('<table hidden><colgroup id="'), yt = v('">'), wt = v("</colgroup></table>");
    function bt(u, m, T, M) {
      switch (T.insertionMode) {
        case kn:
        case Rt:
          return g(u, Ji), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, Aa);
        case dn:
          return g(u, to), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, La);
        case Gt:
          return g(u, no), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, ro);
        case rn:
          return g(u, ti), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, io);
        case Wn:
          return g(u, F), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, H);
        case Ln:
          return g(u, Te), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, Se);
        case Cn:
          return g(u, Ke), g(u, m.segmentPrefix), g(u, p(M.toString(16))), x(u, yt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function on(u, m) {
      switch (m.insertionMode) {
        case kn:
        case Rt:
          return x(u, eo);
        case dn:
          return x(u, Pa);
        case Gt:
          return x(u, ao);
        case rn:
          return x(u, E);
        case Wn:
          return x(u, re);
        case Ln:
          return x(u, Fe);
        case Cn:
          return x(u, wt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var qn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", sr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', ur = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ra = v(qn + ';$RS("'), oo = v('$RS("'), ni = v('","'), Vc = v('")<\/script>');
    function Wc(u, m, T) {
      g(u, m.startInlineScript), m.sentCompleteSegmentFunction ? g(u, oo) : (m.sentCompleteSegmentFunction = !0, g(u, Ra)), g(u, m.segmentPrefix);
      var M = p(T.toString(16));
      return g(u, M), g(u, ni), g(u, m.placeholderPrefix), g(u, M), x(u, Vc);
    }
    var jc = v(sr + ';$RC("'), Uc = v('$RC("'), Kc = v('","'), Yc = v('")<\/script>');
    function yl(u, m, T, M) {
      if (g(u, m.startInlineScript), m.sentCompleteBoundaryFunction ? g(u, Uc) : (m.sentCompleteBoundaryFunction = !0, g(u, jc)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var q = p(M.toString(16));
      return g(u, T), g(u, Kc), g(u, m.segmentPrefix), g(u, q), x(u, Yc);
    }
    var Gc = v(ur + ';$RX("'), Xc = v('$RX("'), gl = v('"'), qc = v(")<\/script>"), vl = v(",");
    function Os(u, m, T, M, q, de) {
      if (g(u, m.startInlineScript), m.sentClientRenderFunction ? g(u, Xc) : (m.sentClientRenderFunction = !0, g(u, Gc)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, T), g(u, gl), (M || q || de) && (g(u, vl), g(u, p(xl(M || "")))), (q || de) && (g(u, vl), g(u, p(xl(q || "")))), de && (g(u, vl), g(u, p(xl(de)))), x(u, qc);
    }
    var Fs = /[<\u2028\u2029]/g;
    function xl(u) {
      var m = JSON.stringify(u);
      return m.replace(Fs, function(T) {
        switch (T) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var yr = Object.assign, Zc = Symbol.for("react.element"), Ms = Symbol.for("react.portal"), cr = Symbol.for("react.fragment"), zs = Symbol.for("react.strict_mode"), bl = Symbol.for("react.profiler"), lo = Symbol.for("react.provider"), so = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), ri = Symbol.for("react.suspense"), ai = Symbol.for("react.suspense_list"), ii = Symbol.for("react.memo"), Na = Symbol.for("react.lazy"), El = Symbol.for("react.scope"), Sl = Symbol.for("react.debug_trace_mode"), co = Symbol.for("react.legacy_hidden"), Qc = Symbol.for("react.default_value"), Bs = Symbol.iterator, Jc = "@@iterator";
    function ed(u) {
      if (u === null || typeof u != "object")
        return null;
      var m = Bs && u[Bs] || u[Jc];
      return typeof m == "function" ? m : null;
    }
    function Is(u, m, T) {
      var M = u.displayName;
      if (M)
        return M;
      var q = m.displayName || m.name || "";
      return q !== "" ? T + "(" + q + ")" : T;
    }
    function $s(u) {
      return u.displayName || "Context";
    }
    function Sn(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case cr:
          return "Fragment";
        case Ms:
          return "Portal";
        case bl:
          return "Profiler";
        case zs:
          return "StrictMode";
        case ri:
          return "Suspense";
        case ai:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case so:
            var m = u;
            return $s(m) + ".Consumer";
          case lo:
            var T = u;
            return $s(T._context) + ".Provider";
          case uo:
            return Is(u, u.render, "ForwardRef");
          case ii:
            var M = u.displayName || null;
            return M !== null ? M : Sn(u.type) || "Memo";
          case Na: {
            var q = u, de = q._payload, me = q._init;
            try {
              return Sn(me(de));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oi = 0, kl, bn, Da, wl, Tl, Cl, Al;
    function Ll() {
    }
    Ll.__reactDisabledLog = !0;
    function Hs() {
      {
        if (oi === 0) {
          kl = console.log, bn = console.info, Da = console.warn, wl = console.error, Tl = console.group, Cl = console.groupCollapsed, Al = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Ll,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        oi++;
      }
    }
    function Vs() {
      {
        if (oi--, oi === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: yr({}, u, {
              value: kl
            }),
            info: yr({}, u, {
              value: bn
            }),
            warn: yr({}, u, {
              value: Da
            }),
            error: yr({}, u, {
              value: wl
            }),
            group: yr({}, u, {
              value: Tl
            }),
            groupCollapsed: yr({}, u, {
              value: Cl
            }),
            groupEnd: yr({}, u, {
              value: Al
            })
          });
        }
        oi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var fo = r.ReactCurrentDispatcher, Pl;
    function li(u, m, T) {
      {
        if (Pl === void 0)
          try {
            throw Error();
          } catch (q) {
            var M = q.stack.trim().match(/\n( *(at )?)/);
            Pl = M && M[1] || "";
          }
        return `
` + Pl + u;
      }
    }
    var si = !1, _a;
    {
      var ui = typeof WeakMap == "function" ? WeakMap : Map;
      _a = new ui();
    }
    function ci(u, m) {
      if (!u || si)
        return "";
      {
        var T = _a.get(u);
        if (T !== void 0)
          return T;
      }
      var M;
      si = !0;
      var q = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var de;
      de = fo.current, fo.current = null, Hs();
      try {
        if (m) {
          var me = function() {
            throw Error();
          };
          if (Object.defineProperty(me.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(me, []);
            } catch (he) {
              M = he;
            }
            Reflect.construct(u, [], me);
          } else {
            try {
              me.call();
            } catch (he) {
              M = he;
            }
            u.call(me.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (he) {
            M = he;
          }
          u();
        }
      } catch (he) {
        if (he && M && typeof he.stack == "string") {
          for (var Le = he.stack.split(`
`), l = M.stack.split(`
`), f = Le.length - 1, k = l.length - 1; f >= 1 && k >= 0 && Le[f] !== l[k]; )
            k--;
          for (; f >= 1 && k >= 0; f--, k--)
            if (Le[f] !== l[k]) {
              if (f !== 1 || k !== 1)
                do
                  if (f--, k--, k < 0 || Le[f] !== l[k]) {
                    var N = `
` + Le[f].replace(" at new ", " at ");
                    return u.displayName && N.includes("<anonymous>") && (N = N.replace("<anonymous>", u.displayName)), typeof u == "function" && _a.set(u, N), N;
                  }
                while (f >= 1 && k >= 0);
              break;
            }
        }
      } finally {
        si = !1, fo.current = de, Vs(), Error.prepareStackTrace = q;
      }
      var $ = u ? u.displayName || u.name : "", oe = $ ? li($) : "";
      return typeof u == "function" && _a.set(u, oe), oe;
    }
    function po(u, m, T) {
      return ci(u, !0);
    }
    function Ws(u, m, T) {
      return ci(u, !1);
    }
    function Rl(u) {
      var m = u.prototype;
      return !!(m && m.isReactComponent);
    }
    function Nl(u, m, T) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return ci(u, Rl(u));
      if (typeof u == "string")
        return li(u);
      switch (u) {
        case ri:
          return li("Suspense");
        case ai:
          return li("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case uo:
            return Ws(u.render);
          case ii:
            return Nl(u.type, m, T);
          case Na: {
            var M = u, q = M._payload, de = M._init;
            try {
              return Nl(de(q), m, T);
            } catch {
            }
          }
        }
      return "";
    }
    var Dl = {}, js = r.ReactDebugCurrentFrame;
    function Oa(u) {
      if (u) {
        var m = u._owner, T = Nl(u.type, u._source, m ? m.type : null);
        js.setExtraStackFrame(T);
      } else
        js.setExtraStackFrame(null);
    }
    function _l(u, m, T, M, q) {
      {
        var de = Function.call.bind(ee);
        for (var me in u)
          if (de(u, me)) {
            var Le = void 0;
            try {
              if (typeof u[me] != "function") {
                var l = Error((M || "React class") + ": " + T + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Le = u[me](m, me, M, T, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Le = f;
            }
            Le && !(Le instanceof Error) && (Oa(q), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", M || "React class", T, me, typeof Le), Oa(null)), Le instanceof Error && !(Le.message in Dl) && (Dl[Le.message] = !0, Oa(q), i("Failed %s type: %s", T, Le.message), Oa(null));
          }
      }
    }
    var ho;
    ho = {};
    var oa = {};
    Object.freeze(oa);
    function Ol(u, m) {
      {
        var T = u.contextTypes;
        if (!T)
          return oa;
        var M = {};
        for (var q in T)
          M[q] = m[q];
        {
          var de = Sn(u) || "Unknown";
          _l(T, M, "context", de);
        }
        return M;
      }
    }
    function Fl(u, m, T, M) {
      {
        if (typeof u.getChildContext != "function") {
          {
            var q = Sn(m) || "Unknown";
            ho[q] || (ho[q] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", q, q));
          }
          return T;
        }
        var de = u.getChildContext();
        for (var me in de)
          if (!(me in M))
            throw new Error((Sn(m) || "Unknown") + '.getChildContext(): key "' + me + '" is not defined in childContextTypes.');
        {
          var Le = Sn(m) || "Unknown";
          _l(M, de, "child context", Le);
        }
        return yr({}, T, de);
      }
    }
    var Kr;
    Kr = {};
    var Us = null, la = null;
    function sa(u) {
      u.context._currentValue = u.parentValue;
    }
    function Ml(u) {
      u.context._currentValue = u.value;
    }
    function Tr(u, m) {
      if (u !== m) {
        sa(u);
        var T = u.parent, M = m.parent;
        if (T === null) {
          if (M !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (M === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Tr(T, M);
        }
        Ml(m);
      }
    }
    function mo(u) {
      sa(u);
      var m = u.parent;
      m !== null && mo(m);
    }
    function yo(u) {
      var m = u.parent;
      m !== null && yo(m), Ml(u);
    }
    function di(u, m) {
      sa(u);
      var T = u.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      T.depth === m.depth ? Tr(T, m) : di(T, m);
    }
    function zl(u, m) {
      var T = m.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      u.depth === T.depth ? Tr(u, T) : zl(u, T), Ml(m);
    }
    function fi(u) {
      var m = la, T = u;
      m !== T && (m === null ? yo(T) : T === null ? mo(m) : m.depth === T.depth ? Tr(m, T) : m.depth > T.depth ? di(m, T) : zl(m, T), la = T);
    }
    function Ks(u, m) {
      var T;
      T = u._currentValue, u._currentValue = m, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Kr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Kr;
      var M = la, q = {
        parent: M,
        depth: M === null ? 0 : M.depth + 1,
        context: u,
        parentValue: T,
        value: m
      };
      return la = q, q;
    }
    function Ys(u) {
      var m = la;
      if (m === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      m.context !== u && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var T = m.parentValue;
        T === Qc ? m.context._currentValue = m.context._defaultValue : m.context._currentValue = T, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Kr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Kr;
      }
      return la = m.parent;
    }
    function go() {
      return la;
    }
    function pi(u) {
      var m = u._currentValue;
      return m;
    }
    function Bl(u) {
      return u._reactInternals;
    }
    function td(u, m) {
      u._reactInternals = m;
    }
    var Fa = {}, vo = {}, Il, xo, bo, hi, Eo, Ma, mi, So, za;
    {
      Il = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), hi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), za = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Ma = function(u, m) {
        if (!(u === null || typeof u == "function")) {
          var T = m + "_" + u;
          ko.has(T) || (ko.add(T), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", m, u));
        }
      }, Eo = function(u, m) {
        if (m === void 0) {
          var T = Sn(u) || "Component";
          hi.has(T) || (hi.add(T), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", T));
        }
      };
    }
    function wo(u, m) {
      {
        var T = u.constructor, M = T && Sn(T) || "ReactClass", q = M + "." + m;
        if (Fa[q])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, m, m, M), Fa[q] = !0;
      }
    }
    var To = {
      isMounted: function(u) {
        return !1;
      },
      enqueueSetState: function(u, m, T) {
        var M = Bl(u);
        M.queue === null ? wo(u, "setState") : (M.queue.push(m), T != null && Ma(T, "setState"));
      },
      enqueueReplaceState: function(u, m, T) {
        var M = Bl(u);
        M.replace = !0, M.queue = [m], T != null && Ma(T, "setState");
      },
      enqueueForceUpdate: function(u, m) {
        var T = Bl(u);
        T.queue === null ? wo(u, "forceUpdate") : m != null && Ma(m, "setState");
      }
    };
    function Gs(u, m, T, M, q) {
      var de = T(q, M);
      Eo(m, de);
      var me = de == null ? M : yr({}, M, de);
      return me;
    }
    function Xs(u, m, T) {
      var M = oa, q = u.contextType;
      if ("contextType" in u) {
        var de = (
          // Allow null for conditional declaration
          q === null || q !== void 0 && q.$$typeof === so && q._context === void 0
        );
        if (!de && !za.has(u)) {
          za.add(u);
          var me = "";
          q === void 0 ? me = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof q != "object" ? me = " However, it is set to a " + typeof q + "." : q.$$typeof === lo ? me = " Did you accidentally pass the Context.Provider instead?" : q._context !== void 0 ? me = " Did you accidentally pass the Context.Consumer instead?" : me = " However, it is set to an object with keys {" + Object.keys(q).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Sn(u) || "Component", me);
        }
      }
      typeof q == "object" && q !== null ? M = pi(q) : M = T;
      var Le = new u(m, M);
      {
        if (typeof u.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var l = Sn(u) || "Component";
          Il.has(l) || (Il.add(l), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Le.state === null ? "null" : "undefined", l));
        }
        if (typeof u.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var f = null, k = null, N = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? k = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (k = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? N = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (N = "UNSAFE_componentWillUpdate"), f !== null || k !== null || N !== null) {
            var $ = Sn(u) || "Component", oe = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            bo.has($) || (bo.add($), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, $, oe, f !== null ? `
  ` + f : "", k !== null ? `
  ` + k : "", N !== null ? `
  ` + N : ""));
          }
        }
      }
      return Le;
    }
    function qs(u, m, T) {
      {
        var M = Sn(m) || "Component", q = u.render;
        q || (m.prototype && typeof m.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", M) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", M)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", M), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", M), u.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", M), u.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", M), u.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", M), m.contextType && m.contextTypes && !So.has(m) && (So.add(m), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", M)), typeof u.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", M), m.prototype && m.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Sn(m) || "A pure component"), typeof u.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", M), typeof u.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", M), typeof u.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", M), typeof u.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", M);
        var de = u.props !== T;
        u.props !== void 0 && de && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", M, M), u.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", M, M), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !xo.has(m) && (xo.add(m), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Sn(m))), typeof u.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof u.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof m.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", M);
        var me = u.state;
        me && (typeof me != "object" || Ee(me)) && i("%s.state: must be set to an object or null", M), typeof u.getChildContext == "function" && typeof m.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", M);
      }
    }
    function nd(u, m) {
      var T = m.state;
      if (typeof m.componentWillMount == "function") {
        if (m.componentWillMount.__suppressDeprecationWarning !== !0) {
          var M = Sn(u) || "Unknown";
          vo[M] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            M
          ), vo[M] = !0);
        }
        m.componentWillMount();
      }
      typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), T !== m.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Sn(u) || "Component"), To.enqueueReplaceState(m, m.state, null));
    }
    function rd(u, m, T, M) {
      if (u.queue !== null && u.queue.length > 0) {
        var q = u.queue, de = u.replace;
        if (u.queue = null, u.replace = !1, de && q.length === 1)
          m.state = q[0];
        else {
          for (var me = de ? q[0] : m.state, Le = !0, l = de ? 1 : 0; l < q.length; l++) {
            var f = q[l], k = typeof f == "function" ? f.call(m, me, T, M) : f;
            k != null && (Le ? (Le = !1, me = yr({}, me, k)) : yr(me, k));
          }
          m.state = me;
        }
      } else
        u.queue = null;
    }
    function Zs(u, m, T, M) {
      qs(u, m, T);
      var q = u.state !== void 0 ? u.state : null;
      u.updater = To, u.props = T, u.state = q;
      var de = {
        queue: [],
        replace: !1
      };
      td(u, de);
      var me = m.contextType;
      if (typeof me == "object" && me !== null ? u.context = pi(me) : u.context = M, u.state === T) {
        var Le = Sn(m) || "Component";
        mi.has(Le) || (mi.add(Le), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var l = m.getDerivedStateFromProps;
      typeof l == "function" && (u.state = Gs(u, m, l, q, T)), typeof m.getDerivedStateFromProps != "function" && typeof u.getSnapshotBeforeUpdate != "function" && (typeof u.UNSAFE_componentWillMount == "function" || typeof u.componentWillMount == "function") && (nd(m, u), rd(de, u, T, M));
    }
    var ad = {
      id: 1,
      overflow: ""
    };
    function id(u) {
      var m = u.overflow, T = u.id, M = T & ~od(T);
      return M.toString(32) + m;
    }
    function Co(u, m, T) {
      var M = u.id, q = u.overflow, de = Ao(M) - 1, me = M & ~(1 << de), Le = T + 1, l = Ao(m) + de;
      if (l > 30) {
        var f = de - de % 5, k = (1 << f) - 1, N = (me & k).toString(32), $ = me >> f, oe = de - f, he = Ao(m) + oe, Ce = Le << oe, $e = Ce | $, nt = N + q;
        return {
          id: 1 << he | $e,
          overflow: nt
        };
      } else {
        var ot = Le << de, vt = ot | me, gn = q;
        return {
          id: 1 << l | vt,
          overflow: gn
        };
      }
    }
    function Ao(u) {
      return 32 - $l(u);
    }
    function od(u) {
      return 1 << Ao(u) - 1;
    }
    var $l = Math.clz32 ? Math.clz32 : sd, Lo = Math.log, ld = Math.LN2;
    function sd(u) {
      var m = u >>> 0;
      return m === 0 ? 32 : 31 - (Lo(m) / ld | 0) | 0;
    }
    function ud(u, m) {
      return u === m && (u !== 0 || 1 / u === 1 / m) || u !== u && m !== m;
    }
    var cd = typeof Object.is == "function" ? Object.is : ud, Or = null, Hl = null, Po = null, Mt = null, ua = !1, ca = !1, Xt = 0, gr = null, da = 0, Ro = 25, $n = !1, Fr;
    function fa() {
      if (Or === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return $n && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Or;
    }
    function Cr(u, m) {
      if (m === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Fr), !1;
      u.length !== m.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Fr, "[" + u.join(", ") + "]", "[" + m.join(", ") + "]");
      for (var T = 0; T < m.length && T < u.length; T++)
        if (!cd(u[T], m[T]))
          return !1;
      return !0;
    }
    function pa() {
      if (da > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Mr() {
      return Mt === null ? Po === null ? (ua = !1, Po = Mt = pa()) : (ua = !0, Mt = Po) : Mt.next === null ? (ua = !1, Mt = Mt.next = pa()) : (ua = !0, Mt = Mt.next), Mt;
    }
    function dd(u, m) {
      Or = m, Hl = u, $n = !1, Xt = 0;
    }
    function Qs(u, m, T, M) {
      for (; ca; )
        ca = !1, Xt = 0, da += 1, Mt = null, T = u(m, M);
      return Vl(), T;
    }
    function No() {
      var u = Xt !== 0;
      return u;
    }
    function Vl() {
      $n = !1, Or = null, Hl = null, ca = !1, Po = null, da = 0, gr = null, Mt = null;
    }
    function fd(u) {
      return $n && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), pi(u);
    }
    function Js(u) {
      return Fr = "useContext", fa(), pi(u);
    }
    function yi(u, m) {
      return typeof m == "function" ? m(u) : m;
    }
    function pd(u) {
      return Fr = "useState", eu(
        yi,
        // useReducer has a special case to support lazy useState initializers
        u
      );
    }
    function eu(u, m, T) {
      if (u !== yi && (Fr = "useReducer"), Or = fa(), Mt = Mr(), ua) {
        var M = Mt.queue, q = M.dispatch;
        if (gr !== null) {
          var de = gr.get(M);
          if (de !== void 0) {
            gr.delete(M);
            var me = Mt.memoizedState, Le = de;
            do {
              var l = Le.action;
              $n = !0, me = u(me, l), $n = !1, Le = Le.next;
            } while (Le !== null);
            return Mt.memoizedState = me, [me, q];
          }
        }
        return [Mt.memoizedState, q];
      } else {
        $n = !0;
        var f;
        u === yi ? f = typeof m == "function" ? m() : m : f = T !== void 0 ? T(m) : m, $n = !1, Mt.memoizedState = f;
        var k = Mt.queue = {
          last: null,
          dispatch: null
        }, N = k.dispatch = nu.bind(null, Or, k);
        return [Mt.memoizedState, N];
      }
    }
    function Do(u, m) {
      Or = fa(), Mt = Mr();
      var T = m === void 0 ? null : m;
      if (Mt !== null) {
        var M = Mt.memoizedState;
        if (M !== null && T !== null) {
          var q = M[1];
          if (Cr(T, q))
            return M[0];
        }
      }
      $n = !0;
      var de = u();
      return $n = !1, Mt.memoizedState = [de, T], de;
    }
    function hd(u) {
      Or = fa(), Mt = Mr();
      var m = Mt.memoizedState;
      if (m === null) {
        var T = {
          current: u
        };
        return Object.seal(T), Mt.memoizedState = T, T;
      } else
        return m;
    }
    function tu(u, m) {
      Fr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function nu(u, m, T) {
      if (da >= Ro)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (u === Or) {
        ca = !0;
        var M = {
          action: T,
          next: null
        };
        gr === null && (gr = /* @__PURE__ */ new Map());
        var q = gr.get(m);
        if (q === void 0)
          gr.set(m, M);
        else {
          for (var de = q; de.next !== null; )
            de = de.next;
          de.next = M;
        }
      }
    }
    function md(u, m) {
      return Do(function() {
        return u;
      }, m);
    }
    function yd(u, m, T) {
      return fa(), m(u._source);
    }
    function gd(u, m, T) {
      if (T === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return T();
    }
    function vd(u) {
      return fa(), u;
    }
    function xd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function bd() {
      return fa(), [!1, xd];
    }
    function Ed() {
      var u = Hl, m = id(u.treeContext), T = Wl;
      if (T === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var M = Xt++;
      return an(T, m, M);
    }
    function _o() {
    }
    var ru = {
      readContext: fd,
      useContext: Js,
      useMemo: Do,
      useReducer: eu,
      useRef: hd,
      useState: pd,
      useInsertionEffect: _o,
      useLayoutEffect: tu,
      useCallback: md,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: _o,
      // Effects are not run in the server environment.
      useEffect: _o,
      // Debugging effect
      useDebugValue: _o,
      useDeferredValue: vd,
      useTransition: bd,
      useId: Ed,
      // Subscriptions are not setup in a server environment.
      useMutableSource: yd,
      useSyncExternalStore: gd
    }, Wl = null;
    function gi(u) {
      Wl = u;
    }
    function au(u) {
      try {
        var m = "", T = u;
        do {
          switch (T.tag) {
            case 0:
              m += li(T.type, null, null);
              break;
            case 1:
              m += Ws(T.type, null, null);
              break;
            case 2:
              m += po(T.type, null, null);
              break;
          }
          T = T.parent;
        } while (T);
        return m;
      } catch (M) {
        return `
Error generating stack: ` + M.message + `
` + M.stack;
      }
    }
    var vi = r.ReactCurrentDispatcher, Oo = r.ReactDebugCurrentFrame, jl = 0, Yr = 1, Fo = 2, Mo = 3, ha = 4, iu = 0, Ul = 1, ma = 2, Sd = 12800;
    function ou(u) {
      return console.error(u), null;
    }
    function Ar() {
    }
    function kd(u, m, T, M, q, de, me, Le, l) {
      var f = [], k = /* @__PURE__ */ new Set(), N = {
        destination: null,
        responseState: m,
        progressiveChunkSize: M === void 0 ? Sd : M,
        status: iu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: k,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: q === void 0 ? ou : q,
        onAllReady: de === void 0 ? Ar : de,
        onShellReady: me === void 0 ? Ar : me,
        onShellError: Le === void 0 ? Ar : Le,
        onFatalError: l === void 0 ? Ar : l
      }, $ = zo(
        N,
        0,
        null,
        T,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      $.parentFlushed = !0;
      var oe = Kl(N, u, null, $, k, oa, Us, ad);
      return f.push(oe), N;
    }
    function wd(u, m) {
      var T = u.pingedTasks;
      T.push(m), T.length === 1 && d(function() {
        return wi(u);
      });
    }
    function xi(u, m) {
      return {
        id: Fn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: m,
        errorDigest: null
      };
    }
    function Kl(u, m, T, M, q, de, me, Le) {
      u.allPendingTasks++, T === null ? u.pendingRootTasks++ : T.pendingTasks++;
      var l = {
        node: m,
        ping: function() {
          return wd(u, l);
        },
        blockedBoundary: T,
        blockedSegment: M,
        abortSet: q,
        legacyContext: de,
        context: me,
        treeContext: Le
      };
      return l.componentStack = null, q.add(l), l;
    }
    function zo(u, m, T, M, q, de) {
      return {
        status: jl,
        id: -1,
        // lazily assigned later
        index: m,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: M,
        boundary: T,
        lastPushedText: q,
        textEmbedded: de
      };
    }
    var zr = null;
    function bi() {
      return zr === null || zr.componentStack === null ? "" : au(zr.componentStack);
    }
    function Gr(u, m) {
      u.componentStack = {
        tag: 0,
        parent: u.componentStack,
        type: m
      };
    }
    function Lr(u, m) {
      u.componentStack = {
        tag: 1,
        parent: u.componentStack,
        type: m
      };
    }
    function Yl(u, m) {
      u.componentStack = {
        tag: 2,
        parent: u.componentStack,
        type: m
      };
    }
    function vr(u) {
      u.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : u.componentStack = u.componentStack.parent;
    }
    var Ba = null;
    function Gl(u, m) {
      {
        var T;
        typeof m == "string" ? T = m : m && typeof m.message == "string" ? T = m.message : T = String(m);
        var M = Ba || bi();
        Ba = null, u.errorMessage = T, u.errorComponentStack = M;
      }
    }
    function xr(u, m) {
      var T = u.onError(m);
      if (T != null && typeof T != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof T + '" instead');
      return T;
    }
    function Xr(u, m) {
      var T = u.onShellError;
      T(m);
      var M = u.onFatalError;
      M(m), u.destination !== null ? (u.status = ma, L(u.destination, m)) : (u.status = Ul, u.fatalError = m);
    }
    function Xl(u, m, T) {
      Gr(m, "Suspense");
      var M = m.blockedBoundary, q = m.blockedSegment, de = T.fallback, me = T.children, Le = /* @__PURE__ */ new Set(), l = xi(u, Le), f = q.chunks.length, k = zo(
        u,
        f,
        l,
        q.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      q.children.push(k), q.lastPushedText = !1;
      var N = zo(
        u,
        0,
        null,
        q.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      N.parentFlushed = !0, m.blockedBoundary = l, m.blockedSegment = N;
      try {
        if (as(u, m, me), Qn(N.chunks, u.responseState, N.lastPushedText, N.textEmbedded), N.status = Yr, $o(l, N), l.pendingTasks === 0) {
          vr(m);
          return;
        }
      } catch (oe) {
        N.status = ha, l.forceClientRender = !0, l.errorDigest = xr(u, oe), Gl(l, oe);
      } finally {
        m.blockedBoundary = M, m.blockedSegment = q;
      }
      var $ = Kl(u, de, M, k, Le, m.legacyContext, m.context, m.treeContext);
      $.componentStack = m.componentStack, u.pingedTasks.push($), vr(m);
    }
    function Ei(u, m, T, M) {
      Gr(m, T);
      var q = m.blockedSegment, de = Za(q.chunks, T, M, u.responseState, q.formatContext);
      q.lastPushedText = !1;
      var me = q.formatContext;
      q.formatContext = On(me, T, M), as(u, m, de), q.formatContext = me, Xi(q.chunks, T), q.lastPushedText = !1, vr(m);
    }
    function Bo(u) {
      return u.prototype && u.prototype.isReactComponent;
    }
    function lu(u, m, T, M, q) {
      var de = {};
      dd(m, de);
      var me = T(M, q);
      return Qs(T, M, me, q);
    }
    function su(u, m, T, M, q) {
      var de = T.render();
      T.props !== q && (ki || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Sn(M) || "a component"), ki = !0);
      {
        var me = M.childContextTypes;
        if (me != null) {
          var Le = m.legacyContext, l = Fl(T, M, Le, me);
          m.legacyContext = l, dr(u, m, de), m.legacyContext = Le;
          return;
        }
      }
      dr(u, m, de);
    }
    function Td(u, m, T, M) {
      Yl(m, T);
      var q = Ol(T, m.legacyContext), de = Xs(T, M, q);
      Zs(de, T, M, q), su(u, m, de, T, M), vr(m);
    }
    var ql = {}, Si = {}, uu = {}, Zl = {}, ki = !1, Ql = !1, Jl = !1, es = !1;
    function cu(u, m, T, M) {
      var q;
      if (q = Ol(T, m.legacyContext), Lr(m, T), T.prototype && typeof T.prototype.render == "function") {
        var de = Sn(T) || "Unknown";
        ql[de] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", de, de), ql[de] = !0);
      }
      var me = lu(u, m, T, M, q), Le = No();
      if (typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0) {
        var l = Sn(T) || "Unknown";
        Si[l] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), Si[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0
      ) {
        {
          var f = Sn(T) || "Unknown";
          Si[f] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), Si[f] = !0);
        }
        Zs(me, T, M, q), su(u, m, me, T, M);
      } else if (du(T), Le) {
        var k = m.treeContext, N = 1, $ = 0;
        m.treeContext = Co(k, N, $);
        try {
          dr(u, m, me);
        } finally {
          m.treeContext = k;
        }
      } else
        dr(u, m, me);
      vr(m);
    }
    function du(u) {
      {
        if (u && u.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), typeof u.getDerivedStateFromProps == "function") {
          var m = Sn(u) || "Unknown";
          Zl[m] || (i("%s: Function components do not support getDerivedStateFromProps.", m), Zl[m] = !0);
        }
        if (typeof u.contextType == "object" && u.contextType !== null) {
          var T = Sn(u) || "Unknown";
          uu[T] || (i("%s: Function components do not support contextType.", T), uu[T] = !0);
        }
      }
    }
    function ts(u, m) {
      if (u && u.defaultProps) {
        var T = yr({}, m), M = u.defaultProps;
        for (var q in M)
          T[q] === void 0 && (T[q] = M[q]);
        return T;
      }
      return m;
    }
    function Cd(u, m, T, M, q) {
      Lr(m, T.render);
      var de = lu(u, m, T.render, M, q), me = No();
      if (me) {
        var Le = m.treeContext, l = 1, f = 0;
        m.treeContext = Co(Le, l, f);
        try {
          dr(u, m, de);
        } finally {
          m.treeContext = Le;
        }
      } else
        dr(u, m, de);
      vr(m);
    }
    function Ad(u, m, T, M, q) {
      var de = T.type, me = ts(de, M);
      ns(u, m, de, me, q);
    }
    function fu(u, m, T, M) {
      T._context === void 0 ? T !== T.Consumer && (es || (es = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : T = T._context;
      var q = M.children;
      typeof q != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var de = pi(T), me = q(de);
      dr(u, m, me);
    }
    function Ld(u, m, T, M) {
      var q = T._context, de = M.value, me = M.children, Le;
      Le = m.context, m.context = Ks(q, de), dr(u, m, me), m.context = Ys(q), Le !== m.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Pd(u, m, T, M, q) {
      Gr(m, "Lazy");
      var de = T._payload, me = T._init, Le = me(de), l = ts(Le, M);
      ns(u, m, Le, l, q), vr(m);
    }
    function ns(u, m, T, M, q) {
      if (typeof T == "function")
        if (Bo(T)) {
          Td(u, m, T, M);
          return;
        } else {
          cu(u, m, T, M);
          return;
        }
      if (typeof T == "string") {
        Ei(u, m, T, M);
        return;
      }
      switch (T) {
        case co:
        case Sl:
        case zs:
        case bl:
        case cr: {
          dr(u, m, M.children);
          return;
        }
        case ai: {
          Gr(m, "SuspenseList"), dr(u, m, M.children), vr(m);
          return;
        }
        case El:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ri: {
          Xl(u, m, M);
          return;
        }
      }
      if (typeof T == "object" && T !== null)
        switch (T.$$typeof) {
          case uo: {
            Cd(u, m, T, M, q);
            return;
          }
          case ii: {
            Ad(u, m, T, M, q);
            return;
          }
          case lo: {
            Ld(u, m, T, M);
            return;
          }
          case so: {
            fu(u, m, T, M);
            return;
          }
          case Na: {
            Pd(u, m, T, M);
            return;
          }
        }
      var de = "";
      throw (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (T == null ? T : typeof T) + "." + de));
    }
    function Rd(u, m) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      u[Symbol.toStringTag] === "Generator" && (Ql || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ql = !0), u.entries === m && (Jl || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Jl = !0);
    }
    function dr(u, m, T) {
      try {
        return rs(u, m, T);
      } catch (M) {
        throw typeof M == "object" && M !== null && typeof M.then == "function" || (Ba = Ba !== null ? Ba : bi()), M;
      }
    }
    function rs(u, m, T) {
      if (m.node = T, typeof T == "object" && T !== null) {
        switch (T.$$typeof) {
          case Zc: {
            var M = T, q = M.type, de = M.props, me = M.ref;
            ns(u, m, q, de, me);
            return;
          }
          case Ms:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Na: {
            var Le = T, l = Le._payload, f = Le._init, k;
            try {
              k = f(l);
            } catch (ot) {
              throw typeof ot == "object" && ot !== null && typeof ot.then == "function" && Gr(m, "Lazy"), ot;
            }
            dr(u, m, k);
            return;
          }
        }
        if (Ee(T)) {
          pu(u, m, T);
          return;
        }
        var N = ed(T);
        if (N) {
          Rd(T, N);
          var $ = N.call(T);
          if ($) {
            var oe = $.next();
            if (!oe.done) {
              var he = [];
              do
                he.push(oe.value), oe = $.next();
              while (!oe.done);
              pu(u, m, he);
              return;
            }
            return;
          }
        }
        var Ce = Object.prototype.toString.call(T);
        throw new Error("Objects are not valid as a React child (found: " + (Ce === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : Ce) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof T == "string") {
        var $e = m.blockedSegment;
        $e.lastPushedText = Zn(m.blockedSegment.chunks, T, u.responseState, $e.lastPushedText);
        return;
      }
      if (typeof T == "number") {
        var nt = m.blockedSegment;
        nt.lastPushedText = Zn(m.blockedSegment.chunks, "" + T, u.responseState, nt.lastPushedText);
        return;
      }
      typeof T == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function pu(u, m, T) {
      for (var M = T.length, q = 0; q < M; q++) {
        var de = m.treeContext;
        m.treeContext = Co(de, M, q);
        try {
          as(u, m, T[q]);
        } finally {
          m.treeContext = de;
        }
      }
    }
    function fr(u, m, T) {
      var M = m.blockedSegment, q = M.chunks.length, de = zo(
        u,
        q,
        null,
        M.formatContext,
        // Adopt the parent segment's leading text embed
        M.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      M.children.push(de), M.lastPushedText = !1;
      var me = Kl(u, m.node, m.blockedBoundary, de, m.abortSet, m.legacyContext, m.context, m.treeContext);
      m.componentStack !== null && (me.componentStack = m.componentStack.parent);
      var Le = me.ping;
      T.then(Le, Le);
    }
    function as(u, m, T) {
      var M = m.blockedSegment.formatContext, q = m.legacyContext, de = m.context, me = null;
      me = m.componentStack;
      try {
        return dr(u, m, T);
      } catch (Le) {
        if (Vl(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          fr(u, m, Le), m.blockedSegment.formatContext = M, m.legacyContext = q, m.context = de, fi(de), m.componentStack = me;
          return;
        } else
          throw m.blockedSegment.formatContext = M, m.legacyContext = q, m.context = de, fi(de), m.componentStack = me, Le;
      }
    }
    function hu(u, m, T, M) {
      var q = xr(u, M);
      if (m === null ? Xr(u, M) : (m.pendingTasks--, m.forceClientRender || (m.forceClientRender = !0, m.errorDigest = q, Gl(m, M), m.parentFlushed && u.clientRenderedBoundaries.push(m))), u.allPendingTasks--, u.allPendingTasks === 0) {
        var de = u.onAllReady;
        de();
      }
    }
    function Nd(u) {
      var m = this, T = u.blockedBoundary, M = u.blockedSegment;
      M.status = Mo, mu(m, T, M);
    }
    function Io(u, m, T) {
      var M = u.blockedBoundary, q = u.blockedSegment;
      if (q.status = Mo, M === null)
        m.allPendingTasks--, m.status !== ma && (m.status = ma, m.destination !== null && S(m.destination));
      else {
        if (M.pendingTasks--, !M.forceClientRender) {
          M.forceClientRender = !0;
          var de = T === void 0 ? new Error("The render was aborted by the server without a reason.") : T;
          M.errorDigest = m.onError(de);
          {
            var me = "The server did not finish this Suspense boundary: ";
            de && typeof de.message == "string" ? de = me + de.message : de = me + String(de);
            var Le = zr;
            zr = u;
            try {
              Gl(M, de);
            } finally {
              zr = Le;
            }
          }
          M.parentFlushed && m.clientRenderedBoundaries.push(M);
        }
        if (M.fallbackAbortableTasks.forEach(function(f) {
          return Io(f, m, T);
        }), M.fallbackAbortableTasks.clear(), m.allPendingTasks--, m.allPendingTasks === 0) {
          var l = m.onAllReady;
          l();
        }
      }
    }
    function $o(u, m) {
      if (m.chunks.length === 0 && m.children.length === 1 && m.children[0].boundary === null) {
        var T = m.children[0];
        T.id = m.id, T.parentFlushed = !0, T.status === Yr && $o(u, T);
      } else {
        var M = u.completedSegments;
        M.push(m);
      }
    }
    function mu(u, m, T) {
      if (m === null) {
        if (T.parentFlushed) {
          if (u.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          u.completedRootSegment = T;
        }
        if (u.pendingRootTasks--, u.pendingRootTasks === 0) {
          u.onShellError = Ar;
          var M = u.onShellReady;
          M();
        }
      } else if (m.pendingTasks--, !m.forceClientRender) {
        if (m.pendingTasks === 0)
          T.parentFlushed && T.status === Yr && $o(m, T), m.parentFlushed && u.completedBoundaries.push(m), m.fallbackAbortableTasks.forEach(Nd, u), m.fallbackAbortableTasks.clear();
        else if (T.parentFlushed && T.status === Yr) {
          $o(m, T);
          var q = m.completedSegments;
          q.length === 1 && m.parentFlushed && u.partialBoundaries.push(m);
        }
      }
      if (u.allPendingTasks--, u.allPendingTasks === 0) {
        var de = u.onAllReady;
        de();
      }
    }
    function yu(u, m) {
      var T = m.blockedSegment;
      if (T.status === jl) {
        fi(m.context);
        var M = null;
        M = zr, zr = m;
        try {
          dr(u, m, m.node), Qn(T.chunks, u.responseState, T.lastPushedText, T.textEmbedded), m.abortSet.delete(m), T.status = Yr, mu(u, m.blockedBoundary, T);
        } catch (de) {
          if (Vl(), typeof de == "object" && de !== null && typeof de.then == "function") {
            var q = m.ping;
            de.then(q, q);
          } else
            m.abortSet.delete(m), T.status = ha, hu(u, m.blockedBoundary, T, de);
        } finally {
          zr = M;
        }
      }
    }
    function wi(u) {
      if (u.status !== ma) {
        var m = go(), T = vi.current;
        vi.current = ru;
        var M;
        M = Oo.getCurrentStack, Oo.getCurrentStack = bi;
        var q = Wl;
        gi(u.responseState);
        try {
          var de = u.pingedTasks, me;
          for (me = 0; me < de.length; me++) {
            var Le = de[me];
            yu(u, Le);
          }
          de.splice(0, me), u.destination !== null && Vo(u, u.destination);
        } catch (l) {
          xr(u, l), Xr(u, l);
        } finally {
          gi(q), vi.current = T, Oo.getCurrentStack = M, T === ru && fi(m);
        }
      }
    }
    function Ti(u, m, T) {
      switch (T.parentFlushed = !0, T.status) {
        case jl: {
          var M = T.id = u.nextSegmentId++;
          return T.lastPushedText = !1, T.textEmbedded = !1, Sa(m, u.responseState, M);
        }
        case Yr: {
          T.status = Fo;
          for (var q = !0, de = T.chunks, me = 0, Le = T.children, l = 0; l < Le.length; l++) {
            for (var f = Le[l]; me < f.index; me++)
              g(m, de[me]);
            q = Ho(u, m, f);
          }
          for (; me < de.length - 1; me++)
            g(m, de[me]);
          return me < de.length && (q = x(m, de[me])), q;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(u, m, T) {
      var M = T.boundary;
      if (M === null)
        return Ti(u, m, T);
      if (M.parentFlushed = !0, M.forceClientRender)
        return Xn(m, u.responseState, M.errorDigest, M.errorMessage, M.errorComponentStack), Ti(u, m, T), ml(m, u.responseState);
      if (M.pendingTasks > 0) {
        M.rootSegmentID = u.nextSegmentId++, M.completedSegments.length > 0 && u.partialBoundaries.push(M);
        var q = M.id = Kn(u.responseState);
        return Ta(m, u.responseState, q), Ti(u, m, T), Ca(m, u.responseState);
      } else {
        if (M.byteSize > u.progressiveChunkSize)
          return M.rootSegmentID = u.nextSegmentId++, u.completedBoundaries.push(M), Ta(m, u.responseState, M.id), Ti(u, m, T), Ca(m, u.responseState);
        Zi(m, u.responseState);
        var de = M.completedSegments;
        if (de.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var me = de[0];
        return Ho(u, m, me), Qi(m, u.responseState);
      }
    }
    function gu(u, m, T) {
      return Os(m, u.responseState, T.id, T.errorDigest, T.errorMessage, T.errorComponentStack);
    }
    function Ci(u, m, T) {
      return bt(m, u.responseState, T.formatContext, T.id), Ho(u, m, T), on(m, T.formatContext);
    }
    function Ai(u, m, T) {
      for (var M = T.completedSegments, q = 0; q < M.length; q++) {
        var de = M[q];
        is(u, m, T, de);
      }
      return M.length = 0, yl(m, u.responseState, T.id, T.rootSegmentID);
    }
    function Dd(u, m, T) {
      for (var M = T.completedSegments, q = 0; q < M.length; q++) {
        var de = M[q];
        if (!is(u, m, T, de))
          return q++, M.splice(0, q), !1;
      }
      return M.splice(0, q), !0;
    }
    function is(u, m, T, M) {
      if (M.status === Fo)
        return !0;
      var q = M.id;
      if (q === -1) {
        var de = M.id = T.rootSegmentID;
        if (de === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ci(u, m, M);
      } else
        return Ci(u, m, M), Wc(m, u.responseState, q);
    }
    function Vo(u, m) {
      y();
      try {
        var T = u.completedRootSegment;
        T !== null && u.pendingRootTasks === 0 && (Ho(u, m, T), u.completedRootSegment = null, fl(m, u.responseState));
        var M = u.clientRenderedBoundaries, q;
        for (q = 0; q < M.length; q++) {
          var de = M[q];
          gu(u, m, de);
        }
        M.splice(0, q);
        var me = u.completedBoundaries;
        for (q = 0; q < me.length; q++) {
          var Le = me[q];
          Ai(u, m, Le);
        }
        me.splice(0, q), w(m), y(m);
        var l = u.partialBoundaries;
        for (q = 0; q < l.length; q++) {
          var f = l[q];
          if (!Dd(u, m, f)) {
            u.destination = null, q++, l.splice(0, q);
            return;
          }
        }
        l.splice(0, q);
        var k = u.completedBoundaries;
        for (q = 0; q < k.length; q++) {
          var N = k[q];
          Ai(u, m, N);
        }
        k.splice(0, q);
      } finally {
        w(m), u.allPendingTasks === 0 && u.pingedTasks.length === 0 && u.clientRenderedBoundaries.length === 0 && u.completedBoundaries.length === 0 && (u.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), S(m));
      }
    }
    function _d(u) {
      d(function() {
        return wi(u);
      });
    }
    function vu(u, m) {
      if (u.status === Ul) {
        u.status = ma, L(m, u.fatalError);
        return;
      }
      if (u.status !== ma && u.destination === null) {
        u.destination = m;
        try {
          Vo(u, m);
        } catch (T) {
          xr(u, T), Xr(u, T);
        }
      }
    }
    function Wo(u, m) {
      try {
        var T = u.abortableTasks;
        T.forEach(function(M) {
          return Io(M, u, m);
        }), T.clear(), u.destination !== null && Vo(u, u.destination);
      } catch (M) {
        xr(u, M), Xr(u, M);
      }
    }
    function Od(u, m) {
      return new Promise(function(T, M) {
        var q, de, me = new Promise(function($, oe) {
          de = $, q = oe;
        });
        function Le() {
          var $ = new ReadableStream(
            {
              type: "bytes",
              pull: function(oe) {
                vu(f, oe);
              },
              cancel: function(oe) {
                Wo(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          $.allReady = me, T($);
        }
        function l($) {
          me.catch(function() {
          }), M($);
        }
        var f = kd(u, Zt(m ? m.identifierPrefix : void 0, m ? m.nonce : void 0, m ? m.bootstrapScriptContent : void 0, m ? m.bootstrapScripts : void 0, m ? m.bootstrapModules : void 0), _n(m ? m.namespaceURI : void 0), m ? m.progressiveChunkSize : void 0, m ? m.onError : void 0, de, Le, l, q);
        if (m && m.signal) {
          var k = m.signal, N = function() {
            Wo(f, k.reason), k.removeEventListener("abort", N);
          };
          k.addEventListener("abort", N);
        }
        _d(f);
      });
    }
    Mu.renderToReadableStream = Od, Mu.version = t;
  }()), Mu;
}
var Wi, $f;
process.env.NODE_ENV === "production" ? (Wi = gS(), $f = vS()) : (Wi = xS(), $f = bS());
Xa.version = Wi.version;
Xa.renderToString = Wi.renderToString;
Xa.renderToStaticMarkup = Wi.renderToStaticMarkup;
Xa.renderToNodeStream = Wi.renderToNodeStream;
Xa.renderToStaticNodeStream = Wi.renderToStaticNodeStream;
Xa.renderToReadableStream = $f.renderToReadableStream;
const tm = ({ columnData: e }) => /* @__PURE__ */ n.createElement("ul", null, e == null ? void 0 : e.map((t, r) => /* @__PURE__ */ n.createElement("li", { key: r }, t.label, ": ", t.value, " (", t.additional_info, "%)"))), ES = (e, t) => {
  var y, g, x, w, S, A;
  const r = `${(((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((p) => p.node === t)) || {}).value}`, a = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((p) => p.node === t)) || {}).summary}`, i = (((x = e == null ? void 0 : e.tooltips) == null ? void 0 : x.find((p) => p.node === t)) || {}).column1Label, o = (((w = e == null ? void 0 : e.tooltips) == null ? void 0 : w.find((p) => p.node === t)) || {}).column2Label, d = (((S = e == null ? void 0 : e.tooltips) == null ? void 0 : S.find((p) => p.node === t)) || {}).column1, c = (((A = e == null ? void 0 : e.tooltips) == null ? void 0 : A.find((p) => p.node === t)) || {}).column2, s = Xa.renderToString(/* @__PURE__ */ n.createElement(tm, { columnData: d })), h = Xa.renderToString(/* @__PURE__ */ n.createElement(tm, { columnData: c }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${r}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${a}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${s}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${h}
      </div>
    </div>
  </div>
`;
}, SS = ({ width: e, height: t, runtime: r }) => {
  var Y, ae;
  const { config: a } = se.useContext(pt), { sankey: i } = a, [o, d] = se.useState(0), [c, s] = se.useState(""), { showAlert: h, alert: y } = yS(), g = se.useRef([]), x = (B) => {
    const X = c;
    X && s(""), X !== B && s(B);
  };
  if (se.useEffect(() => {
    var X;
    let B = 0;
    (X = g == null ? void 0 : g.current) == null || X.map((ce) => {
      const ne = ce == null ? void 0 : ce.getBoundingClientRect().width;
      ne > B && (B = ne);
    }), d(B);
  }, [g, i, window.innerWidth]), a.visualizationType !== "Sankey")
    return;
  const w = a == null ? void 0 : a.data[0], S = Array.from(new Set((Y = w == null ? void 0 : w.links) == null ? void 0 : Y.flatMap((B) => [B.source, B.target]))), A = {
    nodes: S.map((B) => ({ id: B })),
    links: (ae = w == null ? void 0 : w.links) == null ? void 0 : ae.map((B) => ({
      source: S.findIndex((X) => X === B.source),
      target: S.findIndex((X) => X === B.target),
      value: B.value
    }))
  };
  let p = 5;
  const v = 50, L = fS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(lS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - p - o, a.heights.vertical - v]
  ]), { links: P } = L(A), R = (B) => {
    var V;
    let X = 30, ce = 0, ne = "node-value--storynode", Q = !0;
    return (V = w == null ? void 0 : w.storyNodeText) != null && V.every((j) => j.StoryNode !== B) && (Q = !1, ce = 10, X = 8, ne = "node-value"), { textPositionHorizontal: X, textPositionVertical: ce, classStyle: ne, storyNodes: Q };
  }, C = (B) => {
    if (!(A != null && A.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const X = A.nodes.find((Q) => Q.id === B), ce = [], ne = [];
    return X && (P.forEach((Q) => {
      const V = Q.target, j = Q.source;
      V.id === B && ce.push(j.id);
    }), ce.forEach((Q) => {
      P.forEach((V) => {
        const j = V.target, te = V.source;
        j.id === c && te.id === Q && ne.push(V);
      });
    })), { sourceNodes: ce, activeLinks: ne };
  }, z = ES(w, c), W = A.nodes.map((B, X) => {
    var xe, be;
    let { textPositionHorizontal: ce, textPositionVertical: ne, classStyle: Q, storyNodes: V } = R(B.id), { sourceNodes: j } = C(c), te = i.opacity.nodeOpacityDefault, U = i.nodeColor.default;
    c !== B.id && c !== "" && !j.includes(B.id) && (U = i.nodeColor.inactive, te = i.opacity.nodeOpacityInactive);
    const ue = L.nodeWidth(), ke = () => Math.sqrt(
      Math.pow(P[0].target.x0 - P[0].source.x1, 2) + Math.pow(P[0].target.y0 - P[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ n.createElement(et, { className: "", key: X }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: ue,
        x: B.x0,
        y: B.y0 - 1,
        fill: U,
        fillOpacity: te,
        rx: i.rxValue,
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        onClick: () => x(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), V ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      dt,
      {
        width: ke(),
        x: B.x0 + ce,
        textAnchor: A.nodes.length - 1 === X ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((xe = w == null ? void 0 : w.storyNodeText) == null ? void 0 : xe.find((Ae) => Ae.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        width: ke(),
        verticalAnchor: "middle",
        className: Q,
        x: B.x0 + ce,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        width: ke(),
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: A.nodes.length === X ? "end" : "start",
        className: "node-text",
        verticalAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((be = w == null ? void 0 : w.storyNodeText) == null ? void 0 : be.find((Ae) => Ae.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      dt,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + ne,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      B.id
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      /* @__PURE__ */ n.createElement("tspan", { className: Q }, i.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + i.nodeValueStyle.textAfter)
    )));
  }), Z = P.map((B, X) => {
    const ne = mS()(B);
    let Q = i.opacity.LinkOpacityDefault, V = i.linkColor.default, { activeLinks: j } = C(c);
    return !j.includes(B) && c !== "" && (V = i.linkColor.inactive, Q = i.opacity.LinkOpacityInactive), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: X,
        d: ne,
        stroke: V,
        fill: "none",
        strokeOpacity: Q,
        strokeWidth: B.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.target.id || null),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      }
    );
  }), ee = A.nodes.reduce((B, X) => Math.max(B, X.depth), -1), le = A.nodes.filter((B) => B.depth === ee).map((B, X) => {
    var ue, ke;
    let { textPositionHorizontal: ce, textPositionVertical: ne, classStyle: Q, storyNodes: V } = R(B.id), { sourceNodes: j } = C(c), te = i.opacity.nodeOpacityDefault, U = i.nodeColor.default;
    return c !== B.id && c !== "" && !j.includes(B.id) && (U = i.nodeColor.inactive, te = i.opacity.nodeOpacityInactive), /* @__PURE__ */ n.createElement(et, { className: "", key: X, innerRef: (xe) => g.current[X] = xe }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: L.nodeWidth(),
        x: B.x0,
        y: B.y0 - 1,
        fill: U,
        fillOpacity: te,
        rx: i.rxValue,
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": "tooltip",
        onClick: () => x(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), V ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      dt,
      {
        x: B.x0 + ce,
        textAnchor: A.nodes.length - 1 === X ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((ue = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ue.find((xe) => xe.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        verticalAnchor: "end",
        className: Q,
        x: B.x0 + ce,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: A.nodes.length === X ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((ke = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ke.find((xe) => xe.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + ne,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { id: B.id, className: "node-id" }, B.id)
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ce,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { onClick: () => x(B.id), className: Q }, i.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + i.nodeValueStyle.textAfter)
    )));
  });
  return h ? y : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      className: "sankey-chart__diagram",
      width: e,
      height: Number(a.heights.vertical),
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ n.createElement(et, { className: "links" }, Z),
    /* @__PURE__ */ n.createElement(et, { className: "nodes" }, W),
    /* @__PURE__ */ n.createElement(et, { className: "finalNodes", style: { display: "none" } }, le)
  ), /* @__PURE__ */ n.createElement(
    mc,
    {
      id: `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
      afterHide: () => s(""),
      events: ["click"],
      place: "bottom",
      style: {
        backgroundColor: "rgba(238, 238, 238, 1)",
        color: "black",
        boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
      }
    }
  )));
};
var kS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const pr = kS;
function wS(e) {
  var t = e.labelOffset, r = e.labelProps, a = e.orientation, i = e.range, o = e.tickLabelFontSize, d = e.tickLength, c = a === pr.left || a === pr.top ? -1 : 1, s, h, y;
  if (a === pr.top || a === pr.bottom) {
    var g = a === pr.bottom && typeof r.fontSize == "number" ? r.fontSize : 0;
    s = (Number(i[0]) + Number(i[i.length - 1])) / 2, h = c * (d + t + o + g);
  } else
    s = c * ((Number(i[0]) + Number(i[i.length - 1])) / 2), h = -(d + t), y = "rotate(" + c * 90 + ")";
  return {
    x: s,
    y: h,
    transform: y
  };
}
function vs() {
  return vs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, vs.apply(this, arguments);
}
function TS(e) {
  var t = e.hideTicks, r = e.horizontal, a = e.orientation, i = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, c = e.tickStroke, s = c === void 0 ? "#222" : c, h = e.tickTransform, y = e.ticks, g = e.strokeWidth, x = e.tickLineProps;
  return y.map(function(w) {
    var S, A = w.value, p = w.index, v = w.from, L = w.to, P = w.formattedValue, R = (S = d[p]) != null ? S : {}, C = Math.max(10, typeof R.fontSize == "number" && R.fontSize || 0), z = L.y + (r && a !== pr.top ? C : 0);
    return /* @__PURE__ */ n.createElement(et, {
      key: "visx-tick-" + A + "-" + p,
      className: Rn("visx-axis-tick", i),
      transform: h
    }, !t && /* @__PURE__ */ n.createElement(ln, vs({
      from: v,
      to: L,
      stroke: s,
      strokeWidth: g,
      strokeLinecap: "square"
    }, x)), o ? o(vs({}, R, {
      x: L.x,
      y: z,
      formattedValue: P
    })) : /* @__PURE__ */ n.createElement(dt, vs({
      x: L.x,
      y: z
    }, R), P));
  });
}
function gc() {
  return gc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, gc.apply(this, arguments);
}
var nm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function CS(e) {
  var t = e.axisFromPoint, r = e.axisLineClassName, a = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, c = e.label, s = c === void 0 ? "" : c, h = e.labelClassName, y = e.labelOffset, g = y === void 0 ? 14 : y, x = e.labelProps, w = x === void 0 ? nm : x, S = e.orientation, A = S === void 0 ? pr.bottom : S, p = e.scale, v = e.stroke, L = v === void 0 ? "#222" : v, P = e.strokeDasharray, R = e.strokeWidth, C = R === void 0 ? 1 : R, z = e.tickClassName, W = e.tickComponent, Z = e.tickLineProps, ee = e.tickLabelProps, K = e.tickLength, le = K === void 0 ? 8 : K, Y = e.tickStroke, ae = Y === void 0 ? "#222" : Y, B = e.tickTransform, X = e.ticks, ce = e.ticksComponent, ne = ce === void 0 ? TS : ce, Q = gc({}, nm, typeof ee == "object" ? ee : null), V = X.map(function(te) {
    var U = te.value, ue = te.index;
    return typeof ee == "function" ? ee(U, ue, X) : Q;
  }), j = Math.max.apply(Math, [10].concat(V.map(function(te) {
    return typeof te.fontSize == "number" ? te.fontSize : 0;
  })));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, ne({
    hideTicks: o,
    horizontal: d,
    orientation: A,
    scale: p,
    tickClassName: z,
    tickComponent: W,
    tickLabelProps: V,
    tickStroke: ae,
    tickTransform: B,
    ticks: X,
    strokeWidth: C,
    tickLineProps: Z
  }), !i && /* @__PURE__ */ n.createElement(ln, {
    className: Rn("visx-axis-line", r),
    from: t,
    to: a,
    stroke: L,
    strokeWidth: C,
    strokeDasharray: P
  }), s && /* @__PURE__ */ n.createElement(dt, gc({
    className: Rn("visx-axis-label", h)
  }, wS({
    labelOffset: g,
    labelProps: w,
    orientation: A,
    range: p.range(),
    tickLabelFontSize: j,
    tickLength: le
  }), w), s));
}
function AS(e, t) {
  t === void 0 && (t = "center");
  var r = e;
  if (t !== "start" && "bandwidth" in r) {
    var a = r.bandwidth();
    return t === "center" && (a /= 2), r.round() && (a = Math.round(a)), function(i) {
      var o = r(i);
      return typeof o == "number" ? o + a : o;
    };
  }
  return e;
}
function LS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : jE;
}
function zu(e, t) {
  var r = e.x, a = e.y;
  return new Tg(t ? {
    x: r,
    y: a
  } : {
    x: a,
    y: r
  });
}
function Hf() {
  return Hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Hf.apply(this, arguments);
}
var ef = 0;
function PS(e) {
  return e === void 0 && (e = ef), typeof e == "number" ? {
    start: e,
    end: e
  } : Hf({
    start: ef,
    end: ef
  }, e);
}
var RS = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Vf() {
  return Vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Vf.apply(this, arguments);
}
function NS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Bc(e) {
  var t = e.children, r = t === void 0 ? CS : t, a = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, d = e.hideTicks, c = d === void 0 ? !1 : d, s = e.hideZero, h = s === void 0 ? !1 : s, y = e.innerRef, g = e.left, x = g === void 0 ? 0 : g, w = e.numTicks, S = w === void 0 ? 10 : w, A = e.orientation, p = A === void 0 ? pr.bottom : A, v = e.rangePadding, L = v === void 0 ? 0 : v, P = e.scale, R = e.tickFormat, C = e.tickLength, z = C === void 0 ? 8 : C, W = e.tickValues, Z = e.top, ee = Z === void 0 ? 0 : Z, K = NS(e, RS), le = R ?? LS(P), Y = p === pr.left, ae = p === pr.top, B = ae || p === pr.bottom, X = AS(P), ce = Y || ae ? -1 : 1, ne = P.range(), Q = PS(L), V = zu({
    x: Number(ne[0]) + 0.5 - Q.start,
    y: 0
  }, B), j = zu({
    x: Number(ne[ne.length - 1]) + 0.5 + Q.end,
    y: 0
  }, B), te = (W ?? Gy(P, S)).filter(function(ue) {
    return !h || ue !== 0 && ue !== "0";
  }).map(function(ue, ke) {
    return {
      value: ue,
      index: ke
    };
  }), U = te.map(function(ue) {
    var ke = ue.value, xe = ue.index, be = WE(X(ke));
    return {
      value: ke,
      index: xe,
      from: zu({
        x: be,
        y: 0
      }, B),
      to: zu({
        x: be,
        y: z * ce
      }, B),
      formattedValue: le(ke, xe, te)
    };
  });
  return /* @__PURE__ */ n.createElement(et, {
    className: Rn("visx-axis", a),
    innerRef: y,
    top: ee,
    left: x
  }, r(Vf({}, K, {
    axisFromPoint: V,
    axisToPoint: j,
    hideAxisLine: o,
    hideTicks: c,
    hideZero: h,
    horizontal: B,
    numTicks: S,
    orientation: p,
    rangePadding: L,
    scale: P,
    tickFormat: le,
    tickLength: z,
    tickPosition: X,
    tickSign: ce,
    ticks: U
  })));
}
var DS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function _S(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var OS = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function rm(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = _S(e, DS), s = typeof d == "function" ? d : vc({}, OS, d);
  return /* @__PURE__ */ n.createElement(Bc, vc({
    axisClassName: Rn("visx-axis-left", t),
    labelOffset: a,
    orientation: pr.left,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var FS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function MS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var zS = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function BS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = MS(e, FS), s = typeof d == "function" ? d : xc({}, zS, d);
  return /* @__PURE__ */ n.createElement(Bc, xc({
    axisClassName: Rn("visx-axis-right", t),
    labelOffset: a,
    orientation: pr.right,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var IS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, bc.apply(this, arguments);
}
function $S(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var HS = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function VS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = $S(e, IS), s = typeof d == "function" ? d : bc({}, HS, d);
  return /* @__PURE__ */ n.createElement(Bc, bc({
    axisClassName: Rn("visx-axis-top", t),
    labelOffset: a,
    orientation: pr.top,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var WS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function jS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var US = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function ju(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = jS(e, WS), s = typeof d == "function" ? d : Ec({}, US, d);
  return /* @__PURE__ */ n.createElement(Bc, Ec({
    axisClassName: Rn("visx-axis-bottom", t),
    labelOffset: a,
    orientation: pr.bottom,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
const tf = (e) => () => e;
function KS(e, {
  sourceEvent: t,
  target: r,
  selection: a,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    selection: { value: a, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function YS(e) {
  e.stopImmediatePropagation();
}
function nf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var am = { name: "drag" }, rf = { name: "space" }, qo = { name: "handle" }, Zo = { name: "center" };
const { abs: im, max: nr, min: rr } = Math;
function om(e) {
  return [+e[0], +e[1]];
}
function lm(e) {
  return [om(e[0]), om(e[1])];
}
var Uu = {
  name: "x",
  handles: ["w", "e"].map(Sc),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, af = {
  name: "y",
  handles: ["n", "s"].map(Sc),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, ya = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, sm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, um = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, GS = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, XS = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Sc(e) {
  return { type: e };
}
function qS(e) {
  return !e.ctrlKey && !e.button;
}
function ZS() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function QS() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function of(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function JS(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function ek() {
  return tk(Uu);
}
function tk(e) {
  var t = ZS, r = qS, a = QS, i = !0, o = Cg("start", "brush", "end"), d = 6, c;
  function s(p) {
    var v = p.property("__brush", A).selectAll(".overlay").data([Sc("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ya.overlay).merge(v).each(function() {
      var P = of(this).extent;
      Jo(this).attr("x", P[0][0]).attr("y", P[0][1]).attr("width", P[1][0] - P[0][0]).attr("height", P[1][1] - P[0][1]);
    }), p.selectAll(".selection").data([Sc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ya.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var L = p.selectAll(".handle").data(e.handles, function(P) {
      return P.type;
    });
    L.exit().remove(), L.enter().append("rect").attr("class", function(P) {
      return "handle handle--" + P.type;
    }).attr("cursor", function(P) {
      return ya[P.type];
    }), p.each(h).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(a).on("touchstart.brush", x).on("touchmove.brush", w).on("touchend.brush touchcancel.brush", S).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  s.move = function(p, v, L) {
    p.tween ? p.on("start.brush", function(P) {
      y(this, arguments).beforestart().start(P);
    }).on("interrupt.brush end.brush", function(P) {
      y(this, arguments).end(P);
    }).tween("brush", function() {
      var P = this, R = P.__brush, C = y(P, arguments), z = R.selection, W = e.input(typeof v == "function" ? v.apply(this, arguments) : v, R.extent), Z = lv(z, W);
      function ee(K) {
        R.selection = K === 1 && W === null ? null : Z(K), h.call(P), C.brush();
      }
      return z !== null && W !== null ? ee : ee(1);
    }) : p.each(function() {
      var P = this, R = arguments, C = P.__brush, z = e.input(typeof v == "function" ? v.apply(P, R) : v, C.extent), W = y(P, R).beforestart();
      Dp(P), C.selection = z === null ? null : z, h.call(P), W.start(L).brush(L).end(L);
    });
  }, s.clear = function(p, v) {
    s.move(p, null, v);
  };
  function h() {
    var p = Jo(this), v = of(this).selection;
    v ? (p.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), p.selectAll(".handle").style("display", null).attr("x", function(L) {
      return L.type[L.type.length - 1] === "e" ? v[1][0] - d / 2 : v[0][0] - d / 2;
    }).attr("y", function(L) {
      return L.type[0] === "s" ? v[1][1] - d / 2 : v[0][1] - d / 2;
    }).attr("width", function(L) {
      return L.type === "n" || L.type === "s" ? v[1][0] - v[0][0] + d : d;
    }).attr("height", function(L) {
      return L.type === "e" || L.type === "w" ? v[1][1] - v[0][1] + d : d;
    })) : p.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function y(p, v, L) {
    var P = p.__brush.emitter;
    return P && (!L || !P.clean) ? P : new g(p, v, L);
  }
  function g(p, v, L) {
    this.that = p, this.args = v, this.state = p.__brush, this.active = 0, this.clean = L;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(p, v) {
      return this.starting ? (this.starting = !1, this.emit("start", p, v)) : this.emit("brush", p), this;
    },
    brush: function(p, v) {
      return this.emit("brush", p, v), this;
    },
    end: function(p, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", p, v)), this;
    },
    emit: function(p, v, L) {
      var P = Jo(this.that).datum();
      o.call(
        p,
        this.that,
        new KS(p, {
          sourceEvent: v,
          target: s,
          selection: e.output(this.state.selection),
          mode: L,
          dispatch: o
        }),
        P
      );
    }
  };
  function x(p) {
    if (c && !p.touches || !r.apply(this, arguments))
      return;
    var v = this, L = p.target.__data__.type, P = (i && p.metaKey ? L = "overlay" : L) === "selection" ? am : i && p.altKey ? Zo : qo, R = e === af ? null : GS[L], C = e === Uu ? null : XS[L], z = of(v), W = z.extent, Z = z.selection, ee = W[0][0], K, le, Y = W[0][1], ae, B, X = W[1][0], ce, ne, Q = W[1][1], V, j, te = 0, U = 0, ue, ke = R && C && i && p.shiftKey, xe, be, Ae = Array.from(p.touches || [p], (Be) => {
      const Ze = Be.identifier;
      return Be = _p(Be, v), Be.point0 = Be.slice(), Be.identifier = Ze, Be;
    });
    Dp(v);
    var Ye = y(v, arguments, !0).beforestart();
    if (L === "overlay") {
      Z && (ue = !0);
      const Be = [Ae[0], Ae[1] || Ae[0]];
      z.selection = Z = [[
        K = e === af ? ee : rr(Be[0][0], Be[1][0]),
        ae = e === Uu ? Y : rr(Be[0][1], Be[1][1])
      ], [
        ce = e === af ? X : nr(Be[0][0], Be[1][0]),
        V = e === Uu ? Q : nr(Be[0][1], Be[1][1])
      ]], Ae.length > 1 && ze(p);
    } else
      K = Z[0][0], ae = Z[0][1], ce = Z[1][0], V = Z[1][1];
    le = K, B = ae, ne = ce, j = V;
    var Pe = Jo(v).attr("pointer-events", "none"), ye = Pe.selectAll(".overlay").attr("cursor", ya[L]);
    if (p.touches)
      Ye.moved = fe, Ye.ended = Ne;
    else {
      var Re = Jo(p.view).on("mousemove.brush", fe, !0).on("mouseup.brush", Ne, !0);
      i && Re.on("keydown.brush", qe, !0).on("keyup.brush", He, !0), Ag(p.view);
    }
    h.call(v), Ye.start(p, P.name);
    function fe(Be) {
      for (const Ze of Be.changedTouches || [Be])
        for (const Ve of Ae)
          Ve.identifier === Ze.identifier && (Ve.cur = _p(Ze, v));
      if (ke && !xe && !be && Ae.length === 1) {
        const Ze = Ae[0];
        im(Ze.cur[0] - Ze[0]) > im(Ze.cur[1] - Ze[1]) ? be = !0 : xe = !0;
      }
      for (const Ze of Ae)
        Ze.cur && (Ze[0] = Ze.cur[0], Ze[1] = Ze.cur[1]);
      ue = !0, nf(Be), ze(Be);
    }
    function ze(Be) {
      const Ze = Ae[0], Ve = Ze.point0;
      var je;
      switch (te = Ze[0] - Ve[0], U = Ze[1] - Ve[1], P) {
        case rf:
        case am: {
          R && (te = nr(ee - K, rr(X - ce, te)), le = K + te, ne = ce + te), C && (U = nr(Y - ae, rr(Q - V, U)), B = ae + U, j = V + U);
          break;
        }
        case qo: {
          Ae[1] ? (R && (le = nr(ee, rr(X, Ae[0][0])), ne = nr(ee, rr(X, Ae[1][0])), R = 1), C && (B = nr(Y, rr(Q, Ae[0][1])), j = nr(Y, rr(Q, Ae[1][1])), C = 1)) : (R < 0 ? (te = nr(ee - K, rr(X - K, te)), le = K + te, ne = ce) : R > 0 && (te = nr(ee - ce, rr(X - ce, te)), le = K, ne = ce + te), C < 0 ? (U = nr(Y - ae, rr(Q - ae, U)), B = ae + U, j = V) : C > 0 && (U = nr(Y - V, rr(Q - V, U)), B = ae, j = V + U));
          break;
        }
        case Zo: {
          R && (le = nr(ee, rr(X, K - te * R)), ne = nr(ee, rr(X, ce + te * R))), C && (B = nr(Y, rr(Q, ae - U * C)), j = nr(Y, rr(Q, V + U * C)));
          break;
        }
      }
      ne < le && (R *= -1, je = K, K = ce, ce = je, je = le, le = ne, ne = je, L in sm && ye.attr("cursor", ya[L = sm[L]])), j < B && (C *= -1, je = ae, ae = V, V = je, je = B, B = j, j = je, L in um && ye.attr("cursor", ya[L = um[L]])), z.selection && (Z = z.selection), xe && (le = Z[0][0], ne = Z[1][0]), be && (B = Z[0][1], j = Z[1][1]), (Z[0][0] !== le || Z[0][1] !== B || Z[1][0] !== ne || Z[1][1] !== j) && (z.selection = [[le, B], [ne, j]], h.call(v), Ye.brush(Be, P.name));
    }
    function Ne(Be) {
      if (YS(Be), Be.touches) {
        if (Be.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        Lg(Be.view, ue), Re.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Pe.attr("pointer-events", "all"), ye.attr("cursor", ya.overlay), z.selection && (Z = z.selection), JS(Z) && (z.selection = null, h.call(v)), Ye.end(Be, P.name);
    }
    function qe(Be) {
      switch (Be.keyCode) {
        case 16: {
          ke = R && C;
          break;
        }
        case 18: {
          P === qo && (R && (ce = ne - te * R, K = le + te * R), C && (V = j - U * C, ae = B + U * C), P = Zo, ze(Be));
          break;
        }
        case 32: {
          (P === qo || P === Zo) && (R < 0 ? ce = ne - te : R > 0 && (K = le - te), C < 0 ? V = j - U : C > 0 && (ae = B - U), P = rf, ye.attr("cursor", ya.selection), ze(Be));
          break;
        }
        default:
          return;
      }
      nf(Be);
    }
    function He(Be) {
      switch (Be.keyCode) {
        case 16: {
          ke && (xe = be = ke = !1, ze(Be));
          break;
        }
        case 18: {
          P === Zo && (R < 0 ? ce = ne : R > 0 && (K = le), C < 0 ? V = j : C > 0 && (ae = B), P = qo, ze(Be));
          break;
        }
        case 32: {
          P === rf && (Be.altKey ? (R && (ce = ne - te * R, K = le + te * R), C && (V = j - U * C, ae = B + U * C), P = Zo) : (R < 0 ? ce = ne : R > 0 && (K = le), C < 0 ? V = j : C > 0 && (ae = B), P = qo), ye.attr("cursor", ya[L]), ze(Be));
          break;
        }
        default:
          return;
      }
      nf(Be);
    }
  }
  function w(p) {
    y(this, arguments).moved(p);
  }
  function S(p) {
    y(this, arguments).ended(p);
  }
  function A() {
    var p = this.__brush || { selection: null };
    return p.extent = lm(t.apply(this, arguments)), p.dim = e, p;
  }
  return s.extent = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : tf(lm(p)), s) : t;
  }, s.filter = function(p) {
    return arguments.length ? (r = typeof p == "function" ? p : tf(!!p), s) : r;
  }, s.touchable = function(p) {
    return arguments.length ? (a = typeof p == "function" ? p : tf(!!p), s) : a;
  }, s.handleSize = function(p) {
    return arguments.length ? (d = +p, s) : d;
  }, s.keyModifiers = function(p) {
    return arguments.length ? (i = !!p, s) : i;
  }, s.on = function() {
    var p = o.on.apply(o, arguments);
    return p === o ? s : p;
  }, s;
}
const nk = ({ xMax: e, yMax: t }) => {
  var B, X;
  const { tableData: r, config: a, setBrushConfig: i, dashboardConfig: o, formatDate: d, parseDate: c } = se.useContext(pt), [s, h] = se.useState({ isBrushing: !1, selection: [] }), [y, g] = se.useState(0), x = ((B = o == null ? void 0 : o.dashboard) == null ? void 0 : B.sharedFilters) ?? [], w = (x == null ? void 0 : x.length) > 0, [S, A] = se.useState(!1), p = se.useRef(), v = 25, L = 15, P = Pg(r, (ce) => new Date(ce[a.runtime.originalXAxis.dataKey])), R = Yy().domain(P).range([0, e]), z = hr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), W = 50, Z = 1.5, ee = () => (o == null ? void 0 : o.type) === "dashboard" ? Number(t) + a.xAxis.axisBBox + v * Z + W : Number(t) + a.xAxis.axisBBox + v * Z, K = () => {
    s.selection[0] === 0 && e === s.selection[1] && A(!0);
  }, le = () => {
    (s.selection[0] !== 0 || s.selection[1] !== e) && A(!1), A(!1);
  }, Y = (ce, ne, Q, V) => {
    const j = hr(Q, `normal ${14.545454545454545}px sans-serif`);
    return ce.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((te) => {
      const U = te.append("g").attr("class", "handle--custom");
      return U.append("text").attr("x", (ue) => ue.side === "left" ? 0 : -j).attr("y", 30).text((ue) => ue.side === "left" ? Q : V).attr("font-size", "13px"), U;
    }).attr("display", "block").attr("transform", ne === null ? null : (te, U) => `translate(${ne[U]},10)`);
  }, ae = () => {
    const ce = Jo(p.current).attr("overflow", "visible");
    ce.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", L).attr("rx", L).attr("height", v).attr("width", e);
    const ne = (te) => {
      const U = te == null ? void 0 : te.selection;
      let ue = te.type === "brush" && U && U.length > 0;
      const [ke, xe] = U.map((Ne) => R.invert(Ne)), be = Je.filter(r, (Ne) => {
        const qe = new Date(Ne[a.xAxis.dataKey]);
        return qe && !isNaN(qe.getTime()) && qe >= ke && qe <= xe;
      }), Ae = a.xAxis.sortByRecentDate, Ye = Je.sortBy(be, (Ne) => new Date(Ne[a.xAxis.dataKey])), Pe = Ae ? Ye.reverse() : Ye, ye = Je.get(Je.first(Pe), a.xAxis.dataKey, ""), Re = Je.get(Je.last(Pe), a.xAxis.dataKey, "");
      ce.selectAll(".handle--custom").remove();
      const [fe, ze] = [ye, Re].map((Ne) => d(c(Ne)));
      ce.call(Y, U, fe, ze), i({
        active: a.brush.active,
        isBrushing: ue,
        data: Pe
      }), h({
        isBrushing: !0,
        selection: U
      });
    }, Q = ek().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", ne), V = [0, e];
    let j = ce.append("g").call(Q).call(Q.move, V);
    j.select(".overlay").style("pointer-events", "none"), j.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", L).attr("ry", L);
  };
  return se.useEffect(() => {
    var Q, V, j;
    const ce = (Q = a.filters) == null ? void 0 : Q.some((te) => te.active), ne = (V = a.exclusions) == null ? void 0 : V.active;
    return (ce || ne || w) && ((j = a.brush) != null && j.active) && (g((te) => te + 1), i((te) => ({
      ...te,
      data: r
    }))), () => i((te) => ({
      ...te,
      data: []
    }));
  }, [a.filters, a.exclusions, (X = a.brush) == null ? void 0 : X.active, w]), se.useEffect(() => {
    y && ae();
  }, [y]), s.isBrushing || ae(), /* @__PURE__ */ n.createElement(
    et,
    {
      onMouseLeave: le,
      onMouseOver: K,
      className: "brush-container",
      left: Number(a.runtime.yAxis.size),
      top: ee()
    },
    /* @__PURE__ */ n.createElement(
      dt,
      {
        pointerEvents: "visiblePainted",
        display: S ? "block" : "none",
        fontSize: 16,
        x: (Number(e) - Number(z)) / 2,
        y: -10
      },
      "Drag edges to focus on a specific segment"
    ),
    /* @__PURE__ */ n.createElement("svg", { width: "100%", height: v * 3, ref: p })
  );
}, Mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: p0,
  curveBasisClosed: h0,
  curveBasisOpen: m0,
  curveBundle: y0,
  curveCardinal: g0,
  curveCardinalClosed: v0,
  curveCardinalOpen: x0,
  curveCatmullRom: b0,
  curveCatmullRomClosed: E0,
  curveCatmullRomOpen: S0,
  curveLinear: _c,
  curveLinearClosed: kf,
  curveMonotoneX: Wu,
  curveMonotoneY: k0,
  curveNatural: w0,
  curveStep: T0,
  curveStepAfter: A0,
  curveStepBefore: C0
}, Symbol.toStringTag, { value: "Module" })), rk = (e) => {
  var z, W;
  const { xScale: t, yScale: r, yMax: a, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: c, children: s } = e;
  let { transformedData: h, config: y, handleLineType: g, parseDate: x, formatDate: w, formatNumber: S, seriesHighlight: A, colorScale: p, rawData: v, brushConfig: L } = se.useContext(pt);
  const P = (z = y.brush) != null && z.active && ((W = L.data) != null && W.length) ? L.data : h;
  if (!P)
    return;
  const R = (Z) => (Pn(y.xAxis) ? t(x(Z[y.xAxis.dataKey], !1)) : t(Z[y.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), C = (Z, ee, K = void 0) => r(Z[K.dataKey]);
  return P && /* @__PURE__ */ n.createElement("svg", null, /* @__PURE__ */ n.createElement(Vr, { component: "AreaChart" }, /* @__PURE__ */ n.createElement(et, { className: "area-chart", key: "area-wrapper", left: Number(y.yAxis.size) }, (y.runtime.areaSeriesKeys || y.series).map((Z, ee) => {
    let K = P.map((B) => ({
      [y.xAxis.dataKey]: B[y.xAxis.dataKey],
      [Z.dataKey]: B[Z.dataKey]
    })), le = Mi[Z.lineType], Y = y.legend.behavior === "highlight" && A.length > 0 && A.indexOf(Z.dataKey) === -1, ae = y.legend.behavior === "highlight" || A.length === 0 || A.indexOf(Z.dataKey) !== -1;
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: ee }, /* @__PURE__ */ n.createElement(
      Hr,
      {
        data: K,
        x: (B) => R(B),
        y: (B) => C(B, ee, Z),
        stroke: ae ? p ? p(y.runtime.seriesLabels ? y.runtime.seriesLabels[Z.dataKey] : Z.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: le,
        strokeDasharray: Z.type ? g(Z.type) : 0
      }
    ), /* @__PURE__ */ n.createElement(
      Pf,
      {
        key: "area-chart",
        fill: ae ? p ? p(y.runtime.seriesLabels ? y.runtime.seriesLabels[Z.dataKey] : Z.dataKey) : "#000" : "transparent",
        fillOpacity: Y ? 0.25 : 0.5,
        data: K,
        x: (B) => R(B),
        y: (B) => C(B, ee, Z),
        yScale: r,
        curve: le,
        strokeDasharray: Z.type ? g(Z.type) : 0
      }
    ));
  }), /* @__PURE__ */ n.createElement(Rr, { width: Number(i), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (Z) => o(Z, v), onMouseLeave: d }))));
}, ak = se.memo(rk), ik = ({ xScale: e, yScale: t, yMax: r, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: d }) => {
  var A, p;
  let { transformedData: c, config: s, seriesHighlight: h, colorScale: y, rawData: g } = se.useContext(pt);
  const x = (A = s.brush) != null && A.active && ((p = s.brush.data) != null && p.length) ? s.brush.data : c;
  if (!x)
    return;
  const w = (v) => {
    if (s.xAxis.type === "categorical")
      return e(v);
    if (Pn(s.xAxis)) {
      let L = new Date(v);
      return e(L);
    }
  }, S = 2;
  return x && /* @__PURE__ */ n.createElement("svg", { height: Number(r) }, /* @__PURE__ */ n.createElement(Vr, { component: "AreaChartStacked" }, /* @__PURE__ */ n.createElement(
    et,
    {
      className: "area-chart",
      key: "area-wrapper",
      left: Number(s.yAxis.size) + S / 2,
      height: Number(r),
      style: { overflow: "hidden" }
    },
    /* @__PURE__ */ n.createElement(
      aE,
      {
        data: x,
        keys: s.runtime.areaSeriesKeys.map((v) => v.dataKey) || s.series.map((v) => v.dataKey),
        x0: (v) => w(v.data[s.xAxis.dataKey]),
        y0: (v) => Number(t(v[0])),
        y1: (v) => Number(t(v[1])),
        curve: Mi[ol[s.stackedAreaChartLineType]]
      },
      ({ stacks: v, path: L }) => v.map((P, R) => {
        let C = s.legend.behavior === "highlight" && h.length > 0 && h.indexOf(P.key) === -1, z = s.legend.behavior === "highlight" || h.length === 0 || h.indexOf(P.key) !== -1;
        return (
          // prettier-ignore
          /* @__PURE__ */ n.createElement(
            "path",
            {
              key: P.key,
              d: L(P) || "",
              strokeWidth: 2,
              stroke: z ? y ? y(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent",
              fillOpacity: C ? 0.2 : 1,
              fill: z ? y ? y(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent"
            }
          )
        );
      })
    ),
    /* @__PURE__ */ n.createElement(Rr, { width: Number(a), height: Number(r), fill: "transparent", onMouseMove: (v) => i(v, g), onMouseLeave: o })
  )));
}, ok = se.memo(ik), Ic = () => {
  const { config: e, colorPalettes: t, tableData: r, updateConfig: a, parseDate: i, formatDate: o, setSeriesHighlight: d, seriesHighlight: c } = se.useContext(pt), { orientation: s } = e, [h, y] = se.useState(null), g = s === "horizontal", x = 1, w = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, S = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, A = e.yAxis.labelPlacement === "Below Bar", p = e.yAxis.displayNumbersOnBar, v = e.orientation === "horizontal" ? "yAxis" : "xAxis", L = e.barStyle === "rounded", P = e.visualizationSubType === "stacked", R = e.tipRounding, C = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", z = e.runtime.seriesKeys.length, W = Object.keys(e.runtime.seriesLabels).length > 1, ee = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return se.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), se.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), se.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), se.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (L || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: g,
    barBorderWidth: x,
    lollipopBarWidth: w,
    lollipopShapeSize: S,
    isLabelBelowBar: A,
    displayNumbersOnBar: p,
    shouldSuppress: (V) => {
      var j;
      return (j = e.preliminaryData) == null ? void 0 : j.some((te) => {
        const U = te.column ? te.column === V.key : !0, ue = String(V.value) === String(te.value) && te.value !== "";
        return U && ue && te.symbol && te.type === "suppression";
      });
    },
    section: v,
    isRounded: L,
    isStacked: P,
    tipRounding: R,
    radius: C,
    stackCount: z,
    barStackedSeriesKeys: ee,
    hasMultipleSeries: W,
    applyRadius: (V) => {
      if (V == null || !L)
        return {};
      let j = {};
      return (P && V + 1 === z || !P) && (j = g ? { borderRadius: `0 ${C}  ${C}  0` } : { borderRadius: `${C} ${C} 0 0` }), !P && V === -1 && (j = g ? { borderRadius: `${C} 0  0 ${C} ` } : { borderRadius: ` 0  0 ${C} ${C}` }), R === "full" && P && V === 0 && z > 1 && (j = g ? { borderRadius: `${C} 0 0 ${C}` } : { borderRadius: `0 0 ${C} ${C}` }), R === "full" && (P && V === 0 && z === 1 || !P) && (j = { borderRadius: C }), j;
    },
    updateBars: (V) => {
      if (e.visualizationType !== "Bar" && !g)
        return V;
      const j = [...V];
      let te;
      const U = {
        stacked: e.barHeight,
        lollipop: w
      };
      P ? te = U.stacked : te = U[e.isLollipopChart ? "lollipop" : "stacked"] * z;
      const ue = A ? Lc * 1.2 : 0;
      let ke = Number(e.barSpace), xe = j.length * (te + ue + ke);
      return g && (e.heights.horizontal = xe), j.map((be, Ae) => {
        let Ye = 0;
        return be.index !== 0 && (Ye = (te + ke + ue) * Ae), { ...be, y: Ye, height: te };
      });
    },
    assignColorsToValues: (V, j, te) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return te;
      const U = e.customColors ?? t[e.palette], ue = r.map((Ae) => Ae[e.legend.colorCode]);
      let ke = /* @__PURE__ */ new Map(), xe = [];
      for (let Ae = 0; Ae < ue.length; Ae++)
        ke.has(ue[Ae]) || ke.set(ue[Ae], U[ke.size % U.length]), xe.push(ke.get(ue[Ae]));
      for (; xe.length < V; )
        xe = xe.concat(xe);
      return xe[j];
    },
    getHighlightedBarColorByValue: (V) => {
      const j = e == null ? void 0 : e.highlightedBarValues.find((te) => {
        if (te.value)
          return e.xAxis.type === "date" ? o(i(te.value)) === V : te.value === V;
      });
      return j != null && j.color ? j.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (V) => {
      const j = e == null ? void 0 : e.highlightedBarValues.filter((te) => {
        if (te.value)
          return e.xAxis.type === "date" ? o(i(te.value)) === V : te.value === V;
      })[0];
      return j != null && j.color ? j : !1;
    },
    getAdditionalColumn: (V, j) => {
      if (!j)
        return "";
      const te = e.columns, U = [];
      let ue = "";
      const ke = r.find((xe) => xe[e.xAxis.dataKey] === j) || {};
      return Object.keys(te).forEach((xe) => {
        if (V && e.columns[xe].series && e.columns[xe].series !== V)
          return;
        const be = {
          addColPrefix: e.columns[xe].prefix,
          addColSuffix: e.columns[xe].suffix,
          addColRoundTo: e.columns[xe].roundToPlace ? e.columns[xe].roundToPlace : "",
          addColCommas: e.columns[xe].commas
        }, Ae = Gf(
          ke[e.columns[xe].name],
          "left",
          !0,
          e,
          be
        );
        e.columns[xe].tooltips && U.push([e.columns[xe].label, Ae]);
      }), U.forEach((xe) => {
        ue += `${xe[0]} : ${xe[1]} <br/>`;
      }), ue;
    },
    hoveredBar: h,
    setHoveredBar: y,
    onMouseOverBar: (V, j) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && j && d([j]), y(V);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && d([]);
    }
  };
}, Ns = se.createContext(null), xp = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: r = 1,
  yMax: a,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: d,
  tooltipData: c,
  showTooltip: s,
  hideTooltip: h
}) => {
  const { parseDate: y, config: g } = se.useContext(pt), { runtime: x, regions: w, visualizationType: S, orientation: A, xAxis: p } = g, v = e.domain(), L = (C) => {
    let z;
    if (!(C != null && C.fromType) || C.fromType === "Fixed") {
      const W = new Date(C.from), Z = y(os(g.xAxis.dateParseFormat, W)).getTime();
      z = e(Z), S === "Bar" && p.type === "date-time" && (z = z - t * r / 2);
    }
    if (C.fromType === "Previous Days") {
      const W = Number(C.from) || 0;
      v.map((le) => os(g.xAxis.dateParseFormat, new Date(le)));
      const Z = C.toType === "Last Date" ? new Date(v[v.length - 1]).getTime() : new Date(C.to), ee = g.xAxis.type === "categorical" ? os(g.xAxis.dateParseFormat, Z) : os(g.xAxis.dateParseFormat, Z), K = new Date(ee);
      if (z = new Date(K.setDate(K.getDate() - Number(W))), p.type === "date") {
        z = new Date(os(p.dateParseFormat, z)).getTime();
        let le = v[0], Y = Math.abs(z - le);
        for (let ae = 1; ae < v.length; ae++) {
          const B = Math.abs(z - v[ae]);
          B < Y && (Y = B, le = v[ae]);
        }
        z = le;
      }
      if (p.type === "categorical") {
        let le = v[0], Y = Math.abs(new Date(z).getTime() - new Date(le).getTime());
        for (let ae = 1; ae < v.length; ae++) {
          const B = Math.abs(new Date(z).getTime() - new Date(v[ae]).getTime());
          B < Y && (Y = B, le = v[ae]);
        }
        z = le;
      }
      z = e(z);
    }
    if (p.type === "categorical" && C.fromType !== "Previous Days" && (z = e(C.from)), S === "Line" || S === "Area Chart") {
      let W = Number(g.yAxis.size);
      e.bandwidth && (W += e.bandwidth() / 2), z = z + W;
    }
    return S === "Bar" && g.xAxis.type === "date-time" && C.fromType === "Previous Days" && (z = z - t * r / 2), z;
  }, P = (C) => {
    let z;
    if (p.type === "categorical" && (z = e(C.to)), Pn(p) && ((!(C != null && C.toType) || C.toType === "Fixed") && (z = e(y(C.to).getTime())), (S === "Bar" || g.visualizationType === "Combo") && (z = C.toType !== "Last Date" ? e(y(C.to).getTime()) + t * r : z)), C.toType === "Last Date") {
      const W = v[v.length - 1];
      z = Number(
        e(W) + ((S === "Bar" || S === "Combo") && g.xAxis.type === "date" ? t * r : 0)
      );
    }
    if (S === "Line" || S === "Area Chart") {
      let W = Number(g.yAxis.size);
      e.bandwidth && (W += e.bandwidth() / 2), z = z + W;
    }
    return S === "Bar" && g.xAxis.type === "date-time" && C.toType !== "Last Date" && (z = z - t * r / 2), (S === "Bar" || S === "Combo") && p.type === "categorical" && (z = z + (S === "Bar" || S === "Combo" ? t * r : 0)), z;
  }, R = (C, z) => C - z;
  if (w && A === "vertical")
    return w.map((C) => {
      const z = L(C), W = P(C), Z = R(W, z);
      if (!z || !W)
        return null;
      const ee = () => /* @__PURE__ */ n.createElement("rect", { x: z, y: 0, width: Z, height: a, fill: C.background, opacity: 0.3 });
      return /* @__PURE__ */ n.createElement(
        et,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          key: C.label,
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: d,
          tooltipData: JSON.stringify(c),
          showTooltip: s
        },
        /* @__PURE__ */ n.createElement(ee, null),
        /* @__PURE__ */ n.createElement(dt, { x: z + Z / 2, y: 5, fill: C.color, verticalAnchor: "start", textAnchor: "middle" }, C.label)
      );
    });
};
function Ds(e) {
  var U, ue;
  const { config: t, index: r, id: a, className: i, background: o, borderColor: d, borderWidth: c, width: s, height: h, x: y, y: g, onMouseOver: x, onMouseLeave: w, onClick: S, tooltipHtml: A, tooltipId: p, styleOverrides: v, seriesHighlight: L, type: P } = e, R = Math.max(0, s), C = Math.max(0, h), z = t.orientation === "horizontal", W = t.barStyle === "rounded", Z = t.visualizationSubType === "stacked", ee = t.tipRounding, K = t.visualizationType === "Combo" && ((ue = (U = t.runtime) == null ? void 0 : U.barSeriesKeys) == null ? void 0 : ue.length), le = t.runtime.seriesKeys.length, Y = t.visualizationType === "Bar" && t.legend.axisAlign && (L != null && L.length) ? L == null ? void 0 : L.length : 0, ae = K || Y || le;
  let B = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (B > R / 2 || B > C / 2) && (B = Math.min(R / 2, C / 2));
  const X = () => `M${y},${g + C}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + R - B},${g}
      Q${y + R},${g} ${y + R},${g + B}
      L${y + R},${g + C}
      L${y},${g + C}`, ce = () => `M${y},${g + C}
      L${y},${g}
      L${y + R - B},${g}
      Q${y + R},${g} ${y + R},${g + B}
      L${y + R},${g + C - B}
      Q${y + R},${g + C} ${y + R - B},${g + C}
      L${y},${g + C}`, ne = () => `M${y + B},${g + C}
      Q${y},${g + C} ${y},${g + C - B}
      L${y},${g}
      L${y + R},${g}
      L${y + R},${g + C - B}
      Q${y + R},${g + C} ${y + R - B},${g + C}
      L${y + B},${g + C}`, Q = () => `M${y + B},${g + C}
      Q${y},${g + C} ${y},${g + C - B}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + R},${g}
      L${y + R},${g + C}
      L${y + B},${g + C}`, V = () => `M${y + B},${g + C}
      Q${y},${g + C} ${y},${g + C - B}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + R - B},${g}
      Q${y + R},${g} ${y + R},${g + B}
      L${y + R},${g + C - B}
      Q${y + R},${g + C} ${y + R - B},${g + C}
      L${y + B},${g + C}`, j = () => `M${y},${g}
      L${y + R},${g}
      L${y + R},${g + C}
      L${y},${g + C}
      L${y},${g}`;
  let te;
  return r == null || !W || P == "axisBar" ? te = j() : (te = j(), (Z && r + 1 === ae || !Z) && (te = z ? ce() : X()), !Z && r === -1 && (te = z ? Q() : ne()), ee === "full" && Z && r === 0 && ae > 1 && (te = z ? Q() : ne()), ee === "full" && (Z && r === 0 && ae === 1 || !Z) && (te = V())), /* @__PURE__ */ n.createElement(
    "path",
    {
      id: a,
      className: i,
      d: te,
      fill: o,
      stroke: d,
      strokeWidth: c,
      onMouseOver: x,
      onMouseLeave: w,
      onClick: S,
      "data-tooltip-html": A,
      "data-tooltip-id": p,
      style: {
        transition: "all 0.2s linear",
        ...v
      }
    }
  );
}
const lk = () => {
  var le, Y;
  const [e, t] = se.useState(0), { xScale: r, yScale: a, seriesScale: i, xMax: o, yMax: d } = se.useContext(Ns), { transformedData: c, colorScale: s, seriesHighlight: h, config: y, formatNumber: g, formatDate: x, parseDate: w, setSharedFilter: S } = se.useContext(pt), {
    isHorizontal: A,
    barBorderWidth: p,
    applyRadius: v,
    hoveredBar: L,
    getAdditionalColumn: P,
    onMouseLeaveBar: R,
    onMouseOverBar: C,
    barStackedSeriesKeys: z
  } = Ic(), { orientation: W } = y, Z = (le = y.brush) != null && le.active && ((Y = y.brush.data) != null && Y.length) ? y.brush.data : c, ee = y.runtime.xAxis.type === "date-time" || y.runtime.xAxis.type === "date", K = y.runtime.xAxis.type === "date-time";
  return y.visualizationSubType === "stacked" && !A && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Fy,
    {
      data: Z,
      keys: z,
      x: (ae) => ae[y.runtime.xAxis.dataKey],
      xScale: r,
      yScale: a,
      color: s
    },
    (ae) => ae.reverse().map(
      (B) => B.bars.map((X) => {
        let ce = y.legend.behavior === "highlight" && h.length > 0 && h.indexOf(X.key) === -1, ne = y.legend.behavior === "highlight" || h.length === 0 || h.indexOf(X.key) !== -1, Q = ee ? i.range()[1] - i.range()[0] : o / B.bars.length;
        y.runtime.xAxis.type !== "date" && (Q = y.barThickness * Q);
        const V = X.bar.data[y.runtime.xAxis.dataKey], j = ee ? x(w(V)) : V, te = g(X.bar ? X.bar.data[X.key] : 0, "left");
        if (!te)
          return;
        const U = r(ee ? w(V) : V) - (K ? Q / 2 : 0), ue = y.runtime.xAxis.label ? `${y.runtime.xAxis.label}: ${j}` : j, ke = P(L), xe = `${y.runtime.seriesLabels[X.key]}: ${te}`, be = `<ul>
                  <li class="tooltip-heading"">${ue}</li>
                  <li class="tooltip-body ">${xe}</li>
                  <li class="tooltip-body ">${ke}</li>
                    </li></ul>`;
        return t(Q), /* @__PURE__ */ n.createElement(et, { key: `${B.index}--${X.index}--${W}` }, /* @__PURE__ */ n.createElement(
          et,
          {
            key: `bar-stack-${B.index}-${X.index}`,
            id: `barStack${B.index}-${X.index}`,
            className: "stack vertical"
          },
          Ds({
            config: y,
            seriesHighlight: h,
            index: B.index,
            background: s(y.runtime.seriesLabels[X.key]),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: `${y.barHasBorder === "true" ? p : 0}px`,
            width: Q,
            height: X.height,
            x: U,
            y: X.y,
            onMouseOver: () => C(j, X.key),
            onMouseLeave: R,
            tooltipHtml: be,
            tooltipId: `cdc-open-viz-tooltip-${y.runtime.uniqueId}`,
            onClick: (Ae) => {
              Ae.preventDefault(), S && (X[y.xAxis.dataKey] = j, S(y.uid, X));
            },
            styleOverrides: {
              animationDelay: `${B.index * 0.5}s`,
              transformOrigin: `${Q / 2}px ${X.y + X.height}px`,
              opacity: ce ? 0.2 : 1,
              display: ne ? "block" : "none"
            }
          })
        ));
      })
    )
  ), /* @__PURE__ */ n.createElement(xp, { xScale: r, yMax: d, barWidth: e, totalBarsInGroup: 1 }));
}, sk = () => {
  const { yMax: e, yScale: t, xScale: r } = se.useContext(Ns), {
    animatedChart: a,
    colorScale: i,
    config: o,
    formatDate: d,
    formatNumber: c,
    parseDate: s,
    seriesHighlight: h,
    setSharedFilter: y,
    transformedData: g
  } = se.useContext(pt), { barBorderWidth: x, displayNumbersOnBar: w, getAdditionalColumn: S, hoveredBar: A, isHorizontal: p, isLabelBelowBar: v, onMouseLeaveBar: L, onMouseOverBar: P, updateBars: R, barStackedSeriesKeys: C } = Ic(), { orientation: z, visualizationSubType: W } = o;
  return o.visualizationSubType === "stacked" && p && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    dE,
    {
      data: g,
      keys: C,
      height: e,
      y: (Z) => Z[o.runtime.yAxis.dataKey],
      xScale: r,
      yScale: t,
      color: i,
      offset: "none"
    },
    (Z) => Z.map(
      (ee) => R(ee.bars).map((K, le) => {
        const Y = o.legend.behavior === "highlight" && h.length > 0 && h.indexOf(K.key) === -1, ae = o.legend.behavior === "highlight" || h.length === 0 || h.indexOf(K.key) !== -1;
        o.barHeight = Number(o.barHeight);
        let B = i(o.runtime.seriesLabels[K.key]), X = il("#000", B);
        Em("#000", B) < 7 && (X = "#fff");
        const Q = c(g[K.index][K.key], "left"), V = o.runtime.yAxis.type === "date" ? d(s(g[K.index][o.runtime.originalXAxis.dataKey])) : g[K.index][o.runtime.originalXAxis.dataKey], j = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${V}` : V, te = hr(Q), U = S(A), ue = `${o.runtime.seriesLabels[K.key]}: ${Q}`, ke = `<ul>
                  <li class="tooltip-heading"">${j}</li>
                  <li class="tooltip-body ">${ue}</li>
                  <li class="tooltip-body ">${U}</li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(et, { key: le, id: `barStack${ee.index}-${K.index}`, className: "stack horizontal" }, Ds({
          config: o,
          seriesHighlight: h,
          index: ee.index,
          className: `animated-chart group ${a ? "animated" : ""}`,
          background: i(o.runtime.seriesLabels[K.key]),
          borderColor: "#333",
          borderStyle: "solid",
          borderWidth: `${o.barHasBorder === "true" ? x : 0}px`,
          width: K.width,
          height: K.height,
          x: K.x,
          y: K.y,
          onMouseOver: () => P(V, K.key),
          onMouseLeave: L,
          tooltipHtml: ke,
          tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
          onClick: (xe) => {
            xe.preventDefault(), y && (K[o.xAxis.dataKey] = Q, y(o.uid, K));
          },
          styleOverrides: {
            animationDelay: `${ee.index * 0.5}s`,
            transformOrigin: `${K.x}px 0`,
            opacity: Y ? 0.2 : 1,
            display: ae ? "block" : "none"
          }
        }), z === "horizontal" && W === "stacked" && v && ee.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          dt,
          {
            x: `${K.x + (o.isLollipopChart ? 15 : 5)}`,
            y: K.y + K.height * 1.2,
            fill: "#000000",
            textAnchor: "start",
            verticalAnchor: "start"
          },
          V
        ), w && te < K.width && /* @__PURE__ */ n.createElement(
          dt,
          {
            display: ae ? "block" : "none",
            x: K.x + ee.bars[K.index].width / 2,
            y: K.y + K.height / 2,
            fill: X,
            textAnchor: "middle",
            verticalAnchor: "middle"
          },
          Q
        )));
      })
    )
  ));
}, $c = (e, t) => {
  var A;
  const { formatDate: r, parseDate: a } = se.useContext(pt);
  let i = [], o = "", d = [], c = [];
  ((A = e.series) == null ? void 0 : A.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, c = e.data.map((p) => p[e.xAxis.dataKey])) : (i = [], o = "", d = [], c = []);
  const s = (p, v) => {
    const L = [...e.highlightedBarValues];
    L[v].borderWidth = p.target.value, t({
      ...e,
      highlightedBarValues: L
    });
  }, h = (p, v) => {
    p.preventDefault();
    const L = [...e.highlightedBarValues];
    L[v].value = p.target.value, L[v].dataKey = o, t({
      ...e,
      highlightedBarValues: L
    });
  }, y = (p, v) => {
    p.preventDefault();
    const L = [...e.highlightedBarValues];
    L.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: L
    });
  }, g = (p, v) => {
    p.preventDefault();
    const L = [...e.highlightedBarValues];
    L.splice(v, 1), t({
      ...e,
      highlightedBarValues: L
    });
  }, x = (p, v) => {
    const L = [...e.highlightedBarValues];
    L[v].color = p.target.value, t({
      ...e
    });
  }, w = (p, v) => {
    const L = [...e.highlightedBarValues];
    L[v].legendLabel = p.target.value, t({
      ...e,
      copyOfHighlightedBarValues: L
    });
  }, S = () => {
  };
  return S.checkFontColor = (p, v, L) => {
    if (e.xAxis.type === "date") {
      if (S.formatDates(v).includes(p))
        return "#000";
    } else if (v.includes(p))
      return "#000";
    return L;
  }, S.formatDates = (p) => p.map((v) => v ? r(a(v)) : !1), S.findDuplicates = (p) => {
    const v = {};
    return p == null ? void 0 : p.filter((P) => {
      const { legendLabel: R } = P;
      return v[R] ? !1 : (v[R] = !0, !0);
    });
  }, {
    HighLightedBarUtils: S,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: h,
    handleAddNewHighlightedBar: y,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: w,
    handleUpdateHighlightedBorderWidth: s
  };
};
function Vi(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const sg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: r,
  config: a,
  barWidth: i,
  isVertical: o
}) => {
  let c = t, s = r, h = "", y = !1, g = !1, x = !1;
  const w = a.general.showSuppressedSymbol;
  if (a.preliminaryData.forEach((p) => {
    (!p.column || p.column === e.key) && p.type === "suppression" && p.value && String(p.value) === String(e.value) && (!p.hideBarSymbol && w ? (c = i > 10 ? 3 : 0, s = 3, y = !0) : (c = 0, s = 0, y = !0));
  }), !y && !Vi(e.value) && a.general.showMissingDataLabel) {
    const p = hr(h, `normal ${i / 2}px sans-serif`), v = Number(p) < i && i > 10;
    g = !0, c = v ? 3 : 0, s = 3;
  }
  if (!y && e.value === "0" && a.general.showZeroValueData) {
    const p = hr("0", `normal ${i / 2}px sans-serif`), v = Number(p) < i && i > 10;
    x = !0, c = v ? 3 : 0, s = 3;
  }
  return { barWidthHorizontal: s, barHeight: c, isSuppressed: y, showMissingDataLabel: g, getBarY: (p, v) => y || g || x ? a.isLollipopChart ? v - 3 * 2 : v - 3 : p, getAbsentDataLabel: (p) => {
    let v = "";
    String(p) === "0" && (v = ""), y && (v = ""), g && (v = "N/A"), x && (v = "0");
    const L = hr(h, `normal ${i / 2}px sans-serif`), P = Number(L) < i && i > 10;
    return a.isLollipopChart || P && o ? v : o ? "" : v;
  } };
}, xs = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), ug = (e, t, r) => {
  const a = e.series.find((s) => s.dynamicCategory);
  if (!a)
    return t;
  const { dynamicCategory: i, dataKey: o } = a, d = e.runtime.originalXAxis.dataKey, c = Je.groupBy(t, d);
  return Object.values(c).map((s) => s.reduce((h, y) => {
    const g = y[o], x = y[i];
    if (r) {
      const { lower: w, upper: S } = e.confidenceKeys;
      h.CI || (h.CI = {});
      const A = y[w], p = y[S];
      h.CI[x] = { lower: A, upper: p };
    }
    return h[x] = g, h[d] = y[d], h.dynamicData = !0, h;
  }, {}));
}, uk = () => {
  const { xScale: e, yScale: t, xMax: r, yMax: a, seriesScale: i, convertLineToBarGraph: o } = se.useContext(Ns), [d, c] = se.useState(0), [s, h] = se.useState(0), {
    // prettier-ignore
    assignColorsToValues: y,
    barBorderWidth: g,
    getAdditionalColumn: x,
    getHighlightedBarByValue: w,
    getHighlightedBarColorByValue: S,
    lollipopBarWidth: A,
    lollipopShapeSize: p,
    onMouseLeaveBar: v,
    onMouseOverBar: L,
    section: P
  } = Ic(), { colorScale: R, config: C, dashboardConfig: z, tableData: W, formatDate: Z, formatNumber: ee, parseDate: K, seriesHighlight: le, setSharedFilter: Y, transformedData: ae, brushConfig: B } = se.useContext(pt), { HighLightedBarUtils: X } = $c(C), ce = document.documentElement, ne = getComputedStyle(ce).getPropertyValue("--cool-gray-90");
  let Q = ae;
  C.preliminaryData.some((U) => U.value && U.type === "suppression") && (Q = W), B.data.length && (Q = B.data);
  const j = Object.keys(C.confidenceKeys).length > 0, te = ug(C, Q, j);
  return C.visualizationSubType !== "stacked" && (C.visualizationType === "Bar" || C.visualizationType === "Combo" || o) && C.orientation === "vertical" && /* @__PURE__ */ n.createElement(et, null, /* @__PURE__ */ n.createElement(
    Dy,
    {
      data: te,
      keys: C.runtime.barSeriesKeys || C.runtime.seriesKeys,
      height: a,
      x0: (U) => {
        const ue = U[C.runtime.originalXAxis.dataKey];
        return Pn(C.runtime.xAxis) ? K(ue) : ue;
      },
      x0Scale: e,
      x1Scale: i,
      yScale: t,
      color: () => ""
    },
    (U) => U.map((ue, ke) => /* @__PURE__ */ n.createElement(
      et,
      {
        className: `bar-group-${ue.index}-${ue.x0}--${ke} ${C.orientation}`,
        key: `bar-group-${ue.index}-${ue.x0}--${ke}`,
        id: `bar-group-${ue.index}-${ue.x0}--${ke}`,
        left: ue.x0
      },
      ue.bars.map((xe, be) => {
        var cn, pn;
        const Ae = te[ue.index], Ye = Ae[C.runtime.originalXAxis.dataKey], Pe = C.yAxis.type === "logarithmic" ? 0.1 : 0;
        let ye = C.highlightedBarValues.map((ft) => ft.value).filter((ft) => ft !== void 0);
        ye = C.xAxis.type === "date" ? X.formatDates(ye) : ye;
        const Re = C.legend.behavior === "highlight" && le.length > 0 && le.indexOf(xe.key) === -1, fe = C.legend.behavior === "highlight" || le.length === 0 || le.indexOf(xe.key) !== -1;
        let ze = i.range()[1] - i.range()[0];
        const Ne = Math.abs(t(xe.value) - t(Pe)), qe = xe.value >= 0 && Vi(xe.value) ? xe.y : t(0);
        let He = C.isLollipopChart ? A : i.bandwidth(), Be = xe.x + (C.isLollipopChart ? (ze / ue.bars.length - A) / 2 : 0) - (C.xAxis.type === "date-time" ? ze / 2 : 0);
        c(He), h(ue.bars.length);
        const Ze = ee(/[a-zA-Z]/.test(String(xe.value)) ? "" : xe.value, "left"), Ve = C.runtime[P].type === "date" ? Z(K(Ye)) : Ye, je = xe.value < 0 ? -1 : be, Ue = x(xe.key, Ye);
        let we = C.runtime.xAxis.label ? `${C.runtime.xAxis.label}: ${Ve}` : Ve;
        const De = `${C.runtime.seriesLabels[xe.key]}: ${Ze}`, rt = `<ul>
                  <li class="tooltip-heading">${we}</li>
                  <li class="tooltip-body ">${De}</li>
                  ${Ue ? '<li class="tooltip-body ">' + Ue + "</li>" : ""}
                    </li></ul>`;
        let ge = "#000000";
        ge = X.checkFontColor(Ze, ye, ge);
        const ut = C.isLollipopChart && C.lollipopColorStyle === "regular", at = C.isLollipopChart && C.lollipopColorStyle === "two-tone", it = ye == null ? void 0 : ye.includes(Ve), St = S(Ve), jt = w(Ve), Bt = it ? St : C.barHasBorder === "true" ? "#000" : "transparent", Nt = it ? jt.borderWidth : C.isLollipopChart ? 0 : C.barHasBorder === "true" ? g : 0, { barHeight: sn, isSuppressed: gt, getBarY: Dt, getAbsentDataLabel: _t } = sg({
          bar: xe,
          defaultBarHeight: Ne,
          config: C,
          barWidth: He,
          isVertical: !0
        }), un = _t(Ze), En = gt || !C.labels ? "" : Ze, $t = Dt(qe, t(Pe)), It = xs(xe.value) ? "none" : "block", fn = (ft, Pt) => {
          var Tt;
          let Ot = ft, hn = Pt || "#f2f2f2";
          if (z && ((Tt = z.dashboard.sharedFilters) == null ? void 0 : Tt.length) !== 0) {
            const { sharedFilters: Ct } = z.dashboard;
            return Ot = Ct ? Ct.map((nn) => nn.setBy === C.uid ? nn.resetLabel === nn.active || nn.active === ae[ue.index][C.xAxis.dataKey] ? R(C.runtime.seriesLabels[xe.key]) : hn : R(C.runtime.seriesLabels[xe.key]))[0] : R(C.runtime.seriesLabels[xe.key]), ut && (Ot = ft), it && (Ot = "transparent"), C.legend.colorCode && (Ot = y(U.length, ue.index, ft)), at && (Ot = Ua(ft).brighten(1)), Ot;
          }
          return at && (Ot = Ua(ft).brighten(1)), C.legend.colorCode && (Ot = y(U.length, ue.index, ft)), it && (Ot = "transparent"), Ot;
        }, tt = 5, st = Be + (C.xAxis.type !== "date-time" ? He / 2 : 0), Tn = t(
          Ae.dynamicData && ((cn = Ae == null ? void 0 : Ae.CI) != null && cn[xe.key]) ? Ae.CI[xe.key].upper : Ae[C.confidenceKeys.upper]
        ), tn = t(
          Ae.dynamicData && ((pn = Ae == null ? void 0 : Ae.CI) != null && pn[xe.key]) ? Ae.CI[xe.key].lower : Ae[C.confidenceKeys.lower]
        );
        return /* @__PURE__ */ n.createElement(et, { key: `${ue.index}--${be}` }, /* @__PURE__ */ n.createElement(et, { key: `bar-sub-group-${ue.index}-${ue.x0}-${$t}--${be}` }, Ds({
          config: C,
          index: je,
          id: `barGroup${ue.index}`,
          background: fn(R(C.runtime.seriesLabels[xe.key])),
          borderColor: Bt,
          borderStyle: "solid",
          borderWidth: `${Nt}px`,
          width: He,
          height: sn,
          x: Be,
          y: $t,
          onMouseOver: () => L(Ve, xe.key),
          onMouseLeave: v,
          tooltipHtml: rt,
          tooltipId: `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          onClick: (ft) => {
            ft.preventDefault(), Y && (xe[C.xAxis.dataKey] = Ve, Y(C.uid, xe));
          },
          styleOverrides: {
            transformOrigin: `0 ${$t + sn}px`,
            opacity: Re ? 0.2 : 1,
            display: fe ? "block" : "none",
            cursor: z ? "pointer" : "default"
          }
        }), C.preliminaryData.map((ft, Pt) => {
          const Ot = !ft.column || ft.column === xe.key;
          if (!(String(ft.value) === String(xe.value) && ft.value !== "" && Ot) || He < 10 || !C.general.showSuppressedSymbol || ft.hideBarSymbol)
            return;
          const Ct = String(ft.symbol).includes("Asterisk"), nn = Ct ? -5 : -8, Nn = Ct ? "middle" : "end", At = ft.symbol === "Asterisk" ? He * 1.2 : ft.symbol === "Double Asterisk" ? He : He / 1.5, xt = ft.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            dt,
            {
              key: Pt,
              dy: nn,
              display: fe ? "block" : "none",
              opacity: Re ? 0.5 : 1,
              x: Be + He / 2,
              y: $t,
              verticalAnchor: Nn,
              fill: xt,
              textAnchor: "middle",
              fontSize: `${At}px`
            },
            ft.iconCode
          );
        }), /* @__PURE__ */ n.createElement(
          dt,
          {
            display: fe ? "block" : "none",
            opacity: Re ? 0.5 : 1,
            x: Be + He / 2,
            y: $t - 5,
            fill: ge,
            textAnchor: "middle"
          },
          xs(xe.value) ? "" : En
        ), /* @__PURE__ */ n.createElement(
          dt,
          {
            display: fe ? "block" : "none",
            opacity: Re ? 0.5 : 1,
            x: Be + He / 2,
            y: $t - 5,
            fill: ge,
            textAnchor: "middle",
            fontSize: C.isLollipopChart ? null : He / 2
          },
          un
        ), C.isLollipopChart && C.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: It,
            cx: Be + p / 3.5,
            cy: xe.y,
            r: p / 2,
            fill: fn(R(C.runtime.seriesLabels[xe.key])),
            key: `circle--${xe.index}`,
            "data-tooltip-html": rt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), C.isLollipopChart && C.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: It,
            x: Be - A / 2,
            y: xe.y,
            width: p,
            height: p,
            fill: fn(R(C.runtime.seriesLabels[xe.key])),
            key: `circle--${xe.index}`,
            "data-tooltip-html": rt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${p}`, dur: "2.5s" })
        ), j && xe.value !== void 0 && Ae && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-v-${Ae[C.runtime.originalXAxis.dataKey]}`,
            stroke: ne,
            strokeWidth: "px",
            d: `M${st - tt} ${Tn}
                                L${st + tt} ${Tn}
                                M${st} ${Tn}
                                L${st} ${tn}
                                M${st - tt} ${tn}
                                L${st + tt} ${tn}`
          }
        )));
      })
    ))
  ), /* @__PURE__ */ n.createElement(xp, { xScale: e, yMax: a, barWidth: d, totalBarsInGroup: s }));
}, ck = () => {
  var Q;
  const { xScale: e, yScale: t, yMax: r, seriesScale: a } = se.useContext(Ns), {
    transformedData: i,
    tableData: o,
    colorScale: d,
    seriesHighlight: c,
    config: s,
    formatNumber: h,
    formatDate: y,
    parseDate: g,
    setSharedFilter: x,
    isNumber: w
  } = se.useContext(pt), {
    isHorizontal: S,
    barBorderWidth: A,
    updateBars: p,
    assignColorsToValues: v,
    section: L,
    isLabelBelowBar: P,
    displayNumbersOnBar: R,
    lollipopBarWidth: C,
    lollipopShapeSize: z,
    getHighlightedBarColorByValue: W,
    getHighlightedBarByValue: Z,
    getAdditionalColumn: ee,
    hoveredBar: K,
    onMouseLeaveBar: le,
    onMouseOverBar: Y
  } = Ic(), { HighLightedBarUtils: ae } = $c(s), B = Object.keys(s.confidenceKeys).length > 0, X = ug(s, i, B), ce = document.documentElement, ne = getComputedStyle(ce).getPropertyValue("--cool-gray-90");
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ n.createElement(et, null, /* @__PURE__ */ n.createElement(
    Dy,
    {
      data: (Q = s.preliminaryData) != null && Q.some((V) => V.value && V.type === "suppression") ? o : X,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: r,
      x0: (V) => V[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (V) => p(V).map((j, te) => /* @__PURE__ */ n.createElement(
      et,
      {
        className: `bar-group-${j.index}-${j.x0}--${te} ${s.orientation}`,
        key: `bar-group-${j.index}-${j.x0}--${te}`,
        id: `bar-group-${j.index}-${j.x0}--${te}`,
        top: j.y
      },
      j.bars.map((U, ue) => {
        var hn;
        const ke = X[j.index], xe = ke[s.runtime.originalXAxis.dataKey], be = s.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Ae = s.highlightedBarValues.map((Tt) => Tt.value).filter((Tt) => Tt !== void 0);
        Ae = s.xAxis.type === "date" ? ae.formatDates(Ae) : Ae;
        let Ye = s.legend.behavior === "highlight" && c.length > 0 && c.indexOf(U.key) === -1, Pe = s.legend.behavior === "highlight" || c.length === 0 || c.indexOf(U.key) !== -1, ye = s.barHeight, Re = parseInt(s.isLollipopChart ? C : ye);
        isNaN(Re) && (Re = 25);
        let fe = U.value >= 0 && w(U.value) ? U.y : t(be);
        const ze = Math.abs(e(U.value) - e(be)), Ne = U.value >= 0 && w(U.value), {
          barWidthHorizontal: qe,
          isSuppressed: He,
          getAbsentDataLabel: Be
        } = sg({ bar: U, defaultBarWidth: ze, config: s, isNumber: w, isVertical: !1 }), Ze = U.value < 0 ? Math.abs(e(U.value)) : e(be), Ve = h(U.value, "left"), je = s.runtime[L].type === "date" ? y(g(xe)) : xe, Ue = Ne ? "above" : "below", we = Be(Ve), De = s.yAxis.displayNumbersOnBar ? Ve : "", rt = hr(De), ge = Number(rt) < ze - 5;
        let ut = ge ? "end" : "start", at = "start", it = ge ? -5 : 5, St = 10;
        Ue === "below" && (ut = ge ? "start" : "end", it = ge ? 5 : -5, s.isLollipopChart && (at = "end", St = -10));
        const jt = U.value < 0 ? -1 : ue;
        let Bt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${je}` : je;
        const Nt = ee(K), sn = `${s.runtime.seriesLabels[U.key]}: ${Ve}`, gt = `<ul>
                  <li class="tooltip-heading"">${Bt}</li>
                  <li class="tooltip-body ">${sn}</li>
                  <li class="tooltip-body ">${Nt}</li>
                    </li></ul>`;
        let Dt = "#000000";
        Dt = ae.checkFontColor(Ve, Ae, Dt);
        let _t = s.runtime.seriesLabels && s.runtime.seriesLabels[U.key] ? d(s.runtime.seriesLabels[U.key]) : d(U.key);
        s.series.find((Tt) => Tt.dynamicCategory) || (_t = v(V.length, j.index, _t));
        const En = s.isLollipopChart && s.lollipopColorStyle === "regular", $t = s.isLollipopChart && s.lollipopColorStyle === "two-tone", It = Ae == null ? void 0 : Ae.includes(je), fn = W(je), tt = Z(je), st = It ? fn : s.barHasBorder === "true" ? "#000" : "transparent", Tn = It ? tt.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? A : 0, tn = xs(U.value) ? "none" : "block";
        _t && Dt && ge && (Dt = il("#000", _t), Em("#000", _t) < 7 && (Dt = "#fff"));
        const cn = () => En ? _t : $t ? Ua(_t).brighten(1) : It ? "transparent" : _t, pn = 5, ft = ye * U.index + ye / 2, [Pt, Ot] = ["upper", "lower"].map((Tt) => {
          if (!B)
            return;
          if (ke.dynamicData) {
            const nn = ke.CI[U.key];
            if (!nn)
              return;
            const Nn = nn[Tt];
            return e(Nn);
          }
          const Ct = ke[s.confidenceKeys[Tt]];
          return e(Ct);
        });
        return /* @__PURE__ */ n.createElement(et, { key: `${j.index}--${ue}` }, /* @__PURE__ */ n.createElement(et, { key: `bar-sub-group-${j.index}-${j.x0}-${fe}--${ue}` }, Ds({
          config: s,
          index: jt,
          id: `barGroup${j.index}`,
          background: cn(),
          borderColor: st,
          borderStyle: "solid",
          borderWidth: `${Tn}px`,
          width: qe,
          height: Re,
          x: Ze,
          y: ye * U.index,
          onMouseOver: () => Y(je, U.key),
          onMouseLeave: le,
          tooltipHtml: gt,
          tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          onClick: (Tt) => {
            Tt.preventDefault(), x && (U[s.xAxis.dataKey] = Ve, x(s.uid, U));
          },
          styleOverrides: {
            transformOrigin: `0 ${fe + ye}px`,
            opacity: Ye ? 0.2 : 1,
            display: Pe ? "block" : "none"
          }
        }), (hn = s.preliminaryData) == null ? void 0 : hn.map((Tt, Ct) => {
          const nn = !Tt.column || Tt.column === U.key;
          if (!(String(Tt.value) === String(U.value) && Tt.value !== "" && nn) || Tt.hideBarSymbol || !s.general.showSuppressedSymbol)
            return;
          const Dn = String(Tt.symbol).includes("Asterisk") ? "middle" : "end", Oe = Tt.symbol === "Asterisk" ? ye * 1.2 : Tt.symbol === "Double Asterisk" ? ye : ye / 1.5, _e = Tt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            dt,
            {
              key: Ct,
              fontSize: Oe,
              display: Pe ? "block" : "none",
              opacity: Ye ? 0.5 : 1,
              x: Ze,
              y: s.barHeight / 2 + s.barHeight * U.index,
              fill: _e,
              dy: s.barHeight / 5,
              dx: 10,
              textAnchor: "start",
              verticalAnchor: Dn
            },
            Tt.iconCode
          );
        }), !s.isLollipopChart && /* @__PURE__ */ n.createElement(
          dt,
          {
            display: Pe ? "block" : "none",
            x: U.y,
            opacity: Ye ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * U.index,
            fill: Dt,
            dx: it,
            verticalAnchor: "middle",
            textAnchor: ut
          },
          xs(U.value) ? "" : De
        ), /* @__PURE__ */ n.createElement(
          dt,
          {
            display: Pe ? "block" : "none",
            x: U.y,
            opacity: Ye ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * U.index,
            fill: Dt,
            dx: we === "N/A" ? 20 : it,
            dy: s.isLollipopChart ? -10 : 0,
            verticalAnchor: "middle",
            textAnchor: we === "N/A" ? "middle" : ut
          },
          we
        ), s.isLollipopChart && /* @__PURE__ */ n.createElement(
          dt,
          {
            display: Pe ? "block" : "none",
            x: U.y,
            y: 0,
            fill: "#000000",
            dx: St,
            textAnchor: at,
            verticalAnchor: "middle",
            fontWeight: "normal"
          },
          xs(U.value) ? "" : De
        ), P && !s.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          dt,
          {
            x: s.yAxis.hideAxis ? 0 : 5,
            y: j.height,
            dy: 4,
            verticalAnchor: "start",
            textAnchor: "start"
          },
          s.runtime.yAxis.type === "date" ? y(g(xe)) : S ? xe : h(xe)
        ), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: tn,
            cx: U.y,
            cy: ye * U.index + C / 2,
            r: z / 2,
            fill: _t,
            key: `circle--${U.index}`,
            "data-tooltip-html": gt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: tn,
            x: U.y > 10 ? U.y - z / 2 : 0,
            y: 0 - C / 2,
            width: z,
            height: z,
            fill: _t,
            key: `circle--${U.index}`,
            "data-tooltip-html": gt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${z}`, dur: "2.5s" })
        ), B && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-h-${ft}-${ke[s.runtime.originalXAxis.dataKey]}`,
            stroke: ne,
            strokeWidth: "px",
            d: `
                                M${Ot} ${ft - pn}
                                L${Ot} ${ft + pn}
                                M${Ot} ${ft}
                                L${Pt} ${ft}
                                M${Pt} ${ft - pn}
                                L${Pt} ${ft + pn} `
          }
        )));
      })
    ))
  ));
}, Bu = {
  Vertical: uk,
  Horizontal: ck,
  StackedVertical: lk,
  StackedHorizontal: sk
}, dk = ({
  xScale: e,
  yScale: t,
  seriesScale: r,
  xMax: a,
  yMax: i,
  handleTooltipMouseOver: o,
  handleTooltipMouseOff: d,
  handleTooltipClick: c
}) => {
  const { transformedData: s, config: h, convertLineToBarGraph: y } = se.useContext(pt), g = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: i,
    seriesScale: r,
    convertLineToBarGraph: y
  };
  return /* @__PURE__ */ n.createElement(Vr, { component: "BarChart" }, /* @__PURE__ */ n.createElement(Ns.Provider, { value: g }, /* @__PURE__ */ n.createElement(et, { left: parseFloat(h.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(Bu.StackedVertical, null), /* @__PURE__ */ n.createElement(Bu.StackedHorizontal, null), /* @__PURE__ */ n.createElement(Bu.Vertical, null), /* @__PURE__ */ n.createElement(Bu.Horizontal, null), /* @__PURE__ */ n.createElement(
    Rr,
    {
      key: "bars",
      display: h.tooltips.singleSeries ? "none" : "block",
      width: Number(a),
      height: Number(i),
      fill: "transparent",
      fillOpacity: 0.05,
      onMouseMove: (x) => o(x, s),
      onMouseOut: d,
      onClick: (x) => c(x, s)
    }
  ))));
};
function Ha() {
  return Ha = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ha.apply(this, arguments);
}
function _i(e) {
  var t = e.x1, r = e.x2, a = e.y1, i = e.y2;
  return {
    x1: a,
    x2: i,
    y1: t,
    y2: r
  };
}
function cg(e) {
  var t = e.left, r = t === void 0 ? 0 : t, a = e.top, i = a === void 0 ? 0 : a, o = e.className, d = e.max, c = e.min, s = e.firstQuartile, h = e.thirdQuartile, y = e.median, g = e.boxWidth, x = g === void 0 ? 10 : g, w = e.fill, S = e.fillOpacity, A = e.stroke, p = e.strokeWidth, v = e.rx, L = v === void 0 ? 2 : v, P = e.ry, R = P === void 0 ? 2 : P, C = e.valueScale, z = e.outliers, W = z === void 0 ? [] : z, Z = e.horizontal, ee = e.medianProps, K = ee === void 0 ? {} : ee, le = e.maxProps, Y = le === void 0 ? {} : le, ae = e.minProps, B = ae === void 0 ? {} : ae, X = e.boxProps, ce = X === void 0 ? {} : X, ne = e.outlierProps, Q = ne === void 0 ? {} : ne, V = e.container, j = V === void 0 ? !1 : V, te = e.containerProps, U = te === void 0 ? {} : te, ue = e.children, ke = Z ? i : r, xe = ke + (x || 0) / 2, be = C.range(), Ae = C(c ?? 0), Ye = C(s ?? 0), Pe = C(y ?? 0), ye = C(h ?? 0), Re = C(d ?? 0), fe = {
    valueRange: be,
    center: xe,
    offset: ke,
    boxWidth: x,
    max: {
      x1: xe - (x || 0) / 4,
      x2: xe + (x || 0) / 4,
      y1: Re,
      y2: Re
    },
    maxToThird: {
      x1: xe,
      x2: xe,
      y1: Re,
      y2: ye
    },
    median: {
      x1: ke,
      x2: ke + (x || 0),
      y1: Pe,
      y2: Pe
    },
    minToFirst: {
      x1: xe,
      x2: xe,
      y1: Ye,
      y2: Ae
    },
    min: {
      x1: xe - (x || 0) / 4,
      x2: xe + (x || 0) / 4,
      y1: Ae,
      y2: Ae
    },
    box: {
      x1: ke,
      x2: x || 0,
      y1: ye,
      y2: Math.abs(ye - Ye)
    },
    container: {
      x1: ke,
      x2: x || 0,
      y1: Math.min.apply(Math, be),
      y2: Math.abs(be[0] - be[1])
    }
  };
  return Z && (fe.max = _i(fe.max), fe.maxToThird = _i(fe.maxToThird), fe.box.y1 = Ye, fe.box = _i(fe.box), fe.median = _i(fe.median), fe.minToFirst = _i(fe.minToFirst), fe.min = _i(fe.min), fe.container = _i(fe.container), fe.container.y1 = Math.min.apply(Math, be)), ue ? /* @__PURE__ */ n.createElement(n.Fragment, null, ue(fe)) : /* @__PURE__ */ n.createElement(et, {
    className: Rn("visx-boxplot", o)
  }, W.map(function(ze, Ne) {
    var qe = Z ? C(ze) : xe, He = Z ? xe : C(ze);
    return /* @__PURE__ */ n.createElement("circle", Ha({
      key: "visx-boxplot-outlier-" + Ne,
      className: "visx-boxplot-outlier",
      cx: qe,
      cy: He,
      r: 4,
      stroke: A,
      strokeWidth: p,
      fill: w,
      fillOpacity: S
    }, Q));
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-max",
    x1: fe.max.x1,
    y1: fe.max.y1,
    x2: fe.max.x2,
    y2: fe.max.y2,
    stroke: A,
    strokeWidth: p
  }, Y)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: fe.maxToThird.x1,
    y1: fe.maxToThird.y1,
    x2: fe.maxToThird.x2,
    y2: fe.maxToThird.y2,
    stroke: A,
    strokeWidth: p
  }), /* @__PURE__ */ n.createElement("rect", Ha({
    className: "visx-boxplot-box",
    x: fe.box.x1,
    y: fe.box.y1,
    width: fe.box.x2,
    height: fe.box.y2,
    stroke: A,
    strokeWidth: p,
    fill: w,
    fillOpacity: S,
    rx: L,
    ry: R
  }, ce)), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-median",
    x1: fe.median.x1,
    y1: fe.median.y1,
    x2: fe.median.x2,
    y2: fe.median.y2,
    stroke: A,
    strokeWidth: p
  }, K)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: fe.minToFirst.x1,
    y1: fe.minToFirst.y1,
    x2: fe.minToFirst.x2,
    y2: fe.minToFirst.y2,
    stroke: A,
    strokeWidth: p
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-min",
    x1: fe.min.x1,
    y1: fe.min.y1,
    x2: fe.min.x2,
    y2: fe.min.y2,
    stroke: A,
    strokeWidth: p
  }, B)), j && /* @__PURE__ */ n.createElement("rect", Ha({
    x: fe.container.x1,
    y: fe.container.y1,
    width: fe.container.x2,
    height: fe.container.y2,
    fillOpacity: "0"
  }, U)));
}
cg.propTypes = {
  max: Me.number,
  min: Me.number,
  firstQuartile: Me.number,
  thirdQuartile: Me.number,
  median: Me.number,
  boxWidth: Me.number,
  fill: Me.string,
  fillOpacity: Me.oneOfType([Me.number, Me.string]),
  stroke: Me.string,
  strokeWidth: Me.oneOfType([Me.number, Me.string]),
  rx: Me.number,
  ry: Me.number,
  outliers: Me.arrayOf(Me.number),
  container: Me.bool,
  children: Me.func
};
const fk = (e, t, r, a, i, o, d, c, s) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${s};">
        ${c ? `${c} : ${t}` : t}
      </div>
      <div class="" style="background: ${s}; height: 2px;"></div>
        <strong>Key:</strong> ${r}<br/>
        <strong>${e.labels.q1}:</strong> ${a}<br/>
        <strong>${e.labels.q3}:</strong> ${i}<br/>
        <strong>${e.labels.iqr}:</strong> ${d}<br/>
        <strong>${e.labels.median}:</strong> ${o}
    </div>
  `, pk = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = Je.sortBy(e), r = Ts(t, 0.25) ?? 0, a = Ts(t, 0.75) ?? 0, i = a - r, o = r - 1.5 * i, d = a + 1.5 * i, c = t.filter((s) => s >= o && s <= d);
  return {
    min: vf(c),
    // Smallest non-outlier value
    max: Ju(c),
    // Largest non-outlier value
    median: ry(t),
    // Median of all values
    firstQuartile: r,
    thirdQuartile: a,
    iqr: i
  };
}, hk = (e, t, r) => {
  const a = t.series.map((d) => d == null ? void 0 : d.dataKey), i = {}, o = r.filter((d) => d[t.xAxis.dataKey] === e);
  return a.forEach((d) => {
    i[d] = o.map((c) => c[d]);
  }), i;
}, mk = (e, t, r) => {
  const a = r - t, i = t - 1.5 * a, o = r + 1.5 * a;
  return e.filter((d) => d < i || d > o);
}, yk = (e, t, r) => {
  const a = r - t, i = t - 1.5 * a, o = r + 1.5 * a;
  return e.filter((d) => d >= i && d <= o);
}, gk = (e, t) => {
  const r = e.map((o) => o[t.xAxis.dataKey]), a = [], i = Je.uniq(r);
  return i && i.length > 0 && i.forEach((o) => {
    const d = hk(o, t, e), c = {}, s = {}, h = {}, y = {}, g = {}, x = {}, w = {}, S = {};
    Object.keys(d).forEach((A) => {
      const p = d[A], { firstQuartile: v, thirdQuartile: L, min: P, max: R, median: C, iqr: z } = pk(p);
      c[A] = mk(p, v, L).map(Number), s[A] = yk(p, v, L).map(Number), h[A] = C, y[A] = P, g[A] = R, x[A] = v, w[A] = L, S[A] = z;
    }), a.push({
      columnCategory: o,
      keyValues: d,
      columnOutliers: c,
      columnNonOutliers: s,
      min: y,
      max: g,
      q1: x,
      q3: w,
      median: h,
      iqr: S
    });
  }), a;
}, vk = ({ xScale: e, yScale: t, seriesScale: r }) => {
  const { config: a, colorScale: i, seriesHighlight: o, transformedData: d } = se.useContext(pt), { boxplot: c } = a, s = `cdc-open-viz-tooltip-${a.runtime.uniqueId}`, h = e.bandwidth(), g = getComputedStyle(document.body).getPropertyValue("--cool-gray-90").trim(), x = Math.min(40, h);
  Je.get(Sr, [a.palette, 0], "#000");
  const w = gk(d, a);
  return /* @__PURE__ */ n.createElement(Vr, { component: "BoxPlot" }, /* @__PURE__ */ n.createElement(et, { left: Number(a.yAxis.size), className: "boxplot", key: "boxplot-group" }, w.map((S, A) => {
    const p = h - x, v = 4;
    return /* @__PURE__ */ n.createElement(
      et,
      {
        key: `boxplotplot-${S.columnCategory}`,
        left: e(S.columnCategory) + (e.bandwidth() - r.bandwidth()) / 2
      },
      a.series.map((L, P) => {
        const R = a.legend.behavior === "highlight" && o.length > 0 && o.indexOf(L.dataKey) === -1, C = a.legend.behavior === "highlight" || o.length === 0 || o.indexOf(L.dataKey) !== -1, z = R ? 0.3 : 0.5;
        return /* @__PURE__ */ n.createElement(et, { key: `boxplotplot-${L.dataKey}-${P}` }, c.plotNonOutlierValues && S.columnNonOutliers[L.dataKey].map((W, Z) => /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: C ? "block" : "none",
            cx: r(L.dataKey) + r.bandwidth() / 2,
            cy: t(W),
            r: v,
            opacity: z,
            fill: g,
            style: { stroke: g },
            key: `boxplot-${A}--circle-${Z}`
          }
        )), C && /* @__PURE__ */ n.createElement(
          cg,
          {
            display: C ? "block" : "none",
            "data-left": e(S.columnCategory) + a.yAxis.size + p / 2 + 0.5,
            key: `box-plot-${A}-${L}`,
            min: Number(S.min[L.dataKey]),
            max: Number(S.max[L.dataKey]),
            left: r(L.dataKey),
            firstQuartile: S.q1[L.dataKey],
            thirdQuartile: S.q3[L.dataKey],
            median: S.median[L.dataKey],
            boxWidth: r.bandwidth(),
            fill: i(L.dataKey),
            fillOpacity: 1,
            stroke: g,
            valueScale: t,
            outliers: c.plotOutlierValues ? Je.map(S.columnOutliers[L.dataKey], (W) => W) : [],
            outlierProps: {
              style: {
                fill: g,
                opacity: z,
                stroke: g
              }
            },
            medianProps: {
              style: {
                opacity: z,
                stroke: g
              }
            },
            boxProps: {
              style: {
                stroke: g,
                strokeWidth: c.borders === "true" ? 1.5 : 0,
                opacity: z
              }
            },
            maxProps: {
              style: {
                opacity: z,
                stroke: g
              }
            },
            container: !0,
            containerProps: {
              "data-tooltip-html": fk(
                c,
                S.columnCategory,
                L.dataKey,
                Je.round(S.q1[L.dataKey], a.dataFormat.roundTo),
                Je.round(S.q3[L.dataKey], a.dataFormat.roundTo),
                Je.round(S.median[L.dataKey], a.dataFormat.roundTo),
                Je.round(S.iqr[L.dataKey], a.dataFormat.roundTo),
                a.xAxis.label,
                g
              ),
              "data-tooltip-id": s,
              tabIndex: -1
            }
          }
        ));
      })
    );
  })));
}, xk = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: r,
    config: a,
    tableData: i,
    formatNumber: o,
    seriesHighlight: d,
    colorPalettes: c
  } = se.useContext(pt), s = 4.5, h = Object.keys(a.runtime.seriesLabels).length > 1, y = Object.entries(a.columns).filter(([x, w]) => w.tooltips).map(([x, w]) => [
    w.label || w.name,
    w.name,
    {
      addColPrefix: w.prefix,
      addColSuffix: w.suffix,
      addColRoundTo: w.roundToPlace,
      addColCommas: w.commas
    }
  ]), g = (x, w, S) => `<div>
    ${a.legend.showLegendValuesTooltip && a.runtime.seriesLabels && h ? `${a.runtime.seriesLabels[w] || ""}<br/>` : ""}
    ${a.xAxis.label}: ${o(x[a.xAxis.dataKey], "bottom")} <br/>
    ${a.yAxis.label}: ${o(x[w], "left")}<br/>
   ${y.map(
    ([A, p, v]) => `${A} : ${Gf(i[S][p], "left", !1, a, v)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ n.createElement(et, { className: "scatter-plot", left: a.yAxis.size }, r.map((x, w) => a.runtime.seriesKeys.map((S, A) => {
    const p = a.legend.behavior === "highlight" && d.length > 0 && d.indexOf(S) === -1, v = a.legend.behavior === "highlight" || d.length === 0 || d.indexOf(S) !== -1, L = a != null && a.customColors ? a.customColors[A] : a.palette ? c[a.palette][A] : "#000";
    let P = {
      filter: "unset",
      opacity: 1,
      stroke: v ? "black" : ""
    };
    return /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `${w}-${A}`,
        r: s,
        cx: e(x[a.xAxis.dataKey]),
        cy: t(x[S]),
        fill: v ? L : "transparent",
        fillOpacity: p ? 0.25 : 1,
        style: P,
        "data-tooltip-html": g(x, S, w),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function bk({ height: e, xScale: t }) {
  const {
    transformedData: r,
    config: a,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: d,
    parseDate: c,
    formatDate: s,
    currentViewport: h
  } = se.useContext(pt), { barStyle: y, tipRounding: g, roundingStyle: x, twoColor: w } = a, S = se.useRef([]), [A, p] = se.useState(window.innerWidth), v = x === "standard" ? "8px" : x === "shallow" ? "5px" : x === "finger" ? "15px" : "0px";
  a.barStyle;
  const L = Number(a.xAxis.target), P = a.series[0].dataKey, R = Number(t.domain()[1]), z = r.some((ne) => ne[P] < 0) || L > 0 || t.domain()[0] < 0, W = a.barHasBorder === "true" ? 1 : 0, Z = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, ee = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, K = Math.max(t(0), Math.min(t(L), t(R))), le = (ne) => {
    if (ne == null || y !== "rounded")
      return;
    let Q = {};
    return ne === "left" && (Q = { borderRadius: `${v} 0 0 ${v}` }), ne === "right" && (Q = { borderRadius: `0 ${v} ${v} 0` }), g === "full" && (Q = { borderRadius: v }), Q;
  }, Y = {
    calculate: function() {
      const Q = r[0][P] < L ? "left" : "right", V = `${a.xAxis.targetLabel} ${i(a.xAxis.target || 0, "left")}`, j = hr(V);
      let te = a.isLollipopChart ? Z / 2 : Number(a.barHeight) / 2, U = 0, ue = 0, ke = !1;
      Q === "right" && (U = -10, ke = j - U < K, ue = K - j), Q === "left" && (U = 10, ke = t(R) - K > j + U, ue = K), this.text = V, this.y = te, this.x = ue, this.padding = U, this.showLabel = a.xAxis.showTargetLabel ? ke : !1;
    }
  };
  Y.calculate();
  const ae = se.useRef(null), B = pp(ae, {});
  se.useEffect(() => {
    const ne = () => {
      var Q;
      p(window.innerWidth), (Q = S.current) == null || Q.forEach((V) => {
        !V || !V.style || (V.style.transition = "none", V.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", ne), () => {
      window.removeEventListener("resize", ne);
    };
  }, []);
  const [X, ce] = se.useState(!1);
  return se.useEffect(() => {
    B != null && B.isIntersecting && setTimeout(() => {
      ce(!0);
    }, 100);
  }, [B == null ? void 0 : B.isIntersecting, a.animate]), se.useEffect(() => {
    var ne;
    (ne = S.current) == null || ne.forEach((Q, V) => {
      if (!(!Q || !Q.style)) {
        if (a.animate) {
          const j = L / R * 100;
          Q.style.opacity = "0", Q.style.transform = `translate(${j / 1.07}%) scale(0, 1)`, setTimeout(() => {
            Q.style.opacity = "1", Q.style.transform = "translate(0) scale(1)", Q.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          Q.style.transition = "none", Q.style.opacity = "0";
        a.animate || (Q.style.transition = "none", Q.style.opacity = "1");
      }
    });
  }, [a.animate, a, X]), /* @__PURE__ */ n.createElement(Vr, { component: "Deviation Bar" }, /* @__PURE__ */ n.createElement(et, { left: Number(a.xAxis.size) }, r.map((ne, Q) => {
    const V = Number(ne[P]), j = a.isLollipopChart ? Z : Number(a.barHeight), te = Number(a.barSpace), U = Math.abs(t(V) - K), ue = t(V), ke = V > L ? K : ue, xe = V < L ? "left" : "right";
    let be = 0;
    be = Q !== 0 ? (te + j + W) * Q : be;
    const Ae = (te + j + W) * r.length;
    a.heights.horizontal = Ae;
    const Pe = hr(i(V, "left")) < U - 6, ye = ue, Re = be + j / 2, fe = ue, ze = be + j / 2, Ne = ue, qe = be - j / 2, He = le(xe), [Be, Ze] = o[w.palette], Ve = { left: Be, right: Ze }, je = il("#000", Ve[xe]);
    let Ue = Ek(a.isLollipopChart, Pe, ee, je);
    const we = i(V, "left"), De = a.runtime.yAxis.type === "date" ? s(c(r[Q][a.runtime.originalXAxis.dataKey])) : r[Q][a.runtime.originalXAxis.dataKey];
    let rt = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${De}` : De, ge = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${we}` : we;
    const ut = `<div>
          ${rt}<br />
          ${ge}
            </div>`;
    return /* @__PURE__ */ n.createElement(et, { key: `deviation-bar-${a.orientation}-${P}-${Q}` }, /* @__PURE__ */ n.createElement(
      "foreignObject",
      {
        ref: (at) => {
          S.current[Q] = at;
        },
        x: ke,
        y: be,
        width: U,
        height: j,
        "data-tooltip-html": ut,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          style: {
            width: U,
            height: j,
            border: `${W}px solid #333`,
            backgroundColor: Ve[xe],
            ...He
          }
        }
      )
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ n.createElement(dt, { verticalAnchor: "middle", x: ye, y: Re, ...Ue[xe] }, i(ne[P], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: fe,
        cy: ze,
        r: ee / 2,
        fill: Ve[xe],
        style: { filter: "unset", opacity: 1 }
      }
    ), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        x: Ne,
        y: qe,
        width: ee,
        height: ee,
        fill: Ve[xe],
        style: { opacity: 1, filter: "unset" }
      }
    ));
  }), Y.showLabel && /* @__PURE__ */ n.createElement(dt, { fontWeight: "bold", dx: Y.padding, verticalAnchor: "middle", x: Y.x, y: Y.y }, Y.text), z && /* @__PURE__ */ n.createElement(ln, { from: { x: K, y: 0 }, to: { x: K, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ n.createElement("foreignObject", { y: e / 2, ref: ae }));
}
function Ek(e, t, r, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: r + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -r,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const Sk = ({ xScale: e, yScale: t, height: r, width: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var S;
  const { transformedData: d, rawData: c, config: s, seriesHighlight: h } = se.useContext(pt), { xAxis: y, yAxis: g, legend: x, runtime: w } = s;
  return d && /* @__PURE__ */ n.createElement(Vr, { component: "ForecastingChart" }, /* @__PURE__ */ n.createElement(et, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(g.size) }, (S = w.forecastingSeriesKeys) == null ? void 0 : S.map((A, p) => !A || !A.stages ? !1 : A.stages.map((v, L) => {
    var W;
    const { behavior: P } = x, R = c.filter((Z) => Z[A.stageColumn] === v.key);
    let C = P === "highlight" && h.length > 0 && h.indexOf(v.key) === -1, z = P === "highlight" || h.length === 0 || h.indexOf(v.key) !== -1;
    return /* @__PURE__ */ n.createElement(et, { className: `forecasting-areas-combo-${p}`, key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}-${p}` }, (W = A.confidenceIntervals) == null ? void 0 : W.map((Z, ee) => {
      const K = Yu[v.color] || Sr[v.color] || !1, le = () => z && K[2] ? K[2] : "transparent", Y = () => z && K[1] ? K[1] : "transparent";
      if (!(Z.high === "" || Z.low === ""))
        return /* @__PURE__ */ n.createElement(et, { key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}--group-${L}-${ee}` }, /* @__PURE__ */ n.createElement(
          q0,
          {
            curve: Wu,
            data: R,
            fill: le(),
            opacity: C ? 0.1 : 0.5,
            x: (ae) => e(Date.parse(ae[y.dataKey])),
            y0: (ae) => t(ae[Z.low]),
            y1: (ae) => t(ae[Z.high])
          }
        ), ee === 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Hr, { data: R, x: (ae) => Number(e(Date.parse(ae[y.dataKey]))), y: (ae) => Number(t(ae[Z.high])), curve: Wu, stroke: Y(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ n.createElement(Hr, { data: R, x: (ae) => Number(e(Date.parse(ae[y.dataKey]))), y: (ae) => Number(t(ae[Z.low])), curve: Wu, stroke: Y(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ n.createElement(et, { key: "tooltip-hover-section" }, /* @__PURE__ */ n.createElement(Rr, { key: "bars", width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (A) => i(A, d), onMouseOut: o }))));
};
function Hc(e, t) {
  const r = e.series.every(({ type: w }) => w === "Bar"), a = e.series.every(({ type: w }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(w)), i = (w) => (S) => w.reduce((A, p) => isNaN(Number(S[p])) ? A : A + Number(S[p]), 0), o = (w) => {
    const S = e.runtime.series.find((A) => A.dataKey === w);
    return S != null && S.dynamicCategory ? S.originalDataKey : w;
  }, d = () => {
    let w = Math.max(
      ...t == null ? void 0 : t.map(
        (S) => Math.max(
          ...e.runtime.seriesKeys.map((A) => {
            const p = o(A);
            return Vi(S[p]) ? Number(h(S[p])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && r) && e.visualizationSubType === "stacked") {
      const S = t.map(i(e.runtime.seriesKeys)).filter((A) => !isNaN(A));
      w = Math.max(...S);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const S = t.map(i(e.runtime.seriesKeys));
      w = Math.max(...S);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (w = Math.max(
      ...t.map((S) => Vi(S[e.series.dataKey]) ? Number(h(S[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !r && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const S = t.map(i(e.runtime.barSeriesKeys)), A = Math.max(
        ...t.map((v) => Math.max(...e.runtime.lineSeriesKeys.map((L) => Number(h(v[L])))))
      ), p = Math.max(...S);
      w = Math.max(p, A);
    }
    return w;
  }, c = () => {
    const w = Math.min(
      ...t.map(
        (S) => Math.min(
          ...e.runtime.seriesKeys.map((A) => {
            const p = o(A);
            return Vi(S[p]) ? Number(h(S[p])) : 1 / 0;
          })
        )
      )
    );
    return String(w);
  }, s = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((w) => t.some((S) => S[o(w)] >= 0)) : !1, h = (w) => w === null || w === "" ? "" : typeof w == "string" ? w.replace(/[,$]/g, "") : w, y = Number(d()), g = Number(c()), x = s();
  return { minValue: g, maxValue: y, existPositiveValue: x, isAllLine: a };
}
function bp({ config: e, yMax: t = 0, data: r = [], updateConfig: a }) {
  var x, w, S, A;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((p) => p.axis === "Right").map((p) => p.dataKey);
  let { minValue: d } = Hc(e, r);
  const c = (p) => {
    if (!p)
      return [0];
    let v = [];
    return p.map((L, P) => v = [...v, ...r.map((R) => Number(R[L]))]), v;
  };
  let s = Math.max.apply(null, c(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const h = ((w = (x = e.runtime) == null ? void 0 : x.barSeriesKeys) == null ? void 0 : w.length) > 0, y = ((A = (S = e.runtime) == null ? void 0 : S.lineSeriesKeys) == null ? void 0 : A.length) > 0;
  return (h || y) && d > 0 && (d = 0), { yScaleRight: Vn({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: i };
}
const kk = (e) => {
  const { preliminaryData: t, data: r, stroke: a, strokeWidth: i, handleLineType: o, lineType: d, seriesKey: c } = e, s = t.filter(
    (x) => x.seriesKey && x.column && x.value && x.type && x.style && x.type === "effect"
  ), h = (x) => s.find(
    (w) => w.seriesKey === c && x[w.column] === w.value && w.type === "effect" && w.style !== "Open Circles"
  );
  let y = [];
  const g = (x) => ({
    stroke: a,
    strokeWidth: i,
    strokeDasharray: x
  });
  return r.forEach((x, w) => {
    let S = h(x), A = g(o(S ? S.style : d));
    y.push(A), S && w > 0 && (y[w - 1] = g(o(S.style)));
  }), y;
}, wk = (e, t, r) => {
  const a = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    a.forEach((d) => {
      if (o[d.column] === d.value && d.seriesKey === r && o[r] && d.style === "Open Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !1
        };
        i.push(c);
      }
      if ((!d.value || o[d.column] === d.value) && d.seriesKey === r && o[r] && d.style === "Filled Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !0
        };
        i.push(c);
      }
    });
  }), i;
}, kc = (e) => !isNaN(parseFloat(e)) && isFinite(e), Tk = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return i;
  const o = e[0], d = (s) => {
    if (!(s.type === "effect" || s.hideLineStyle))
      return s.type == "suppression" && s.value === o[t] && (!s.column || s.column === t);
  }, c = r.find(d);
  if (c && c.style) {
    const s = { ...o, [t]: 0 };
    i.data[a].push(s), i.style = c.style;
    let h = 1;
    for (; h < e.length && !kc(e[h][t]); )
      h++;
    h < e.length && i.data[a].push(e[h]);
  } else
    i.data[a].push(o);
  return i;
}, Ck = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  let o = -1;
  return r == null || r.forEach((d) => {
    if (d.type !== "effect" && e[e.length - 1][t] === d.value && d.style && (!d.column || d.column === t) && d.type == "suppression" && !d.hideLineStyle) {
      const c = e.length - 1, s = { ...e[c], [t]: 0 };
      i.data[a].push(s);
      let h = c - 1;
      for (; h >= 0 && !kc(e[h][t]); )
        h--;
      h >= 0 && o !== h && (i.data[a].push(e[h]), o = h), i.style = d.style;
    }
  }), i;
};
function Ak(e, t, r) {
  let a = {
    data: {},
    style: ""
  }, i = 1;
  return e.forEach((o, d) => {
    r.forEach((c) => {
      const s = c.value;
      if (o[t] === s) {
        let h = null, y = null;
        for (let g = d - 1; g >= 0; g--)
          if (kc(e[g][t])) {
            h = e[g];
            break;
          }
        for (let g = d + 1; g < e.length; g++)
          if (kc(e[g][t])) {
            y = e[g];
            break;
          }
        h && y && (a.style = c.style, a.data[i++] = [h, y]);
      }
    });
  }), a;
}
const Lk = (e, t, r, a) => {
  const i = Tk(e, t, r), o = Ck(e, t, r), d = Ak(e, t, r);
  return [i, d, o];
};
var Pk = ["children", "className", "top", "left", "size"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function Rk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Ep(e) {
  var t = e.children, r = e.className, a = e.top, i = e.left, o = e.size, d = Rk(e, Pk), c = Rg();
  return c.type(f0), (typeof o == "number" || o) && c.size(o), t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: c
  })) : /* @__PURE__ */ n.createElement(Yf, {
    top: a,
    left: i
  }, /* @__PURE__ */ n.createElement("path", Wf({
    className: Rn("visx-glyph-cross", r),
    d: c() || ""
  }, d)));
}
Ep.propTypes = {
  children: Me.func,
  className: Me.string,
  top: Me.number,
  left: Me.number,
  size: Me.oneOfType([Me.number, Me.func])
};
const Nk = [
  Sm,
  km,
  Gu,
  wm,
  Gu,
  Ep,
  ({ fill: e }) => /* @__PURE__ */ n.createElement(Yf, null, /* @__PURE__ */ n.createElement(dt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, ""))
], lf = (e) => {
  var ee, K, le, Y, ae, B, X, ce;
  const {
    config: t,
    d: r,
    tableData: a,
    displayArea: i,
    seriesKey: o,
    tooltipData: d,
    xScale: c,
    yScale: s,
    colorScale: h,
    parseDate: y,
    yScaleRight: g,
    data: x,
    circleData: w,
    dataIndex: S,
    mode: A,
    seriesIndex: p
  } = e, { lineDatapointStyle: v, visual: L } = t, P = (K = (ee = t == null ? void 0 : t.runtime) == null ? void 0 : ee.series.filter((ne) => ne.dataKey === o)) == null ? void 0 : K[0], R = Nk[t.visual.lineDatapointSymbol === "standard" && p < L.maximumShapeAmount ? p : 0], C = p === 4, z = (ne, Q) => `translate(${Q}, ${ne})${C ? " rotate(180)" : ""}`, W = (ne, Q, V, j, te) => {
    const U = V.runtime.seriesLabels || [];
    let ue = ne ? Q(U[j] || te) : " transparent";
    return V.lineDatapointColor === "Lighter than Line" && ue !== "transparent" && ue && (ue = Ua(ue).brighten(1)), ue;
  }, Z = (ne) => (t.xAxis.type === "categorical" ? c(ne) : c(y(ne))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (A === "ALWAYS_SHOW_POINTS" && v !== "hidden" && v === "always show") {
    if ((w == null ? void 0 : w.some(
      (j) => j[t.xAxis.dataKey] === r[t.xAxis.dataKey] && j[o] === r[o]
    )) || !P || L.maximumShapeAmount === p && L.lineDatapointSymbol === "standard")
      return /* @__PURE__ */ n.createElement(n.Fragment, null);
    const Q = Z(r[t.xAxis.dataKey]), V = P.axis === "Right" ? g(r[P.dataKey]) : s(r[P.dataKey]);
    return /* @__PURE__ */ n.createElement("g", { transform: z(V, Q) }, /* @__PURE__ */ n.createElement(
      R,
      {
        opacity: r[o] ? 1 : 0,
        fillOpacity: 1,
        fill: W(i, h, t, o, o),
        style: { filter: "unset", opacity: 1 }
      }
    ));
  }
  if (A === "HOVER_POINTS" && v === "hover") {
    if (!d || !o || !d.data)
      return;
    let ne = (Y = (le = d == null ? void 0 : d.data) == null ? void 0 : le[0]) == null ? void 0 : Y[1];
    if (!ne)
      return;
    let Q, V = d.data.filter((U) => U[0] === o), j = (ae = V == null ? void 0 : V[0]) == null ? void 0 : ae[0], te = (B = V == null ? void 0 : V[0]) == null ? void 0 : B[2];
    return j ? (d == null || d.data.indexOf(j), Q = (X = a == null ? void 0 : a.find((U) => U[t == null ? void 0 : t.xAxis.dataKey] === ne)) == null ? void 0 : X[o], d == null ? void 0 : d.data.map((U, ue) => {
      if (isNaN(Q))
        return /* @__PURE__ */ n.createElement(n.Fragment, null);
      if ((w == null ? void 0 : w.some((Ae) => Ae[t.xAxis.dataKey] === ne)) || !Q || L.maximumShapeAmount === p && L.lineDatapointSymbol === "standard")
        return /* @__PURE__ */ n.createElement(n.Fragment, null);
      const xe = te === "right" ? g(Q) : s(Q), be = Z(ne);
      return /* @__PURE__ */ n.createElement("g", { transform: z(xe, be) }, /* @__PURE__ */ n.createElement(
        R,
        {
          size: 55,
          opacity: 1,
          fillOpacity: 1,
          fill: W(i, h, t, j, o),
          style: { filter: "unset", opacity: 1 }
        }
      ));
    })) : void 0;
  }
  if (A === "ISOLATED_POINTS" && ((Q, V) => {
    const j = x[Q], te = x[Q - 1] || {}, U = x[Q + 1] || {};
    if (w.some((Ae) => (Ae == null ? void 0 : Ae.data[V]) === j[V]))
      return !1;
    const ke = Q === 0 && !U[V], xe = Q === x.length - 1 && !te[V], be = Q > 0 && Q < x.length - 1 && j[V] && !te[V] && !U[V];
    return ke || xe || be;
  })(S, o) && !t.series.some((Q) => Q.dynamicCategory)) {
    const Q = (P == null ? void 0 : P.axis) === "Right" ? g(r[P == null ? void 0 : P.dataKey]) : s(r[P == null ? void 0 : P.dataKey]), V = Z(r[(ce = t.xAxis) == null ? void 0 : ce.dataKey]), j = h(t.runtime.seriesLabels[o]);
    return /* @__PURE__ */ n.createElement("g", { transform: z(Q, V) }, /* @__PURE__ */ n.createElement(R, { size: 124, stroke: j, fill: j }));
  }
  return null;
}, Dk = (e) => {
  var y, g;
  const { config: t, xScale: r, yScale: a, parseDate: i } = e;
  if (!((y = t == null ? void 0 : t.runtime) != null && y.series))
    return;
  const o = (x) => {
    if (t.xAxis.type === "date")
      return i(x).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(x);
    if (t.xAxis.type === "categorical")
      return x;
  }, d = (x) => r.bandwidth ? r.bandwidth() / 2 + Number(x) : Number(x), c = (x) => {
    var w;
    return (w = Object.values(t.columns)) == null ? void 0 : w.filter((S) => S.tooltips).map((S) => `
        <li className='tooltip-body'>
          <strong>${S.label || S.name}</strong>: ${x[S.name]}
        </li>`).join(" ");
  }, s = (x) => `<ul> ${c(x)} </ul>`, h = (g = t.runtime) == null ? void 0 : g.series.map((x) => t.data.map((w, S) => {
    let A = w[x.dataKey], p = w[t.xAxis.dataKey];
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: `bump-circle-${A}-${S}` }, /* @__PURE__ */ n.createElement(et, { left: Number(t.runtime.yAxis.size) }, A && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `bump-circle-${A}-${S}`,
        "data-tooltip-html": s(w),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(d(r(o(p)))),
        cy: Number(a(A)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), A.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(p)))) - 7,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(p)))) - 4,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ))));
  }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, h);
}, cm = (e) => {
  var ae;
  const {
    getXAxisData: t,
    getYAxisData: r,
    handleTooltipClick: a,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: c,
    xScale: s,
    yMax: h,
    yScale: y
  } = e, { colorScale: g, config: x, formatNumber: w, handleLineType: S, parseDate: A, seriesHighlight: p, tableData: v, transformedData: L, updateConfig: P, brushConfig: R, clean: C } = se.useContext(pt), { yScaleRight: z } = bp({ config: x, yMax: h, data: L, updateConfig: P });
  if (!o)
    return;
  const { lineDatapointStyle: W, showLineSeriesLabels: Z, legend: ee } = x;
  let K = L, le = v;
  R.data.length > 0 && ((ae = x.brush) != null && ae.active) && (K = C(R.data), le = C(R.data));
  const Y = (B) => s(t(B)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
  return /* @__PURE__ */ n.createElement(Vr, { component: "LineChart" }, /* @__PURE__ */ n.createElement(et, { left: Number(x.runtime.yAxis.size) }, " ", (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((B, X) => {
    var xe;
    const ce = x.runtime.series.find((be) => be.dataKey === B), ne = ce.type, Q = ce.axis || "left", V = ee.behavior === "highlight" || p.length === 0 || p.indexOf(B) !== -1, j = Lk(
      v,
      B,
      x.preliminaryData,
      x.xAxis.dataKey
    ), te = ((xe = x == null ? void 0 : x.preliminaryData) == null ? void 0 : xe.filter((be) => be.style && !be.style.includes("Circles")).length) > 0, U = ce.dynamicCategory ? K.filter((be) => be[ce.dynamicCategory] === B) : K, ue = ce.dynamicCategory ? ce.originalDataKey : B, ke = wk(x == null ? void 0 : x.preliminaryData, le, ue);
    return /* @__PURE__ */ n.createElement(
      et,
      {
        key: `series-${B}-${X}`,
        opacity: ee.behavior === "highlight" && p.length > 0 && p.indexOf(ue) === -1 ? 0.5 : 1,
        display: ee.behavior === "highlight" || p.length === 0 && !ee.dynamicLegend || p.indexOf(ue) !== -1 ? "block" : "none"
      },
      /* @__PURE__ */ n.createElement(
        Rr,
        {
          key: "bars",
          width: Number(c),
          height: Number(h),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (be) => o(be, v),
          onMouseOut: i,
          onClick: (be) => a(be, K)
        }
      ),
      U.map((be, Ae) => Vi(be[ue]) && /* @__PURE__ */ n.createElement(n.Fragment, { key: `series-${B}-point-${Ae}` }, x.labels && /* @__PURE__ */ n.createElement(
        dt,
        {
          x: Y(be),
          y: Q === "Right" ? z(r(be, ue)) : y(r(be, ue)),
          fill: "#000",
          textAnchor: "middle"
        },
        w(be[ue], "left")
      ), W === "always show" && /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ALWAYS_SHOW_POINTS",
          dataIndex: Ae,
          circleData: ke,
          tableData: v,
          data: U,
          d: be,
          config: x,
          seriesKey: ue,
          displayArea: V,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: A,
          yScaleRight: z,
          seriesAxis: Q,
          seriesIndex: X,
          key: `line-circle--${Ae}`
        }
      ), /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ISOLATED_POINTS",
          seriesIndex: X,
          dataIndex: Ae,
          tableData: v,
          circleData: ke,
          data: U,
          d: be,
          config: x,
          seriesKey: ue,
          displayArea: V,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: A,
          yScaleRight: z,
          seriesAxis: Q,
          key: `isolated-circle-${Ae}`
        }
      ))),
      /* @__PURE__ */ n.createElement(n.Fragment, null, W === "hover" && /* @__PURE__ */ n.createElement(
        lf,
        {
          seriesIndex: X,
          tableData: v,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: ke,
          data: U,
          config: x,
          seriesKey: B,
          displayArea: V,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: A,
          yScaleRight: z,
          seriesAxis: Q
        }
      )),
      te ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        My,
        {
          curve: Mi[ce.lineType],
          segments: U.map((be) => [be]),
          segmentation: "x",
          x: (be) => Y(be),
          y: (be) => Q === "Right" ? z(r(be, ue)) : y(Number(r(be, ue))),
          styles: kk({
            preliminaryData: x.preliminaryData,
            data: le,
            stroke: g(x.runtime.seriesLabels[B]),
            strokeWidth: ce.weight || 2,
            handleLineType: S,
            lineType: ne,
            seriesKey: B
          }),
          defined: (be, Ae) => be[B] !== "" && be[B] !== null && be[B] !== void 0
        }
      ), j.map((be, Ae) => Object.entries(be.data).map(([Ye, Pe]) => {
        var ye;
        return /* @__PURE__ */ n.createElement(
          Hr,
          {
            key: Ae,
            data: Pe,
            x: (Re) => Y(Re),
            y: (Re) => Q === "Right" ? z(r(Re, B)) : y(Number(r(Re, B))),
            stroke: g(x.runtime.seriesLabels[B]),
            strokeWidth: ((ye = ce[0]) == null ? void 0 : ye.weight) || 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            strokeDasharray: S(be.style),
            defined: (Re, fe) => Re[B] !== "" && Re[B] !== null && Re[B] !== void 0
          }
        );
      }))) : /* @__PURE__ */ n.createElement(n.Fragment, null, x.confidenceKeys && x.series.map((be, Ae) => be.dynamicCategory ? [...new Set(K.map((Pe) => Pe[be.dynamicCategory]))].map((Pe, ye) => {
        const Re = K.filter((fe) => fe[be.dynamicCategory] === Pe);
        return /* @__PURE__ */ n.createElement(
          Pf,
          {
            key: `area-closed-${Ae}-${ye}`,
            data: Re,
            x: (fe) => Y(fe),
            y0: (fe) => y(fe[x.confidenceKeys.lower]),
            y1: (fe) => y(fe[x.confidenceKeys.upper]),
            opacity: 0.5,
            fill: g(Pe),
            yScale: y,
            curve: Mi[be.lineType]
          }
        );
      }) : /* @__PURE__ */ n.createElement(
        Pf,
        {
          key: `area-closed-${Ae}`,
          data: K,
          x: (Ye) => Y(Ye),
          y0: (Ye) => y(Ye[x.confidenceKeys.lower]),
          y1: (Ye) => y(Ye[x.confidenceKeys.upper]),
          opacity: 0.5,
          fill: g(
            x.runtime.seriesLabels ? x.runtime.seriesLabels[be.dataKey] : be.dataKey
          ),
          yScale: y,
          curve: Mi[be.lineType]
        }
      )), /* @__PURE__ */ n.createElement(
        Hr,
        {
          curve: Mi[ce.lineType],
          data: x.visualizationType == "Bump Chart" ? U : x.xAxis.type === "date-time" || x.xAxis.type === "date" ? U.sort((be, Ae) => {
            let Ye = t(be), Pe = t(Ae);
            return Ye < Pe ? -1 : Pe < Ye ? 1 : 0;
          }) : U,
          x: (be) => Y(be),
          y: (be) => Q === "Right" ? z(r(be, ue)) : y(Number(r(be, ue))),
          stroke: g(x.runtime.seriesLabels[B]),
          strokeWidth: ce.weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ne ? S(ne) : 0,
          defined: (be, Ae) => be[ue] !== "" && be[ue] !== null && be[ue] !== void 0
        }
      )),
      ke.map((be, Ae) => /* @__PURE__ */ n.createElement(
        "circle",
        {
          key: Ae,
          cx: Y(be.data),
          cy: Q === "Right" ? z(r(be.data, ue)) : y(Number(r(be.data, ue))),
          r: be.size,
          strokeWidth: ce.weight || 2,
          stroke: g ? g(x.runtime.seriesLabels[B]) : "#000",
          fill: be.isFilled ? g ? g(x.runtime.seriesLabels[B]) : "#000" : "#fff"
        }
      )),
      x.animate && /* @__PURE__ */ n.createElement(
        Hr,
        {
          className: "animation",
          curve: Mi[ce.lineType],
          data: U,
          x: (be) => Y(be),
          y: (be) => Q === "Right" ? z(r(be, ue)) : y(Number(r(be, ue))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ne ? S(ne) : 0,
          defined: (be, Ae) => be[B] !== "" && be[B] !== null && be[B] !== void 0
        }
      ),
      Z && (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((be) => {
        let Ae;
        for (let Ye = U.length - 1; Ye >= 0; Ye--)
          if (U[Ye][be]) {
            Ae = U[Ye];
            break;
          }
        return Ae ? /* @__PURE__ */ n.createElement(
          dt,
          {
            x: Y(Ae) + 5,
            y: y(r(Ae, be)),
            alignmentBaseline: "middle",
            fill: x.colorMatchLineSeriesLabels && g ? g(x.runtime.seriesLabels[be] || be) : "black"
          },
          x.runtime.seriesLabels[be] || be
        ) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      })
    );
  }), x.legend.dynamicLegend && p.length === 0 && /* @__PURE__ */ n.createElement(dt, { x: c / 2, y: h / 2, fill: "black", textAnchor: "middle", color: "black" }, x.legend.dynamicLegendChartMessage)), x.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(Dk, { config: x, xScale: s, yScale: y }));
}, _k = ({
  xScale: e,
  yScale: t,
  config: r,
  height: a,
  width: i,
  handleTooltipMouseOff: o,
  handleTooltipMouseOver: d,
  forestPlotRightLabelRef: c
}) => {
  const { rawData: s, updateConfig: h } = se.useContext(pt), { forestPlot: y } = r, g = r.xAxis.tickWidthMax + 10, [x, w] = se.useState(!1);
  se.useEffect(() => {
    try {
      const R = ["estimateField", "lower", "upper", "estimateRadius"], C = r, z = 10;
      for (let W = 0; W < z; W++)
        R.forEach((Z) => {
          var ee;
          r.forestPlot[Z] && r.forestPlot[Z] !== ((ee = C.columns[r.forestPlot[`additionalColumn${W}`]]) == null ? void 0 : ee.name) && (delete C.columns[`additionalColumn${W}`], C.columns[r.forestPlot[Z]] = {}, C.columns[r.forestPlot[Z]].dataKey = C.forestPlot[Z], C.columns[r.forestPlot[Z]].name = C.forestPlot[Z], C.columns[r.forestPlot[Z]].dataTable = !0, C.columns[r.forestPlot[Z]].tooltips = !0, C.columns[r.forestPlot[Z]].label = C.forestPlot[Z]);
        });
      r.forestPlot.radius.scalingColumn && (C.columns[r.forestPlot.radius.scalingColumn] = {}, C.columns[r.forestPlot.radius.scalingColumn].dataKey = C.forestPlot.radius.scalingColumn, C.columns[r.forestPlot.radius.scalingColumn].name = C.forestPlot.radius.scalingColumn, C.columns[r.forestPlot.radius.scalingColumn].label = C.forestPlot.radius.scalingColumn, C.columns[r.forestPlot.radius.scalingColumn].dataTable = !0, C.columns[r.forestPlot.radius.scalingColumn].tooltips = !0), C.table.showVertical && (C.table.indexLabel = r.xAxis.dataKey), h(C);
    } catch (R) {
      console.log(R.message);
    }
  }, []), se.useEffect(() => {
    !x && r.forestPlot.type === "Logarithmic" && (h({
      ...r,
      dataFormat: {
        ...r.dataFormat,
        roundTo: 2
      }
    }), w(!0));
  }, [r.forestPlot.type]);
  const S = r.data.find((R) => R[r.xAxis.dataKey] === r.forestPlot.pooledResult.column), A = S ? [
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) },
    {
      x: e(S[r.forestPlot.estimateField]),
      y: a - y.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight)
    },
    { x: e(S[r.forestPlot.upper]), y: a - Number(r.forestPlot.rowHeight) },
    {
      x: e(S[r.forestPlot.estimateField]),
      y: a + y.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight)
    },
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) }
  ] : [], p = r.forestPlot.rowHeight, v = [
    { x: 0, y: p },
    { x: i, y: p }
  ], L = [
    { x: 0, y: a },
    { x: i, y: a }
  ], P = Object.entries(r.columns).map((R) => R[1]).filter((R) => R.forestPlot === !0);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(et, { width: i }, y.title && /* @__PURE__ */ n.createElement(
    dt,
    {
      className: "forest-plot--title",
      x: y.type === "Linear" ? e(0) : e(1),
      y: 0,
      textAnchor: "middle",
      verticalAnchor: "start",
      fill: "black"
    },
    y.title
  ), y.lineOfNoEffect.show && y.type === "Linear" && /* @__PURE__ */ n.createElement(
    ln,
    {
      from: { x: e(0), y: 0 + p },
      to: { x: e(0), y: a },
      className: "forestplot__line-of-no-effect",
      stroke: y.regression.baseLineColor || "black"
    }
  ), y.lineOfNoEffect.show && y.type === "Logarithmic" && /* @__PURE__ */ n.createElement(
    ln,
    {
      from: { x: e(1), y: 0 + p },
      to: { x: e(1), y: a },
      className: "forestplot__line-of-no-effect",
      stroke: y.regression.baseLineColor || "black"
    }
  ), s.map((R, C) => {
    const z = Vn({
      domain: s.map((Y) => Y[y.radius.scalingColumn]),
      range: [y.radius.min, y.radius.max]
    }), W = y.radius.scalingColumn !== "" ? z(s[C][y.radius.scalingColumn]) : 4, Z = y.colors.shape ? y.colors.shape : "black", ee = y.colors.line ? y.colors.line : "black", K = 4;
    return R[r.xAxis.dataKey] === y.pooledResult.column ? /* @__PURE__ */ n.createElement(
      Hr,
      {
        data: A,
        x: (Y) => Y.x,
        y: (Y) => Y.y - Lc / 2,
        stroke: "black",
        strokeWidth: 2,
        fill: "black",
        curve: kf
      }
    ) : /* @__PURE__ */ n.createElement(et, null, /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: ee,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${e(R[y.lower])} ${t(C) - Number(K)}
                    L${e(R[y.lower])} ${t(C) + Number(K)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: ee,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${e(R[y.upper])} ${t(C) - Number(K)}
                    L${e(R[y.upper])} ${t(C) + Number(K)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "line",
      {
        stroke: ee,
        className: `line-${R[r.yAxis.dataKey]}`,
        key: C,
        x1: e(R[y.lower]),
        x2: e(R[y.upper]),
        y1: t(C),
        y2: t(C)
      }
    ), y.shape === "circle" && /* @__PURE__ */ n.createElement(
      tv,
      {
        className: "forest-plot--circle",
        cx: e(Number(R[y.estimateField])),
        cy: t(C),
        r: y.radius.scalingColumn !== "" ? z(s[C][y.radius.scalingColumn]) : 4,
        fill: Z,
        style: { opacity: 1, filter: "unset" }
      }
    ), y.shape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        className: "forest-plot--square",
        x: e(Number(R[y.estimateField])),
        y: t(C) - W / 2,
        width: W,
        height: W,
        fill: Z,
        style: { opacity: 1, filter: "unset" }
      }
    ), y.shape === "text" && /* @__PURE__ */ n.createElement(
      dt,
      {
        className: "forest-plot--text",
        x: e(Number(R[y.estimateField])),
        y: t(C),
        textAnchor: "middle",
        verticalAnchor: "middle",
        fill: Z
      },
      R[y.estimateField]
    ));
  }), A && y.regression.showDiamond && /* @__PURE__ */ n.createElement(
    Hr,
    {
      data: A,
      x: (R) => R.x,
      y: (R) => R.y,
      stroke: "black",
      strokeWidth: 2,
      fill: y.regression.baseLineColor,
      curve: kf
    }
  ), y.regression.description && /* @__PURE__ */ n.createElement(
    dt,
    {
      x: 0 - Number(r.xAxis.size),
      width: i,
      y: a - r.forestPlot.rowHeight - Number(y.rowHeight) / 3,
      verticalAnchor: "start",
      textAnchor: "start",
      style: { fontWeight: "bold", fontSize: 12 }
    },
    y.regression.description
  ), /* @__PURE__ */ n.createElement(
    Rr,
    {
      key: "forest-plot-tooltip-area",
      className: "forest-plot-tooltip-area",
      width: i,
      height: a,
      fill: "transparent",
      fillOpacity: 0.5,
      onMouseMove: (R) => d(R, s),
      onMouseOut: o
    }
  )), /* @__PURE__ */ n.createElement(
    ln,
    {
      from: v[0],
      to: v[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__top-line"
    }
  ), /* @__PURE__ */ n.createElement(
    ln,
    {
      from: L[0],
      to: L[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__bottom-line"
    }
  ), P.map((R) => s.map((C, z) => /* @__PURE__ */ n.createElement(
    dt,
    {
      className: `${C[R.name]}`,
      x: R.forestPlotAlignRight ? i : R.forestPlotStartingPoint,
      y: t(z),
      textAnchor: R.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    C[R.name]
  ))), !y.hideDateCategoryCol && s.map((R, C) => /* @__PURE__ */ n.createElement(
    dt,
    {
      className: `${R[r.xAxis.dataKey]}`,
      x: 0,
      y: t(C),
      textAnchor: "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    R[r.xAxis.dataKey]
  )), !y.hideDateCategoryCol && r.xAxis.dataKey && /* @__PURE__ */ n.createElement(dt, { className: r.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black" }, r.xAxis.dataKey), P.map((R) => /* @__PURE__ */ n.createElement(
    dt,
    {
      className: `${R.label}`,
      x: R.forestPlotAlignRight ? i : R.forestPlotStartingPoint,
      y: 0,
      textAnchor: R.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "start",
      fill: "black"
    },
    R.label
  )), y.leftLabel && /* @__PURE__ */ n.createElement(
    dt,
    {
      className: "forest-plot__left-label",
      x: y.type === "Linear" ? e(0) - 25 : e(1) - 25,
      y: a + g,
      textAnchor: "end",
      verticalAnchor: "start"
    },
    y.leftLabel
  ), y.rightLabel && /* @__PURE__ */ n.createElement(
    dt,
    {
      innerRef: c,
      className: "forest-plot__right-label",
      x: y.type === "Linear" ? e(0) + 25 : e(1) + 25,
      y: a + g,
      textAnchor: "start",
      verticalAnchor: "start"
    },
    y.rightLabel
  ));
}, Ok = ({ width: e, height: t, originalWidth: r }) => {
  var v, L, P;
  const { config: a, colorScale: i, transformedData: o, formatNumber: d, seriesHighlight: c } = se.useContext(pt);
  if (!a || ((v = a == null ? void 0 : a.series) == null ? void 0 : v.length) < 2)
    return;
  const s = a.barHasBorder === "true" ? 1 : 0, h = e / 2, y = 1.02, g = {
    parentKey: (L = a.dataDescription) == null ? void 0 : L.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: i(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[a.series[0].dataKey])
    ),
    labelColor: ""
  }, x = {
    parentKey: (P = a.dataDescription) == null ? void 0 : P.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: i(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[a.series[1].dataKey])
    ),
    labelColor: ""
  }, w = Vn({
    domain: [0, Math.max(g.max * y, x.max * 1.1)],
    range: [0, h]
  });
  g.labelColor = g.color ? il("#000", g.color) : "#000", x.labelColor = x.color ? il("#000", x.color) : "#000";
  const S = a.yAxis.label ? `${a.yAxis.label}: ` : "", A = (R) => {
    var C;
    return `<p>
				${(C = a.dataDescription) == null ? void 0 : C.seriesKey}: ${g.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${R[a.xAxis.dataKey]}<br/>
				${S}${d(R[g.dataKey], "left")}
			</p>`;
  }, p = (R) => {
    var C;
    return `<p>
				${(C = a.dataDescription) == null ? void 0 : C.seriesKey}: ${x.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${R[a.xAxis.dataKey]}<br/>
				${S}${d(R[x.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ n.createElement(
    "svg",
    {
      id: "cdc-visualization__paired-bar-chart",
      width: r,
      height: t,
      viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`,
      role: "img",
      tabIndex: 0
    },
    /* @__PURE__ */ n.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`),
    /* @__PURE__ */ n.createElement(et, { top: 0, left: Number(a.xAxis.size) }, o.filter((R) => a.series[0].dataKey === g.dataKey).map((R, C) => {
      var B, X;
      let z = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[0].dataKey) === -1, W = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[0].dataKey) !== -1, Z = w(R[a.series[0].dataKey]), ee = Number(a.barHeight) ? Number(a.barHeight) : 25, K = 0;
      K = C !== 0 ? (Number(a.barSpace) + ee + s) * C : K;
      const le = (Number(a.barSpace) + ee + s) * o.length;
      a.heights.horizontal = le;
      const ae = hr(d(R[g.dataKey], "left")) < Z - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(et, { key: `group-${g.dataKey}-${R[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Rr,
        {
          id: `bar-${g.dataKey}-${R[(B = a.dataDescription) == null ? void 0 : B.xKey]}`,
          className: "bar group-1",
          key: `bar-${g.dataKey}-${R[(X = a.dataDescription) == null ? void 0 : X.xKey]}`,
          x: h - Z,
          y: K,
          width: w(R[a.series[0].dataKey]),
          height: ee,
          fill: g.color,
          "data-tooltip-html": A(R),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          stroke: "#333",
          strokeWidth: s,
          opacity: z ? 0.5 : 1,
          display: W ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && W && /* @__PURE__ */ n.createElement(
        dt,
        {
          textAnchor: ae ? "start" : "end",
          dx: ae ? 5 : -5,
          verticalAnchor: "middle",
          x: h - Z,
          y: K + a.barHeight / 2,
          fill: ae ? g.labelColor : "#000"
        },
        d(R[g.dataKey], "left")
      )));
    }), o.filter((R) => a.series[1].dataKey === x.dataKey).map((R, C) => {
      var B, X, ce;
      let z = w(R[a.series[1].dataKey]), W = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[1].dataKey) === -1, Z = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[1].dataKey) !== -1, ee = a.barHeight ? Number(a.barHeight) : 25, K = 0;
      K = C !== 0 ? (Number(a.barSpace) + ee + s) * C : K;
      const le = (Number(a.barSpace) + ee + s) * o.length;
      a.heights.horizontal = le;
      const ae = hr(d(R[x.dataKey], "left")) < z - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
                      .bar-${x.dataKey}-${R[a.xAxis.dataKey]} {
                          transform-origin: ${h}px ${K}px
                      }
							      `), /* @__PURE__ */ n.createElement(et, { key: `group-${x.dataKey}-${R[(B = a.dataDescription) == null ? void 0 : B.xKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Rr,
        {
          id: `bar-${x.dataKey}-${R[(X = a.dataDescription) == null ? void 0 : X.xKey]}`,
          className: "bar group-2",
          key: `bar-${x.dataKey}-${R[(ce = a.dataDescription) == null ? void 0 : ce.xKey]}`,
          x: h,
          y: K,
          width: w(R[a.series[1].dataKey]),
          height: ee,
          fill: x.color,
          "data-tooltip-html": p(R),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          strokeWidth: s,
          stroke: "#333",
          opacity: W ? 0.5 : 1,
          display: Z ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && Z && /* @__PURE__ */ n.createElement(
        dt,
        {
          textAnchor: ae ? "end" : "start",
          dx: ae ? -5 : 5,
          verticalAnchor: "middle",
          x: h + z,
          y: K + a.barHeight / 2,
          fill: ae ? x.labelColor : "#000"
        },
        d(R[x.dataKey], "left")
      )));
    }))
  ));
}, Fk = ({ yMax: e, leftSize: t, max: r, xMax: a }) => {
  var p;
  const { config: i } = se.useContext(pt), { orientation: o } = i, d = (v, L = "#f1f1f1") => {
    try {
      return Ua(v).hex();
    } catch {
      return L;
    }
  }, c = (p = i.yAxis) == null ? void 0 : p.categories, y = ((v) => {
    const L = Object.keys(v), P = L[L.length - 1];
    if (v[P] === "") {
      const R = L.slice(0, -1).reduce((z, W) => {
        const Z = Number(v[W]);
        return z + (isNaN(Z) ? 0 : Z);
      }, 0), C = r - R;
      v[P] = C;
    }
    return [v];
  })(((v) => [...v].reduce((P, R) => (P[R.label] = R.height, P), {}))(c)), g = 0, x = dc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), w = Vn({
    domain: [0, r],
    range: [e, 0],
    clamp: !0
  }), S = yp({
    domain: c.map((v) => v == null ? void 0 : v.label),
    range: c.map((v) => {
      var L;
      return d((L = v == null ? void 0 : v.color) == null ? void 0 : L.trim());
    })
  }), A = Object.keys(y[0]);
  return /* @__PURE__ */ n.createElement(et, { left: t - x.bandwidth(), top: 0 }, /* @__PURE__ */ n.createElement(
    Fy,
    {
      data: y,
      keys: A,
      x: () => x(g),
      xScale: x,
      yScale: w,
      color: S
    },
    (v) => v.map(
      (L) => L.bars.map((P) => {
        const R = i.yAxis.categories.length - 1 === L.index, C = Lc / 1.3, z = Ua(P.color).luminance() < 0.4 ? "#fff" : "#000", W = hr(P.key), Z = Number(W) < P.width && P.height > C, ee = `<ul>
              <li class="tooltip-heading""> Label : ${P.key}  </li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(et, { key: `${L.index}--${P.index}--${o}` }, /* @__PURE__ */ n.createElement(
          et,
          {
            key: `bar-stack-${L.index}-${P.index}`,
            id: `barStack${L.index}-${P.index}`,
            className: "stack vertical"
          },
          Ds({
            type: "axisBar",
            config: i,
            index: L.index,
            background: S(P.key),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: 0,
            width: x.bandwidth(),
            height: P.height,
            x: P.x,
            y: P.y,
            tooltipHtml: ee,
            tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
          }),
          /* @__PURE__ */ n.createElement(
            dt,
            {
              display: Z ? "block" : "none",
              key: `text-${L.index}-${P.index}`,
              x: P.x + x.bandwidth() / 2,
              y: P.y + P.height / 2,
              fill: z,
              textAnchor: "middle",
              verticalAnchor: "middle",
              style: { fontSize: C }
            },
            P.key
          ),
          i.runtime.yAxis.gridLines && /* @__PURE__ */ n.createElement(
            ln,
            {
              from: { x: P.x + x.bandwidth(), y: P.y },
              to: { x: a + x.bandwidth(), y: P.y },
              stroke: "#d6d6d6"
            }
          ),
          !R && /* @__PURE__ */ n.createElement("rect", { x: P.x, y: P.y, width: P.width, height: 1, fill: "#fff" }),
          /* @__PURE__ */ n.createElement("rect", { x: P.x + P.width, y: 0, width: 1, height: e, fill: "#000" })
        ));
      })
    )
  ));
};
function Mk({ orientation: e, heights: t, visualizationType: r }, a) {
  const o = e === "vertical" || r === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && mf(a) ? "mobileVertical" : "vertical";
  return o ? c : "horizontal";
}
function zk({ heights: e, orientation: t, visualizationType: r }, a) {
  if (!e)
    return 0;
  const i = Mk({ orientation: t, heights: e, visualizationType: r }, a), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
const dg = ({ config: e, minValue: t, maxValue: r, existPositiveValue: a, data: i, isAllLine: o, tableData: d }) => {
  let c = 0, s = 0, h = 0, y = 0;
  const { convertLineToBarGraph: g } = se.useContext(pt);
  if (!i)
    return { min: c, max: s };
  const { visualizationType: x, series: w } = e, { max: S, min: A } = e.runtime.yAxis, p = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, v = e.yAxis.type === "logarithmic", L = a ? Number(S) >= r : Number(S) >= 0, P = v ? Number(A) >= 0 : Number(A) <= 0 && t >= 0 || Number(A) <= t && t < 0;
  c = A && P ? Number(A) : t, s = S && L ? Number(S) : Number.MIN_VALUE;
  const { lower: R, upper: C } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (R && C && e.visualizationType === "Bar") {
    const z = c < 0 ? 1.1 : 0, W = Math.max(...i.flatMap((ee) => [ee[C], ee[R]])) * p, Z = Math.min(...i.flatMap((ee) => [ee[C], ee[R]])) * p * z;
    s = s > W ? s : W, c = c < Z ? c : Z;
  }
  if (e.series.filter((z) => (z == null ? void 0 : z.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: z }
    } = e;
    if ((z == null ? void 0 : z.length) > 0) {
      let W = [];
      z.forEach((le) => {
        var Y;
        (Y = le.confidenceIntervals) == null || Y.map((ae) => {
          W.push(ae.high), W.push(ae.low);
        });
      });
      const Z = i.map((le) => W.map((Y) => le[Y])), ee = Math.max.apply(
        null,
        Z.map((le) => le[0])
      ), K = Math.min.apply(
        null,
        Z.map((le) => le[1])
      );
      ee > s && (s = ee), K < c && (c = K);
    }
  }
  if (x === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let z = w.filter((ee) => ee.axis === "Left"), W = w.filter((ee) => ee.axis === "Right");
      const Z = (ee, K, le, Y = "left") => {
        let ae = 0;
        return (K.map((X) => X.dataKey) || []).forEach((X) => {
          let ce = K.find((V) => V.dataKey === X), ne = ee.map((V) => V[X]), Q = Math.max.apply(null, ne);
          e.visualizationSubType === "stacked" && Y === "left" && ce.type === "Bar" && (ae += Q), Q > le && (le = Q), le < ae && (le = ae);
        }), le;
      };
      h = Z(i, z, h, "left"), y = Z(i, W, y, "right"), h < Number(S) && (h = Number(S));
    } catch (z) {
      console.error(z.message);
    }
  if ((x === "Bar" || g || x === "Combo" && !o) && c > 0 && (c = 0), (e.visualizationType === "Bar" || g || e.visualizationType === "Combo" && !o) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && o && ((A == null || A === "") && c > 0 && (c = 0), A)) {
    const z = v ? Number(A) >= 0 && Number(A) < t : Number(A) < t;
    c = Number(A) && z ? Number(A) : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const z = Number(A) < Math.min(t, Number(e.xAxis.target));
    c = Number(A) && z ? Number(A) : 0;
  }
  if (e.visualizationType === "Line" && !g) {
    const z = v ? Number(A) >= 0 && Number(A) < t : Number(A) < t, W = d == null ? void 0 : d.some((ee, K) => {
      var le;
      return (le = e.preliminaryData) == null ? void 0 : le.some((Y) => {
        var ce;
        if (Y.type !== "suppression" || !Y.style)
          return !1;
        const ae = Je.pick(ee, (ce = e.runtime) == null ? void 0 : ce.seriesKeys), B = Je.values(ae).includes(Y.value);
        return (Y.column ? ee[Y.column] === Y.value : B) && (K === 0 || K === d.length - 1);
      });
    });
    let Z = e.yAxis.type === "categorical";
    c = A !== "" && z ? Number(A) : W || Z ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = a ? r : 0), e.runtime.yAxis.paddingPercent) {
    let z = (s - c) * e.runtime.yAxis.paddingPercent;
    c -= z, s += z;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const z = i.map((Z) => Z[e.series[0].dataKey]), W = Math.max(...z).toString().length;
    switch (!0) {
      case (W > 8 && W <= 12):
        s = s * 1.3;
        break;
      case (W > 4 && W <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (c = 0), e.visualizationType === "Scatter Plot" && (s = s * 1.1), { min: c, max: s, leftMax: h, rightMax: y };
}, Qr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Bk = (e) => {
  let { xAxisDataMapped: t, xMax: r, yMax: a, min: i, max: o, config: d, data: c } = e;
  const { rawData: s, dimensions: h } = se.useContext(pt), [y] = h, g = d.runtime.barSeriesKeys || d.runtime.seriesKeys, x = d.runtime.xAxis.type, w = d.orientation === "horizontal", { visualizationType: S, xAxis: A, forestPlot: p } = d;
  let v = null, L = null, P = null, R = null, C = null, z = null, W = Vn({
    domain: [0, 100],
    range: [0, r]
  });
  if (w && (v = Wk({ min: i * 1.03, ...e }), v.type = d.yAxis.type === "logarithmic" ? Qr.LOG : Qr.LINEAR, L = Uk(x, t), L.rangeRound([0, a]), C = Kk(g, [0, a])), w || (v = Qo(t, [0, r], 1 - d.barThickness), L = jk(e), C = Qo(g, [0, v.bandwidth()], 0)), d.xAxis.type === "date" && !w) {
    const Z = dm(t, d.xAxis.sortByRecentDate);
    v = Qo(Z, [0, r], 1 - d.barThickness);
  }
  if (A.type === "date-time" || A.type === "continuous") {
    let Z = Math.min(...t.map(Number)), ee = Math.max(...t.map(Number));
    Z -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ee - Z), ee += S === "Line" ? 0 : (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ee - Z);
    const K = d.xAxis.sortByRecentDate ? [r, 0] : [0, r];
    v = $E({
      domain: [Z, ee],
      range: K
    }), v.type = Qr.TIME;
    let le = Number.MAX_VALUE, Y = dm(t, d.xAxis.sortByRecentDate);
    for (let ae = 0; ae < Y.length - 1; ae++) {
      let B = v(Y[ae + 1]) - v(Y[ae]);
      B < le && (le = B);
    }
    (t.length === 1 || le > r / 4) && (le = r / 4), C = Qo(g, [0, (d.barThickness || 1) * le], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const Z = d.isLollipopChart ? 1.05 : 1.03;
    L = dc({
      domain: t,
      range: [0, a]
    }), v = Vn({
      domain: [i * Z, Math.max(Number(A.target), o)],
      range: [0, r],
      round: !0,
      nice: !0
    }), v.type = Qr.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot") {
    if (A.type === "continuous") {
      let Z = A.min ? A.min : Math.min.apply(null, v.domain()), ee = A.max ? A.max : Math.max.apply(null, v.domain());
      v = Vn({
        domain: [Z, ee],
        range: [0, r]
      }), v.type = Qr.LINEAR;
    }
    if (A.type === "categorical") {
      const Z = t.map((ee) => {
        const K = String(ee), le = parseFloat(K);
        return isNaN(le) ? K : Math.round(le).toString();
      });
      v = Qo(Z, [0, r], 1 - d.barThickness);
    }
  }
  if (S === "Box Plot") {
    const Z = [];
    if (d.boxplot.plots.map((X) => X.columnOutliers.map((ce) => Z.push(ce))) && !d.boxplot.hideOutliers) {
      let X = Math.min(...Z), ce = Math.max(...Z);
      X < i && (i = X), ce > o && (o = ce);
    }
    let K = Math.min(...d.boxplot.plots.map((X) => X.columnLowerBounds)), le = Math.max(...d.boxplot.plots.map((X) => X.columnUpperBounds));
    K < i && (i = K), le > o && (o = le);
    const Y = Je.uniq(c.map((X) => X[d.xAxis.dataKey])), ae = [0, d.barThickness * 100 || 1], B = Je.map(d.series, "dataKey");
    L = Vn({
      range: [a, 0],
      round: !0,
      domain: [i, o]
    }), v = dc({
      range: [0, r],
      domain: Y
    }), v.type = Qr.BAND, C = Qo(B, ae);
  }
  if (S === "Paired Bar") {
    let ee = Math.max.apply(
      Math,
      c.map((le) => {
        var Y;
        return le[(Y = d.series[0]) == null ? void 0 : Y.dataKey];
      })
    ), K = Math.max.apply(
      Math,
      c.map((le) => {
        var Y;
        return le[(Y = d.series[1]) == null ? void 0 : Y.dataKey];
      })
    );
    R = Vn({
      domain: [0, Math.max(ee, K) * 1.02],
      range: [r / 2, 0]
    }), P = Vn({
      domain: R.domain(),
      range: [r / 2, r],
      nice: !0
    });
  }
  if (S === "Forest Plot") {
    const Z = () => p.regression.showDiamond || p.regression.description ? [0 + p.rowHeight * 2, a - p.rowHeight] : [0 + p.rowHeight * 2, a];
    L = Vn({
      domain: [0, s.length],
      range: Z()
    });
    const ee = 5, K = Number(p.leftWidthOffset) / 100 * r, le = Number(p.rightWidthOffset) / 100 * r, Y = Number(p.rightWidthOffsetMobile) / 100 * r, ae = Number(p.leftWidthOffsetMobile) / 100 * r;
    if (y > 480) {
      if (p.type === "Linear" && (v = Vn({
        domain: [
          Math.min(...c.map((B) => parseFloat(B[p.lower]))) - ee,
          Math.max(...c.map((B) => parseFloat(B[p.upper]))) + ee
        ],
        range: [K, Number(y) - le]
      }), v.type = Qr.LINEAR), p.type === "Logarithmic") {
        let B = Math.max(...c.map((ce) => parseFloat(ce[p.upper]))), X = Math.min(...c.map((ce) => parseFloat(ce[p.lower])));
        v = fc({
          domain: [X, B],
          range: [K, r - le],
          nice: !0
        }), v.type = Qr.LOG;
      }
    } else if (p.type === "Linear" && (v = Vn({
      domain: [
        Math.min(...c.map((B) => parseFloat(B[p.lower]))) - ee,
        Math.max(...c.map((B) => parseFloat(B[p.upper]))) + ee
      ],
      range: [ae, r - Y],
      type: Qr.LINEAR
    })), p.type === "Logarithmic") {
      let B = Math.max(...c.map((ce) => parseFloat(ce[p.upper]))), X = Math.min(...c.map((ce) => parseFloat(ce[p.lower])));
      v = fc({
        domain: [X, B],
        range: [K, r - le],
        nice: !0,
        base: B > 1 ? 10 : 2,
        round: !1,
        type: Qr.LOG
      });
    }
  }
  return { xScale: v, yScale: L, seriesScale: C, g1xScale: R, g2xScale: P, xScaleNoPadding: z, xScaleAnnotation: W };
}, Ik = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, $k = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), Hk = (e, t, r, a) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], d = e[0], c = (o - d) / (r - 1);
    let s = [];
    for (let h = o; h >= d; h -= c)
      s.push(h);
    return s[s.length - 1] !== d && s.push(d), s.reverse(), $k(a.xAxis.dateDisplayFormat) && (s = s.map((h) => Ik(h))), s;
  }
  if (i.length > 2) {
    const o = r || 1, d = [];
    for (let c = i.length; c > 0; c -= o) {
      const s = Math.max(Math.round(c) - 1, 0);
      d.push(i[s]);
    }
    return d.reverse(), d;
  }
}, Vk = (e, t, r, a) => {
  let i = t.ticks;
  const o = Gy(t.scale, t.numTicks);
  if (o.length < r.length) {
    let d = 0;
    const c = r.indexOf(o[o.length - 1]);
    c < r.length - 1 && (d = e.xAxis.sortByRecentDate ? r.indexOf(o[0]) * -1 : r.length - 1 - c), i = o.map((s) => t.ticks[t.ticks.findIndex((h) => h.value === s) + d]);
  }
  return i.forEach((d, c) => {
    d.formattedValue = a(d.value, c, i);
  }), i;
}, Wk = ({ min: e, max: t, xMax: r, config: a }) => {
  const i = a.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? fc : Vn)({
    domain: [e, t],
    range: [0, r],
    nice: i,
    zero: i
  });
}, jk = ({ min: e, max: t, yMax: r, config: a, leftMax: i }) => {
  const o = a.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const d = o ? fc : Vn;
  a.visualizationType === "Combo" && (t = i);
  const c = a.visualizationType === "Bump Chart" ? [1, t] : [e, t], s = a.visualizationType === "Bump Chart" ? [30, r] : [r, 0];
  return d({
    domain: c,
    range: s,
    nice: o,
    zero: o
  });
}, Uk = (e, t) => e === "date" ? Vn({
  domain: [Math.min(...t), Math.max(...t)]
}) : nl({ domain: t, padding: 0.5 }), Kk = (e, t, r = 0) => nl({
  domain: e,
  range: t,
  padding: r
}), Qo = (e, t, r = 0) => dc({
  domain: e,
  range: t,
  padding: r
}), dm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((r, a) => Number(a) - Number(r)) : e.sort((r, a) => Number(r) - Number(a));
function Yk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const _s = () => {
  const { config: e } = se.useContext(pt), { visualizationType: t, series: r, orientation: a, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), s = () => !!["Scatter Plot"].includes(t), h = () => !!["Scatter Plot"].includes(t), y = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), x = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), w = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), S = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, A = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), p = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), v = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, L = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, P = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && a === "vertical", R = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : r == null ? void 0 : r.some(
    (De) => De.type === "Bar" || De.type === "Paired Bar" || De.type === "Deviation Bar"
  ), C = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, z = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: w,
    visHasAnchors: v,
    visHasBarBorders: R,
    visHasDataCutoff: C,
    visHasLabelOnData: x,
    visHasDataSuppression: L,
    visHasLegend: S,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var we;
      return t === "Bar" && i === "regular" && ((we = e.series) == null ? void 0 : we.length) === 1;
    },
    visHasBrushChart: P,
    visHasNumbersOnBars: A,
    visHasaAdditionalLabelsOnBars: p,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisMin: s,
    visSupportsDateCategoryAxisMax: h,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: y,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: z,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const we = ["Forest Plot"];
      return !(a === "horizontal" || we.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var we;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((we = e.dataFormat.suffix) != null && we.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && a === "vertical")
        return !0;
    }
  };
}, Gk = ({ data: e, xScale: t, yScale: r, config: a, xMax: i, annotationSeriesKey: o }, d) => {
  const { xAxis: c, visualizationType: s, orientation: h } = a, y = (p, v, L, P, R) => {
    let C = [];
    a.xAxis.type === "date-time" && (v = new Date(v), L = new Date(L), P = P.map((Z) => new Date(Z)), C = R.ticks().map((Z) => new Date(Z)));
    const z = (p - v) / (L - v), W = Math.round(z * (P.length - 1));
    return a.xAxis.type === "date-time" ? C[W] : P[W];
  }, x = ((p, v = !1) => {
    if (s !== "Pie" && h !== "horizontal") {
      if (a.xAxis.type === "date-time") {
        const L = new Date(t.invert(p)), P = a.data.map((z) => new Date(z[a.xAxis.dataKey]).getTime());
        let R = 1 / 0, C = null;
        return P.forEach((z) => {
          const W = Math.abs(L.getTime() - z);
          W < R && (R = W, C = z);
        }), new Date(C).getTime();
      }
      if (a.xAxis.type === "categorical" || s === "Combo" && h !== "horizontal" && s !== "Forest Plot") {
        const P = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), C = Math.floor((Number(p) - P / 2) / P);
        return t.domain()[C];
      }
      if (a.xAxis.type === "date") {
        const L = y(p, 0, i, t.domain(), t);
        let P = null, R = Number.MAX_VALUE;
        return t.domain().forEach((C) => {
          const z = Math.abs(L - C);
          z < R && (R = z, P = C);
        }), P;
      }
      return p;
    }
  })(d - Number(a.yAxis.size || 0));
  let w = [];
  if (!x)
    return { x: 0, y: 0 };
  c.type === "categorical" && (w = a.data.filter((p) => p[a.xAxis.dataKey] === x)), (c.type === "date" || c.type === "date-time") && (w = a.data.filter((p) => new Date(p[a.xAxis.dataKey]).getTime() === x));
  const S = w[0][o];
  return { x, y: S };
}, Xk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "right" ? "end" : a === "left" ? "start" : a === "bottom" || a === "top" || t(e.xKey) + e.dx < r.yAxis.size ? "middle" : null;
}, qk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "top" ? "start" : a === "bottom" ? "end" : a === "right" || a === "left" ? "middle" : t(e.xKey) + e.dx < r.yAxis.size ? "end" : null;
};
const Zk = ({ xScale: e, yScale: t, xScaleAnnotation: r, xMax: a, svgRef: i, onDragStateChange: o }) => {
  const { config: d, dimensions: c, isEditor: s, updateConfig: h, colorScale: y } = se.useContext(pt), { annotations: g } = d, [x] = c, w = s ? _g : Og;
  return g && g.map((S, A) => {
    var P;
    const p = S.text || "", v = r(S.x), L = () => ({
      __html: Cm.sanitize(p)
    });
    return /* @__PURE__ */ n.createElement(
      w,
      {
        width: 200,
        height: x,
        dx: S.dx,
        dy: S.dy,
        x: v,
        y: S.y,
        canEditLabel: S.edit.label || !1,
        canEditSubject: S.edit.subject && S.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (R) => {
          o(!1);
          let C = [...g];
          if (S.x === r.invert(R.x) && S.y === R.y)
            C[A] = { ...C[A], dx: R.dx, dy: R.dy };
          else if (S.snapToNearestPoint) {
            let z = Gk(
              {
                data: d.data,
                xScale: e,
                yScale: t,
                config: d,
                xMax: a - d.yAxis.size / 2,
                annotationSeriesKey: S.seriesKey
              },
              R.x
            );
            C[A] = {
              ...C[A],
              x: r.invert(e(z.x)),
              y: t(z.y)
            };
          } else
            C[A] = {
              ...C[A],
              x: r.invert(R.x),
              y: R.y
            };
          h({
            ...d,
            annotations: C
          });
        }
      },
      /* @__PURE__ */ n.createElement(
        Ng,
        {
          className: "annotation__desktop-label",
          showAnchorLine: !1,
          horizontalAnchor: Xk(S, e, d),
          verticalAnchor: qk(S, e, d)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            style: {
              borderRadius: 5,
              // Optional: set border radius
              backgroundColor: `rgba(255, 255, 255, ${S != null && S.opacity ? Number(S == null ? void 0 : S.opacity) / 100 : 1})`,
              padding: "10px",
              width: "auto",
              display: d.general.showAnnotationDropdown ? "inline-flex" : "flex",
              justifyContent: "start",
              flexDirection: "row"
            },
            tabIndex: 0,
            "aria-label": `Annotation text that reads: ${S.text}`
          },
          ((P = d == null ? void 0 : d.general) == null ? void 0 : P.showAnnotationDropdown) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, A + 1)),
          /* @__PURE__ */ n.createElement("div", { dangerouslySetInnerHTML: L() })
        )
      ),
      S.connectionType === "line" && /* @__PURE__ */ n.createElement(Op, { type: "line", pathProps: { markerStart: `url(#marker-start--${A})` } }),
      S.connectionType === "elbow" && /* @__PURE__ */ n.createElement(Op, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${A})` } }),
      S.connectionType === "curve" && /* @__PURE__ */ n.createElement(
        Hr,
        {
          d: `M ${v},${S.y}
                      Q ${v + S.dx / 2}, ${S.y + S.dy / 2 + Number(S == null ? void 0 : S.bezier) || 0} ${v + S.dx},${S.y + S.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${A})`
        }
      ),
      S.marker === "circle" && /* @__PURE__ */ n.createElement(
        Dg,
        {
          id: `marker-start--${A}`,
          className: "circle-subject",
          stroke: y(S.seriesKey),
          radius: 8
        }
      ),
      S.marker === "arrow" && /* @__PURE__ */ n.createElement(
        Tm,
        {
          fill: "black",
          id: `marker-start--${A}`,
          x: v,
          y: S.y,
          stroke: "#333",
          markerWidth: 10,
          size: 10,
          strokeWidth: 1,
          orient: "auto-start-reverse",
          markerUnits: "userSpaceOnUse"
        }
      ),
      /* @__PURE__ */ n.createElement(
        "circle",
        {
          fill: "white",
          cx: v + S.dx,
          cy: S.y + S.dy,
          r: 16,
          className: "annotation__mobile-label annotation__mobile-label-circle",
          stroke: y(S.seriesKey)
        }
      ),
      /* @__PURE__ */ n.createElement(
        "text",
        {
          height: 16,
          x: v + S.dx,
          y: S.y + S.dy,
          className: "annotation__mobile-label",
          alignmentBaseline: "middle",
          textAnchor: "middle"
        },
        A + 1
      )
    );
  });
};
const Qk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = se.useContext(pt), r = t.annotations || [], a = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = r.map((o, d) => {
    const c = o.text || "", s = () => ({
      __html: Cm.sanitize(c)
    });
    return /* @__PURE__ */ n.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-circle" }, d + 1), /* @__PURE__ */ n.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: s() })));
  });
  return /* @__PURE__ */ n.createElement("ul", { className: a() }, i);
};
const Jk = () => {
  var s;
  const { currentViewport: e, config: t } = se.useContext(pt), [r, a] = se.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Lc}px`;
  se.useContext(pt);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, d = () => {
    const h = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return r || h.push("collapsed"), h.join(" ");
  }, c = () => {
    const h = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (h.push("d-lg-block"), h.splice(h.indexOf("d-lg-none"), 1)), h.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("section", { className: c() }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { fontSize: i },
      role: "button",
      className: d(),
      onClick: () => {
        a(!r);
      },
      tabIndex: 0,
      onKeyDown: (h) => {
        h.keyCode === 13 && a(!r);
      }
    },
    /* @__PURE__ */ n.createElement(Ge, { display: r ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (s = t == null ? void 0 : t.general) == null ? void 0 : s.annotationDropdownText
  ), r && /* @__PURE__ */ n.createElement("div", { className: "table-container annotation-dropdown__panel", style: o }, /* @__PURE__ */ n.createElement(Sp.List, { useBootstrapVisibilityClasses: !1 }))));
}, Sp = {
  Draggable: Zk,
  // Mobile auto display
  List: Qk,
  // Desktop Accessible Option
  Dropdown: Jk
}, ew = ({ axis: e, max: t, runtime: r, currentViewport: a, isHorizontal: i, data: o, config: d, min: c }) => {
  let { numTicks: s } = r[e];
  r[e].viewportNumTicks && r[e].viewportNumTicks[a] && (s = r[e].viewportNumTicks[a]);
  let h;
  return e === "yAxis" && (h = i && !s ? o.length : i && s ? s : !i && !s ? void 0 : !i && s && s, h === void 0 && !d.dataFormat.roundTo && (Number(t) <= 3 ? h = 2 : h = 4), Number(h) > Number(t) && !i && (h = Number(c) < 0 ? Math.round(t) * 2 : Math.round(t))), e === "xAxis" && (h = i && !s ? void 0 : i && s ? s : !i && !s ? void 0 : !i && s && s, i && h === void 0 && !d.dataFormat.roundTo && (t <= 3 ? h = 2 : h = 4), d.visualizationType === "Forest Plot" && (h = d.yAxis.numTicks !== "" ? d.yAxis.numTicks : 4)), h;
}, sf = 9, uf = 4.5, cf = 8, tw = 1e3 * 60 * 60 * 24 * 30, nw = 16, rw = 13, aw = 18, iw = 14, ow = 4.5, df = se.forwardRef(({ parentHeight: e, parentWidth: t }, r) => {
  var ir, Zn, Qn, b, _;
  const {
    brushConfig: a,
    colorScale: i,
    config: o,
    convertLineToBarGraph: d,
    currentViewport: c,
    dimensions: s,
    formatDate: h,
    formatNumber: y,
    handleChartAriaLabels: g,
    handleLineType: x,
    handleDragStateChange: w,
    isDraggingAnnotation: S,
    legendRef: A,
    parseDate: p,
    parentRef: v,
    tableData: L,
    transformedData: P,
    updateConfig: R,
    seriesHighlight: C
  } = se.useContext(pt), {
    heights: z,
    visualizationType: W,
    visualizationSubType: Z,
    orientation: ee,
    xAxis: K,
    yAxis: le,
    runtime: Y,
    legend: ae,
    forestPlot: B,
    brush: X,
    dataFormat: ce,
    debugSvg: ne
  } = o, { suffix: Q, onlyShowTopPrefixSuffix: V } = ce, { labelsAboveGridlines: j, hideAxis: te } = o.yAxis, { minValue: U, maxValue: ue, existPositiveValue: ke, isAllLine: xe } = Hc(o, P), { visSupportsReactTooltip: be } = _s(), { hasTopAxis: Ae } = Yk(o), [Ye, Pe] = se.useState(!1), [ye, Re] = se.useState({ x: 0, y: 0 }), [fe, ze] = se.useState(0), [Ne, qe] = se.useState(0), He = se.useRef(null), Be = se.useRef(null), Ze = se.useRef(null), Ve = se.useRef(null), je = se.useRef(), Ue = se.useRef([]), we = se.useRef(null), De = se.useRef(ue), rt = pp(je, {
    freezeOnceVisible: !1
  }), ge = !0, ut = ee === "horizontal" || o.visualizationType === "Forest Plot", at = o.yAxis.type === "logarithmic", it = W === "Forest Plot", St = o.xAxis.type === "date-time", jt = !Q.includes(" "), Bt = V && !jt, Nt = Number(ee === "horizontal" ? o.xAxis.size : o.yAxis.size), sn = isNaN(parseInt(`${Y.yAxis.labelOffset}`)) ? 0 : parseInt(`${Y.yAxis.labelOffset}`), gt = mf(c) ? rw : nw, Dt = mf(c) ? iw : aw, _t = `normal ${gt}px Nunito, sans-serif`, un = it ? o.data.length * o.forestPlot.rowHeight : 0, En = se.useMemo(
    () => zk(o, c),
    [o, c, e, (ir = o.heights) == null ? void 0 : ir.vertical, (Zn = o.heights) == null ? void 0 : Zn.horizontal]
  ), $t = se.useMemo(() => En + un, [En, un]), It = se.useMemo(() => {
    var J;
    const D = s[0], G = ae == null ? void 0 : ae.hide, pe = ["bottom", "top"].includes((J = o.legend) == null ? void 0 : J.position), O = Va(c);
    if (!(!it && !G && !pe && !O))
      return D;
    if (A.current) {
      const ve = getComputedStyle(A.current);
      return D - A.current.getBoundingClientRect().width - parseInt(ve.marginLeft) - parseInt(ve.marginRight);
    }
    return D * 0.73;
  }, [s[0], o.legend, c, A.current]), fn = se.useMemo(() => {
    var G;
    return Ue.current = (G = Ue.current) == null ? void 0 : G.filter((pe) => pe), Ue.current.length ? Math.max(...Ue.current.map((pe) => pe.getBBox().height)) + uf + cf : void 0;
  }, [s[0], o.xAxis, Ue.current, o.xAxis.tickRotation]), tt = It - Y.yAxis.size - (W === "Combo" ? o.yAxis.rightAxisSize : 0), st = En + un, Tn = o.filters && o.filters.values.length === 0 && P.length === 0, tn = (D) => Pn(o.runtime.xAxis) ? p(D[o.runtime.originalXAxis.dataKey]).getTime() : D[o.runtime.originalXAxis.dataKey], cn = (D, G) => D[G], pn = o.brush.active && ((Qn = a.data) != null && Qn.length) ? a.data.map((D) => tn(D)) : P.map((D) => tn(D)), ft = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", Pt = {
    data: P,
    tableData: L,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: Bt ? Ne : o.yAxis.scalePadding,
        enablePadding: Bt || o.yAxis.enablePadding
      }
    },
    minValue: U,
    maxValue: ue,
    isAllLine: xe,
    existPositiveValue: ke,
    xAxisDataMapped: pn,
    xMax: tt,
    yMax: st
  }, { min: Ot, max: hn, leftMax: Tt, rightMax: Ct } = dg(Pt), { yScaleRight: nn, hasRightAxis: Nn } = bp({ config: o, yMax: st, data: P, updateConfig: R }), { xScale: At, yScale: xt, seriesScale: Dn, g1xScale: Oe, g2xScale: _e, xScaleNoPadding: Ee, xScaleAnnotation: ct } = Bk({
    ...Pt,
    min: Ot,
    max: hn,
    leftMax: Tt,
    rightMax: Ct,
    dimensions: s,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size)
  }), [qt, Kt] = ["yAxis", "xAxis"].map(
    (D) => ew({ axis: D, max: hn, runtime: Y, currentViewport: c, isHorizontal: ut, data: P, config: o, min: Ot })
  ), Ft = it ? o.data.length : qt, { tooltipData: kt, showTooltip: ht, hideTooltip: Et, tooltipOpen: An, tooltipLeft: Zt, tooltipTop: kn } = zy(), {
    handleTooltipMouseOver: Rt,
    handleTooltipClick: dn,
    handleTooltipMouseOff: Gt,
    TooltipListItem: rn,
    getXValueFromCoordinate: Wn
  } = Vy({
    xScale: At,
    yScale: xt,
    showTooltip: ht,
    hideTooltip: Et
  }), { dataKey: Ln } = Y.xAxis, Cn = P.length && St ? [0, P.length - 1].map((D) => p(P[D][Ln])).reduce((D, G) => Math.abs(D - G)) / tw : 0, mn = St && Cn > Kt, _n = (D, G, pe) => {
    if (at && D === 0.1 && (D = 0), !(o.data && !o.data[G] && W === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[G][o.xAxis.dataKey] : Pn(Y.yAxis) ? h(p(D)) : ee === "vertical" && hn - Ot < 3 ? y(D, "left", ge, !1, !1, "1", { index: G, length: pe.length }) : ee === "vertical" ? y(D, "left", ge, !1, !1, void 0, { index: G, length: pe.length }) : D;
  }, On = (D, G, pe) => (at && D === 0.1 && (D = 0), Pn(Y.xAxis) && o.visualizationType !== "Forest Plot" ? h(D, G, pe) : ee === "horizontal" && o.visualizationType !== "Forest Plot" ? y(D, "left", ge) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? y(D, "bottom", ge) : o.visualizationType === "Forest Plot" ? y(
    D,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : D), Fn = () => {
    const { visualizationType: D } = o;
    return D === "Combo" && Y.forecastingSeriesKeys > 0 || D === "Area Chart" || D === "Line" || D === "Bar";
  }, Kn = () => {
    let D = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[c] && (D = o.xAxis.viewportStepCount[c]), D;
  }, an = (D) => {
    const G = D.currentTarget.getBoundingClientRect(), pe = D.clientX - G.left, O = D.clientY - G.top;
    Re({
      x: pe,
      y: O
    });
  };
  se.useEffect(() => {
    document.querySelector(".isEditor") && Pe((G) => !0);
  }), se.useEffect(() => {
    (rt == null ? void 0 : rt.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Pe((D) => !0);
    }, 500);
  }, [rt == null ? void 0 : rt.isIntersecting, o.animate]), se.useEffect(() => {
    const D = Ze.current;
    if (!D && !fe)
      return;
    if (!D)
      return ze(0);
    const G = D.getBBox().width;
    ze(G);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), se.useEffect(() => {
    if (!it || K.hideLabel)
      return;
    const D = Be.current;
    if (!D)
      return;
    const G = st + Number(o.xAxis.axisPadding), O = D.getBBox().y - G + D.getBBox().height + sf;
    we.current && we.current.setAttribute("y", O);
  }, [(b = o == null ? void 0 : o.data) == null ? void 0 : b.length, un]), se.useEffect(() => {
    if (!He.current)
      return;
    const D = He.current.getBBox().height, G = W === "Forest Plot", pe = Ve.current && le.labelsAboveGridlines, O = X != null && X.active ? X == null ? void 0 : X.height : 0, I = G ? o.data.length * B.rowHeight : 0, J = pe ? Ve.current.getBBox().height : 0, ve = D + O + I + J, Ie = En + ve;
    if (!v.current || (v.current.style.height = `${Ie}px`, !J))
      return;
    const Xe = r.current;
    if (!Xe)
      return;
    const lt = v.current.getBoundingClientRect().width;
    if (Xe.setAttribute("viewBox", `0 ${-J} ${lt} ${Ie}`), !A.current)
      return;
    const Ut = (ae == null ? void 0 : ae.position) !== "top" && (ae == null ? void 0 : ae.position) !== "bottom" && !Va(c);
    A.current.style.transform = Ut ? `translateY(${J}px)` : "none";
  }, [He.current, o, fn, X, c, Ve.current, En]), se.useEffect(() => {
    De.current !== ue && (De.current = ue, Ne && qe(0));
  }, [ue]), se.useEffect(() => {
    if (ee === "horizontal" || !Bt)
      return;
    const D = 0.025, pe = Math.max(...xt.ticks(Ft)) - ue * D;
    if (!(ue > pe))
      return;
    const I = xt.ticks(Ft), J = I.length === 1 ? I[0] : I[1] - I[0], ve = Math.max(...xt.ticks(Ft)) + J, Ie = U < 0 ? ue / 2 : ue, Xe = (ve - ue) / Ie, lt = Xe > D ? Xe : Xe + J / Ie;
    qe(lt * 100 + 0.1);
  }, [ue, Bt, xt, Ft]);
  const yn = () => {
    const D = fn + sf, G = (pe, O) => {
      if (!pe.length)
        return !1;
      const I = pe.filter((Jt) => Jt.index !== 0), J = I == null ? void 0 : I.length, ve = O.range()[0] || tt / 2, Ie = I.map(
        (Jt) => hr(y(Jt.value, "left"), _t)
      ), Xe = 100, lt = Ie.reduce((Jt, en) => Jt + en, Xe), Ut = (ve - lt) / J;
      let Ht = [0];
      for (let Jt = 1; Jt < Ie.length; Jt++)
        Ht[Jt] = Ht[Jt - 1] + Ie[Jt - 1] + Ut;
      let Qt = !1;
      return Ie.forEach((Jt, en) => {
        if (Ht[en] + Ie[en] > Ht[en + 1]) {
          Qt = !0;
          return;
        }
      }), Qt;
    };
    return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      ju,
      {
        top: st,
        left: Number(Y.yAxis.size),
        label: Y.xAxis.label,
        tickFormat: Pn(Y.xAxis) ? h : y,
        scale: Oe,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: Y.xAxis.numTicks || void 0
      },
      (pe) => /* @__PURE__ */ n.createElement(et, { className: "bottom-axis" }, pe.ticks.map((O, I) => {
        const J = G(pe.ticks, Oe), ve = Number(o.xAxis.maxTickRotation) || 90, Ie = o.isResponsiveTicks && J, Xe = O.index !== 0 && (Ie ? ve : Number(o.yAxis.tickRotation)), lt = Xe && O.index !== 0 ? "end" : "middle";
        return /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !Y.yAxis.hideTicks && /* @__PURE__ */ n.createElement(ln, { from: O.from, to: O.to, stroke: "#333" }), !Y.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          dt,
          {
            innerRef: (Ut) => Ue.current[I] = Ut,
            x: O.to.x,
            y: O.to.y,
            angle: -Xe,
            verticalAnchor: Xe ? "middle" : "start",
            textAnchor: lt,
            fontSize: gt
          },
          y(O.value, "left")
        ));
      }), !Y.yAxis.hideAxis && /* @__PURE__ */ n.createElement(ln, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" }))
    ), /* @__PURE__ */ n.createElement(
      ju,
      {
        innerRef: He,
        top: st,
        left: Number(Y.yAxis.size),
        label: Y.xAxis.label,
        tickFormat: Pn(Y.xAxis) ? h : Y.xAxis.dataKey !== "Year" ? y : (pe) => pe,
        scale: _e,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: Y.xAxis.numTicks || void 0
      },
      (pe) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(et, { className: "bottom-axis" }, pe.ticks.map((O, I) => {
        const J = G(pe.ticks, _e), ve = Number(o.xAxis.maxTickRotation) || 90, Ie = o.isResponsiveTicks && J, Xe = O.index !== 0 && (Ie ? ve : Number(o.yAxis.tickRotation)), lt = Xe && O.index !== 0 ? "end" : "middle";
        return I ? /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !Y.yAxis.hideTicks && /* @__PURE__ */ n.createElement(ln, { from: O.from, to: O.to, stroke: "#333" }), !Y.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          dt,
          {
            x: O.to.x,
            y: O.to.y + uf,
            angle: -Xe,
            verticalAnchor: Xe ? "middle" : "start",
            textAnchor: lt,
            fontSize: gt
          },
          y(O.value, "left")
        )) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      }), !Y.yAxis.hideAxis && /* @__PURE__ */ n.createElement(ln, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" })), /* @__PURE__ */ n.createElement(et, null, /* @__PURE__ */ n.createElement(
        dt,
        {
          className: "x-axis-title-label",
          x: tt / 2,
          y: D,
          stroke: "#333",
          textAnchor: "middle",
          verticalAnchor: "start",
          fontSize: Dt
        },
        Y.xAxis.label
      )))
    ));
  };
  return isNaN(It) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(Vr, { component: "LinearChart" }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary"
    },
    /* @__PURE__ */ n.createElement(
      "svg",
      {
        ref: r,
        onMouseMove: an,
        width: t,
        height: Tn ? 1 : e,
        className: `linear ${o.animate ? "animated" : ""} ${Ye && o.animate ? "animate" : ""} ${ne && "debug"} ${S && "dragging-annotation"}`,
        role: "img",
        "aria-label": g(o),
        style: { overflow: "visible" }
      },
      !S && /* @__PURE__ */ n.createElement(Rr, { width: t, height: En, fill: "transparent" }),
      " ",
      !["Spark Line", "Forest Plot"].includes(W) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        rm,
        {
          scale: xt,
          left: Number(Y.yAxis.size) - o.yAxis.axisPadding,
          numTicks: Ft
        },
        (D) => {
          const G = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2;
          return /* @__PURE__ */ n.createElement(et, { className: "left-axis" }, D.ticks.map((pe, O) => {
            const I = String(pe.value).startsWith("1") || pe.value === 0.1 ? "block" : "none", J = pe.index === 0 && pe.value === 0 && o.xAxis.hideAxis;
            return /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${pe.value}-${O}`, className: "vx-axis-tick" }, Y.yAxis.gridLines && !J ? /* @__PURE__ */ n.createElement(
              ln,
              {
                key: `${pe.value}--hide-hideGridLines`,
                display: (at && I).toString(),
                from: { x: pe.from.x + tt, y: pe.from.y },
                to: pe.from,
                stroke: "#d6d6d6"
              }
            ) : "");
          }), /* @__PURE__ */ n.createElement(
            dt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * Y.yAxis.size + sn}, ${G}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor,
              fontSize: Dt
            },
            D.label
          ));
        }
      ),
      W === "Paired Bar" && yn(),
      W === "Deviation Bar" && ((_ = o.runtime.series) == null ? void 0 : _.length) === 1 && /* @__PURE__ */ n.createElement(bk, { animatedChart: Ye, xScale: At, yScale: xt, width: tt, height: st }),
      W === "Paired Bar" && /* @__PURE__ */ n.createElement(Ok, { originalWidth: It, width: tt, height: st }),
      W === "Scatter Plot" && /* @__PURE__ */ n.createElement(
        xk,
        {
          xScale: At,
          yScale: xt,
          getXAxisData: tn,
          getYAxisData: cn,
          xMax: tt,
          yMax: st,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          handleTooltipClick: dn,
          tooltipData: kt,
          showTooltip: ht
        }
      ),
      W === "Box Plot" && /* @__PURE__ */ n.createElement(
        vk,
        {
          seriesScale: Dn,
          xMax: tt,
          yMax: st,
          min: Ot,
          max: hn,
          xScale: At,
          yScale: xt
        }
      ),
      (W === "Area Chart" && o.visualizationSubType === "regular" || W === "Combo") && /* @__PURE__ */ n.createElement(
        ak,
        {
          xScale: At,
          yScale: xt,
          yMax: st,
          xMax: tt,
          chartRef: r,
          width: tt,
          height: st,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          tooltipData: kt,
          showTooltip: ht
        }
      ),
      (W === "Area Chart" && o.visualizationSubType === "stacked" || W === "Combo") && /* @__PURE__ */ n.createElement(
        ok,
        {
          xScale: At,
          yScale: xt,
          yMax: st,
          xMax: tt,
          chartRef: r,
          width: tt,
          height: st,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          tooltipData: kt,
          showTooltip: ht
        }
      ),
      (W === "Bar" || W === "Combo" || d) && /* @__PURE__ */ n.createElement(
        dk,
        {
          xScale: At,
          yScale: xt,
          seriesScale: Dn,
          xMax: tt,
          yMax: st,
          getXAxisData: tn,
          getYAxisData: cn,
          animatedChart: Ye,
          visible: Ye,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          handleTooltipClick: dn,
          tooltipData: kt,
          showTooltip: ht,
          chartRef: r
        }
      ),
      (W === "Line" && !d || W === "Combo" || W === "Bump Chart") && /* @__PURE__ */ n.createElement(
        cm,
        {
          xScale: At,
          yScale: xt,
          getXAxisData: tn,
          getYAxisData: cn,
          xMax: tt,
          yMax: st,
          seriesStyle: o.runtime.series,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          handleTooltipClick: dn,
          tooltipData: kt,
          showTooltip: ht,
          chartRef: r
        }
      ),
      (W === "Forecasting" || W === "Combo") && /* @__PURE__ */ n.createElement(
        Sk,
        {
          showTooltip: ht,
          tooltipData: kt,
          xScale: At,
          yScale: xt,
          width: tt,
          le: !0,
          height: st,
          xScaleNoPadding: Ee,
          chartRef: r,
          getXValueFromCoordinate: Wn,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          isBrush: !1
        }
      ),
      W === "Forest Plot" && /* @__PURE__ */ n.createElement(
        _k,
        {
          xScale: At,
          yScale: xt,
          seriesScale: Dn,
          width: It,
          height: $t,
          getXAxisData: tn,
          getYAxisData: cn,
          animatedChart: Ye,
          visible: Ye,
          handleTooltipMouseOver: Rt,
          handleTooltipMouseOff: Gt,
          handleTooltipClick: dn,
          tooltipData: kt,
          showTooltip: ht,
          chartRef: r,
          config: o,
          forestPlotRightLabelRef: Be
        }
      ),
      o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(nk, { xMax: tt, yMax: st }),
      !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
        W
      ) && !d && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        cm,
        {
          xScale: At,
          yScale: xt,
          getXAxisData: tn,
          getYAxisData: cn,
          xMax: tt,
          yMax: st,
          seriesStyle: o.runtime.series
        }
      )),
      o.yAxis.anchors && o.yAxis.anchors.map((D, G) => {
        let pe = xt(D.value), O = 0;
        if (D.value && (o.yAxis.labelPlacement === "Below Bar" ? O = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : O = 8, !!pe))
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              ln,
              {
                key: `yAxis-${D.value}--${G}`,
                strokeDasharray: x(D.lineStyle),
                stroke: D.color ? D.color : "rgba(0,0,0,1)",
                className: "anchor-y",
                from: { x: 0 + Nt, y: pe - O },
                to: { x: It - o.yAxis.rightAxisSize, y: pe - O }
              }
            )
          );
      }),
      o.xAxis.anchors && o.xAxis.anchors.map((D, G) => {
        let pe = K;
        ee === "horizontal" && (pe = le);
        let I = (() => {
          let J;
          return J = Pn(pe) ? At(p(D.value, !1)) : At(D.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (J = J ? J + (pe.type === "categorical" || pe.type === "date" ? At.bandwidth() : 0) / 2 : 0), J;
        })();
        if (I)
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              ln,
              {
                key: `xAxis-${D.value}--${G}`,
                strokeDasharray: x(D.lineStyle),
                stroke: D.color ? D.color : "rgba(0,0,0,1)",
                fill: D.color ? D.color : "rgba(0,0,0,1)",
                className: "anchor-x",
                from: { x: Number(I) + Number(Nt), y: 0 },
                to: { x: Number(I) + Number(Nt), y: st }
              }
            )
          );
      }),
      o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ n.createElement(
        xp,
        {
          xScale: At,
          handleTooltipClick: dn,
          handleTooltipMouseOff: Gt,
          handleTooltipMouseOver: Rt,
          showTooltip: ht,
          hideTooltip: Et,
          tooltipData: kt,
          yMax: st,
          width: It
        }
      ),
      Fn && ht && kt && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(et, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        ln,
        {
          from: { x: kt.dataXPosition - 10, y: 0 },
          to: { x: kt.dataXPosition - 10, y: st },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      Fn && ht && kt && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        et,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          ln,
          {
            from: { x: 0, y: kt.dataYPosition },
            to: { x: tt, y: kt.dataYPosition },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      Tn && /* @__PURE__ */ n.createElement(
        dt,
        {
          x: Number(o.yAxis.size) + Number(tt / 2),
          y: En / 2 - (o.xAxis.padding || 0) / 2,
          textAnchor: "middle"
        },
        o.chartMessage.noData
      ),
      (o.visualizationType === "Bar" || d) && o.tooltips.singleSeries && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        et,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          ln,
          {
            from: { x: 0, y: ye.y },
            to: { x: tt, y: ye.y },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      (o.visualizationType === "Bar" || d) && o.tooltips.singleSeries && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(et, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        ln,
        {
          from: { x: ye.x, y: 0 },
          to: { x: ye.x, y: st },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      /* @__PURE__ */ n.createElement(et, { left: Number(o.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(
        Sp.Draggable,
        {
          xScale: At,
          yScale: xt,
          xScaleAnnotation: ct,
          xMax: tt,
          svgRef: r,
          onDragStateChange: w
        }
      )),
      !["Spark Line", "Forest Plot"].includes(W) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        rm,
        {
          scale: xt,
          tickLength: at ? 6 : 8,
          left: Number(Y.yAxis.size) - o.yAxis.axisPadding,
          label: Y.yAxis.label || Y.yAxis.label,
          stroke: "#333",
          tickFormat: _n,
          numTicks: Ft
        },
        (D) => {
          const G = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = st / D.ticks.length / 2 - st / D.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(et, { className: "left-axis" }, !o.yAxis.hideAxis && /* @__PURE__ */ n.createElement(
            ln,
            {
              from: D.axisFromPoint,
              to: Y.horizontal ? {
                x: 0,
                y: o.visualizationType === "Forest Plot" ? e : Number(z.horizontal)
              } : D.axisToPoint,
              stroke: "#000"
            }
          ), xt.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            ln,
            {
              from: { x: D.axisFromPoint.x, y: xt(0) },
              to: { x: tt, y: xt(0) },
              stroke: "#333"
            }
          ), W === "Bar" && ee === "horizontal" && At.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            ln,
            {
              from: { x: At(0), y: 0 },
              to: { x: At(0), y: st },
              stroke: "#333",
              strokeWidth: 2
            }
          ), D.ticks.map((O, I) => {
            const J = D.ticks[0].to.y, ve = 15, Ie = String(O.value).startsWith("1") || O.value === 0.1 ? "block" : "none", Xe = Ie === "block" ? 7 : 0, lt = { x: O.to.x - Xe, y: O.to.y }, Ut = D.ticks.length - 1 === I, Ht = Ut && V && Q && !jt, Jt = j ? te ? -8 : -12 : ow, en = j ? 4 : 0, jn = O.to.x - Jt, Jn = O.to.y - en, er = j ? "end" : "middle", Yn = V && j && Q && Ut;
            return /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !Y.yAxis.hideTicks && !j && !Ht && /* @__PURE__ */ n.createElement(
              ln,
              {
                key: `${O.value}--hide-hideTicks`,
                from: O.from,
                to: at ? lt : O.to,
                stroke: o.yAxis.tickColor,
                display: ee === "horizontal" ? "none" : "block",
                fontSize: gt
              }
            ), ee === "horizontal" && Z !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              dt,
              {
                transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - J : O.to.y - J + (Number(o.barHeight * o.runtime.series.length) - ve) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: gt
              },
              O.formattedValue
            ), ee === "horizontal" && Z === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              dt,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - J + (Number(o.barHeight) - ve) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: gt
              },
              O.formattedValue
            ), ee === "horizontal" && W === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              dt,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - J + Number(o.barHeight) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: gt
              },
              O.formattedValue
            ), ee === "horizontal" && W === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              dt,
              {
                transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - J + 2 : O.to.y - J + Number(o.barHeight) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: gt
              },
              O.formattedValue
            ), ee === "vertical" && W === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
              dt,
              {
                display: o.useLogScale ? Ie : "block",
                dx: o.useLogScale ? -6 : 0,
                x: o.runtime.horizontal ? O.from.x + 2 : O.to.x - 8.5,
                y: O.to.y - 13 + (o.runtime.horizontal ? pe : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                textAnchor: o.runtime.horizontal ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                fontSize: gt
              },
              o.runtime.seriesLabelsAll[O.formattedValue - 1]
            ), (C.length === 0 || C.includes(
              o.runtime.seriesLabelsAll[O.formattedValue - 1]
            )) && /* @__PURE__ */ n.createElement(
              "rect",
              {
                x: 0 - Number(o.yAxis.size),
                y: O.to.y - 8 + (o.runtime.horizontal ? pe : 7),
                width: Number(o.yAxis.size) + At(At.domain()[0]),
                height: "2",
                fill: i(o.runtime.seriesLabelsAll[O.formattedValue - 1])
              }
            )), ee === "vertical" && W !== "Paired Bar" && W !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, V && Ut && !j && /* @__PURE__ */ n.createElement(
              Vp,
              {
                innerRef: Ze,
                display: at ? Ie : "block",
                dx: at ? -6 : 0,
                x: jn,
                y: Jn,
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: er,
                textAnchor: jt ? "end" : "start",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                paintOrder: "stroke",
                strokeLinejoin: "round",
                style: { whiteSpace: "pre-wrap" },
                fontSize: gt
              },
              Q
            ), /* @__PURE__ */ n.createElement(
              Vp,
              {
                innerRef: (Er) => Ut && (Ve.current = Er),
                display: at ? Ie : "block",
                dx: at ? -6 : 0,
                x: jt ? jn - fe : jn,
                y: Jn + (o.runtime.horizontal ? pe : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : er,
                textAnchor: o.runtime.horizontal || j ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                disableStroke: !j,
                strokeLinejoin: "round",
                paintOrder: "stroke",
                style: { whiteSpace: "pre-wrap" },
                fontSize: gt
              },
              `${O.formattedValue}${Yn ? Q : ""}`
            )));
          }), /* @__PURE__ */ n.createElement(
            dt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * Y.yAxis.size + sn}, ${G}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor,
              fontSize: Dt
            },
            D.label
          ));
        }
      ),
      o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ n.createElement(
        Fk,
        {
          max: hn,
          maxValue: ue,
          height: En,
          xMax: tt,
          yMax: st,
          leftSize: Number(Y.yAxis.size) - o.yAxis.axisPadding
        }
      ),
      Nn && /* @__PURE__ */ n.createElement(
        BS,
        {
          scale: nn,
          left: Number(It - o.yAxis.rightAxisSize),
          label: o.yAxis.rightLabel,
          tickFormat: (D) => y(D, "right"),
          numTicks: Y.yAxis.rightNumTicks || void 0,
          labelOffset: 45
        },
        (D) => {
          const G = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = st / D.ticks.length / 2 - st / D.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(et, { className: "right-axis" }, D.ticks.map((O, I) => /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !Y.yAxis.rightHideTicks && /* @__PURE__ */ n.createElement(
            ln,
            {
              from: O.from,
              to: O.to,
              display: Y.horizontal ? "none" : "block",
              stroke: o.yAxis.rightAxisTickColor
            }
          ), Y.yAxis.rightGridLines ? /* @__PURE__ */ n.createElement(ln, { from: { x: O.from.x + tt, y: O.from.y }, to: O.from, stroke: "#d6d6d6" }) : "", !o.yAxis.rightHideLabel && /* @__PURE__ */ n.createElement(
            dt,
            {
              x: O.to.x,
              y: O.to.y + (Y.horizontal ? pe : 0),
              verticalAnchor: Y.horizontal ? "start" : "middle",
              textAnchor: "start",
              fill: o.yAxis.rightAxisTickLabelColor,
              fontSize: gt
            },
            O.formattedValue
          ))), !o.yAxis.rightHideAxis && /* @__PURE__ */ n.createElement(ln, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            dt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${G}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.rightAxisLabelColor,
              fontSize: Dt
            },
            D.label
          ));
        }
      ),
      Ae && o.topAxis.hasLine && /* @__PURE__ */ n.createElement(
        VS,
        {
          stroke: "#333",
          left: Number(Y.yAxis.size),
          scale: At,
          hideTicks: !0,
          hideZero: !0,
          tickLabelProps: () => ({
            fill: "transparent"
          })
        }
      ),
      W !== "Paired Bar" && W !== "Spark Line" && /* @__PURE__ */ n.createElement(
        ju,
        {
          innerRef: He,
          top: Y.horizontal && o.visualizationType !== "Forest Plot" ? Number(z.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? st + Number(o.xAxis.axisPadding) : st,
          left: o.visualizationType !== "Forest Plot" ? Number(Y.yAxis.size) : 0,
          label: o[ft].label,
          tickFormat: On,
          scale: At,
          stroke: "#333",
          numTicks: mn ? Cn : Kt,
          tickStroke: "#333",
          tickValues: o.runtime.xAxis.manual ? Hk(pn, At, St ? Kt : Kn(), o) : o.runtime.xAxis.type === "date" ? pn : void 0
        },
        (D) => {
          var xa;
          const G = o.series.some((Lt) => Lt.dynamicCategory);
          o.runtime.xAxis.type === "date" && !o.runtime.xAxis.manual && !G && (D.ticks = Vk(o, D, pn, h));
          const pe = mn && At.ticks(Kt).map(
            (Lt) => D.ticks.findIndex(
              (xn) => (typeof xn.value == "number" ? xn.value : xn.value.getTime()) === Lt.getTime()
            )
          ).slice(0, 2).reduce((Lt, xn) => xn - Lt), O = mn ? [...D.ticks].reverse().filter((Lt, xn) => xn % pe === 0).reverse().map((Lt, xn, ra) => ({
            ...Lt,
            // reformat in case showYearsOnce, since first month of year may have changed
            formattedValue: On(Lt.value, xn, ra)
          })) : D.ticks, I = fn + sf, J = (Lt) => /\s/.test(Lt), ve = O.some((Lt) => J(Lt.value)), Ie = Math.max(
            ...O.map((Lt) => hr(Lt.formattedValue, _t))
          ), Xe = ve ? 180 : 100, lt = O.map((Lt) => hr(Lt.formattedValue, _t)), Ut = lt.reduce((Lt, xn) => Lt + xn, Xe), Ht = (tt - Ut) / (O.length - 1);
          let Qt = [0];
          for (let Lt = 1; Lt < lt.length; Lt++)
            Qt[Lt] = Qt[Lt - 1] + lt[Lt - 1] + Ht;
          const Jt = (xa = He == null ? void 0 : He.current) == null ? void 0 : xa.getBBox().height;
          o.xAxis.axisBBox = Jt;
          let en = !1;
          lt.forEach((Lt, xn) => {
            if (Qt[xn] + lt[xn] > Qt[xn + 1]) {
              en = !0;
              return;
            }
          }), o.xAxis.showYearsOnce && (en = !0);
          const jn = lt[lt.length - 1], er = Qt[Qt.length - 1] + jn + jn / 2, Yn = tt - jn;
          er > Yn && (en = !0);
          const Er = en && o.isResponsiveTicks ? Ie + cf + 20 : 0;
          return o.dynamicMarginTop = Er, o.xAxis.tickWidthMax = Ie, /* @__PURE__ */ n.createElement(et, { className: "bottom-axis", width: s[0] }, O.map((Lt, xn, ra) => {
            const Nr = String(Lt.value).startsWith("1") || Lt.value === 0.1 ? "block" : "none", or = Nr === "block" ? 16 : cf, Dr = { x: Lt.to.x, y: or }, Wr = 100 / ra.length;
            o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
            const Vt = o.isResponsiveTicks && en ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
            return /* @__PURE__ */ n.createElement(et, { key: `vx-tick-${Lt.value}-${xn}`, className: "vx-axis-tick" }, !o.xAxis.hideTicks && /* @__PURE__ */ n.createElement(
              ln,
              {
                from: Lt.from,
                to: ee === "horizontal" && at ? Dr : Lt.to,
                stroke: o.xAxis.tickColor,
                strokeWidth: Nr === "block" && at ? 1.3 : 1
              }
            ), !o.xAxis.hideLabel && /* @__PURE__ */ n.createElement(
              dt,
              {
                innerRef: (mr) => Ue.current[xn] = mr,
                dy: o.orientation === "horizontal" && at ? 8 : 0,
                display: o.orientation === "horizontal" && at ? Nr : "block",
                x: Lt.to.x,
                y: Lt.to.y + uf,
                angle: Vt,
                verticalAnchor: Vt < -50 ? "middle" : "start",
                textAnchor: Vt ? "end" : "middle",
                width: en && !o.isResponsiveTicks && !Number(o[ft].tickRotation) ? Wr : void 0,
                fill: o.xAxis.tickLabelColor,
                fontSize: gt
              },
              Lt.formattedValue
            ));
          }), !o.xAxis.hideAxis && /* @__PURE__ */ n.createElement(ln, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            dt,
            {
              innerRef: we,
              className: "x-axis-title-label",
              x: tt / 2,
              y: it ? 0 : I,
              textAnchor: "middle",
              verticalAnchor: "start",
              fontWeight: "bold",
              fill: o.xAxis.labelColor,
              fontSize: Dt
            },
            D.label
          ));
        }
      )
    ),
    !S && kt && Object.entries(kt.data).length > 0 && An && ht && kt.dataYPosition && kt.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ n.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ n.createElement(
      Hy,
      {
        key: Math.random(),
        className: "tooltip cdc-open-viz-module",
        left: Zt,
        top: kn
      },
      /* @__PURE__ */ n.createElement("ul", null, typeof kt == "object" && Object.entries(kt.data).map((D, G) => /* @__PURE__ */ n.createElement(rn, { item: D, key: G })))
    )),
    o.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(
      mc,
      {
        id: "bump-chart",
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    be() && !S && /* @__PURE__ */ n.createElement(
      mc,
      {
        id: `cdc-open-viz-tooltip-${Y.uniqueId}`,
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    /* @__PURE__ */ n.createElement("div", { className: "animation-trigger", ref: je })
  ));
});
const lw = (e) => {
  var le;
  const { width: t, height: r } = e, { transformedData: a, config: i, parseDate: o, formatDate: d, seriesHighlight: c, formatNumber: s, colorScale: h, handleChartAriaLabels: y } = se.useContext(pt);
  let g = Number(t);
  const { minValue: x, maxValue: w } = Hc(i, a), S = { top: 5, right: 10, bottom: 10, left: 10 }, A = Number(r), p = g - i.runtime.yAxis.size, v = A - S.top - 20, L = (Y) => i.runtime.xAxis.type === "date" ? o(Y[i.runtime.originalXAxis.dataKey]).getTime() : Y[i.runtime.originalXAxis.dataKey], P = (Y, ae) => Y[ae];
  let R, C;
  const { max: z, min: W } = i.runtime.yAxis, Z = Number(z) >= Number(w), ee = Number(W) <= Number(x);
  if (a) {
    let Y = Number(W && ee ? W : x), ae = Number(z && Z ? z : Number.MIN_VALUE);
    if (ae === Number.MIN_VALUE && (ae = w), i.runtime.yAxis.paddingPercent) {
      let X = (ae - Y) * i.runtime.yAxis.paddingPercent;
      Y -= X, ae += X;
    }
    let B = a.map((X) => L(X));
    i.runtime.horizontal ? (R = Vn({
      domain: [Y, ae],
      range: [0, p]
    }), C = i.runtime.xAxis.type === "date" ? Vn({ domain: [Math.min(...B), Math.max(...B)] }) : nl({ domain: B, padding: 0.5 }), nl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, v]
    }), C.rangeRound([0, v])) : (Y = Y < 0 ? Y * 1.11 : Y, C = Vn({
      domain: [Y, ae],
      range: [v - S.bottom, S.top]
    }), R = nl({
      domain: B,
      range: [S.left, g - S.right]
    }), nl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, p]
    }));
  }
  const K = [R.domain()[0], R.domain()[R.domain().length - 1]];
  return /* @__PURE__ */ n.createElement(Vr, { component: "SparkLine" }, /* @__PURE__ */ n.createElement("svg", { role: "img", "aria-label": y(i), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ n.createElement("title", null, `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}`), ((le = i.runtime.lineSeriesKeys) == null ? void 0 : le.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((Y, ae) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    et,
    {
      style: { width: g },
      className: "sparkline-group",
      key: `series-${Y}`,
      opacity: i.legend.behavior === "highlight" && c.length > 0 && c.indexOf(Y) === -1 ? 0.5 : 1,
      display: i.legend.behavior === "highlight" || c.length === 0 || c.indexOf(Y) !== -1 ? "block" : "none"
    },
    i.labels && a.map((B, X) => /* @__PURE__ */ n.createElement(et, { key: `series-${Y}-point-${X}` }, /* @__PURE__ */ n.createElement(dt, { x: R(L(B)), y: C(P(B, Y)), fill: h ? h(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000", textAnchor: "middle" }, s(B[Y])))),
    /* @__PURE__ */ n.createElement(
      Hr,
      {
        curve: _c,
        data: a,
        x: (B) => R(L(B)),
        y: (B) => C(P(B, Y)),
        stroke: h ? h(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${ae})`
      }
    ),
    /* @__PURE__ */ n.createElement(Tm, { id: `arrow--${ae}`, refX: 2, size: 6, markerEnd: `url(#arrow--${ae})`, strokeOpacity: 1, fillOpacity: 1, fill: h ? h(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000" })
  ), /* @__PURE__ */ n.createElement(
    ju,
    {
      top: v + S.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: R,
      tickValues: K,
      tickFormat: (B) => i.xAxis.type === "date" ? d(B) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
};
var sw = ["flexDirection", "alignItems", "margin", "display", "children"];
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, jf.apply(this, arguments);
}
function uw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function wc(e) {
  var t = e.flexDirection, r = t === void 0 ? "row" : t, a = e.alignItems, i = a === void 0 ? "center" : a, o = e.margin, d = o === void 0 ? "0" : o, c = e.display, s = c === void 0 ? "flex" : c, h = e.children, y = uw(e, sw);
  return /* @__PURE__ */ n.createElement("div", jf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: i,
      flexDirection: r,
      margin: d
    }
  }, y), h);
}
wc.propTypes = {
  alignItems: Me.string,
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node,
  display: Me.string
};
var cw = ["flex", "label", "margin", "align", "children"];
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function dw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Tc(e) {
  var t = e.flex, r = t === void 0 ? "1" : t, a = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, d = e.align, c = d === void 0 ? "left" : d, s = e.children, h = dw(e, cw);
  return /* @__PURE__ */ n.createElement("div", Uf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: r,
      margin: o
    }
  }, h), s || a);
}
Tc.propTypes = {
  align: Me.string,
  label: Me.node,
  flex: Me.oneOfType([Me.string, Me.number]),
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node
};
function Kf() {
  return Kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Kf.apply(this, arguments);
}
function kp(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style;
  return /* @__PURE__ */ n.createElement("div", {
    style: Kf({
      width: r,
      height: a,
      background: t
    }, i)
  });
}
kp.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function fg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, d = typeof a == "string" || typeof a > "u" ? 0 : a, c = Math.max(o, d), s = c / 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ n.createElement(et, {
    top: s,
    left: s
  }, /* @__PURE__ */ n.createElement("circle", {
    r: s,
    fill: t,
    style: i
  })));
}
fg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function pg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof a == "string" || typeof a > "u" ? 0 : a, d = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: r,
    height: a
  }, /* @__PURE__ */ n.createElement(et, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ n.createElement("line", {
    x1: 0,
    x2: r,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: i
  })));
}
pg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function bs() {
  return bs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, bs.apply(this, arguments);
}
var ff = function() {
};
function fw(e) {
  var t = e.shape, r = t === void 0 ? "rect" : t, a = e.fill, i = a === void 0 ? ff : a, o = e.size, d = o === void 0 ? ff : o, c = e.width, s = e.height, h = e.label, y = e.item, g = e.itemIndex, x = e.shapeStyle, w = x === void 0 ? ff : x, S = {
    width: c,
    height: s,
    item: y,
    itemIndex: g,
    label: h,
    fill: i(bs({}, h)),
    size: d(bs({}, h)),
    style: w(bs({}, h))
  };
  return typeof r == "string" ? r === "circle" ? /* @__PURE__ */ n.createElement(fg, S) : r === "line" ? /* @__PURE__ */ n.createElement(pg, S) : /* @__PURE__ */ n.createElement(kp, S) : /* @__PURE__ */ n.isValidElement(r) ? /* @__PURE__ */ n.cloneElement(r, S) : r ? /* @__PURE__ */ n.createElement(r, S) : null;
}
function Cc() {
  return Cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Cc.apply(this, arguments);
}
function hg(e) {
  var t = e.shape, r = t === void 0 ? kp : t, a = e.width, i = e.height, o = e.margin, d = e.label, c = e.item, s = e.itemIndex, h = e.fill, y = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ n.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: y ? y(Cc({}, d)) : a,
      height: y ? y(Cc({}, d)) : i,
      margin: o
    }
  }, fw({
    shape: r,
    item: c,
    itemIndex: s,
    label: d,
    width: a,
    height: i,
    fill: h,
    shapeStyle: g
  }));
}
hg.propTypes = {
  itemIndex: Me.number.isRequired,
  margin: Me.oneOfType([Me.string, Me.number]),
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function mg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function fm(e) {
  return String(mg(e));
}
function pw(e) {
  var t = e.scale, r = e.labelFormat;
  return function(a, i) {
    return {
      datum: a,
      index: i,
      text: "" + r(a, i),
      value: t(a)
    };
  };
}
var hw = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Es.apply(this, arguments);
}
function mw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var yw = {
  display: "flex"
};
function yg(e) {
  var t = e.className, r = e.style, a = r === void 0 ? yw : r, i = e.scale, o = e.shape, d = e.domain, c = e.fill, s = c === void 0 ? fm : c, h = e.size, y = h === void 0 ? fm : h, g = e.labelFormat, x = g === void 0 ? mg : g, w = e.labelTransform, S = w === void 0 ? pw : w, A = e.shapeWidth, p = A === void 0 ? 15 : A, v = e.shapeHeight, L = v === void 0 ? 15 : v, P = e.shapeMargin, R = P === void 0 ? "2px 4px 2px 0" : P, C = e.shapeStyle, z = e.labelAlign, W = z === void 0 ? "left" : z, Z = e.labelFlex, ee = Z === void 0 ? "1" : Z, K = e.labelMargin, le = K === void 0 ? "0 4px" : K, Y = e.itemMargin, ae = Y === void 0 ? "0" : Y, B = e.direction, X = B === void 0 ? "column" : B, ce = e.itemDirection, ne = ce === void 0 ? "row" : ce, Q = e.legendLabelProps, V = e.children, j = mw(e, hw), te = d || ("domain" in i ? i.domain() : []), U = S({
    scale: i,
    labelFormat: x
  }), ue = te.map(U);
  return V ? /* @__PURE__ */ n.createElement(n.Fragment, null, V(ue)) : /* @__PURE__ */ n.createElement("div", {
    className: Rn("visx-legend", t),
    style: Es({}, a, {
      flexDirection: X
    })
  }, ue.map(function(ke, xe) {
    return /* @__PURE__ */ n.createElement(wc, Es({
      key: "legend-" + ke.text + "-" + xe,
      margin: ae,
      flexDirection: ne
    }, j), /* @__PURE__ */ n.createElement(hg, {
      shape: o,
      height: L,
      width: p,
      margin: R,
      item: te[xe],
      itemIndex: xe,
      label: ke,
      fill: s,
      size: y,
      shapeStyle: C
    }), /* @__PURE__ */ n.createElement(Tc, Es({
      label: ke.text,
      flex: ee,
      margin: le,
      align: W
    }, Q)));
  }));
}
yg.propTypes = {
  children: Me.func,
  className: Me.string,
  domain: Me.array,
  shapeWidth: Me.oneOfType([Me.string, Me.number]),
  shapeHeight: Me.oneOfType([Me.string, Me.number]),
  shapeMargin: Me.oneOfType([Me.string, Me.number]),
  labelAlign: Me.string,
  labelFlex: Me.oneOfType([Me.string, Me.number]),
  labelMargin: Me.oneOfType([Me.string, Me.number]),
  itemMargin: Me.oneOfType([Me.string, Me.number]),
  fill: Me.func,
  size: Me.func,
  shapeStyle: Me.func
};
function gw(e) {
  return /* @__PURE__ */ n.createElement(yg, e);
}
const vw = (e) => {
  const { position: t, singleRow: r, verticalSorted: a, hideBorder: i } = e.legend, o = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, d = {
    bottom: r ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: r ? ["single-row", "top"] : ["double-column", "top"]
  }, c = ["legend-container", o[t]].filter(Boolean), s = ["legend-container__inner", ...d[t] || []];
  ["bottom", "top"].includes(t) && a && s.push("vertical-sorted");
  const h = (["right", "left"].includes(t) || !t) && i.side, y = ["top", "bottom"].includes(t) && i.topBottom;
  return h || y ? c.push("border-0", "p-0") : c.push("p-3"), {
    containerClasses: c,
    innerClasses: s
  };
}, xw = (e, t, r) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((c) => c == null ? void 0 : c.value) : (r == null ? void 0 : r.range()) ?? [], d = e.legend.colorCode ? i.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (r == null ? void 0 : r.domain()) ?? [];
  return { colors: o, labels: d };
}, bw = (e, t) => {
  var r;
  return e ? e && ((r = t.brush) != null && r.active) ? `${t.brush.height * 1.5}px` : "27px" : "0px";
}, Ew = (e, t) => {
  var o, d, c;
  const r = ((o = t.legend) == null ? void 0 : o.position) === "top" && !t.legend.hide, a = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((d = t.preliminaryData) == null ? void 0 : d.some((s) => s.label && s.type === "suppression" && s.value && ((s == null ? void 0 : s.style) || s.symbol)));
  let i = 0;
  return r && (i = 27), r && ((c = t.dataFormat) != null && c.onlyShowTopPrefixSuffix) && (i += 9), e && (i += 9), a && (i += 40), `${i}px`;
}, Sw = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: r, visualizationType: a, visualizationSubType: i, legend: o } = e, d = () => (r == null ? void 0 : r.some((w) => w.label && w.type === "effect" && w.style !== "Filled Circles")) && ["Line", "Combo"].includes(a), c = () => !o.hideSuppressedLabels && (r == null ? void 0 : r.some(
    (w) => w.label && w.displayLegend && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)
  )) && (a === "Bar" && i === "regular" || a === "Line" || a === "Combo"), s = () => r == null ? void 0 : r.map(
    (w, S) => w.label && w.type === "effect" && w.style && /* @__PURE__ */ n.createElement("div", { key: S, className: "legend-preliminary" }, /* @__PURE__ */ n.createElement("span", { className: w.symbol }, w.lineCode), /* @__PURE__ */ n.createElement("p", null, w.label))
  ), h = (w) => {
    w.preventDefault();
  }, y = () => {
    const w = (S) => S ? {
      color: "#777772"
    } : null;
    return r == null ? void 0 : r.map((S, A) => {
      if (!S.displayLegend || S.type !== "suppression")
        return null;
      const p = "legend-preliminary", v = A + a;
      return a === "Bar" ? /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: `${p} ${S.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: S.symbol }, S.iconCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)) : a === "Line" ? /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: p }, /* @__PURE__ */ n.createElement("span", null, S.lineCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)) : a === "Combo" ? /* @__PURE__ */ n.createElement(n.Fragment, null, S.symbol && S.iconCode && /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: `${p} ${S.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: S.symbol }, S.iconCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)), S.style && S.lineCode && /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: p }, /* @__PURE__ */ n.createElement("span", null, S.lineCode), /* @__PURE__ */ n.createElement("p", null, S.label))) : null;
    });
  }, g = () => o.singleRow && t ? "legend-container__inner bottom single-row" : "", x = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (r == null ? void 0 : r.some((w) => w.label && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, d() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, s())), c() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, y())), x() && /* @__PURE__ */ n.createElement("div", { className: "legend-container__outer definition-link" }, /* @__PURE__ */ n.createElement(Ge, { alt: "info-icon", display: "info" }), /* @__PURE__ */ n.createElement("p", null, "This chart contains", /* @__PURE__ */ n.createElement(
    "a",
    {
      onClick: h,
      "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
      "data-tooltip-id": "my-tooltip",
      href: "no-router-link"
    },
    "suppressed data"
  ))), /* @__PURE__ */ n.createElement(
    mc,
    {
      id: "my-tooltip",
      variant: "light",
      style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
    }
  ));
}, gg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, kw = [
  Sm,
  km,
  Gu,
  wm,
  Gu,
  Ep,
  ({ fill: e }) => /* @__PURE__ */ n.createElement(Yf, null, /* @__PURE__ */ n.createElement(dt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, ""))
], ww = (e) => {
  var c;
  const { config: t, label: r, index: a } = e, i = a === 4, o = kw[t.visual.lineDatapointSymbol === "standard" && a < t.visual.maximumShapeAmount ? a : 0], d = `translate(15, 3) ${i ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ n.createElement("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2" }, /* @__PURE__ */ n.createElement(
    ln,
    {
      from: { x: 0, y: 3 },
      to: { x: 30, y: 3 },
      stroke: r.value,
      strokeWidth: 2,
      strokeDasharray: gg(((c = t.series[a]) == null ? void 0 : c.type) || "")
    }
  ), /* @__PURE__ */ n.createElement("g", { display: t.legend.hasShape ? "block" : "none", transform: d }, /* @__PURE__ */ n.createElement(o, { fillOpacity: 1, fill: r.value })));
}, Tw = 36, Cw = se.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: r,
    highlight: a,
    handleShowAll: i,
    currentViewport: o,
    formatLabels: d,
    skipId: c = "legend",
    dimensions: s
  }, h) => {
    const { innerClasses: y, containerClasses: g } = vw(e), { runtime: x, legend: w } = e, S = (w == null ? void 0 : w.position) === "bottom" || Va(o) && !w.hide && (w == null ? void 0 : w.position) !== "top", A = {
      marginBottom: Ew(S, e),
      marginTop: bw(S, e)
    }, { HighLightedBarUtils: p } = $c(e);
    let v = p.findDuplicates(e.highlightedBarValues);
    return w ? /* @__PURE__ */ n.createElement(
      "aside",
      {
        ref: h,
        style: A,
        id: c || "legend",
        className: g.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0
      },
      (w.label || w.description) && /* @__PURE__ */ n.createElement("div", { className: w.description ? "mb-3" : "mb-2" }, w.label && /* @__PURE__ */ n.createElement("h3", { className: "fw-bold" }, Oi(w.label)), w.description && /* @__PURE__ */ n.createElement("p", { className: "mt-2" }, Oi(w.description))),
      /* @__PURE__ */ n.createElement(
        Fg,
        {
          config: e,
          ...xw(e, d, t),
          dimensions: s,
          parentPaddingToSubtract: w.hideBorder ? 0 : Tw
        }
      ),
      /* @__PURE__ */ n.createElement(gw, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (L) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: y.join(" ") }, d(L).map((P, R) => {
        var W, Z;
        let C = ["legend-item", `legend-text--${P.text.replace(" ", "").toLowerCase()}`], z = P.datum;
        if (e.exclusions.active && ((W = e.exclusions.keys) != null && W.includes(z)))
          return null;
        if (x.seriesLabels) {
          let ee = e.runtime.seriesLabelsAll.indexOf(z);
          z = e.runtime.seriesKeys[ee], ((Z = x == null ? void 0 : x.forecastingSeriesKeys) == null ? void 0 : Z.length) > 0 && (z = P.text);
        }
        return r.length && (r.includes(z) ? C.push("highlighted") : C.push("inactive")), e.legend.style === "gradient" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
          wc,
          {
            className: C.join(" "),
            tabIndex: 0,
            key: `legend-quantile-${R}`,
            onKeyDown: (ee) => {
              ee.key === "Enter" && (ee.preventDefault(), a(P));
            },
            onClick: (ee) => {
              ee.preventDefault(), a(P);
            },
            role: "button"
          },
          /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(ww, { index: R, label: P, config: e })) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
            Mp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              fill: P.value
            }
          ))),
          /* @__PURE__ */ n.createElement(Tc, { align: "left", className: "m-0" }, P.text)
        );
      }), v.map((P, R) => {
        let C = "legend-item", z = P.legendLabel;
        return z ? (r.length > 0 && r.includes(z) === !1 && (C += " inactive"), /* @__PURE__ */ n.createElement(
          wc,
          {
            className: C,
            tabIndex: 0,
            key: `legend-quantile-${R}`,
            onKeyDown: (W) => {
              W.key === "Enter" && (W.preventDefault(), a(P.legendLabel));
            },
            onClick: (W) => {
              W.preventDefault(), a(P.legendLabel);
            }
          },
          /* @__PURE__ */ n.createElement(
            Mp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              style: { borderRadius: "0px" },
              fill: "transparent",
              borderColor: P.color ? P.color : "rgba(255, 102, 1)"
            }
          ),
          " ",
          /* @__PURE__ */ n.createElement(Tc, { align: "left" }, P.legendLabel ? P.legendLabel : P.value)
        )) : !1;
      })), /* @__PURE__ */ n.createElement(Sw, { config: e, isLegendBottom: S }))),
      r.length > 0 && /* @__PURE__ */ n.createElement(Rc, { onClick: (L) => i(L), style: { marginTop: "1rem" } }, "Show All")
    ) : null;
  }
);
function Aw(e) {
  return Mg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Lw = (e, t, r, a) => (i) => {
  var w, S, A, p, v;
  const { visualizationType: o, visualizationSubType: d, series: c, runtime: s, legend: h } = e, y = (L) => h.verticalSorted ? Je.sortBy(Je.cloneDeep(L), (P) => {
    var C;
    const R = (C = P.datum) == null ? void 0 : C.match(/-?\d+(\.\d+)?/);
    return R ? parseFloat(R[0]) : Number.MAX_SAFE_INTEGER;
  }) : L, g = (L) => e.legend.reverseLabelOrder ? y(L).reverse() : y(L), x = (w = e.legend) == null ? void 0 : w.colorCode;
  if (o === "Deviation Bar") {
    const [L, P] = Pc[e.twoColor.palette], R = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: L
    }, C = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: P
    };
    return g([R, C]);
  }
  if (o === "Bar" && d === "regular" && x && (c == null ? void 0 : c.length) === 1) {
    let L = Sr[e.palette];
    for (; t.length > L.length; )
      L = L.concat(L);
    L = L.slice(0, r.length);
    const P = /* @__PURE__ */ new Set();
    t.forEach((C) => P.add(C[x]));
    const R = Array.from(P).map((C, z) => ({
      datum: C,
      index: z,
      text: C,
      value: L[z]
    }));
    return g(R);
  }
  if (((S = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : S.length) > 0) {
    let L = [];
    return (p = (A = e.runtime) == null ? void 0 : A.forecastingSeriesKeys) == null || p.map((P, R) => {
      var C;
      return (C = P == null ? void 0 : P.stages) == null ? void 0 : C.map((z, W) => {
        var K, le, Y, ae;
        let Z = (K = Yu[z.color]) != null && K[2] ? (le = Yu[z.color]) == null ? void 0 : le[2] : (Y = Sr[z.color]) != null && Y[2] ? (ae = Sr[z.color]) == null ? void 0 : ae[2] : "#ccc";
        const ee = {
          datum: z.key,
          index: W,
          text: z.key,
          value: Z
        };
        L.push(ee);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((P, R) => {
      let C = Sr[e.palette][R] ? Sr[e.palette][R] : "#ccc";
      const z = {
        datum: P,
        index: R,
        text: P,
        value: C
      };
      L.push(z);
    }), g(L);
  }
  if (e.series.some((L) => L.name)) {
    const L = Array.from(new Set(e.series.map((P) => P.name || P.dataKey))).map((P, R) => ({
      datum: P,
      index: R,
      text: P,
      value: a(P)
    }));
    return g(L);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const L = i.length - 1;
    let P = [];
    return (v = e.suppressedData) == null || v.forEach(({ label: R, icon: C }, z) => {
      if (R && C) {
        const W = {
          datum: R,
          index: L + z,
          text: R,
          icon: /* @__PURE__ */ n.createElement(Aw, { color: "#000", size: 15 })
        };
        P.push(W);
      }
    }), [...i, ...P];
  }
  return g(i);
}, Pw = se.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: r,
    colorScale: a,
    seriesHighlight: i,
    highlight: o,
    tableData: d,
    handleShowAll: c,
    transformedData: s,
    currentViewport: h,
    dimensions: y,
    getTextWidth: g
  } = se.useContext(pt);
  if (!r.legend)
    return null;
  const x = Lw(r, d, s, a);
  return /* @__PURE__ */ n.createElement(se.Fragment, null, /* @__PURE__ */ n.createElement(
    Cw,
    {
      getTextWidth: g,
      dimensions: y,
      ref: t,
      skipId: e.skipId || "legend",
      config: r,
      colorScale: a,
      seriesHighlight: i,
      highlight: o,
      handleShowAll: c,
      currentViewport: h,
      formatLabels: x
    }
  ));
}), pf = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    shape: "circle",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right"
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, Rw = ({
  config: e,
  deleteColumn: t,
  updateField: r,
  colKey: a,
  controls: i
}) => {
  var g, x, w, S;
  const [o, d] = i, c = (A, p) => {
    if (A === "dataTable" && p === !0) {
      const v = Je.cloneDeep(e.columns);
      v[a] = { ...v[a], dataTable: p }, r(null, null, "columns", v);
    } else
      r("columns", a, A, p);
  }, s = (A) => {
    const p = Je.cloneDeep(e.columns), L = { ...e.columns[a], name: A, label: A };
    if (L.dataTable === void 0 && (L.dataTable = !0), A !== a) {
      p[A] = L, delete p[a];
      const P = { ...Je.cloneDeep(o), [A]: !0 };
      delete P[a], d(P);
    }
    r(null, null, "columns", p);
  }, h = () => {
    var L;
    const A = e.data.flatMap((P) => Object.keys(P).map((R) => R)), p = Object.values(e.columns).map((P) => P.name), v = Je.uniq(A).filter((P) => !(e.table.groupBy === P || p.includes(P)));
    return (L = e.columns[a]) != null && L.name && v.push(e.columns[a].name), v;
  }, y = (g = e.columns[a]) == null ? void 0 : g.name;
  return /* @__PURE__ */ n.createElement(
    zg,
    {
      fieldName: y,
      fieldKey: a,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(a)
    },
    /* @__PURE__ */ n.createElement(
      mt,
      {
        label: "Column",
        value: (x = e.columns[a]) == null ? void 0 : x.name,
        fieldName: "name",
        section: "columns",
        initial: "-Select-",
        options: h(),
        updateField: (A, p, v, L) => s(L)
      }
    ),
    e.type !== "table" && /* @__PURE__ */ n.createElement(
      mt,
      {
        label: "Associate to Series",
        value: (w = e.columns[a]) == null ? void 0 : w.series,
        fieldName: "series",
        section: "columns",
        initial: "Select series",
        options: ((S = e.series) == null ? void 0 : S.map((A) => A.dataKey)) || [],
        updateField: (A, p, v, L) => c("series", L)
      }
    ),
    /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].label,
        section: "columns",
        subsection: a,
        fieldName: "label",
        label: "Label",
        updateField: r
      }
    ),
    /* @__PURE__ */ n.createElement("ul", { className: "column-edit" }, /* @__PURE__ */ n.createElement("li", { className: "three-col" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].prefix,
        section: "columns",
        subsection: a,
        fieldName: "prefix",
        label: "Prefix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].suffix,
        section: "columns",
        subsection: a,
        fieldName: "suffix",
        label: "Suffix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "number",
        value: e.columns[a].roundToPlace,
        section: "columns",
        subsection: a,
        fieldName: "roundToPlace",
        label: "Round",
        updateField: r
      }
    )), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].commas,
        onChange: (A) => {
          c("commas", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Add Commas to Numbers"))), /* @__PURE__ */ n.createElement("li", null, e.table.showVertical && /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].dataTable ?? !0,
        onChange: (A) => {
          c("dataTable", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Data Table"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].showInViz,
        onChange: (A) => {
          c("showInViz", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Visualization"))), e.type !== "table" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].tooltips || !1,
        onChange: (A) => {
          r("columns", a, "tooltips", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in tooltip"))), e.visualizationType === "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlot || !1,
        onChange: (A) => {
          c("forestPlot", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Forest Plot"))), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlotAlignRight || !1,
        onChange: (A) => {
          c("forestPlotAlignRight", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Align Right"))), !e.columns[a].forestPlotAlignRight && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "text" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Forest Plot Starting Point"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "number",
        value: e.columns[a].forestPlotStartingPoint || 0,
        onChange: (A) => {
          c("forestPlotStartingPoint", A.target.value);
        }
      }
    ))))),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Order"), /* @__PURE__ */ n.createElement(
      "input",
      {
        onWheel: (A) => A.currentTarget.blur(),
        type: "number",
        min: "1",
        value: e.columns[a].order,
        onChange: (A) => r("columns", a, "order", parseInt(A.target.value))
      }
    ))
  );
}, Nw = ({ config: e, updateField: t, deleteColumn: r }) => {
  var d;
  const a = se.useState({}), i = Object.keys(e.columns), o = (c) => {
    const s = `additionalColumn${c}`, h = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [y, g] = a;
    g({ ...y, [s]: !0 }), t("columns", null, s, h);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.type !== "navigation" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Configurations", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can specify additional columns to display in tooltips and / or the supporting data table."))))), i.map((c, s) => /* @__PURE__ */ n.createElement(
    Rw,
    {
      key: c + s,
      controls: a,
      config: e,
      deleteColumn: r,
      updateField: t,
      colKey: c
    }
  )), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary",
      onClick: (c) => {
        c.preventDefault(), o(i.length + 1);
      }
    },
    "Add Configuration"
  )), ((d = e.legend) == null ? void 0 : d.type) === "category" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Additional Category", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can provide additional categories to ensure they appear in the legend"))))), e.legend.additionalCategories && e.legend.additionalCategories.map((c, s) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: c }, /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (h) => {
        h.preventDefault();
        const y = [...e.legend.additionalCategories];
        y.splice(s, 1), t("legend", null, "additionalCategories", y);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: c,
      label: "Category",
      section: "legend",
      subsection: null,
      fieldName: "additionalCategories",
      updateField: (h, y, g, x) => {
        const w = [...e.legend.additionalCategories];
        w[s] = x, t(h, y, g, w);
      }
    }
  ))), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary full-width",
      onClick: (c) => {
        c.preventDefault();
        const s = [...e.legend.additionalCategories || []];
        s.push(""), t("legend", null, "additionalCategories", s);
      }
    },
    "Add Category"
  )));
}, pm = "-Select-", Dw = ({ config: e, updateField: t, isDashboard: r, columns: a }) => {
  var h, y, g, x, w, S, A;
  const i = ((h = e.dataKey) == null ? void 0 : h.includes("http://")) || ((y = e == null ? void 0 : e.dataKey) == null ? void 0 : y.includes("https://")), o = se.useMemo(() => Object.keys(e.columns).map((p) => [p, e.columns[p].dataTable]).filter(([p, v]) => !v).map(([p]) => p), [e.columns]), d = se.useMemo(() => {
    const p = e.data.flatMap(Object.keys);
    return Je.uniq(p).filter((L) => !0);
  }, [e.data]), c = (p) => {
    p === pm && (p = void 0), t("table", null, "groupBy", p);
  }, s = (p, v, L, P) => {
    const R = Je.cloneDeep(e.columns), C = [];
    for (let z in R) {
      const W = R[z];
      C.push(W.name), P.includes(W.name) ? R[z].dataTable = !1 : R[z].dataTable = !0;
    }
    P.forEach((z) => {
      C.includes(z) || (R[z] = { name: z, dataTable: !1 });
    }), t(null, null, "columns", R);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.label,
      updateField: t,
      section: "table",
      fieldName: "label",
      id: "tableLabel",
      label: "Data Table Title",
      placeholder: "Data Table",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Label is required for Data Table for 508 Compliance")))
    }
  ), e.type !== "table" ? /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.show,
      fieldName: "show",
      label: "Show Data Table",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement.")))
    }
  ) : /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: (g = e.general) == null ? void 0 : g.showDownloadButton,
      fieldName: "showDownloadButton",
      label: "Show Download CSV link",
      section: "general",
      updateField: t,
      className: "column-heading"
    }
  ), e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showVertical,
      fieldName: "showVertical",
      label: "Show Vertical Data",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This will draw the data table with vertical data instead of horizontal.")))
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.indexLabel,
      section: "table",
      fieldName: "indexLabel",
      label: "Index Column Header",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.caption,
      updateField: t,
      section: "table",
      type: "textarea",
      fieldName: "caption",
      label: "Screen Reader Description",
      placeholder: " Data table",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter a description of the data table to be read by screen readers.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.limitHeight,
      section: "table",
      fieldName: "limitHeight",
      label: " Limit Table Height",
      updateField: t
    }
  ), e.table.limitHeight && /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.height,
      section: "table",
      fieldName: "height",
      label: "Data Table Height",
      type: "number",
      min: 0,
      max: 500,
      placeholder: "Height(px)",
      updateField: t
    }
  ), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-1" }, "Exclude Columns "), /* @__PURE__ */ n.createElement(
    Wp,
    {
      key: o.join("") + "excluded",
      options: a.map((p) => ({ label: p, value: p })),
      selected: o,
      label: "Exclude Columns",
      fieldName: "dataTable",
      section: "columns",
      updateField: s
    }
  )), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.collapsible,
      fieldName: "collapsible",
      label: " Collapsible",
      section: "table",
      updateField: t
    }
  ), e.table.collapsible !== !1 && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.expanded,
      fieldName: "expanded",
      label: " Expanded by Default",
      section: "table",
      updateField: t
    }
  ), r && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDataTableLink,
      fieldName: "showDataTableLink",
      label: "Show Data Table Name & Link",
      section: "table",
      updateField: t
    }
  ), i && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadUrl,
      fieldName: "showDownloadUrl",
      label: "Show URL to Automatically Updated Data",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadImgButton,
      fieldName: "showDownloadImgButton",
      label: "Display Image Button",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadLinkBelow,
      fieldName: "showDownloadLinkBelow",
      label: "Show Download Link Below Table",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Table Cell Min Width"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
      onChange: (p) => t("table", null, "cellMinWidth", p.target.value)
    }
  )), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: e.table.groupBy,
      fieldName: "groupBy",
      section: "table",
      label: "Group By",
      updateField: (p, v, L, P) => c(P),
      initial: pm,
      options: d.filter(
        (p) => {
          var v, L;
          return p !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && !(((L = e.table.pivot) == null ? void 0 : L.valueColumns) || []).includes(p);
        }
      ),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration.")))
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      label: "Pivot Column",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select a Column whos data values will be pivoted to Column Values."))),
      value: (x = e.table.pivot) == null ? void 0 : x.columnName,
      options: d.filter(
        (p) => {
          var v;
          return p !== e.table.groupBy && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(p);
        }
      ),
      initial: "-Select-",
      section: "table",
      subsection: "pivot",
      fieldName: "columnName",
      updateField: t
    }
  ), ((w = e.table.pivot) == null ? void 0 : w.columnName) && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-1" }, "Pivot Value Column(s)", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "The column(s) whos values will be pivoted under the column selected as the Filter.")))), /* @__PURE__ */ n.createElement(
    Wp,
    {
      key: (S = e.table.pivot) == null ? void 0 : S.columnName,
      options: d.filter((p) => {
        var v;
        return p !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && p !== e.table.groupBy;
      }).map((p) => ({ label: p, value: p })),
      selected: (A = e.table.pivot) == null ? void 0 : A.valueColumns,
      label: "Pivot Value Column(s) ",
      section: "table",
      subsection: "pivot",
      fieldName: "valueColumns",
      updateField: t
    }
  )));
}, Ku = (e) => /* @__PURE__ */ se.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ se.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), _w = ({ name: e }) => {
  var c, s, h, y, g;
  const { config: t, rawData: r, updateConfig: a } = se.useContext(pt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, o = (x = !0) => {
    let w = {};
    return r.forEach((S) => {
      Object.keys(S).forEach((A) => w[A] = !0);
    }), x && Object.keys(w).forEach((S) => {
      (t.series && t.series.filter((A) => A.dataKey === S).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(S)) && delete w[S];
    }), Object.keys(w);
  }, d = (x, w, S, A) => {
    if (x === "boxplot" && w === "legend") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.boxplot[w],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === "boxplot" && w === "labels") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.boxplot[w],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && w) {
      let P = {
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.forestPlot[w],
            [S]: A
          }
        }
      };
      a(P);
      return;
    }
    if (x === "columns" && w !== "" && S !== "") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t[x][w],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === null && w === null) {
      let P = { ...t, [S]: A };
      i(P), a(P);
      return;
    }
    const p = Array.isArray(t[x]);
    let v = p ? [...t[x], A] : { ...t[x], [S]: A };
    w !== null && (p ? (v = [...t[x]], v[w] = { ...v[w], [S]: A }) : typeof A == "string" ? v[w] = A : v = { ...t[x], [w]: { ...t[x][w], [S]: A } });
    let L = { ...t, [x]: v };
    i(L), a(L);
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: d,
      options: o(!1),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Column Settings"), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: x.target.value
            }
          }
        }), x.target.value = "";
      }
    }
  ))), /* @__PURE__ */ n.createElement(Qe, { value: ((h = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : h.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Width Settings"), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement(We, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: x.target.value
            }
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, Ki = n.createContext({}), Ow = (e) => {
  const { updateConfig: t, config: r, rawData: a } = se.useContext(pt), { getColumns: i, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (s, h, y) => {
    let g = [...r.series];
    if (g[s][y] = h, y === "type" && h === "Bar" && (g[s].axis = "Left"), g[s].type === "Forecasting") {
      let x = Array.from(new Set(a.map((S) => S[g[s].dataKey]))), w = [];
      x.forEach((S) => {
        w.push({ key: S });
      }), g[s].stages = w, g[s].stageColumn = g[s].dataKey;
    }
    t({ ...r, series: g });
  };
  return /* @__PURE__ */ n.createElement(Ki.Provider, { value: { updateSeries: c, supportedRightAxisTypes: d, getColumns: i, selectComponent: o } }, e.children);
}, Fw = (e) => {
  const { config: t, updateConfig: r } = se.useContext(pt), { series: a, index: i } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((y) => y.includes(a.type)) && (s = !0), s;
  })())
    return;
  const d = (s, h) => {
    let y = [...t.series];
    y[s].lineType = h, r({ ...t, series: y });
  };
  let c = [];
  return Object.keys(ol).map((s) => c.push(ol[s])), /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(i, s.target.value);
      },
      options: c
    }
  );
}, Mw = (e) => {
  const { config: t } = se.useContext(pt), { updateSeries: r } = se.useContext(Ki), { index: a, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ n.createElement(
      Ka,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (d) => {
          r(a, d.target.value, "type");
        },
        options: o()
      }
    );
}, zw = (e) => {
  const { config: t, updateConfig: r, rawData: a } = se.useContext(pt), { updateSeries: i, getColumns: o } = se.useContext(Ki), { index: d, series: c } = e;
  return /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let h = [], y = new Set(a == null ? void 0 : a.map((x) => x[s.target.value]));
        y = Array.from(y), y = y.filter((x) => x !== void 0), y.forEach((x) => h.push({ key: x }));
        const g = [...t.series];
        g[d] = { ...g[d], stages: h, stageColumn: s.target.value }, r({
          ...t,
          series: g
        });
      },
      options: o(!1)
    }
  );
}, Bw = (e) => {
  const { config: t, rawData: r } = se.useContext(pt), { updateSeries: a } = se.useContext(Ki), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !r || !o.stageColumn)
    return;
  let d = new Set(r.map((c) => c[o.stageColumn]));
  return d = Array.from(d), d = d.filter((c) => c !== void 0), /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        a(i, c.target.value, "stageItem");
      },
      options: d
    }
  );
}, Iw = (e) => {
  const { config: t } = se.useContext(pt), { updateSeries: r, supportedRightAxisTypes: a } = se.useContext(Ki), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && a.includes(o.type))
    return /* @__PURE__ */ n.createElement(
      Ka,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          r(i, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, $w = (e) => {
  var o;
  const { config: t, updateConfig: r } = se.useContext(pt), { index: a, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((d, c) => {
      var s, h, y, g;
      return /* @__PURE__ */ n.createElement(
        Ka,
        {
          key: `${d}--${c}`,
          initial: "Select an option",
          value: (h = (s = t.series) == null ? void 0 : s[a].stages) != null && h[c].color ? (g = (y = t.series) == null ? void 0 : y[a].stages) == null ? void 0 : g[c].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (x) => {
            const w = [...t.series], S = w[a].stages;
            S[c].color = x.target.value, w[a] = { ...w[a], stages: S }, r({
              ...t,
              series: w
            });
          },
          options: Object.keys(Yu)
        }
      );
    });
}, Hw = (e) => {
  var d;
  const { config: t, updateConfig: r } = se.useContext(pt), { series: a, index: i } = e, { getColumns: o } = se.useContext(Ki);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (d = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : d.map((c, s) => {
      const h = c.showInTooltip ? c.showInTooltip : !1, y = (g, x, w) => {
        g.preventDefault();
        let S = [...t.series];
        S[x].confidenceIntervals[w].showInTooltip = !h, r({
          ...t,
          series: S
        });
      };
      return /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (g) => {
            g.preventDefault();
            const x = [...t.series[i].confidenceIntervals];
            x.splice(s, 1);
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: [...x] }, r({
              ...t,
              series: w
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ n.createElement(
        "div",
        {
          className: "cove-input__checkbox--small",
          onClick: (g) => y(g, i, s)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            className: "cove-input__checkbox-box custom-color",
            style: { backgroundColor: "" }
          },
          h && /* @__PURE__ */ n.createElement(Mm, { className: "", style: { fill: "#025eaa" } })
        ),
        /* @__PURE__ */ n.createElement(
          "input",
          {
            className: "cove-input--hidden",
            type: "checkbox",
            name: "showInTooltip",
            checked: h || !1,
            readOnly: !0
          }
        )
      )), /* @__PURE__ */ n.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].low ? t.series[i].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (g) => {
            const x = [...t.series[i].confidenceIntervals];
            x[s].low = g.target.value;
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: x }, r({
              ...t,
              series: w
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ n.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].high ? t.series[i].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (g) => {
            const x = [...t.series[i].confidenceIntervals];
            x[s].high = g.target.value;
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: x }, r({
              ...t,
              series: w
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (c) => {
          c.preventDefault();
          let s = null;
          t.series[i].confidenceIntervals ? s = [...t.series[i].confidenceIntervals] : s = [];
          const h = [...t.series];
          h[i] = {
            ...h[i],
            confidenceIntervals: [...s, { high: "", low: "" }]
          }, r({
            ...t,
            series: h
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Vw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(pt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s, h, y) => {
    let g = [...a.series], x = { ...a.runtime.seriesLabels };
    g[c].weight = s && Math.max(Number(h), Math.min(Number(y), Number(s))), x[g[c].dataKey] = g[c].weight ? g[c].weight : g[c].dataKey;
    const w = {
      ...a,
      series: g,
      runtime: {
        ...a.runtime,
        seriesLabels: x
      }
    };
    i(w);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${r}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (c) => {
        d(r, c.target.value, c.target.min, c.target.max);
      }
    }
  ));
}, Ww = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(pt);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const d = (c, s) => {
    let h = [...a.series], y = { ...a.runtime.seriesLabels };
    h[c].name = s, y[h[c].dataKey] = h[c].name ? h[c].name : h[c].dataKey;
    let g = {
      ...a,
      series: h,
      runtime: {
        ...a.runtime,
        seriesLabels: y
      }
    };
    i(g);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${r}`,
      value: t.name ? t.name : "",
      onChange: (c) => {
        d(r, c.target.value);
      }
    }
  ));
}, jw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(pt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const o = (d) => {
    let c = [...a.series];
    c[d].tooltip && c[d].tooltip, c[d].tooltip = !c[d].tooltip, i({
      ...a,
      series: c
    });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: `series-tooltip--${r}` }, "Show In Tooltip"), /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox--small", onClick: (d) => o(r) }, /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ n.createElement(Mm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ n.createElement(
    "input",
    {
      className: "cove-input--hidden",
      type: "checkbox",
      name: `series-tooltip--${r}`,
      checked: t.tooltip ? t.tooltip : !1,
      readOnly: !0
    }
  ))));
}, Uw = (e) => {
  const { config: t, updateConfig: r } = se.useContext(pt), { series: a, index: i } = e, o = (c) => {
    let s = [...t.series], h = -1;
    for (let y = 0; y < s.length; y++)
      if (s[y].dataKey === c) {
        h = y;
        break;
      }
    if (h !== -1) {
      s.splice(h, 1);
      let y = { ...t, series: s };
      s.length === 0 && delete y.series, r(y);
    }
    t.visualizationType === "Paired Bar" && r({
      ...t,
      series: []
    });
  }, d = (c, s, h) => {
    c.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: (c) => d(c, a) }, "Remove");
}, vg = (e) => {
  const { config: t } = se.useContext(pt), { updateSeries: r, getColumns: a } = se.useContext(Ki), { series: i, getItemStyle: o, sortableItemStyles: d, chartsWithOptions: c, index: s } = e, h = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((y) => y.dynamicCategory && y.dataKey !== i.dataKey);
  return /* @__PURE__ */ n.createElement(Bg, { key: i.dataKey, draggableId: `draggableFilter-${i.dataKey}`, index: s }, (y, g) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: s,
      className: g.isDragging ? "currently-dragging" : "",
      style: o(g.isDragging, y.draggableProps.style, d),
      ref: y.innerRef,
      ...y.draggableProps,
      ...y.dragHandleProps
    },
    /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart" }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(
      Bn,
      {
        className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow"
      },
      /* @__PURE__ */ n.createElement(Ge, { display: "move", size: 15, style: { cursor: "default" } }),
      i.dataKey,
      /* @__PURE__ */ n.createElement(Jr.Button.Remove, { series: i, index: s })
    )), c.includes(t.visualizationType) && /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Jr.Input.Name, { series: i, index: s }), h && /* @__PURE__ */ n.createElement(
      mt,
      {
        label: "Dynamic Category",
        value: i.dynamicCategory,
        options: ["- Select - ", ...a().filter((x) => i.dataKey !== x)],
        updateField: (x, w, S, A) => {
          A === "- Select -" && (A = ""), r(s, A, "dynamicCategory");
        },
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization.")))
      }
    ), /* @__PURE__ */ n.createElement(Jr.Input.Weight, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.SeriesType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.AxisPosition, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.LineType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.ForecastingColor, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.ConfidenceInterval, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Checkbox.DisplayInTooltip, { series: i, index: s }))))
  ));
}, Kw = (e) => {
  const { series: t, getItemStyle: r, sortableItemStyles: a, chartsWithOptions: i } = e;
  return t.map((o, d) => /* @__PURE__ */ n.createElement(
    vg,
    {
      getItemStyle: r,
      sortableItemStyles: a,
      chartsWithOptions: i,
      series: o,
      index: d,
      key: `series-list-${d}`
    }
  ));
}, Jr = {
  Wrapper: Ow,
  Dropdown: {
    SeriesType: Mw,
    AxisPosition: Iw,
    ConfidenceInterval: Hw,
    LineType: Fw,
    ForecastingStage: zw,
    ForecastingColumn: Bw,
    ForecastingColor: $w
  },
  Input: {
    Name: Ww,
    Weight: Vw
  },
  Checkbox: {
    DisplayInTooltip: jw
  },
  Button: {
    Remove: Uw
  },
  Item: vg,
  List: Kw
}, Yw = se.memo(({ config: e, updateConfig: t }) => {
  let r = (s, h, y) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[y][s] = h, t({ ...e, regions: g });
  }, a = (s, h, y, g, x) => r(y, g, x), i = (s) => {
    let h = [];
    e.regions && (h = [...e.regions]), h.splice(s, 1), t({ ...e, regions: h });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.regions && e.regions.map(({ label: s, color: h, from: y, to: g, background: x, range: w = "Custom" }, S) => {
    var A;
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `region-${S}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        type: "button",
        className: "btn btn-danger remove-column",
        onClick: (p) => {
          p.preventDefault(), i(S);
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(We, { value: s, label: "Region Label", fieldName: "label", i: S, updateField: a }), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: h,
        label: "Text Color",
        fieldName: "color",
        updateField: (p, v, L, P) => r(L, P, S)
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: x,
        label: "Background",
        fieldName: "background",
        updateField: (p, v, L, P) => r(L, P, S)
      }
    )), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.regions[S].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (p) => {
          if (p.target.value !== "" && p.target.value !== "Select") {
            const v = [...e.regions];
            v[S].fromType = p.target.value, t({
              ...e,
              regions: v
            });
          }
          p.target.value = "";
        },
        options: d
      }
    ), (e.regions[S].fromType === "Fixed" || e.regions[S].fromType === "Previous Days" || !e.regions[S].fromType) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: y,
        label: e.regions[S].fromType === "Fixed" || !((A = e.regions[S]) != null && A.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (p, v, L, P) => r(L, P, S),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.regions[S].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (p) => {
          if (p.target.value !== "" && p.target.value !== "Select") {
            const v = [...e.regions];
            v[S].toType = p.target.value, t({
              ...e,
              regions: v
            });
          }
          p.target.value = "";
        },
        options: c
      }
    ), (e.regions[S].toType === "Fixed" || !e.regions[S].toType) && /* @__PURE__ */ n.createElement(
      We,
      {
        value: g,
        label: "To Value",
        fieldName: "to",
        updateField: (p, v, L, P) => r(L, P, S)
      }
    ));
  }), !e.regions && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), Gw = ({ name: e }) => {
  const { visSupportsRegions: t } = _s(), { config: r, updateConfig: a } = se.useContext(pt);
  return t() ? /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Yw, { config: r, updateConfig: a }))) : null;
}, wp = se.createContext(null), Tp = () => {
  const e = se.useContext(wp);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Xw = (e) => {
  const { config: t } = se.useContext(pt), { updateField: r } = Tp(), {
    enabledChartTypes: a,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: d,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: s,
    visSupportsSuperTitle: h,
    visSupportsFootnotes: y
  } = _s(), { visualizationType: g, visualizationSubType: x, barStyle: w } = t, S = () => (g === "Bar" || g === "Deviation Bar") && x !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ n.createElement(Mn, null, " ", /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "General")), /* @__PURE__ */ n.createElement(In, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: g,
      fieldName: "visualizationType",
      label: "Chart Type",
      updateField: r,
      options: a
    }
  ), c() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement("div", { className: s() ? "two-col-inputs" : "" }, /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, "", /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), s() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.heights.mobileVertical,
      section: "heights",
      fieldName: "mobileVertical",
      label: "Mobile Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height.")))
    }
  )), (g === "Bar" || g === "Combo" || g === "Area Chart") && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: x || "Regular",
      fieldName: "visualizationSubType",
      label: "Chart Subtype",
      updateField: r,
      options: ["regular", "stacked"]
    }
  ), g === "Area Chart" && x === "stacked" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.stackedAreaChartLineType || "Linear",
      fieldName: "stackedAreaChartLineType",
      label: "Stacked Area Chart Line Type",
      updateField: r,
      options: Object.keys(ol)
    }
  ), g === "Bar" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.orientation || "vertical",
      fieldName: "orientation",
      label: "Orientation",
      updateField: r,
      options: ["vertical", "horizontal"]
    }
  ), g === "Deviation Bar" && /* @__PURE__ */ n.createElement(mt, { label: "Orientation", options: ["horizontal"] }), (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.isLollipopChart ? "lollipop" : w || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: r,
      options: S(),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.tipRounding || "top",
      fieldName: "tipRounding",
      label: "tip rounding",
      updateField: r,
      options: ["top", "full"]
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.roundingStyle || "standard",
      fieldName: "roundingStyle",
      label: "rounding style",
      updateField: r,
      options: ["standard", "shallow", "finger"]
    }
  ), g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.yAxis.labelPlacement || "Below Bar",
      section: "yAxis",
      fieldName: "labelPlacement",
      label: "Label Placement",
      updateField: r,
      options: ["Below Bar", "On Date/Category Axis"]
    }
  ), i() ? /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.yAxis.displayNumbersOnBar,
      section: "yAxis",
      fieldName: "displayNumbersOnBar",
      label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
      updateField: r
    }
  ) : d() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Recommended set to display for Section 508 compliance."), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("p", null, "Selecting this option will ", /* @__PURE__ */ n.createElement("i", null, " not "), ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), o() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueData,
      section: "general",
      fieldName: "showZeroValueData",
      label: 'Display "Zero Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)."), t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart."))),
      value: t.general.hideNullValue,
      section: "general",
      fieldName: "hideNullValue",
      label: 'Remove "Null" Values From Hover',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will show the ", /* @__PURE__ */ n.createElement("i", null, "suppression indicator "), " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."), t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)."))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: r
    }
  )), g === "Pie" && /* @__PURE__ */ n.createElement(mt, { fieldName: "pieType", label: "Pie Chart Type", updateField: r, options: ["Regular", "Donut"] }), g === "Line" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ n.createElement(Qe, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: r }), h() && /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.superTitle,
      updateField: r,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.introText,
      updateField: r,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), y() && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: r,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, qw = (e) => {
  const { config: t } = se.useContext(pt), { boxplot: r } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = Tp();
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.name)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.iqr,
      fieldName: "iqr",
      section: "boxplot",
      subsection: "labels",
      label: "Interquartile Range",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.count,
      fieldName: "count",
      section: "boxplot",
      subsection: "labels",
      label: "Count",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.mean,
      fieldName: "mean",
      section: "boxplot",
      subsection: "labels",
      label: "Mean",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.outliers,
      fieldName: "outliers",
      section: "boxplot",
      subsection: "labels",
      label: "Outliers",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.values,
      fieldName: "values",
      section: "boxplot",
      subsection: "labels",
      label: "Values",
      updateField: a
    }
  )));
}, Zw = (e, t) => {
  let r = [], a = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const d = e.twoColor.isPaletteReversed;
    r = Object.keys(Pc).filter(
      (c) => d ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const d = [], c = [];
    for (const s in Sr) {
      const h = s.startsWith("sequential"), y = s.startsWith("qualitative"), g = s.startsWith("colorblindsafe"), x = s.endsWith("reverse");
      h && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && d.push(s), y && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && c.push(s), g && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && o.push(s);
    }
    a = d, i = c;
  }
  return se.useEffect(() => {
    let d = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: d } });
  }, [e.twoColor.isPaletteReversed]), se.useEffect(() => {
    let d = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (d = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (d = e.palette.slice(0, -7)), t({ ...e, palette: d });
  }, [e.isPaletteReversed]), { twoColorPalettes: r, sequential: a, nonSequential: i, accessibleColors: o };
}, Qw = (e) => {
  var ee;
  const { config: t, updateConfig: r, colorPalettes: a, twoColorPalette: i } = se.useContext(pt), { visual: o } = t, { setLollipopShape: d, updateField: c } = Tp(), {
    visHasBarBorders: s,
    visCanAnimate: h,
    visSupportsNonSequentialPallete: y,
    headerColors: g,
    visSupportsTooltipOpacity: x,
    visSupportsTooltipLines: w,
    visSupportsBarSpace: S,
    visSupportsBarThickness: A,
    visHasDataCutoff: p,
    visSupportsSequentialPallete: v,
    visSupportsReverseColorPalette: L,
    visHasSingleSeriesTooltip: P
  } = _s(), { twoColorPalettes: R, sequential: C, nonSequential: z, accessibleColors: W } = Zw(t, r), Z = (K, le) => {
    if (console.log("value", le), K === "storyNodeFontColor") {
      r({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: le
        }
      });
      return;
    } else
      r({
        ...t,
        sankey: {
          ...t.sankey,
          [K]: {
            ...t.sankey[K],
            default: le
          }
        }
      });
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Visual")), /* @__PURE__ */ n.createElement(In, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", { className: "header" }, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ n.createElement(
    "div",
    {
      onChange: (K) => {
        d(K.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
      fieldName: "lollipopColorStyle",
      label: "Lollipop Color Style",
      updateField: c,
      options: ["regular", "two-tone"]
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.lollipopSize ? t.lollipopSize : "small",
      fieldName: "lollipopSize",
      label: "Lollipop Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  )), t.visualizationType === "Box Plot" && /* @__PURE__ */ n.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ n.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.boxplot.borders,
      fieldName: "borders",
      section: "boxplot",
      label: "Box Plot Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.boxplot.plotOutlierValues,
      fieldName: "plotOutlierValues",
      section: "boxplot",
      label: "Plot Outliers",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.boxplot.plotNonOutlierValues,
      fieldName: "plotNonOutlierValues",
      section: "boxplot",
      label: "Plot non-outlier values",
      updateField: c
    }
  )), s() && /* @__PURE__ */ n.createElement(
    mt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Recommended set to display for Section 508 compliance."))),
      value: t.barHasBorder,
      fieldName: "barHasBorder",
      label: "Bar Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), h() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.animate,
      fieldName: "animate",
      label: "Animate Visualization",
      updateField: c
    }
  ), (((ee = t.series) == null ? void 0 : ee.some(
    (K) => K.type === "Line" || K.type === "dashed-lg" || K.type === "dashed-sm" || K.type === "dashed-md"
  )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    mt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points."))),
      value: t.visual.lineDatapointSymbol,
      section: "visual",
      fieldName: "lineDatapointSymbol",
      label: "Line Datapoint Symbols",
      updateField: c,
      options: ["none", "standard"]
    }
  ), t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ n.createElement("small", { className: "text-danger" }, "Standard only supports up to 7 data points"), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.lineDatapointStyle,
      fieldName: "lineDatapointStyle",
      label: "Line Datapoint Style",
      updateField: c,
      options: ["hidden", "hover", "always show"]
    }
  ), /* @__PURE__ */ n.createElement(
    mt,
    {
      value: t.lineDatapointColor,
      fieldName: "lineDatapointColor",
      label: "Line Datapoint Color",
      updateField: c,
      options: ["Same as Line", "Lighter than Line"]
    }
  )), /* @__PURE__ */ n.createElement("label", { className: "header" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, g.map((K) => /* @__PURE__ */ n.createElement(
    "button",
    {
      title: K,
      key: K,
      onClick: (le) => {
        le.preventDefault(), r({ ...t, theme: K });
      },
      className: t.theme === K ? "selected " + K : K
    }
  )))), (y() || y()) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Chart Color Palette")), L() && /* @__PURE__ */ n.createElement(
    Fp,
    {
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.isPaletteReversed
    }
  ), v() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, C.map((K) => {
    const le = {
      backgroundColor: a[K][2]
    }, Y = {
      backgroundColor: a[K][3]
    }, ae = {
      backgroundColor: a[K][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: K,
        key: K,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: K });
        },
        className: t.palette === K ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: le }),
      /* @__PURE__ */ n.createElement("span", { style: Y }),
      /* @__PURE__ */ n.createElement("span", { style: ae })
    );
  }))), y() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, z.map((K) => {
    const le = {
      backgroundColor: a[K][2]
    }, Y = {
      backgroundColor: a[K][4]
    }, ae = {
      backgroundColor: a[K][6]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: K,
        key: K,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: K });
        },
        className: t.palette === K ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: le }),
      /* @__PURE__ */ n.createElement("span", { style: Y }),
      /* @__PURE__ */ n.createElement("span", { style: ae })
    );
  })), /* @__PURE__ */ n.createElement("span", null, "Colorblind Safe"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, W.map((K) => {
    const le = {
      backgroundColor: a[K][2]
    }, Y = {
      backgroundColor: a[K][3]
    }, ae = {
      backgroundColor: a[K][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: K,
        key: K,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: K });
        },
        className: t.palette === K ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: le }),
      /* @__PURE__ */ n.createElement("span", { style: Y }),
      /* @__PURE__ */ n.createElement("span", { style: ae })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.nodeColor.default,
      id: "storyNodeColor",
      name: "storyNodeColor",
      onChange: (K) => Z("nodeColor", K.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.storyNodeFontColor || "red",
      id: "storyNodeFontColor",
      name: "storyNodeFontColor",
      onChange: (K) => Z("storyNodeFontColor", K.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.linkColor.default,
      id: "linkColor",
      name: "linkColor",
      onChange: (K) => Z("linkColor", K.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Fp,
    {
      section: "twoColor",
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.twoColor.isPaletteReversed
    }
  ), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, R.map((K) => {
    const le = {
      backgroundColor: i[K][0]
    }, Y = {
      backgroundColor: i[K][1]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: K,
        key: K,
        onClick: (ae) => {
          ae.preventDefault(), r({ ...t, twoColor: { ...t.twoColor, palette: K } });
        },
        className: t.twoColor.palette === K ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: le }),
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: Y })
    );
  }))), p() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: c,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), A() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.barHeight || "25",
      fieldName: "barHeight",
      label: " Bar Thickness",
      updateField: c,
      min: 15
    }
  ), (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.barThickness,
      type: "number",
      fieldName: "barThickness",
      label: "Bar Thickness",
      updateField: c
    }
  ), S() && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.barSpace || "15",
      fieldName: "barSpace",
      label: "Bar Space",
      updateField: c,
      min: 0
    }
  ), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.topAxis.hasLine,
      section: "topAxis",
      fieldName: "hasLine",
      label: "Add Top Axis Line",
      updateField: c
    }
  ), t.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.border,
      section: "visual",
      fieldName: "border",
      label: "Show Border",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.borderColorTheme,
      section: "visual",
      fieldName: "borderColorTheme",
      label: "Use Border Color Theme",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.accent,
      section: "visual",
      fieldName: "accent",
      label: "Use Accent Style",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.background,
      section: "visual",
      fieldName: "background",
      label: "Use Theme Background Color",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.hideBackgroundColor,
      section: "visual",
      fieldName: "hideBackgroundColor",
      label: "Hide Background Color",
      updateField: c
    }
  )), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.showLineSeriesLabels,
      fieldName: "showLineSeriesLabels",
      label: "Append Series Name to End of Line Charts",
      updateField: c
    }
  ), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.colorMatchLineSeriesLabels,
      fieldName: "colorMatchLineSeriesLabels",
      label: "Match Series Color to Name at End of Line Charts",
      updateField: c
    }
  ), w() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o.verticalHoverLine,
      fieldName: "verticalHoverLine",
      section: "visual",
      label: "Vertical Hover Line",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o.horizontalHoverLine,
      fieldName: "horizontalHoverLine",
      section: "visual",
      label: "Horizontal Hover Line",
      updateField: c
    }
  )), x() && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (K) => r({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: K.target.value
        }
      })
    }
  )), P() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.tooltips.singleSeries,
      fieldName: "singleSeries",
      section: "tooltips",
      label: "SHOW HOVER FOR SINGLE DATA SERIES",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (K) => r({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: K.target.value
        }
      })
    }
  ))));
}, Jw = (e) => {
  var s, h, y, g, x;
  const { config: t, updateConfig: r } = se.useContext(pt), a = (s = t.data) == null ? void 0 : s[0], { updateField: i } = se.useContext(wp);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (w, S, A) => {
    let p = [];
    a != null && a.storyNodeText && (p = [...a == null ? void 0 : a.storyNodeText]), p[A][w] = S, r({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: p
        }
      }
    });
  }, d = () => {
    const w = a;
    w.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), r({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...w }]
      }
    });
  }, c = (w) => {
    const S = a;
    S.storyNodeText.splice(w, 1), r({ ...t, sankey: { ...t.sankey, data: { ...S } } });
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Sankey Settings")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (a == null ? void 0 : a.storyNodeText) && (a == null ? void 0 : a.storyNodeText.map(({ StoryNode: w, segmentTextBefore: S, segmentTextAfter: A }, p) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: p,
      style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" }
    },
    /* @__PURE__ */ n.createElement("label", null, "Story Node Text", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: w,
        fieldName: "StoryNode",
        label: "StoryNode",
        onChange: (v) => o("StoryNode", v.target.value, p)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text Before", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: S,
        fieldName: "segmentTextBefore",
        label: "Segment Text Before",
        onChange: (v) => o("segmentTextBefore", v.target.value, p)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text After", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: A,
        fieldName: "segmentTextAfter",
        label: "Segment Text After",
        onChange: (v) => o("segmentTextAfter", v.target.value, p)
      }
    )),
    /* @__PURE__ */ n.createElement(Rc, { onClick: (v) => c(p), className: "btn btn-danger full-width" }, "Remove Story Node")
  ))), ((h = a == null ? void 0 : a.storyNodeText) == null ? void 0 : h.length) < 3 && /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (w) => {
        w.preventDefault(), d();
      }
    },
    "Add StoryNode"
  ), ((x = (g = (y = t.data) == null ? void 0 : y[0]) == null ? void 0 : g.tooltips) == null ? void 0 : x.length) > 0 && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.enableTooltips,
      fieldName: "enableTooltips",
      label: "Enable Tooltips",
      updateField: i
    }
  )));
};
const eT = (e) => {
  var c, s, h;
  const { updateConfig: t, config: r, svgRef: a } = se.useContext(pt), i = (y, g, x) => {
    var p;
    const w = (p = document.querySelector(".chart-container  > svg")) == null ? void 0 : p.getBoundingClientRect(), S = [w == null ? void 0 : w.width, w == null ? void 0 : w.height], A = [...r == null ? void 0 : r.annotations];
    A[x][g] = y, A[x].savedDimensions = S, t({
      ...r,
      annotations: A
    });
  }, o = () => {
    var w, S, A, p, v, L, P, R, C, z;
    const y = [
      ((A = (S = (w = a == null ? void 0 : a.current) == null ? void 0 : w.width) == null ? void 0 : S.baseVal) == null ? void 0 : A.value) || ((p = a == null ? void 0 : a.current) == null ? void 0 : p.width),
      ((P = (L = (v = a == null ? void 0 : a.current) == null ? void 0 : v.height) == null ? void 0 : L.baseVal) == null ? void 0 : P.value) || ((R = a == null ? void 0 : a.current) == null ? void 0 : R.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((y == null ? void 0 : y[1]) / 2),
      xKey: r.xAxis.type === "date" ? new Date((z = (C = r == null ? void 0 : r.data) == null ? void 0 : C[0]) == null ? void 0 : z[r.xAxis.dataKey]).getTime() : r.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: y,
      connectionType: "line"
    }, x = Array.isArray(r.annotations) ? r.annotations : [];
    t({
      ...r,
      annotations: [...x, g]
    });
  }, d = (y) => {
    const g = r.annotations.filter((x, w) => w !== y);
    t({
      ...r,
      annotations: g
    });
  };
  return /* @__PURE__ */ n.createElement(Tu, { key: e.name }, /* @__PURE__ */ n.createElement(Tu.Section, { title: e.name, key: e.name }, /* @__PURE__ */ n.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((c = r == null ? void 0 : r.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
      onChange: (y) => {
        t({
          ...r,
          general: {
            ...r.general,
            showAnnotationDropdown: y.target.checked
          }
        });
      }
    }
  )), r.general.showAnnotationDropdown && /* @__PURE__ */ n.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (s = r == null ? void 0 : r.general) == null ? void 0 : s.annotationDropdownText,
      onChange: (y) => {
        t({
          ...r,
          general: {
            ...r.general,
            annotationDropdownText: y.target.value
          }
        });
      }
    }
  )), (r == null ? void 0 : r.annotations) && (r == null ? void 0 : r.annotations.map((y, g) => {
    var x, w, S, A, p, v, L, P;
    return /* @__PURE__ */ n.createElement(Tu, { key: g }, /* @__PURE__ */ n.createElement(
      Tu.Section,
      {
        title: y.text ? y.text.substring(0, 15) + "..." : `Annotation ${g + 1}`
      },
      /* @__PURE__ */ n.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ n.createElement("label", null, "Annotation Text:", /* @__PURE__ */ n.createElement(
        "textarea",
        {
          rows: 5,
          value: y.text,
          onChange: (R) => i(R.target.value, "text", g)
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Opacity", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].opacity = R.target.value, t({
              ...r,
              annotations: C
            });
          },
          value: ((w = (x = r == null ? void 0 : r.annotations) == null ? void 0 : x[g]) == null ? void 0 : w.opacity) || "100"
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Subject", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((A = (S = r == null ? void 0 : r.annotations[g]) == null ? void 0 : S.edit) == null ? void 0 : A.subject) || !1,
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].edit.subject = R.target.checked, t({
              ...r,
              annotations: C
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Label", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((v = (p = r == null ? void 0 : r.annotations[g]) == null ? void 0 : p.edit) == null ? void 0 : v.label) || !1,
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].edit.label = R.target.checked, t({
              ...r,
              annotations: C
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Connection Type:", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-connection-type",
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].connectionType = R.target.value, t({
              ...r,
              annotations: C
            });
          },
          value: (L = r == null ? void 0 : r.annotations[g]) == null ? void 0 : L.connectionType
        },
        /* @__PURE__ */ n.createElement("option", { key: "select", value: "select" }, "Select"),
        ["curve", "line", "elbow", "none"].map((R, C) => /* @__PURE__ */ n.createElement("option", { key: R, value: R }, R))
      )), y.connectionType === "curve" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, "Curve Control", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          min: "-20",
          max: "20",
          value: ((P = r == null ? void 0 : r.annotations[g]) == null ? void 0 : P.bezier) || 0,
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].bezier = R.target.value, t({
              ...r,
              annotations: C
            });
          }
        }
      ))), /* @__PURE__ */ n.createElement("label", null, "Marker", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-marker",
          value: y.marker,
          onChange: (R) => {
            const C = Je.cloneDeep(r == null ? void 0 : r.annotations);
            C[g].marker = R.target.value, t({
              ...r,
              annotations: C
            });
          }
        },
        ["arrow", "circle"].map((R, C) => /* @__PURE__ */ n.createElement("option", { key: `col-${C}` }, R))
      )), /* @__PURE__ */ n.createElement(Rc, { className: "btn btn-danger full-width", onClick: () => d(g) }, "Delete Annotation"))
    ));
  })), ((h = r == null ? void 0 : r.annotations) == null ? void 0 : h.length) < 3 && /* @__PURE__ */ n.createElement("button", { onClick: o, className: "btn btn-primary mt-2 full-width" }, "Add Annotation")));
}, ga = {
  ForestPlot: _w,
  Series: Jr,
  Regions: Gw,
  General: Xw,
  BoxPlot: qw,
  Visual: Qw,
  Sankey: Jw,
  Annotate: eT
};
const hm = [
  ["*", "Asterisk"],
  ["", "Dagger"],
  ["", "Section Symbol"],
  ["", "Paragraph Symbol"]
], tT = hm.concat(hm.map(([e, t]) => [e + e, "Double " + t])), mm = Je.fromPairs(Je.map(tT, ([e, t]) => [t, e])), nT = new Fm(), ym = (e, t) => {
  for (let r = 0; r < e.length; r++) {
    let a = Object.keys(e[r]), i = !0;
    for (let o = 0; o < a.length; o++)
      if (e[r][a[o]] !== t[a[o]]) {
        i = !1;
        break;
      }
    if (i)
      return r;
  }
  return -1;
}, rT = (e, t, r) => {
  var i;
  const a = Je.cloneDeep(e);
  if (a.rankByValue = t, e.rankByValue && !t) {
    const o = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? nT.cleanData(e.data, e.xAxis.dataKey) : e.data, d = r.sort((c, s) => {
      const h = ym(o, c), y = ym(o, s);
      return h - y;
    });
    return [a, d];
  }
  return [a];
}, aT = ({ config: e, updateConfig: t, data: r }) => {
  var p, v, L;
  const a = e.visualizationType === "Combo", i = ((p = e.runtime.lineSeriesKeys) == null ? void 0 : p.length) > 0, o = ((v = e.runtime.barSeriesKeys) == null ? void 0 : v.length) > 0, d = a && i, c = a && o, s = () => Je.uniq(Je.flatMap(r, Je.keys)), h = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], y = {
    "Dashed Small": "- - -",
    "Dashed Medium": " ",
    "Dashed Large": " ",
    "Open Circles": "",
    "Filled Circles": ""
  }, g = (P) => {
    const R = Object.keys(y);
    return P === "suppression" ? R.slice(0, -2) : R;
  }, x = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(mm);
  };
  let w = (P) => {
    let R = [];
    e.preliminaryData && (R = [...e.preliminaryData]), R.splice(P, 1), t({ ...e, preliminaryData: R });
  }, S = () => {
    const P = e.visualizationType === "Line" ? "effect" : "suppression";
    let R = e.preliminaryData ? [...e.preliminaryData] : [];
    const C = {
      type: P,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    R.push(C), t({ ...e, preliminaryData: R });
  }, A = (P, R, C) => {
    let z = [];
    e.preliminaryData && (z = [...e.preliminaryData]), z[C][P] = R, P === "symbol" && (z[C].iconCode = mm[R]), P === "style" && (z[C].lineCode = y[R]), t({ ...e, preliminaryData: z });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.preliminaryData && ((L = e.preliminaryData) == null ? void 0 : L.map(
    ({
      displayGray: P,
      circleSize: R,
      column: C,
      displayLegend: z,
      displayTable: W,
      displayTooltip: Z,
      label: ee,
      seriesKey: K,
      style: le,
      symbol: Y,
      type: ae,
      value: B,
      hideBarSymbol: X,
      hideLineStyle: ce
    }, ne) => {
      var Q, V;
      return /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${ne}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, " ", ae === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ n.createElement(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (j) => {
            j.preventDefault(), w(ne);
          }
        },
        "Remove"
      ), /* @__PURE__ */ n.createElement(
        mt,
        {
          value: ae,
          initial: e.visualizationType == "Bar" ? "" : "Select",
          fieldName: "type",
          label: "Type",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: h()
        }
      ), ae === "suppression" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        mt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", 'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'))),
          value: C,
          initial: "Select",
          fieldName: "column",
          label: "Add Data Series",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: (Q = e.runtime) == null ? void 0 : Q.seriesKeys
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          value: B,
          fieldName: "value",
          label: "Suppressed Data  Value",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), (d || e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        mt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
          value: le,
          initial: "Select",
          fieldName: "style",
          label: "suppression line style",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: g(ae)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: ce,
          fieldName: "hideLineStyle",
          label: "Hide Suppressed line Style",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      )), (c || e.visualizationType === "Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        mt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "A symbol is ", /* @__PURE__ */ n.createElement("i", null, "required"), ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
          value: Y,
          initial: "Select",
          fieldName: "symbol",
          label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: x()
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: X,
          fieldName: "hideBarSymbol",
          label: "Hide Suppressed Bar Symbol  ",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      )), /* @__PURE__ */ n.createElement(
        We,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This label will display in the tooltip and legend."))),
          value: ee || "Suppressed",
          fieldName: "label",
          label: "Suppressed Data Label",
          placeholder: "",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.'))),
          value: Z,
          fieldName: "displayTooltip",
          label: "Display in tooltips",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
          value: z,
          fieldName: "displayLegend",
          label: "Display in legend",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
          value: W,
          fieldName: "displayTable",
          label: "Display in table",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will apply to chart, tooltip hover, legend, and data table."))),
          value: P,
          fieldName: "displayGray",
          label: "Highlight Suppressed Data In Gray",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        mt,
        {
          value: K,
          initial: "Select",
          fieldName: "seriesKey",
          label: "ASSOCIATE TO SERIES",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: e.runtime.lineSeriesKeys ?? ((V = e.runtime) == null ? void 0 : V.seriesKeys)
        }
      ), /* @__PURE__ */ n.createElement(
        mt,
        {
          value: C,
          initial: "Select",
          fieldName: "column",
          label: "COLUMN WITH CONFIGURATION VALUE",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: s()
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
          value: B,
          fieldName: "value",
          label: "VALUE TO TRIGGER",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        mt,
        {
          value: le,
          initial: "Select",
          fieldName: "style",
          label: "Style",
          updateField: (j, te, U, ue) => A(U, ue, ne),
          options: g(ae)
        }
      ), le.includes("Circles") && /* @__PURE__ */ n.createElement(
        We,
        {
          className: "number-narrow",
          type: "number",
          value: R,
          fieldName: "circleSize",
          label: "circle size",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      ), le !== "Filled Circles" && /* @__PURE__ */ n.createElement(
        We,
        {
          value: ee,
          fieldName: "label",
          label: "Label",
          placeholder: "",
          updateField: (j, te, U, ue) => A(U, ue, ne)
        }
      )));
    }
  )), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: S, className: "btn btn-primary full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, iT = ({ config: e, updateConfig: t, display: r }) => {
  var h, y, g, x;
  const a = (h = e == null ? void 0 : e.yAxis) == null ? void 0 : h.maxValue, i = ((g = (y = e == null ? void 0 : e.yAxis) == null ? void 0 : y.categories) == null ? void 0 : g.reduce((w, S) => w + (parseFloat(S.height) || 0), 0)) || 0, o = (w) => {
    let S = [];
    e.yAxis.categories && (S = [...e.yAxis.categories]), S.splice(w, 1), t({ ...e, yAxis: { ...e.yAxis, categories: S } });
  }, d = () => {
    var p, v;
    const w = (v = (p = e.yAxis) == null ? void 0 : p.categories) == null ? void 0 : v.length, S = 0.4;
    return Ua("#ddd").darken(S * w).hex();
  }, c = () => {
    const w = e.yAxis.categories ? [...e.yAxis.categories] : [], S = {
      label: "Label " + Number(w.length + 1),
      height: "",
      color: d()
    };
    w.push(S), t({ ...e, yAxis: { ...e.yAxis, categories: w } });
  }, s = (w, S, A) => {
    let p = [];
    e.yAxis.categories && (p = [...e.yAxis.categories]), p[A][w] = S, t({ ...e, yAxis: { ...e.yAxis, categories: p } });
  };
  return r ? /* @__PURE__ */ n.createElement(n.Fragment, null, e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: w, color: S, height: A }, p) => /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${p}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, "Axis Category ", p + 1), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-danger",
      onClick: (v) => {
        v.preventDefault(), o(p);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: A,
      fieldName: "height",
      label: "Category Height",
      updateField: (v, L, P, R) => s(P, R, p)
    }
  ), Number(i) > Number(a) && e.yAxis.categories.length - 1 === p && /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
    We,
    {
      value: S,
      fieldName: "color",
      label: "Color",
      updateField: (v, L, P, R) => s(P, R, p)
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: w,
      fieldName: "label",
      label: "Label",
      updateField: (v, L, P, R) => s(P, R, p)
    }
  ))))), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: c, className: "btn btn-primary full-width" }, "Add Axis Category")) : /* @__PURE__ */ n.createElement(n.Fragment, null);
}, oT = () => {
  var Zt, kn, Rt, dn, Gt, rn, Wn, Ln, Cn, mn, _n, On, Fn, Kn, an, yn, ir, Zn, Qn, b, _, D, G, pe;
  const {
    config: e,
    updateConfig: t,
    tableData: r,
    transformedData: a,
    loading: i,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: c,
    unfilteredData: s,
    excludedData: h,
    isDashboard: y,
    setParentConfig: g,
    missingRequiredSections: x,
    isDebug: w,
    setFilteredData: S,
    lineOptions: A,
    rawData: p,
    highlight: v,
    handleShowAll: L,
    dimensions: P
  } = se.useContext(pt), { minValue: R, maxValue: C, existPositiveValue: z, isAllLine: W } = Hc(e, s), Z = { data: a, config: e }, { leftMax: ee, rightMax: K } = dg(Z), {
    visHasAnchors: le,
    visHasBrushChart: Y,
    visHasCategoricalAxis: ae,
    visHasLegend: B,
    visHasLegendAxisAlign: X,
    visHasLegendColorCategory: ce,
    visHasSelectableLegendValues: ne,
    visSupportsDateCategoryAxis: Q,
    visSupportsDateCategoryAxisLabel: V,
    visSupportsDateCategoryAxisLine: j,
    visSupportsDateCategoryAxisMax: te,
    visSupportsDateCategoryAxisMin: U,
    visSupportsDateCategoryAxisPadding: ue,
    visSupportsDateCategoryAxisTicks: ke,
    visSupportsDateCategoryHeight: xe,
    visSupportsDateCategoryNumTicks: be,
    visSupportsDateCategoryTickRotation: Ae,
    visSupportsDynamicSeries: Ye,
    visSupportsFilters: Pe,
    visSupportsLeftValueAxis: ye,
    visSupportsPreliminaryData: Re,
    visSupportsRankByValue: fe,
    visSupportsResponsiveTicks: ze,
    visSupportsValueAxisGridLines: Ne,
    visSupportsValueAxisLabels: qe,
    visSupportsValueAxisLine: He,
    visSupportsValueAxisMax: Be,
    visSupportsValueAxisMin: Ze,
    visSupportsValueAxisTicks: Ve,
    visSupportsYPadding: je
  } = _s();
  se.useEffect(() => {
    let O = [];
    e.series && (O = e.series.map((I) => ({
      ...I,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: O
    });
  }, [e.visualizationType]), se.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), se.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Ue } = bp({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), we = (O, I) => ({
    ...I
  }), De = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, rt = (O) => {
    O.orientation === "horizontal" && (O.labels = !1), O.table.show === void 0 && (O.table.show = !y), O.visualizationType === "Combo" && (O.orientation = "vertical"), Pn(O.xAxis) && !O.xAxis.padding && (O.xAxis.padding = 0), O.visualizationType === "Line" && (O.visualizationSubType = "regular", O.barStyle = "flat", O.isLollipopChart = !1);
  }, ge = (O, I, J, ve) => {
    if (w && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      O,
      I,
      J,
      ve
    ), O === "boxplot" && (I === "legend" || I === "labels")) {
      t({
        ...e,
        [O]: {
          ...e[O],
          [I]: {
            ...e.boxplot[I],
            [J]: ve
          }
        }
      });
      return;
    }
    const Ie = (Ht) => Ht === 0 ? !0 : !!Ht;
    if (O === "columns" && Ie(I) && Ie(J)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [I]: {
            ...e.columns[I],
            [J]: ve
          }
        }
      });
      return;
    }
    if (O === null && I === null) {
      Ie(J) || console.error("fieldName is required");
      let Ht = { ...e, [J]: ve };
      rt(Ht), t(Ht);
      return;
    }
    const Xe = Array.isArray(e[O]);
    let lt = Xe ? [...e[O], ve] : { ...e[O], [J]: ve };
    Ie(I) && (Xe ? (lt = [...e[O]], lt[I] = { ...lt[I], [J]: ve }) : typeof ve == "string" ? lt[I] = ve : Ie(J) && (lt = { ...e[O], [I]: { ...e[O][I], [J]: ve } }));
    let Ut = { ...e, [O]: lt };
    rt(Ut), t(Ut);
  }, [ut, at] = se.useState(!0), [it, St] = se.useState(!1);
  if (i)
    return null;
  const jt = (O) => {
    t({
      ...e,
      lollipopShape: O
    });
  }, Bt = (O) => {
    let I = e.series ? [...e.series] : [], J = Array.from(new Set(a.map((Ie) => Ie[O]))), ve = [];
    J.forEach((Ie) => {
      ve.push({ key: Ie });
    }), e.visualizationType === "Forecasting" ? I.push({
      dataKey: O,
      type: e.visualizationType,
      stages: ve,
      stageColumn: O,
      axis: "Left",
      tooltip: !0
    }) : I.push({ dataKey: O, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: I });
  }, Nt = (O) => {
    let I = [...e.exclusions.keys];
    I.push(O);
    let J = { ...e.exclusions, keys: I };
    t({ ...e, exclusions: J });
  }, sn = (O) => {
    let I = -1, J = [...e.exclusions.keys];
    for (let ve = 0; ve < J.length; ve++)
      if (J[ve] === O) {
        I = ve;
        break;
      }
    if (I !== -1) {
      J.splice(I, 1);
      let ve = { ...e.exclusions, keys: J }, Ie = { ...e, exclusions: ve };
      J.length === 0 && delete Ie.exclusions.keys, t(Ie);
    }
  }, gt = (O = !0) => {
    let I = {};
    if (s.forEach((J) => {
      Object.keys(J).forEach((ve) => I[ve] = !0);
    }), O) {
      const { lower: J, upper: ve } = e.confidenceKeys || {};
      Object.keys(I).forEach((Ie) => {
        (e.series && e.series.filter((Xe) => Xe.dataKey === Ie).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(Ie) && (J && ve || J || ve) && Ie !== J && Ie !== ve) && delete I[Ie];
      });
    }
    return Object.keys(I);
  }, Dt = (O) => {
    const I = [];
    switch (O) {
      case "style":
        I.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && I.push("gradient"), e.visualizationType === "Line" && I.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? I.push("linear blocks") : I.push("linear blocks", "smooth");
        break;
    }
    return I;
  }, _t = (O) => {
    if (!O)
      return [];
    const I = /* @__PURE__ */ new Set();
    for (let J = 0; J < O.length; J++)
      for (const [ve] of Object.entries(O[J]))
        I.add(ve);
    return Array.from(I);
  }, un = (O, I = !1) => {
    let J = [];
    return h.forEach((ve) => {
      J.push(ve[O]);
    }), I ? [...new Set(J)] : J;
  }, En = () => {
    at(!ut), t({
      ...e,
      showEditorPanel: !ut
    });
  }, $t = () => {
    let O = JSON.parse(JSON.stringify(e));
    return x(e) === !1 && delete O.newViz, delete O.runtime, O;
  };
  se.useEffect(() => {
    if (g) {
      const O = $t();
      g(O);
    }
  }, [e]), se.useEffect(() => {
    const O = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], I = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: I
      },
      yAxis: {
        ...e.yAxis,
        anchors: O
      }
    });
  }, [e.orientation]), se.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), se.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), se.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const It = se.useCallback(() => {
    const O = [...e.exclusions.keys];
    return /* @__PURE__ */ n.createElement("ul", { className: "series-list" }, O.map((I, J) => /* @__PURE__ */ n.createElement("li", { key: I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name", "data-title": I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name--text" }, I)), /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: () => sn(I) }, ""))));
  }, [e]), fn = (O, I) => {
    let J = e.series, [ve] = J.splice(O, 1);
    J.splice(I, 0, ve), t({ ...e, series: J });
  };
  e.isLollipopChart && ((Zt = e == null ? void 0 : e.series) == null ? void 0 : Zt.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((kn = e == null ? void 0 : e.series) == null ? void 0 : kn.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Rt = e == null ? void 0 : e.series) == null ? void 0 : Rt.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((dn = e == null ? void 0 : e.series) == null ? void 0 : dn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const tt = e.orientation === "horizontal" ? "xAxis" : "yAxis", [st, Tn] = se.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), tn = () => {
    const O = e[tt].max, I = e[tt].rightMax;
    let J = "", ve = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (O && parseFloat(O) < parseFloat(C) && z):
          J = "Max value must be more than " + C;
          break;
        case (O && parseFloat(O) < 0 && !z):
          J = "Value must be more than or equal to 0";
          break;
        default:
          J = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (O && parseFloat(O) < ee):
          J = "Max value must be more than " + ee;
          break;
        case (I && parseFloat(I) < K):
          ve = "Max value must be more than " + K;
          break;
        case (O && parseFloat(O) < 0 && !z):
          J = "Value must be more than or equal to 0";
          break;
        default:
          J = "";
      }
    Tn((Ie) => ({ ...Ie, maxMsg: J, rightMaxMessage: ve }));
  }, cn = () => {
    const O = parseFloat(e[tt].min);
    let I = Number(R), J = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && O < 0):
        J = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && O > I):
        J = "Value should not exceed " + R;
        break;
      case (e.visualizationType === "Combo" && W && O > I):
        J = "Value should not exceed " + R;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !W) && I > 0 && O > 0):
        J = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && O >= Math.min(I, e.xAxis.target)):
        J = "Value must be less than " + Math.min(I, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && O && I < 0 && O > I):
        J = "Value should not exceed " + R;
        break;
      default:
        J = "";
    }
    Tn((ve) => ({ ...ve, minMsg: J }));
  };
  se.useEffect(() => {
    cn(), tn();
  }, [R, C, e]);
  const pn = ((Gt = e == null ? void 0 : e.dataKey) == null ? void 0 : Gt.includes("http://")) || ((rn = e == null ? void 0 : e.dataKey) == null ? void 0 : rn.includes("https://")), ft = () => {
    var O, I;
    if (w !== void 0 && w && !((O = e == null ? void 0 : e.xAxis) != null && O.dataKey)) {
      let J = gt(!1);
      if (J.includes("Date"))
        return "Date";
      if (J.includes("Race"))
        return "Race";
      if (J.includes("Month"))
        return "Month";
    }
    return ((I = e == null ? void 0 : e.xAxis) == null ? void 0 : I.dataKey) || "";
  }, Pt = () => {
    if (w !== void 0 && w && gt(!1).length > 0) {
      let O = gt(!1).filter((I) => I !== ft());
      if (O.length > 0)
        return O[0];
    }
    return "";
  };
  if (w && !e.xAxis.dataKey && (e.xAxis.dataKey = ft()), w && ((Wn = e == null ? void 0 : e.series) == null ? void 0 : Wn.length) === 0) {
    let O = Pt();
    O !== "" && Bt(O), w && console.log("### COVE DEBUG: Chart: Setting default datacol=", O);
  }
  const Ot = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], hn = [
    /* @__PURE__ */ n.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((Ln = e.data) == null ? void 0 : Ln[0]) || []).map((I) => {
      const J = e == null ? void 0 : e.series.some((ve) => ve.dataKey === I);
      if (I !== e.xAxis.dataKey && !J)
        return hn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    e.data.forEach((I) => {
      Object.keys(I).forEach((J) => {
        O[J] = O[J] || [];
        const ve = typeof I[J] == "number" ? I[J].toString() : I[J];
        O[J].indexOf(ve) === -1 && O[J].push(ve);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((I) => {
      const J = a.some((ve) => ve.dataKey === I);
      if (I !== e.xAxis.dataKey && !J)
        return hn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    a.forEach((I) => {
      Object.keys(I).forEach((J) => {
        O[J] = O[J] || [];
        const ve = typeof I[J] == "number" ? I[J].toString() : I[J];
        O[J].indexOf(ve) === -1 && O[J].push(ve);
      });
    });
  }
  const Tt = (O) => {
    const I = Je.cloneDeep(e.columns);
    delete I[O], t({
      ...e,
      columns: I
    });
  }, Ct = async (O, I, J) => {
    switch (I) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: J
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: J
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: nn,
    highlightedSeriesValues: Nn,
    handleUpdateHighlightedBar: At,
    handleAddNewHighlightedBar: xt,
    handleRemoveHighlightedBar: Dn,
    handleUpdateHighlightedBarColor: Oe,
    handleHighlightedBarLegendLabel: _e,
    handleUpdateHighlightedBorderWidth: Ee
  } = $c(e, t), ct = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, qt = () => {
    const O = a.map((I) => I[e.legend.colorCode]);
    return ct ? O : gt(!1).filter((I) => I !== e.xAxis.dataKey);
  }, Kt = (O) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: O } });
  }, Ft = (O, I, J) => {
    var Xe;
    const ve = { ...e[O], [I]: J }, Ie = { ...e, [O]: ve };
    J === "highlight" && ((Xe = e.legend.seriesHighlight) != null && Xe.length) && (Ie.legend.seriesHighlight.length = 0), t(Ie);
  }, kt = (O, I, J) => {
    const ve = { ...e.xAxis[O] };
    ve[I] = J;
    const Ie = { ...e, xAxis: { ...e.xAxis, [O]: ve } };
    t(Ie);
  }, ht = ![void 0, "- Select - "].includes((mn = (Cn = e.series) == null ? void 0 : Cn[0]) == null ? void 0 : mn.dynamicCategory), Et = ((_n = e.series) == null ? void 0 : _n.length) > 1, An = {
    addNewExclusion: Nt,
    data: a,
    editColumn: Ct,
    getColumns: gt,
    getDataValueOptions: _t,
    getDataValues: un,
    getItemStyle: we,
    handleSeriesChange: fn,
    handleAddNewHighlightedBar: xt,
    setCategoryAxis: ft,
    updateField: ge,
    warningMsg: st,
    highlightedBarValues: nn,
    handleHighlightedBarLegendLabel: _e,
    handleUpdateHighlightedBar: At,
    handleRemoveHighlightedBar: Dn,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: Nn,
    handleUpdateHighlightedBorderWidth: Ee,
    handleUpdateHighlightedBarColor: Oe,
    setLollipopShape: jt
  };
  return /* @__PURE__ */ n.createElement(wp.Provider, { value: An }, /* @__PURE__ */ n.createElement(Vr, { component: "EditorPanel" }, /* @__PURE__ */ n.createElement(
    hf.Sidebar,
    {
      displayPanel: ut,
      isDashboard: y,
      title: "Configure Chart",
      onBackClick: En
    },
    /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(ga.General, { name: "General" }), /* @__PURE__ */ n.createElement(ga.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ n.createElement(ga.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Data Series", " ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ n.createElement(
      mt,
      {
        fieldName: "dynamicSeriesType",
        value: e.dynamicSeriesType,
        label: "Series Type",
        initial: "Select",
        updateField: ge,
        options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ n.createElement(
      mt,
      {
        fieldName: "dynamicSeriesLineType",
        value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
        label: "Line Type",
        initial: "Select",
        updateField: ge,
        options: Object.keys(ol).map((O) => ol[O])
      }
    ), (!Ye() || !e.dynamicSeries) && /* @__PURE__ */ n.createElement(n.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      mt,
      {
        fieldName: "visualizationType",
        label: "Add Data Series",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Bt(O.target.value), O.target.value = "";
        },
        options: gt()
      }
    ), e.series && e.series.length !== 0 && /* @__PURE__ */ n.createElement(ga.Series.Wrapper, { getColumns: gt }, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ n.createElement(
      Ig,
      {
        onDragEnd: ({ source: O, destination: I }) => fn(O.index, I.index)
      },
      /* @__PURE__ */ n.createElement($g, { droppableId: "filter_order" }, (O) => /* @__PURE__ */ n.createElement("ul", { ...O.droppableProps, className: "series-list", ref: O.innerRef }, /* @__PURE__ */ n.createElement(
        ga.Series.List,
        {
          series: e.series,
          getItemStyle: we,
          sortableItemStyles: De,
          chartsWithOptions: Ot
        }
      ), O.placeholder))
    ))), (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.confidenceKeys.upper || "",
        section: "confidenceKeys",
        fieldName: "upper",
        label: "Upper",
        updateField: ge,
        initial: "Select",
        options: gt()
      }
    ), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.confidenceKeys.lower || "",
        section: "confidenceKeys",
        fieldName: "lower",
        label: "Lower",
        updateField: ge,
        initial: "Select",
        options: gt()
      }
    )), fe() && e.series && e.series.length === 1 && /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.rankByValue,
        fieldName: "rankByValue",
        label: "Rank by Value",
        initial: "Select",
        updateField: (O, I, J, ve) => {
          const [Ie, Xe] = rT(e, ve, a);
          t(Ie, Xe);
        },
        options: ["asc", "desc"]
      }
    ), Re() && /* @__PURE__ */ n.createElement(aT, { config: e, updateConfig: t, data: a })))), /* @__PURE__ */ n.createElement(ga.BoxPlot, { name: "Measures" }), ye() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.yAxis.dataKey || "",
        section: "yAxis",
        fieldName: "dataKey",
        label: "Data Column",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: gt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the source data to be visually represented.")))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.type,
        onChange: (O) => t({
          ...e,
          yAxis: {
            ...e.yAxis,
            type: O.target.value
          }
        })
      },
      /* @__PURE__ */ n.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
      e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
      e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical")
    )), /* @__PURE__ */ n.createElement(
      iT,
      {
        config: e,
        updateConfig: t,
        data: a,
        display: ae()
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !ae(),
        value: e.yAxis.label,
        section: "yAxis",
        fieldName: "label",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isLegendValue,
        fieldName: "isLegendValue",
        label: "Use Legend Value in Hover",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !ae(),
        value: e.yAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.size,
        type: "number",
        section: "yAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !ae(),
        value: e.yAxis.labelOffset,
        section: "yAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: ge
      }
    ), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ n.createElement(
      We,
      {
        display: !ae(),
        value: e.yAxis.tickRotation || 0,
        type: "number",
        min: 0,
        section: "yAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), Ne() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.gridLines,
        section: "yAxis",
        fieldName: "gridLines",
        label: "Show Gridlines",
        updateField: ge
      }
    ), Ne() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.labelsAboveGridlines,
        section: "yAxis",
        fieldName: "labelsAboveGridlines",
        label: "Tick labels above gridlines",
        updateField: ge,
        disabled: !e.yAxis.gridLines,
        title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
      }
    ), je() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.enablePadding,
        section: "yAxis",
        fieldName: "enablePadding",
        label: "Add Padding to Value Axis Scale",
        updateField: ge
      }
    ), e.yAxis.enablePadding && je() && /* @__PURE__ */ n.createElement(
      We,
      {
        type: "number",
        section: "yAxis",
        fieldName: "scalePadding",
        label: "Padding Percentage",
        className: "number-narrow",
        updateField: ge,
        value: e.yAxis.scalePadding
      }
    )), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.commas,
        section: "dataFormat",
        fieldName: "commas",
        label: "Add commas",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !ae(),
        value: e.dataFormat.abbreviated,
        section: "dataFormat",
        fieldName: "abbreviated",
        label: "Abbreviate Axis Values",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
        type: "number",
        section: "dataFormat",
        fieldName: "roundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    ), " ", /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.prefix,
        section: "dataFormat",
        fieldName: "prefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.suffix,
        section: "dataFormat",
        fieldName: "suffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), e.orientation === "horizontal" ? (
      // horizontal - x is vertical y is horizontal
      /* @__PURE__ */ n.createElement(n.Fragment, null, He() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideAxis,
          section: "xAxis",
          fieldName: "hideAxis",
          label: "Hide Axis",
          updateField: ge
        }
      ), qe() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideLabel,
          section: "xAxis",
          fieldName: "hideLabel",
          label: "Hide Tick Labels",
          updateField: ge
        }
      ), Ve() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideTicks,
          section: "xAxis",
          fieldName: "hideTicks",
          label: "Hide Ticks",
          updateField: ge
        }
      ), Be() && /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.max,
          section: "xAxis",
          fieldName: "max",
          label: "max value",
          type: "number",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.maxMsg), Ze() && /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.min,
          section: "xAxis",
          fieldName: "min",
          type: "number",
          label: "min value",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.target,
          section: "xAxis",
          fieldName: "target",
          type: "number",
          label: "Deviation point",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.targetLabel || "Target",
          section: "xAxis",
          fieldName: "targetLabel",
          type: "text",
          label: "Deviation point Label",
          updateField: ge
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.showTargetLabel,
          section: "xAxis",
          fieldName: "showTargetLabel",
          label: "Show Deviation point label",
          updateField: ge
        }
      )))
    ) : e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !ae(),
        value: e.dataFormat.onlyShowTopPrefixSuffix,
        section: "dataFormat",
        fieldName: "onlyShowTopPrefixSuffix",
        label: "Only Show Top Prefix/Suffix",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !ae(),
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !ae(),
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !ae(),
        value: e.yAxis.hideTicks,
        section: "yAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "max",
        type: "number",
        label: "left axis max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.maxMsg), e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "min",
        type: "number",
        label: "left axis min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.minMsg))), le() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (Fn = (On = e.yAxis) == null ? void 0 : On.anchors) == null ? void 0 : Fn.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const ve = [...e.yAxis.anchors];
          ve.splice(I, 1), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ve
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.yAxis.anchors];
          ve[I].value = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.yAxis.anchors];
          ve[I].color = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const ve = [...e.yAxis.anchors];
          ve[I].lineStyle = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ve
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((J) => /* @__PURE__ */ n.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), le() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (an = (Kn = e.xAxis) == null ? void 0 : Kn.anchors) == null ? void 0 : an.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `xaxis-anchors-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve[I].value = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve[I].color = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const ve = [...e.xAxis.anchors];
          ve[I].lineStyle = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((J) => /* @__PURE__ */ n.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), Ue && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Right Value Axis")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightLabel,
        section: "yAxis",
        fieldName: "rightLabel",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightNumTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "rightNumTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightAxisSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightAxisSize",
        label: "Size (Width)",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightLabelOffsetSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightLabelOffsetSize",
        label: "Label Offset",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.rightCommas,
        section: "dataFormat",
        fieldName: "rightCommas",
        label: "Add commas",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "rightRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightPrefix,
        section: "dataFormat",
        fieldName: "rightPrefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightSuffix,
        section: "dataFormat",
        fieldName: "rightSuffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideAxis,
        section: "yAxis",
        fieldName: "rightHideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideLabel,
        section: "yAxis",
        fieldName: "rightHideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideTicks,
        section: "yAxis",
        fieldName: "rightHideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "rightMax",
        type: "number",
        label: "right axis max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.rightMaxMessage), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "rightMin",
        type: "number",
        label: "right axis min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, st.minMsg))), Q() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.type,
        onChange: (O) => t({
          ...e,
          xAxis: {
            ...e.xAxis,
            type: O.target.value
          }
        })
      },
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "date" }, "Date (Linear Scale)"),
      /* @__PURE__ */ n.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
      e.visualizationType === "Scatter Plot" && /* @__PURE__ */ n.createElement("option", { value: "continuous" }, "Continuous")
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.manual,
        section: "xAxis",
        fieldName: "manual",
        label: "Manual Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: e.xAxis.type !== "categorical",
        value: e.xAxis.sortByRecentDate,
        section: "xAxis",
        fieldName: "sortByRecentDate",
        label: "Show dates newest to oldest",
        updateField: ge
      }
    ), ue() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.padding,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "padding",
        label: "Padding (Percent)",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
      }
    )), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.xAxis.dataKey || ft() || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Data Key",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: gt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
      }
    )), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.xAxis.dataKey || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Segment Labels",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: gt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.label,
        section: "xAxis",
        fieldName: "label",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), e.xAxis.type === "continuous" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomPrefix,
        section: "dataFormat",
        fieldName: "bottomPrefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomSuffix,
        section: "dataFormat",
        fieldName: "bottomSuffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomAbbreviated,
        section: "dataFormat",
        fieldName: "bottomAbbreviated",
        label: "Abbreviate Axis Values",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    )), Pn(e.xAxis) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ n.createElement("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.", " "))),
        value: e.xAxis.dateParseFormat,
        section: "xAxis",
        fieldName: "dateParseFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "Date Parse Format",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Adjusts the date display format on the axis for clear, visual date representation."))),
        value: e.xAxis.dateDisplayFormat,
        section: "xAxis",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "AXIS DATE DISPLAY FORMAT",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.table.dateDisplayFormat,
        section: "table",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "DATA TABLE DATE DISPLAY FORMAT",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.tooltips.dateDisplayFormat,
        section: "tooltips",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "HOVER DATE DISPLAY FORMAT",
        updateField: ge
      }
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis.", " "))),
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.showYearsOnce,
        section: "xAxis",
        fieldName: "showYearsOnce",
        label: "Show years once",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis."))),
        updateField: ge
      }
    ), Y() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: (yn = e.brush) == null ? void 0 : yn.active,
        section: "brush",
        fieldName: "active",
        label: "Brush Slider ",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.", " ")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(It, null)), /* @__PURE__ */ n.createElement(
      mt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Nt(O.target.value), O.target.value = "";
        },
        options: un(e.xAxis.dataKey, !0)
      }
    )), e.xAxis.type === "date" || e.xAxis.type === "date-time" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateStart",
        label: "Start Date",
        updateField: ge,
        value: e.exclusions.dateStart || ""
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateEnd",
        label: "End Date",
        updateField: ge,
        value: e.exclusions.dateEnd || ""
      }
    ))), be() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.manualStep,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "manualStep",
        label: "Step count",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => St(!it),
        className: "edit-label"
      },
      "Step Count: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${it ? "90deg" : "0deg"})` } }, ">")
    )), it && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Cp).map((O) => /* @__PURE__ */ n.createElement(
      We,
      {
        key: `viewport-step-count-input-${O}`,
        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, J, ve, Ie) => kt("viewportStepCount", O, Ie)
      }
    ))))), be() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => St(!it),
        className: "edit-label"
      },
      "Number of ticks: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${it ? "90deg" : "0deg"})` } }, ">")
    )), it && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Cp).map((O) => /* @__PURE__ */ n.createElement(
      We,
      {
        key: `viewport-num-ticks-input-${O}`,
        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, J, ve, Ie) => kt("viewportNumTicks", O, Ie)
      }
    ))))), xe() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.size,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.labelOffset,
        section: "xAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: ge
      }
    ), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomCommas,
        section: "dataFormat",
        fieldName: "bottomCommas",
        label: "Add commas",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "bottomRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    )), ze() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: ge
      }
    ), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Ae() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.tickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), e.orientation === "horizontal" ? /* @__PURE__ */ n.createElement(n.Fragment, null, j() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), V() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, j() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideAxis,
        section: "xAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), V() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideLabel,
        section: "xAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), ke() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideTicks,
        section: "xAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    )), ((ir = e.series) == null ? void 0 : ir.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && nn.map((O, I) => /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `highlighted-bar-${I}` }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-danger", onClick: (J) => Dn(J, I) }, "Remove"), /* @__PURE__ */ n.createElement("p", null, "Highlighted Bar ", I + 1), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.highlightedBarValues[I].value,
        onChange: (J) => At(J, I)
      },
      /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Value -"),
      Nn && [...new Set(Nn)].sort().map((J) => /* @__PURE__ */ n.createElement("option", { key: `special-class-value-option-${I}-${J}` }, J))
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].color ? e.highlightedBarValues[I].color : "",
        onChange: (J) => Oe(J, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ n.createElement(
      "input",
      {
        max: "5",
        min: "0",
        type: "number",
        value: e.highlightedBarValues[I].borderWidth ? e.highlightedBarValues[I].borderWidth : "",
        onChange: (J) => Ee(J, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].legendLabel ? e.highlightedBarValues[I].legendLabel : "",
        onChange: (J) => _e(J, I)
      }
    ))))), /* @__PURE__ */ n.createElement("button", { className: "btn btn-primary full-width", onClick: (O) => xt(O) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: "Exclude one or more values",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(It, null)), /* @__PURE__ */ n.createElement(
      mt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Nt(O.target.value), O.target.value = "";
        },
        options: un(e.xAxis.dataKey, !0)
      }
    ))), U() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.min,
        section: "xAxis",
        fieldName: "min",
        type: "number",
        label: "min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), te() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.max,
        section: "xAxis",
        fieldName: "max",
        type: "number",
        label: "max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), le() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (Qn = (Zn = e.xAxis) == null ? void 0 : Zn.anchors) == null ? void 0 : Qn.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve[I].value = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const ve = [...e.xAxis.anchors];
          ve[I].color = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const ve = [...e.xAxis.anchors];
          ve[I].lineStyle = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ve
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((J) => /* @__PURE__ */ n.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), le() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (_ = (b = e.yAxis) == null ? void 0 : b.anchors) == null ? void 0 : _.map((O, I) => /* @__PURE__ */ n.createElement(
      Mn,
      {
        className: "series-item series-item--chart",
        key: `accordion-yaxis-anchors-${I}`
      },
      /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (J) => {
            J.preventDefault();
            const ve = [...e.yAxis.anchors];
            ve.splice(I, 1), t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ve
              }
            });
          }
        },
        "Remove"
      )))),
      /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
          onChange: (J) => {
            J.preventDefault();
            const ve = [...e.yAxis.anchors];
            ve[I].value = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ve
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
          onChange: (J) => {
            J.preventDefault();
            const ve = [...e.yAxis.anchors];
            ve[I].color = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ve
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
        "select",
        {
          value: e.yAxis.anchors[I].lineStyle || "",
          onChange: (J) => {
            const ve = [...e.yAxis.anchors];
            ve[I].lineStyle = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ve
              }
            });
          }
        },
        /* @__PURE__ */ n.createElement("option", null, "Select"),
        A.map((J) => /* @__PURE__ */ n.createElement("option", { key: J.key }, J.value))
      )))
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), /* @__PURE__ */ n.createElement(ga.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Columns")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Nw, { config: e, updateField: ge, deleteColumn: Tt }), " ")), B() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Legend")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      mt,
      {
        value: (D = e.legend) == null ? void 0 : D.position,
        section: "legend",
        fieldName: "position",
        label: "Position",
        updateField: ge,
        options: ["right", "left", "bottom", "top"]
      }
    ), (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ n.createElement("span", { style: { color: "red", fontSize: "14px" } }, "Position must be set to top or bottom to use gradient style."), /* @__PURE__ */ n.createElement(
      mt,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom."))),
        display: !e.legend.hide,
        value: e.legend.style,
        section: "legend",
        fieldName: "style",
        label: "Legend Style",
        updateField: ge,
        options: Dt("style")
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose option Shapes in Line Datapoint Symbols to display."))),
        display: !e.legend.hide && e.legend.style === "lines",
        value: e.legend.hasShape,
        section: "legend",
        fieldName: "hasShape",
        label: "Shapes",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      mt,
      {
        display: !e.legend.hide && e.legend.style === "gradient",
        value: e.legend.subStyle,
        section: "legend",
        fieldName: "subStyle",
        label: "Gradient Style",
        updateField: ge,
        options: Dt("subStyle")
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: e.legend.style === "gradient" && !e.legend.hide,
        className: "number-narrow",
        type: "number",
        value: e.legend.tickRotation,
        section: "legend",
        fieldName: "tickRotation",
        label: "Tick Rotation (Degrees)",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: (G = e.preliminaryData) == null ? void 0 : G.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressedLabels,
        section: "legend",
        fieldName: "hideSuppressedLabels",
        label: "Hide Suppressed Labels",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: (pe = e.preliminaryData) == null ? void 0 : pe.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressionLink,
        section: "legend",
        fieldName: "hideSuppressionLink",
        label: "Hide Suppression Definition Link",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will hide the suppression definition link from display.")))
      }
    ), /* @__PURE__ */ n.createElement(
      mt,
      {
        display: ht || Et,
        value: e.legend.behavior,
        section: "legend",
        fieldName: "behavior",
        label: "Legend Behavior (When clicked)",
        updateField: (...[O, , I, J]) => Ft(O, I, J),
        options: ["highlight", "isolate"]
      }
    ), /* @__PURE__ */ n.createElement(
      mt,
      {
        display: ce(),
        value: e.legend.colorCode,
        section: "legend",
        fieldName: "colorCode",
        label: "Color code by category",
        initial: "Select",
        updateField: ge,
        options: _t(a)
      }
    ), X() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.legend.axisAlign,
        fieldName: "axisAlign",
        section: "legend",
        label: "Align to Axis on Isolate",
        updateField: ge
      }
    ), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.legend.highlightOnHover,
        section: "legend",
        fieldName: "highlightOnHover",
        label: "HIGHLIGHT DATA SERIES ON HOVER",
        updateField: ge
      }
    ), ne && e.legend.behavior === "isolate" && !ct && /* @__PURE__ */ n.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((O, I) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: `${O}-${I}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-danger",
        onClick: (J) => {
          J.preventDefault();
          const ve = [...e.legend.seriesHighlight];
          ve.splice(I, 1), ge("legend", null, "seriesHighlight", ve), ve.length || L();
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(
      mt,
      {
        value: e.legend.seriesHighlight[I],
        fieldName: "seriesHighlight",
        label: "Isolate Value",
        onChange: (J) => {
          const ve = [...e.legend.seriesHighlight];
          ve.includes(J.target.value) || (ve[I] = J.target.value, Kt([...ve]));
        },
        options: qt()
      }
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = qt(), J = [...e.legend.seriesHighlight];
          if (J.length < I.length) {
            const [Ie] = I.filter((Xe) => !J.includes(Xe));
            J.push(Ie), Kt([...J]);
          }
        }
      },
      "Add Isolate Value"
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.reverseLabelOrder,
        section: "legend",
        fieldName: "reverseLabelOrder",
        label: "Reverse Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide,
        value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
        section: "legend",
        subsection: "hideBorder",
        fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
        label: "Hide Legend Box",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Default option for top and bottom legends is No Box..")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
        value: e.legend.singleRow,
        section: "legend",
        fieldName: "singleRow",
        label: "Single Row Legend",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient" && !e.legend.singleRow && !e.legend.singleRow,
        value: e.legend.verticalSorted,
        section: "legend",
        fieldName: "verticalSorted",
        label: "Vertical sorted Legend",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: ge,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.legend.label,
        section: "legend",
        fieldName: "label",
        label: "Title",
        updateField: ge
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "textarea",
        value: e.legend.description,
        updateField: ge,
        section: "legend",
        fieldName: "description",
        label: "Legend Description"
      }
    ))), Pe() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Filters")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Hg, { config: e, updateField: ge, rawData: p }))), /* @__PURE__ */ n.createElement(ga.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Data Table")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      Dw,
      {
        config: e,
        columns: Object.keys(a[0] || {}),
        updateField: ge,
        isDashboard: y,
        isLoadedFromUrl: pn
      }
    ), " ")), /* @__PURE__ */ n.createElement(ga.Annotate, { name: "Text Annotations" })),
    e.type !== "Spark Line" && /* @__PURE__ */ n.createElement(Vg, { loadConfig: t, config: e, convertStateToConfig: $t })
  )));
}, gm = (e) => {
  let t = "", r = Math.abs(e);
  return r >= 1e9 ? (t = "B", e = e / 1e9) : r >= 1e6 ? (t = "M", e = e / 1e6) : r >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, ds = (e, t) => {
  var r;
  return e ? (r = e.legend) != null && r.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, lT = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], vm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), xm = (e, t) => {
  if (t.rankByValue) {
    const r = t.series[0].dataKey, a = e.sort((i, o) => vm(i[r]) - vm(o[r]));
    return t.rankByValue === "asc" ? a : a.reverse();
  }
  return e;
}, bm = (e = "#000000", t = !1) => {
  let r = Ua(e), a = t ? r.brighten(0.5).hex() : r.saturate(1.3).hex();
  return [e, a, r.darken(0.3).hex()];
}, sT = se.createContext({ displayName: "ConfigContext", setTempConfig: () => {
} }), WT = se.createContext(() => {
}), uT = (e, t, r, a = !1) => !!(e === "Line" && (t == null ? void 0 : t.length) < 3 && r || a), cT = (e, t) => {
  const r = t, a = Je.uniq(Je.map(r, e.xAxis.dataKey)), i = Je.map(e.series, "dataKey"), o = [];
  a.forEach((c) => {
    i.forEach((s) => {
      try {
        if (!c)
          throw new Error("No groups resolved in box plots");
        const { count: h, sortedData: y } = Je.chain(r).filter((v) => v[e.xAxis.dataKey] === c).thru((v) => ({
          count: v.length,
          sortedData: Je.map(v, (L) => Number(L[s])).sort()
        })).value();
        if (!y)
          throw new Error("boxplots dont have data yet");
        if (!o)
          throw new Error("boxplots dont have plots yet");
        const g = Ts(y, 0.25), x = Ts(y, 0.75), w = x - g, S = g - 1.5 * w, A = x + 1.5 * w, p = y.filter((v) => v >= S && v <= A);
        o.push({
          columnCategory: c,
          columnMax: Ju(p),
          columnThirdQuartile: Je.round(x, e.dataFormat.roundTo),
          columnMedian: Number(ry(y)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: Je.round(g, e.dataFormat.roundTo),
          columnMin: Je.min(p),
          columnCount: h,
          columnSd: Number(ox(y)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(lx(y)).toFixed(e.dataFormat.roundTo),
          columnIqr: Je.round(w, e.dataFormat.roundTo),
          values: y,
          columnLowerBounds: S,
          columnUpperBounds: A,
          columnOutliers: Je.filter(y, (v) => v < S || v > A),
          columnNonOutliers: Je.filter(y, (v) => v >= S && v <= A)
        });
      } catch (h) {
        console.error("COVE: ", h.message);
      }
    });
  });
  const d = i.length > 1 ? Je.flatMap(a, (c) => Je.map(i, (s) => `${Je.capitalize(s)} - ${Je.capitalize(c)}`)) : a;
  return [o, d];
}, dT = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, r = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((a) => {
    const i = r.get(a.type);
    if (i) {
      const o = i === "barSeriesKeys" || i === "lineSeriesKeys" ? a.dataKey : a;
      t[i].push(o);
    }
    a.type === "Combo" && (a.type = "Bar");
  }), { ...e.runtime, ...t };
}, fT = (e, t) => {
  var a;
  let r = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((a = e.exclusions.keys) == null ? void 0 : a.length) > 0)
      r = t.filter((i) => !e.exclusions.keys.includes(i[e.xAxis.dataKey]));
    else if (Pn(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const i = (h) => new Date(h).getTime();
      let o = i(e.exclusions.dateStart), d = i(e.exclusions.dateEnd) + 86399999, c = typeof o !== void 0 && isNaN(o) === !1, s = typeof d !== void 0 && isNaN(d) === !1;
      c && s ? r = t.filter(
        (h) => i(h[e.xAxis.dataKey]) >= o && i(h[e.xAxis.dataKey]) <= d
      ) : c ? r = t.filter((h) => i(h[e.xAxis.dataKey]) >= o) : s && (r = t.filter((h) => i(h[e.xAxis.dataKey]) <= d));
    } else
      r = t;
  return r;
}, pT = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, r = { ...Sr, ...Pc };
  let a = e.customColors || r[t], i = e.runtime.seriesKeys.length, o;
  for (; i > a.length; )
    a = a.concat(a);
  return a = a.slice(0, i), o = () => yp({
    domain: e.runtime.seriesLabelsAll,
    range: a,
    unknown: null
  }), o;
};
const hT = ({
  config: e,
  isEditor: t = !1,
  isDebug: r = !1,
  isDashboard: a = !1,
  setConfig: i,
  setEditing: o,
  link: d,
  setSharedFilter: c,
  setSharedFilterValue: s,
  dashboardConfig: h
}) => {
  var ft, Pt, Ot, hn, Tt, Ct, nn, Nn, At, xt, Dn;
  const y = new Fm(), [g, x] = se.useState(!0), w = se.useRef(null), [S, A] = se.useState(null), [p, v] = se.useState({}), [L, P] = se.useState(Je.cloneDeep(e == null ? void 0 : e.data) || []), [R, C] = se.useState(void 0), [z, W] = se.useState(void 0), [Z, ee] = se.useState(
    e && ((Pt = (ft = e == null ? void 0 : e.legend) == null ? void 0 : ft.seriesHighlight) != null && Pt.length) ? [...(Ot = e == null ? void 0 : e.legend) == null ? void 0 : Ot.seriesHighlight] : []
  ), [K, le] = se.useState("lg"), [Y, ae] = se.useState([0, 0]), [B, X] = se.useState(), [ce, ne] = se.useState(), [Q, V] = se.useState(!1), [j, te] = se.useState(!1), [U, ue] = se.useState([]), [ke] = se.useState(`cove-${Math.random().toString(16).slice(-4)}`), [xe, be] = se.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  }), Ae = se.useContext(sT), Ye = (Oe) => {
    v(Oe), t && !a && Ae.setTempConfig(Oe);
  }, { description: Pe, visualizationType: ye } = p, Re = se.useRef(null), fe = se.useRef(null), ze = (Oe) => {
    te(Oe);
  };
  r && console.log("Chart config, isEditor", p, t);
  let { legend: Ne, title: qe } = p;
  t && (!qe || qe === "") && (qe = "Chart Title"), p.table && (!((hn = p.table) != null && hn.label) || ((Tt = p.table) == null ? void 0 : Tt.label) === "") && (p.table.label = "Data Table");
  const { lineDatapointClass: He, contentClasses: Be, sparkLineStyles: Ze } = Wg(p), Ve = se.useId(), Ue = (p.xAxis || p.yAxis) && ["date-time", "date"].includes((p.xAxis || p.yAxis).type) && p.xAxis.dataKey, we = (() => {
    const _e = e.series.some((Ee) => Ee.dynamicCategory) && Je.uniq(e.formattedData.map((Ee) => Ee[e.xAxis.dataKey])).length <= 2;
    return uT(
      p.visualizationType,
      z,
      p.allowLineToBarGraph,
      _e
    );
  })(), De = (Oe, _e) => {
    let Ee = Je.defaultsDeep(Oe, pf);
    return Je.defaultsDeep(Ee, {
      table: { showVertical: !1 }
    }), Je.set(Ee, "table.show", Je.get(Ee, "table.show", !a)), Je.forEach(Ee.series, (ct) => {
      Je.defaults(ct, {
        tooltip: !0,
        axis: "Left"
      });
    }), Ee.visualizationType === "Bump Chart" && Ee.xAxis.type, { ...Yg(Ee) };
  }, rt = (Oe, _e) => {
    var Ft, kt;
    const Ee = Je.cloneDeep(Oe);
    let ct = _e || L;
    ct = xm(ct, Ee), Object.keys(pf).forEach((ht) => {
      Ee[ht] && typeof Ee[ht] == "object" && !Array.isArray(Ee[ht]) && (Ee[ht] = { ...pf[ht], ...Ee[ht] });
    });
    const qt = fT(Ee, _e || L);
    C(qt);
    let Kt = [];
    if (Ee.filters) {
      const ht = cv(Ee.filters, qt);
      Kt = Uo(ht, qt), W(Kt);
    }
    if (Ee.xAxis.type === "date-time" && p.orientation === "horizontal" && (Ee.xAxis.type = "date"), Ee.runtime = {}, Ee.runtime.series = Je.cloneDeep(Ee.series), Ee.runtime.seriesLabels = {}, Ee.runtime.seriesLabelsAll = [], Ee.runtime.originalXAxis = Ee.xAxis, Ee.visualizationType === "Pie")
      Ee.runtime.seriesKeys = (_e || ct).map((ht) => ht[Ee.xAxis.dataKey]), Ee.runtime.seriesLabelsAll = Ee.runtime.seriesKeys;
    else {
      const ht = _e || Ee.formattedData || Ee.data;
      Ee.runtime.seriesKeys = (Ee.runtime.series || []).flatMap((Et) => {
        if (Et.dynamicCategory) {
          Je.remove(Ee.runtime.seriesLabelsAll, (Zt) => Zt === Et.dataKey), Je.remove(Ee.runtime.series, (Zt) => Zt.dataKey === Et.dataKey);
          const An = Je.uniq(ht.map((Zt) => Zt[Et.dynamicCategory]));
          return An.forEach((Zt) => {
            Ee.runtime.seriesLabels[Zt] = Zt, Ee.runtime.seriesLabelsAll.push(Zt), Ee.runtime.series.push({
              dataKey: Zt,
              type: Et.type,
              lineType: Et.lineType,
              originalDataKey: Et.dataKey,
              dynamicCategory: Et.dynamicCategory,
              tooltip: !0
            });
          }), An;
        } else
          return Ee.runtime.seriesLabels[Et.dataKey] = Et.name || Et.label || Et.dataKey, Ee.runtime.seriesLabelsAll.push(Et.name || Et.dataKey), [Et.dataKey];
      });
    }
    if (Ee.visualizationType === "Box Plot" && Ee.series) {
      const [ht, Et] = cT(Ee, L);
      Ee.boxplot.categories = Et, Ee.boxplot.plots = ht;
    }
    Ee.visualizationType === "Combo" && Ee.series && (Ee.runtime = dT(Ee)), Ee.visualizationType === "Forecasting" && Ee.series && (Ee.runtime.forecastingSeriesKeys = [], Ee.series.forEach((ht) => {
      ht.type === "Forecasting" && Ee.runtime.forecastingSeriesKeys.push(ht);
    })), Ee.visualizationType === "Area Chart" && Ee.series && (Ee.runtime.areaSeriesKeys = [], Ee.series.forEach((ht) => {
      Ee.runtime.areaSeriesKeys.push({ ...ht, type: "Area Chart" });
    })), Ee.visualizationType === "Bar" && Ee.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(Ee.visualizationType) ? (Ee.runtime.xAxis = Ee.yAxis.yAxis ? Ee.yAxis.yAxis : Ee.yAxis, Ee.runtime.yAxis = Ee.xAxis.xAxis ? Ee.xAxis.xAxis : Ee.xAxis, Ee.runtime.yAxis.labelOffset *= -1, Ee.runtime.horizontal = !1, Ee.orientation = "horizontal", Ee.yAxis.type = Ee.yAxis.type === "categorical" ? "linear" : Ee.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(Ee.visualizationType) && !we ? (Ee.runtime.xAxis = Ee.xAxis, Ee.runtime.yAxis = Ee.yAxis, Ee.runtime.horizontal = !1, Ee.orientation = "vertical") : (Ee.runtime.xAxis = Ee.xAxis, Ee.runtime.yAxis = Ee.yAxis, Ee.runtime.horizontal = !1), Ee.runtime.uniqueId = Date.now(), Ee.runtime.editorErrorMessage = Ee.visualizationType === "Pie" && !Ee.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", Ee.runtime.editorErrorMessage = "", (Ft = Ee.legend.seriesHighlight) != null && Ft.length && ee((kt = Ee.legend) == null ? void 0 : kt.seriesHighlight), Ye(Ee);
  }, ge = (Oe, _e) => {
    let Ee = p.visualizationType === "Bar" && p.visualizationSubType === "horizontal" ? p.xAxis.dataKey : p.yAxis.sortKey, ct = parseFloat(Oe[Ee]), qt = parseFloat(_e[Ee]);
    return ct < qt ? p.sortData === "ascending" ? 1 : -1 : ct > qt ? p.sortData === "ascending" ? -1 : 1 : 0;
  }, ut = new Eg((Oe) => {
    for (let _e of Oe) {
      let { width: Ee, height: ct } = _e.contentRect;
      const qt = 15;
      Ee = t ? Ee - 350 : Ee;
      const Ft = Sg(Ee);
      le(Ft), _e.target.dataset.lollipop === "true" && (Ee = Ee - 2.5), Ee = Ee - qt, ae([Ee, ct]);
    }
  }), at = se.useCallback((Oe) => {
    Oe !== null && ut.observe(Oe), ne(Oe);
  }, []), it = (Oe, _e) => (Oe.dataDescription && (_e = y.autoStandardize(_e), _e = y.developerStandardize(_e, Oe.dataDescription)), _e = xm(_e, Oe), _e);
  se.useEffect(() => {
    (async () => {
      try {
        const _e = e.data;
        if (e.data && e) {
          const Ee = await De(e, _e), ct = it(e, _e);
          P(ct), C(ct), rt(Ee, ct);
        }
      } catch {
        console.error("Could not Load!");
      }
    })();
  }, [(Ct = e == null ? void 0 : e.data) != null && Ct.length ? e.data : null]), se.useEffect(() => {
    ce && !Je.isEmpty(p) && !Q && (jg("cove_loaded", { config: p }), V(!0));
  }, [ce, p]), se.useEffect(() => {
    const Oe = (_e) => {
      let Ee = [];
      Ee.push(_e.detail), X(Ee);
    };
    return Ug("cove_filterData", (_e) => Oe(_e)), () => {
      Kg("cove_filterData", Oe);
    };
  }, [p]), se.useEffect(() => {
    if (B && B[0] && !B[0].hasOwnProperty("active")) {
      let _e = { ...p };
      delete _e.filters, Ye(_e), W(Uo(B, R));
    }
    if (B && B.length > 0 && B.length > 0 && B[0].hasOwnProperty("active")) {
      let Oe = { ...p, filters: B };
      Ye(Oe), W(Uo(B, R));
    }
  }, [B]), se.useEffect(() => {
    var Oe;
    if (L && p.xAxis && ((Oe = p.runtime) != null && Oe.seriesKeys)) {
      const _e = pT(p);
      A(_e), x(!1);
    }
    p && L && p.sortData && L.sort(ge);
  }, [p, L]);
  const St = (Oe) => {
    if (Z.length + 1 === p.runtime.seriesKeys.length && p.visualizationType !== "Forecasting")
      return jt();
    const _e = Je.findKey(p.runtime.seriesLabels, (ct) => ct === Oe.datum) || Oe.datum, Ee = Je.xor(Z, [_e]);
    ee(Ee);
  }, jt = () => {
    try {
      const Oe = Re.current;
      if (!Oe)
        throw new Bd("No legend available to set previous focus on.");
      Oe.focus();
    } catch (Oe) {
      console.error("COVE:", Oe.message);
    }
    ee([]);
  }, Bt = p.orientation === "horizontal" ? "yAxis" : "xAxis", Nt = (Oe, _e = !0) => {
    let Ee = sy(p.runtime[Bt].dateParseFormat)(Oe);
    return Ee || (_e && (p.runtime.editorErrorMessage = `Error parsing date "${Oe}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, sn = (Oe, _e, Ee) => {
    var qt, Kt;
    let ct = Hu(p.runtime[Bt].dateDisplayFormat)(Oe);
    if ((qt = p.runtime[Bt].dateDisplayFormat) != null && qt.includes("%b.") && ct.includes("May.") && (ct = ct.replace(/May\./g, "May")), p.xAxis.showYearsOnce && ((Kt = p.runtime[Bt].dateDisplayFormat) != null && Kt.includes("%Y")) && Ee) {
      const Ft = Ee[_e - 1] ? Ee[_e - 1].value : null, kt = Hu(p.runtime[Bt].dateDisplayFormat)(Ft), ht = ct.match(/\d{4}/), Et = kt.match(/\d{4}/);
      ht && Et && ht[0] === Et[0] && (ct = ct.replace(ht, ""));
    }
    return ct;
  }, gt = (Oe) => Hu(p.tooltips.dateDisplayFormat)(Oe), Dt = (Oe, _e, Ee = !1, ct, qt, Kt, { index: Ft, length: kt } = { index: null, length: null }) => {
    if (isNaN(Oe) || !Oe)
      return Oe;
    const ht = Oe < 0;
    (_e === void 0 || !_e) && (_e = "left"), ht && (Oe = Math.abs(Oe));
    let {
      dataFormat: {
        commas: Et,
        abbreviated: An,
        roundTo: Zt,
        prefix: kn,
        suffix: Rt,
        rightRoundTo: dn,
        bottomRoundTo: Gt,
        rightPrefix: rn,
        rightSuffix: Wn,
        bottomPrefix: Ln,
        bottomSuffix: Cn,
        bottomAbbreviated: mn,
        onlyShowTopPrefixSuffix: _n
      }
    } = p;
    String(Oe).indexOf(",") !== -1 && (Oe = Oe.replaceAll(",", ""));
    let On = Oe, Fn = {
      useGrouping: !!Et
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let yn;
      Kt !== void 0 ? yn = Kt ? Number(Kt) : 0 : yn = Zt ? Number(Zt) : 0, Fn = {
        useGrouping: Kt ? !0 : !!p.dataFormat.commas,
        minimumFractionDigits: yn,
        maximumFractionDigits: yn
      };
    }
    _e === "right" && (Fn = {
      useGrouping: !!p.dataFormat.rightCommas,
      minimumFractionDigits: dn ? Number(dn) : 0,
      maximumFractionDigits: dn ? Number(dn) : 0
    });
    const Kn = () => p.forestPlot.type === "Logarithmic" && !Gt ? 2 : Number(Gt) ? Number(Gt) : 0;
    if (_e === "bottom" && (Fn = {
      useGrouping: !!p.dataFormat.bottomCommas,
      minimumFractionDigits: Kn(),
      maximumFractionDigits: Kn()
    }), Oe = Up(Oe), isNaN(Oe))
      return p.runtime.editorErrorMessage = `Unable to parse number from data ${On}. Try reviewing your data and selections in the Data Series section.`, On;
    if (!p.dataFormat)
      return Oe;
    if (p.dataCutoff) {
      let yn = Up(p.dataCutoff);
      Oe < yn && (Oe = yn);
    }
    _e === "left" && Et && An && Ee || _e === "bottom" && Et && An && Ee ? Oe = Oe : Oe = Oe.toLocaleString("en-US", Fn);
    let an = "";
    if (An && _e === "left" && Ee && (Oe = gm(parseFloat(Oe))), mn && _e === "bottom" && Ee && (Oe = gm(parseFloat(Oe))), ct && _e === "left")
      an = ct + an;
    else {
      const yn = _n && kt - 1 !== Ft;
      kn && _e === "left" && !yn && (an += kn);
    }
    return rn && _e === "right" && (an += rn), Ln && _e === "bottom" && (an += Ln), an += Oe, qt && _e === "left" ? an += qt : Rt && _e === "left" && !_n && (an += Rt), Wn && _e === "right" && (an += Wn), Cn && _e === "bottom" && (an += Cn), ht && (an = "-" + an), String(an);
  }, _t = (Oe) => {
    try {
      if (!Oe)
        throw new Bd("COVE: No rowObj in applyLegendToRow");
      if (p.type === "navigation") {
        let _e = Sr[p.color] || Sr.bluegreenreverse;
        return bm(_e[3]);
      }
      return bm();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, un = (Oe) => {
    var _e, Ee;
    return Array.isArray(Oe) ? p.visualizationType === "Forecasting" || (_e = p.series) != null && _e.some((ct) => !!ct.dynamicCategory) ? Oe : (Ee = p == null ? void 0 : p.xAxis) != null && Ee.dataKey ? y.cleanData(Oe, p.xAxis.dataKey) : Oe : [];
  }, En = () => {
    var ct, qt, Kt;
    if (ye === "Sankey")
      return (qt = (ct = p == null ? void 0 : p.data) == null ? void 0 : ct[0]) == null ? void 0 : qt.tableData;
    const Oe = z || R, _e = p.series.find((Ft) => !!Ft.dynamicCategory);
    if (!_e)
      return Oe;
    const Ee = Object.values(p.columns).filter((Ft) => Ft.dataTable).map((Ft) => Ft.name).concat([_e.dynamicCategory, _e.dataKey]);
    return (Kt = p.xAxis) != null && Kt.dataKey && Ee.push(p.xAxis.dataKey), Oe.map((Ft) => Je.pick(Ft, Ee));
  }, $t = (Oe) => {
    const _e = Je.cloneDeep(Oe), Ee = _e.series.find((ct) => !!ct.dynamicCategory);
    if (Ee) {
      const ct = { columnName: Ee.dynamicCategory, valueColumns: [Ee.dataKey] };
      _e.table.pivot = ct;
    }
    return _e;
  };
  let It = /* @__PURE__ */ n.createElement(Zg, null);
  const fn = (Oe) => {
    if (Je.isString(Oe))
      return Je.kebabCase(Oe);
  }, tt = () => {
    var Ee;
    const Oe = (Ne == null ? void 0 : Ne.position) === "bottom" || Va(K), _e = ["chart-container", "p-relative"];
    return Ne != null && Ne.position && (Va(K) && (Ne == null ? void 0 : Ne.position) !== "top" ? _e.push("legend-bottom") : _e.push(`legend-${Ne.position}`)), Ne != null && Ne.hide && _e.push("legend-hidden"), He && _e.push(He), p.barHasBorder || _e.push("chart-bar--no-border"), (Ee = p.brush) != null && Ee.active && (h == null ? void 0 : h.type) === "dashboard" && (!Oe || Ne.hide) && _e.push("dashboard-brush"), _e.push(...Be), _e;
  }, st = () => {
    var Ee, ct;
    const Oe = ["subtext mt-4"], _e = (Ne == null ? void 0 : Ne.position) === "bottom" || Va(K);
    return p.isResponsiveTicks && Oe.push("subtext--responsive-ticks "), (Ee = p.brush) != null && Ee.active && !_e && Oe.push("subtext--brush-active "), (ct = p.brush) != null && ct.active && p.legend.hide && Oe.push("subtext--brush-active "), Oe;
  };
  if (!g) {
    const Oe = /* @__PURE__ */ n.createElement("a", { href: `#data-table-${p.dataKey}`, className: "margin-left-href" }, p.dataKey, " (Go to Table)");
    It = /* @__PURE__ */ n.createElement(n.Fragment, null, t && /* @__PURE__ */ n.createElement(oT, null), /* @__PURE__ */ n.createElement(hf.Responsive, { isEditor: t }, p.newViz && /* @__PURE__ */ n.createElement(dv, { updateConfig: rt, config: p }), p.newViz === void 0 && t && p.runtime && ((nn = p.runtime) == null ? void 0 : nn.editorErrorMessage) && /* @__PURE__ */ n.createElement(Bd, { errorMessage: p.runtime.editorErrorMessage }), !yf(p) && !p.newViz && /* @__PURE__ */ n.createElement(
      "div",
      {
        className: `cdc-chart-inner-container cove-component__content type-${fn(
          p.visualizationType
        )}`,
        "aria-label": zf(p),
        tabIndex: 0
      },
      /* @__PURE__ */ n.createElement(
        qg,
        {
          showTitle: p.showTitle,
          isDashboard: a,
          title: qe,
          superTitle: p.superTitle,
          classes: ["chart-title", `${p.theme}`, "cove-component__header", "mb-3"],
          style: void 0
        }
      ),
      /* @__PURE__ */ n.createElement("div", { className: tt().join(" ") }, (p == null ? void 0 : p.introText) && p.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("section", { className: "introText mb-4" }, Oi(p.introText)), p.filters && !B && p.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(
        jp,
        {
          config: p,
          setConfig: Ye,
          setFilteredData: W,
          filteredData: z,
          excludedData: R,
          filterData: Uo,
          dimensions: Y
        }
      ), /* @__PURE__ */ n.createElement(zp, { skipId: ds(p, Ve), skipMessage: "Skip Over Chart Container" }), ((Nn = p.annotations) == null ? void 0 : Nn.length) > 0 && /* @__PURE__ */ n.createElement(
        zp,
        {
          skipId: ds(p, Ve),
          skipMessage: "Skip over annotations",
          key: "skip-annotations"
        }
      ), /* @__PURE__ */ n.createElement(xv, null, /* @__PURE__ */ n.createElement(
        "div",
        {
          className: Ne.hide || Va(K) || Ne.position === "bottom" || Ne.position === "top" || ye === "Sankey" ? "w-100" : "w-75"
        },
        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(p.visualizationType) && /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: w, parentWidth: _e.width, parentHeight: _e.height }))),
        p.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(Ko, { className: "justify-content-center d-flex", style: { width: "100%" } }, (_e) => /* @__PURE__ */ n.createElement(UE, { ref: w, parentWidth: _e.width, parentHeight: _e.height })),
        p.visualizationType === "Line" && (we ? /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: w, parentWidth: _e.width, parentHeight: _e.height }))) : /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: w, parentWidth: _e.width, parentHeight: _e.height })))),
        p.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
          jp,
          {
            config: p,
            setConfig: Ye,
            setFilteredData: W,
            filteredData: z,
            excludedData: R,
            filterData: Uo,
            dimensions: Y
          }
        ), (p == null ? void 0 : p.introText) && /* @__PURE__ */ n.createElement("section", { className: "introText mb-4", style: { padding: "0px 0 35px" } }, Oi(p.introText)), /* @__PURE__ */ n.createElement("div", { style: { height: "100px", width: "100%", ...Ze } }, /* @__PURE__ */ n.createElement(Ko, null, (_e) => /* @__PURE__ */ n.createElement(lw, { width: _e.width, height: _e.height }))), Pe && /* @__PURE__ */ n.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Oi(Pe))),
        p.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(Ko, { "aria-hidden": "true" }, (_e) => /* @__PURE__ */ n.createElement(SS, { runtime: p.runtime, width: _e.width, height: _e.height }))
      ), !p.legend.hide && p.visualizationType !== "Spark Line" && p.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Pw, { ref: Re, skipId: ds(p, Ve) })), a && p.table && p.table.show && p.table.showDataTableLink ? Oe : d && d, p.description && p.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: st().join(" ") }, Oi(p.description)), /* @__PURE__ */ n.createElement(Md.Section, { classes: ["download-buttons"] }, p.table.showDownloadImgButton && /* @__PURE__ */ n.createElement(
        Md.Button,
        {
          text: "Download Image",
          title: "Download Chart as Image",
          type: "image",
          state: p,
          elementToCapture: ke
        }
      ), p.table.showDownloadPdfButton && /* @__PURE__ */ n.createElement(
        Md.Button,
        {
          text: "Download PDF",
          title: "Download Chart as PDF",
          type: "pdf",
          state: p,
          elementToCapture: ke
        }
      )), (p.xAxis.dataKey && p.table.show && p.visualizationType !== "Spark Line" && p.visualizationType !== "Sankey" || p.visualizationType === "Sankey" && p.table.show) && /* @__PURE__ */ n.createElement(
        Xg,
        {
          key: Ue,
          config: $t(p),
          rawData: p.visualizationType === "Sankey" ? (xt = (At = p == null ? void 0 : p.data) == null ? void 0 : At[0]) == null ? void 0 : xt.tableData : p.table.customTableConfig ? Uo(p.filters, p.data) : p.data,
          runtimeData: En(),
          expandDataTable: p.table.expanded,
          columns: p.columns,
          defaultSortBy: Ue,
          displayGeoName: (_e) => _e,
          applyLegendToRow: _t,
          tableTitle: p.table.label,
          indexTitle: p.table.indexLabel,
          vizTitle: qe,
          viewport: K,
          tabbingId: ds(p, Ve),
          colorScale: S
        }
      ), ((Dn = p == null ? void 0 : p.annotations) == null ? void 0 : Dn.length) > 0 && /* @__PURE__ */ n.createElement(Sp.Dropdown, null), (p == null ? void 0 : p.footnotes) && /* @__PURE__ */ n.createElement("section", { className: "footnotes pt-2 mt-4" }, Oi(p.footnotes)))
    )));
  }
  const pn = {
    brushConfig: xe,
    capitalize: (Oe) => Oe.charAt(0).toUpperCase() + Oe.slice(1),
    convertLineToBarGraph: we,
    clean: un,
    colorPalettes: Sr,
    colorScale: S,
    config: p,
    currentViewport: K,
    dashboardConfig: h,
    debugSvg: r,
    dimensions: Y,
    dynamicLegendItems: U,
    excludedData: R,
    formatDate: sn,
    formatNumber: Dt,
    formatTooltipsDate: gt,
    getXAxisData: (Oe) => Pn(p.runtime.xAxis) ? Nt(Oe[p.runtime.originalXAxis.dataKey]).getTime() : Oe[p.runtime.originalXAxis.dataKey],
    getYAxisData: (Oe, _e) => Oe[_e],
    handleChartAriaLabels: zf,
    handleLineType: gg,
    handleChartTabbing: ds,
    highlight: St,
    handleShowAll: jt,
    imageId: ke,
    isDashboard: a,
    isDebug: r,
    isDraggingAnnotation: j,
    handleDragStateChange: ze,
    isEditor: t,
    isNumber: Vi,
    legend: Ne,
    legendId: Ve,
    legendRef: Re,
    lineOptions: lT,
    loading: g,
    missingRequiredSections: yf,
    outerContainerRef: at,
    parentRef: fe,
    parseDate: Nt,
    rawData: Je.cloneDeep(L) ?? {},
    seriesHighlight: Z,
    setBrushConfig: be,
    setConfig: Ye,
    setDynamicLegendItems: ue,
    setEditing: o,
    setFilteredData: W,
    setParentConfig: i,
    setSeriesHighlight: ee,
    setSharedFilter: c,
    setSharedFilterValue: s,
    svgRef: w,
    tableData: z || R,
    // do not clean table data
    transformedData: un(z || R),
    // do this right before passing to components
    twoColorPalette: Pc,
    unfilteredData: Je.cloneDeep(L),
    updateConfig: rt
  };
  return /* @__PURE__ */ n.createElement(pt.Provider, { value: pn }, /* @__PURE__ */ n.createElement(
    hf.VisualizationWrapper,
    {
      config: p,
      isEditor: t,
      currentViewport: K,
      ref: at,
      imageId: ke,
      showEditorPanel: p == null ? void 0 : p.showEditorPanel
    },
    It
  ));
}, jT = hT;
export {
  jT as C,
  Dw as D,
  WT as E,
  sT as a,
  Nw as b,
  tT as f
};
