import { r as ce, R as a } from "./storybook-index-45401197.es.js";
import { v as Oh, a as vy, i as Mh, b as _h, g as xy } from "./storybook-isSolr-cb863e7a.es.js";
import { _ as Xr, P as by, D as Sy, C as Ey, A as ky, F as Nh, g as wy } from "./storybook-Filters-b7b1162e.es.js";
import { L as tf, a as Ty } from "./storybook-coveUpdateWorker-aacf98e7.es.js";
import { B as Vf } from "./storybook-Button-d74e310e.es.js";
import { p as bm, P as he } from "./storybook-index-43433e35.es.js";
import { d as Cy } from "./storybook-debounce-cc216a80.es.js";
import { a as jf } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { P as Fh } from "./storybook-papaparse.min-b07ddc33.es.js";
import { H as Mi, T as Ay } from "./storybook-index-e5bf02db.es.js";
import { _ as pn } from "./storybook-extends-70f3d2a3.es.js";
import { p as zh, d as Ti, s as Wr, c as Ut, h as Bh, a as kc, e as Gn, t as Bu, f as Ko, m as Rd, i as $h, j as qn, k as Ih, l as Py, n as Ly, G as Ry, o as Uu, q as dr, r as Ku, g as Zo, T as vt, I as Hh } from "./storybook-InputToggle-8206ddd1.es.js";
import { t as Dy, a as Pn, f as Sm, L as Wh, b as ns, g as Ci, S as Oy, M as Dd, D as My } from "./storybook-DataTable-def0ac69.es.js";
import { E as Cr, L as _y } from "./storybook-Loading-f180d060.es.js";
import { b as wc, t as Ny, e as Em, f as Vh, g as Fy, h as zy, j as By, k as jh, m as $y, G as nt, c as On } from "./storybook-Group-e6c0d0df.es.js";
import { s as ss, t as km, a as wm, b as Tm, d as As, B as gr, c as Kn, C as Iy } from "./storybook-Circle-c4db6c75.es.js";
import { R as Hy } from "./storybook-index-633d712d.es.js";
import { e as Ss, a as _n, b as Nn, c as Fn, d as zn, A as _i } from "./storybook-index-66852bf6.es.js";
import { _ as Ni } from "./storybook-lodash-c15d8e1c.es.js";
import { i as Cm, m as Od, c as Am, j as Su, k as Eu, l as ku, n as Uh, o as Wy, p as Kh, b as Pm, d as Lm } from "./storybook-year-bedc547d.es.js";
import { a as ft } from "./storybook-Icon-ed0ee925.es.js";
import { C as Vy, V as jy, a as Yh } from "./storybook-footnoteSymbols-afb8d386.es.js";
import { S as At, T as Je, C as ut, D as Uy } from "./storybook-DataTableEditor-01907213.es.js";
import { T as be } from "./storybook-Tooltip-edc0f7ab.es.js";
import { I as Ha } from "./storybook-InputSelect-20478396.es.js";
import { S as Rm } from "./storybook-icon-check-0ef17e76.es.js";
import { u as Ky, p as Yy, s as Xy, a as qy } from "./storybook-useDataVizClasses-707a8d8e.es.js";
import { n as Xh } from "./storybook-numberFromString-24623c03.es.js";
import { D as Gy } from "./storybook-DataTransform-e292f51b.es.js";
import { c as qh } from "./storybook-cacheBustingString-7a3dd9ba.es.js";
function Dm(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Gh(e) {
  let t = e, n = e;
  e.length === 1 && (t = (d, u) => e(d) - u, n = Zy(e));
  function i(d, u, s, h) {
    for (s == null && (s = 0), h == null && (h = d.length); s < h; ) {
      const m = s + h >>> 1;
      n(d[m], u) < 0 ? s = m + 1 : h = m;
    }
    return s;
  }
  function r(d, u, s, h) {
    for (s == null && (s = 0), h == null && (h = d.length); s < h; ) {
      const m = s + h >>> 1;
      n(d[m], u) > 0 ? h = m : s = m + 1;
    }
    return s;
  }
  function o(d, u, s, h) {
    s == null && (s = 0), h == null && (h = d.length);
    const m = i(d, u, s, h - 1);
    return m > s && t(d[m - 1], u) > -t(d[m], u) ? m - 1 : m;
  }
  return { left: i, center: o, right: r };
}
function Zy(e) {
  return (t, n) => Dm(e(t), n);
}
function* Qy(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
  }
}
function Jy(e, t) {
  let n = 0, i, r = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (i = d - r, r += i / ++n, o += i * (d - r));
  else {
    let d = -1;
    for (let u of e)
      (u = t(u, ++d, e)) != null && (u = +u) >= u && (i = u - r, r += i / ++n, o += i * (u - r));
  }
  if (n > 1)
    return o / (n - 1);
}
function ev(e, t) {
  const n = Jy(e, t);
  return n && Math.sqrt(n);
}
function us(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n < i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function cs(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n > i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Om(e, t, n = 0, i = e.length - 1, r = Dm) {
  for (; i > n; ) {
    if (i - n > 600) {
      const s = i - n + 1, h = t - n + 1, m = Math.log(s), y = 0.5 * Math.exp(2 * m / 3), v = 0.5 * Math.sqrt(m * y * (s - y) / s) * (h - s / 2 < 0 ? -1 : 1), w = Math.max(n, Math.floor(t - h * y / s + v)), E = Math.min(i, Math.floor(t + (s - h) * y / s + v));
      Om(e, t, w, E, r);
    }
    const o = e[t];
    let d = n, u = i;
    for (rs(e, n, t), r(e[i], o) > 0 && rs(e, n, i); d < u; ) {
      for (rs(e, d, u), ++d, --u; r(e[d], o) < 0; )
        ++d;
      for (; r(e[u], o) > 0; )
        --u;
    }
    r(e[n], o) === 0 ? rs(e, n, u) : (++u, rs(e, u, i)), u <= t && (n = u + 1), t <= u && (i = u - 1);
  }
  return e;
}
function rs(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function tv(e, t, n) {
  if (e = Float64Array.from(Qy(e, n)), !!(i = e.length)) {
    if ((t = +t) <= 0 || i < 2)
      return cs(e);
    if (t >= 1)
      return us(e);
    var i, r = (i - 1) * t, o = Math.floor(r), d = us(Om(e, o).subarray(0, o + 1)), u = cs(e.subarray(o + 1));
    return d + (u - d) * (r - o);
  }
}
function nv(e, t) {
  let n = 0, i = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, i += r);
  else {
    let r = -1;
    for (let o of e)
      (o = t(o, ++r, e)) != null && (o = +o) >= o && (++n, i += o);
  }
  if (n)
    return i / n;
}
function rv(e, t) {
  return tv(e, 0.5, t);
}
class Zh extends Map {
  constructor(t, n = ov) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [i, r] of t)
        this.set(i, r);
  }
  get(t) {
    return super.get(Qh(this, t));
  }
  has(t) {
    return super.has(Qh(this, t));
  }
  set(t, n) {
    return super.set(av(this, t), n);
  }
  delete(t) {
    return super.delete(iv(this, t));
  }
}
function Qh({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : n;
}
function av({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : (e.set(i, n), n);
}
function iv({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) && (n = e.get(i), e.delete(i)), n;
}
function ov(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function lv(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++i < r; )
    o[i] = e + i * n;
  return o;
}
const Jh = Symbol("implicit");
function Uf() {
  var e = new Zh(), t = [], n = [], i = Jh;
  function r(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (i !== Jh)
        return i;
      e.set(o, d = t.push(o) - 1);
    }
    return n[d % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Zh();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (i = o, r) : i;
  }, r.copy = function() {
    return Uf(t, n).unknown(i);
  }, wc.apply(r, arguments), r;
}
function Kf() {
  var e = Uf().unknown(void 0), t = e.domain, n = e.range, i = 0, r = 1, o, d, u = !1, s = 0, h = 0, m = 0.5;
  delete e.unknown;
  function y() {
    var v = t().length, w = r < i, E = w ? r : i, R = w ? i : r;
    o = (R - E) / Math.max(1, v - s + h * 2), u && (o = Math.floor(o)), E += (R - E - o * (v - s)) * m, d = o * (1 - s), u && (E = Math.round(E), d = Math.round(d));
    var C = lv(v).map(function(g) {
      return E + o * g;
    });
    return n(w ? C.reverse() : C);
  }
  return e.domain = function(v) {
    return arguments.length ? (t(v), y()) : t();
  }, e.range = function(v) {
    return arguments.length ? ([i, r] = v, i = +i, r = +r, y()) : [i, r];
  }, e.rangeRound = function(v) {
    return [i, r] = v, i = +i, r = +r, u = !0, y();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(v) {
    return arguments.length ? (u = !!v, y()) : u;
  }, e.padding = function(v) {
    return arguments.length ? (s = Math.min(1, h = +v), y()) : s;
  }, e.paddingInner = function(v) {
    return arguments.length ? (s = Math.min(1, v), y()) : s;
  }, e.paddingOuter = function(v) {
    return arguments.length ? (h = +v, y()) : h;
  }, e.align = function(v) {
    return arguments.length ? (m = Math.max(0, Math.min(1, v)), y()) : m;
  }, e.copy = function() {
    return Kf(t(), [i, r]).round(u).paddingInner(s).paddingOuter(h).align(m);
  }, wc.apply(y(), arguments);
}
function Mm(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Mm(t());
  }, e;
}
function sv() {
  return Mm(Kf.apply(null, arguments).paddingInner(1));
}
function _m(e, t) {
  e = e.slice();
  var n = 0, i = e.length - 1, r = e[n], o = e[i], d;
  return o < r && (d = n, n = i, i = d, d = r, r = o, o = d), e[n] = t.floor(r), e[i] = t.ceil(o), e;
}
function ep(e) {
  return Math.log(e);
}
function tp(e) {
  return Math.exp(e);
}
function uv(e) {
  return -Math.log(-e);
}
function cv(e) {
  return -Math.exp(-e);
}
function dv(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function fv(e) {
  return e === 10 ? dv : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function hv(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function np(e) {
  return (t, n) => -e(-t, n);
}
function pv(e) {
  const t = e(ep, tp), n = t.domain;
  let i = 10, r, o;
  function d() {
    return r = hv(i), o = fv(i), n()[0] < 0 ? (r = np(r), o = np(o), e(uv, cv)) : e(ep, tp), t;
  }
  return t.base = function(u) {
    return arguments.length ? (i = +u, d()) : i;
  }, t.domain = function(u) {
    return arguments.length ? (n(u), d()) : n();
  }, t.ticks = (u) => {
    const s = n();
    let h = s[0], m = s[s.length - 1];
    const y = m < h;
    y && ([h, m] = [m, h]);
    let v = r(h), w = r(m), E, R;
    const C = u == null ? 10 : +u;
    let g = [];
    if (!(i % 1) && w - v < C) {
      if (v = Math.floor(v), w = Math.ceil(w), h > 0) {
        for (; v <= w; ++v)
          for (E = 1; E < i; ++E)
            if (R = v < 0 ? E / o(-v) : E * o(v), !(R < h)) {
              if (R > m)
                break;
              g.push(R);
            }
      } else
        for (; v <= w; ++v)
          for (E = i - 1; E >= 1; --E)
            if (R = v > 0 ? E / o(-v) : E * o(v), !(R < h)) {
              if (R > m)
                break;
              g.push(R);
            }
      g.length * 2 < C && (g = Vh(h, m, C));
    } else
      g = Vh(v, w, Math.min(w - v, C)).map(o);
    return y ? g.reverse() : g;
  }, t.tickFormat = (u, s) => {
    if (u == null && (u = 10), s == null && (s = i === 10 ? "s" : ","), typeof s != "function" && (!(i % 1) && (s = Fy(s)).precision == null && (s.trim = !0), s = zy(s)), u === 1 / 0)
      return s;
    const h = Math.max(1, i * u / t.ticks().length);
    return (m) => {
      let y = m / o(Math.round(r(m)));
      return y * i < i - 0.5 && (y *= i), y <= h ? s(m) : "";
    };
  }, t.nice = () => n(_m(n(), {
    floor: (u) => o(Math.floor(r(u))),
    ceil: (u) => o(Math.ceil(r(u)))
  })), t;
}
function Nm() {
  const e = pv(Ny()).domain([1, 10]);
  return e.copy = () => Em(e, Nm()).base(e.base()), wc.apply(e, arguments), e;
}
const Yu = Cm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Yu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Cm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Yu);
Yu.range;
function mv(e, t, n, i, r, o) {
  const d = [
    [ss, 1, Su],
    [ss, 5, 5 * Su],
    [ss, 15, 15 * Su],
    [ss, 30, 30 * Su],
    [o, 1, Eu],
    [o, 5, 5 * Eu],
    [o, 15, 15 * Eu],
    [o, 30, 30 * Eu],
    [r, 1, ku],
    [r, 3, 3 * ku],
    [r, 6, 6 * ku],
    [r, 12, 12 * ku],
    [i, 1, Uh],
    [i, 2, 2 * Uh],
    [n, 1, Wy],
    [t, 1, Kh],
    [t, 3, 3 * Kh],
    [e, 1, Od]
  ];
  function u(h, m, y) {
    const v = m < h;
    v && ([h, m] = [m, h]);
    const w = y && typeof y.range == "function" ? y : s(h, m, y), E = w ? w.range(h, +m + 1) : [];
    return v ? E.reverse() : E;
  }
  function s(h, m, y) {
    const v = Math.abs(m - h) / y, w = By(([, , C]) => C).right(d, v);
    if (w === d.length)
      return e.every(jh(h / Od, m / Od, y));
    if (w === 0)
      return Yu.every(Math.max(jh(h, m, y), 1));
    const [E, R] = d[v / d[w - 1][2] < d[w][2] / v ? w - 1 : w];
    return E.every(R);
  }
  return [u, s];
}
const [gv, yv] = mv(Am, Tm, Lm, Pm, wm, km);
function vv(e) {
  return new Date(e);
}
function xv(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Fm(e, t, n, i, r, o, d, u, s, h) {
  var m = $y(), y = m.invert, v = m.domain, w = h(".%L"), E = h(":%S"), R = h("%I:%M"), C = h("%I %p"), g = h("%a %d"), _ = h("%b %d"), P = h("%B"), M = h("%Y");
  function N(T) {
    return (s(T) < T ? w : u(T) < T ? E : d(T) < T ? R : o(T) < T ? C : i(T) < T ? r(T) < T ? g : _ : n(T) < T ? P : M)(T);
  }
  return m.invert = function(T) {
    return new Date(y(T));
  }, m.domain = function(T) {
    return arguments.length ? v(Array.from(T, xv)) : v().map(vv);
  }, m.ticks = function(T) {
    var U = v();
    return e(U[0], U[U.length - 1], T ?? 10);
  }, m.tickFormat = function(T, U) {
    return U == null ? N : h(U);
  }, m.nice = function(T) {
    var U = v();
    return (!T || typeof T.range != "function") && (T = t(U[0], U[U.length - 1], T ?? 10)), T ? v(_m(U, T)) : m;
  }, m.copy = function() {
    return Em(m, Fm(e, t, n, i, r, o, d, u, s, h));
  }, m;
}
function bv() {
  return wc.apply(Fm(gv, yv, Am, Tm, Lm, Pm, wm, km, ss, Dy).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var Sv = As("domain", "range", "reverse", "align", "padding", "round");
function nf(e) {
  return Sv(Kf(), e);
}
var Ev = As("domain", "range", "reverse", "align", "padding", "round");
function Yo(e) {
  return Ev(sv(), e);
}
var kv = As("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function wv(e) {
  return kv(bv(), e);
}
var Tv = As("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function Xu(e) {
  return Tv(Nm(), e);
}
var Cv = As("domain", "range", "reverse", "unknown");
function zm(e) {
  return Cv(Uf(), e);
}
function Av(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Pv(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(i, r, o) {
    return t == null || o.length <= t || r % Math.round((o.length - 1) / t) === 0;
  });
}
function Lv(e) {
  return e == null ? void 0 : e.toString();
}
var Fi = [], Rv = function() {
  return Fi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Dv = function() {
  return Fi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, rp = "ResizeObserver loop completed with undelivered notifications.", Ov = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: rp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = rp), window.dispatchEvent(e);
}, Es;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Es || (Es = {}));
var zi = function(e) {
  return Object.freeze(e);
}, Bm = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zi(this);
  }
  return e;
}(), $m = function() {
  function e(t, n, i, r) {
    return this.x = t, this.y = n, this.width = i, this.height = r, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, i = t.y, r = t.top, o = t.right, d = t.bottom, u = t.left, s = t.width, h = t.height;
    return { x: n, y: i, top: r, right: o, bottom: d, left: u, width: s, height: h };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Yf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Im = function(e) {
  if (Yf(e)) {
    var t = e.getBBox(), n = t.width, i = t.height;
    return !n && !i;
  }
  var r = e, o = r.offsetWidth, d = r.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, ap = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Mv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ds = typeof window < "u" ? window : {}, wu = /* @__PURE__ */ new WeakMap(), ip = /auto|scroll/, _v = /^tb|vertical/, Nv = /msie|trident/i.test(ds.navigator && ds.navigator.userAgent), Vr = function(e) {
  return parseFloat(e || "0");
}, qo = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Bm((n ? t : e) || 0, (n ? e : t) || 0);
}, op = zi({
  devicePixelContentBoxSize: qo(),
  borderBoxSize: qo(),
  contentBoxSize: qo(),
  contentRect: new $m(0, 0, 0, 0)
}), Hm = function(e, t) {
  if (t === void 0 && (t = !1), wu.has(e) && !t)
    return wu.get(e);
  if (Im(e))
    return wu.set(e, op), op;
  var n = getComputedStyle(e), i = Yf(e) && e.ownerSVGElement && e.getBBox(), r = !Nv && n.boxSizing === "border-box", o = _v.test(n.writingMode || ""), d = !i && ip.test(n.overflowY || ""), u = !i && ip.test(n.overflowX || ""), s = i ? 0 : Vr(n.paddingTop), h = i ? 0 : Vr(n.paddingRight), m = i ? 0 : Vr(n.paddingBottom), y = i ? 0 : Vr(n.paddingLeft), v = i ? 0 : Vr(n.borderTopWidth), w = i ? 0 : Vr(n.borderRightWidth), E = i ? 0 : Vr(n.borderBottomWidth), R = i ? 0 : Vr(n.borderLeftWidth), C = y + h, g = s + m, _ = R + w, P = v + E, M = u ? e.offsetHeight - P - e.clientHeight : 0, N = d ? e.offsetWidth - _ - e.clientWidth : 0, T = r ? C + _ : 0, U = r ? g + P : 0, V = i ? i.width : Vr(n.width) - T - N, G = i ? i.height : Vr(n.height) - U - M, ue = V + C + N + _, Z = G + g + M + P, $ = zi({
    devicePixelContentBoxSize: qo(Math.round(V * devicePixelRatio), Math.round(G * devicePixelRatio), o),
    borderBoxSize: qo(ue, Z, o),
    contentBoxSize: qo(V, G, o),
    contentRect: new $m(y, s, V, G)
  });
  return wu.set(e, $), $;
}, Wm = function(e, t, n) {
  var i = Hm(e, n), r = i.borderBoxSize, o = i.contentBoxSize, d = i.devicePixelContentBoxSize;
  switch (t) {
    case Es.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Es.BORDER_BOX:
      return r;
    default:
      return o;
  }
}, Vm = function() {
  function e(t) {
    var n = Hm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = zi([n.borderBoxSize]), this.contentBoxSize = zi([n.contentBoxSize]), this.devicePixelContentBoxSize = zi([n.devicePixelContentBoxSize]);
  }
  return e;
}(), jm = function(e) {
  if (Im(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Fv = function() {
  var e = 1 / 0, t = [];
  Fi.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var u = [];
      d.activeTargets.forEach(function(h) {
        var m = new Vm(h.target), y = jm(h.target);
        u.push(m), h.lastReportedSize = Wm(h.target, h.observedBox), y < e && (e = y);
      }), t.push(function() {
        d.callback.call(d.observer, u, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var n = 0, i = t; n < i.length; n++) {
    var r = i[n];
    r();
  }
  return e;
}, lp = function(e) {
  Fi.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(r) {
      r.isActive() && (jm(r.target) > e ? n.activeTargets.push(r) : n.skippedTargets.push(r));
    });
  });
}, zv = function() {
  var e = 0;
  for (lp(e); Rv(); )
    e = Fv(), lp(e);
  return Dv() && Ov(), e > 0;
}, Md, Um = [], Bv = function() {
  return Um.splice(0).forEach(function(e) {
    return e();
  });
}, $v = function(e) {
  if (!Md) {
    var t = 0, n = document.createTextNode(""), i = { characterData: !0 };
    new MutationObserver(function() {
      return Bv();
    }).observe(n, i), Md = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Um.push(e), Md();
}, Iv = function(e) {
  $v(function() {
    requestAnimationFrame(e);
  });
}, $u = 0, Hv = function() {
  return !!$u;
}, Wv = 250, Vv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, sp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], up = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, _d = !1, jv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Wv), !_d) {
      _d = !0;
      var i = up(t);
      Iv(function() {
        var r = !1;
        try {
          r = zv();
        } finally {
          if (_d = !1, t = i - up(), !Hv())
            return;
          r ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Vv);
    };
    document.body ? n() : ds.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), sp.forEach(function(n) {
      return ds.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), sp.forEach(function(n) {
      return ds.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), rf = new jv(), cp = function(e) {
  !$u && e > 0 && rf.start(), $u += e, !$u && rf.stop();
}, Uv = function(e) {
  return !Yf(e) && !Mv(e) && getComputedStyle(e).display === "inline";
}, Kv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Es.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Wm(this.target, this.observedBox, !0);
    return Uv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Yv = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Tu = /* @__PURE__ */ new WeakMap(), dp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Cu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var i = new Yv(t, n);
    Tu.set(t, i);
  }, e.observe = function(t, n, i) {
    var r = Tu.get(t), o = r.observationTargets.length === 0;
    dp(r.observationTargets, n) < 0 && (o && Fi.push(r), r.observationTargets.push(new Kv(n, i && i.box)), cp(1), rf.schedule());
  }, e.unobserve = function(t, n) {
    var i = Tu.get(t), r = dp(i.observationTargets, n), o = i.observationTargets.length === 1;
    r >= 0 && (o && Fi.splice(Fi.indexOf(i), 1), i.observationTargets.splice(r, 1), cp(-1));
  }, e.disconnect = function(t) {
    var n = this, i = Tu.get(t);
    i.observationTargets.slice().forEach(function(r) {
      return n.unobserve(t, r.target);
    }), i.activeTargets.splice(0, i.activeTargets.length);
  }, e;
}(), Xv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Cu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ap(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Cu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ap(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Cu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Cu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const qv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Xv,
  ResizeObserverEntry: Vm,
  ResizeObserverSize: Bm
}, Symbol.toStringTag, { value: "Module" })), Gv = /* @__PURE__ */ jf(qv);
var fp = Xm, _a = Ym(bm), Zv = Ym(Cy), Wo = ex(ce), Qv = Gv, Jv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Km(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (Km = function(r) {
    return r ? n : t;
  })(e);
}
function ex(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = Km(t);
  if (n && n.has(e))
    return n.get(e);
  var i = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = r ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(i, o, d) : i[o] = e[o];
    }
  return i.default = e, n && n.set(e, i), i;
}
function Ym(e) {
  return e && e.__esModule ? e : { default: e };
}
function qu() {
  return qu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, qu.apply(this, arguments);
}
function tx(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var nx = [];
function Xm(e) {
  var t = e.className, n = e.children, i = e.debounceTime, r = i === void 0 ? 300 : i, o = e.ignoreDimensions, d = o === void 0 ? nx : o, u = e.parentSizeStyles, s = u === void 0 ? {
    width: "100%",
    height: "100%"
  } : u, h = e.enableDebounceLeadingCall, m = h === void 0 ? !0 : h, y = tx(e, Jv), v = (0, Wo.useRef)(null), w = (0, Wo.useRef)(0), E = (0, Wo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), R = E[0], C = E[1], g = (0, Wo.useMemo)(function() {
    var _ = Array.isArray(d) ? d : [d];
    return (0, Zv.default)(function(P) {
      C(function(M) {
        var N = Object.keys(M), T = N.filter(function(V) {
          return M[V] !== P[V];
        }), U = T.every(function(V) {
          return _.includes(V);
        });
        return U ? M : P;
      });
    }, r, {
      leading: m
    });
  }, [r, m, d]);
  return (0, Wo.useEffect)(function() {
    var _ = new Qv.ResizeObserver(function(P) {
      P === void 0 && (P = []), P.forEach(function(M) {
        var N = M.contentRect, T = N.left, U = N.top, V = N.width, G = N.height;
        w.current = window.requestAnimationFrame(function() {
          g({
            width: V,
            height: G,
            top: U,
            left: T
          });
        });
      });
    });
    return v.current && _.observe(v.current), function() {
      window.cancelAnimationFrame(w.current), _.disconnect(), g != null && g.cancel && g.cancel();
    };
  }, [g]), /* @__PURE__ */ Wo.default.createElement("div", qu({
    style: s,
    ref: v,
    className: t
  }, y), n(qu({}, R, {
    ref: v.current,
    resize: g
  })));
}
Xm.propTypes = {
  className: _a.default.string,
  debounceTime: _a.default.number,
  enableDebounceLeadingCall: _a.default.bool,
  ignoreDimensions: _a.default.oneOfType([_a.default.any, _a.default.arrayOf(_a.default.any)]),
  children: _a.default.func.isRequired
};
var Nd = /* @__PURE__ */ new Date(), Fd = /* @__PURE__ */ new Date();
function ha(e, t, n, i) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, r.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, r.round = function(o) {
    var d = r(o), u = r.ceil(o);
    return o - d < u - o ? d : u;
  }, r.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, r.range = function(o, d, u) {
    var s = [], h;
    if (o = r.ceil(o), u = u == null ? 1 : Math.floor(u), !(o < d) || !(u > 0))
      return s;
    do
      s.push(h = /* @__PURE__ */ new Date(+o)), t(o, u), e(o);
    while (h < o && o < d);
    return s;
  }, r.filter = function(o) {
    return ha(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, u) {
      if (d >= d)
        if (u < 0)
          for (; ++u <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --u >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, n && (r.count = function(o, d) {
    return Nd.setTime(+o), Fd.setTime(+d), e(Nd), e(Fd), Math.floor(n(Nd, Fd));
  }, r.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(i ? function(d) {
      return i(d) % o === 0;
    } : function(d) {
      return r.count(0, d) % o === 0;
    }) : r;
  }), r;
}
const rx = 1e3, Xf = rx * 60, ax = Xf * 60, qf = ax * 24, qm = qf * 7;
var Gm = ha(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Xf) / qf,
  (e) => e.getDate() - 1
);
const Zm = Gm;
Gm.range;
function Wi(e) {
  return ha(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setDate(t.getDate() + n * 7);
  }, function(t, n) {
    return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Xf) / qm;
  });
}
var Qm = Wi(0), Gu = Wi(1), ix = Wi(2), ox = Wi(3), Qo = Wi(4), lx = Wi(5), sx = Wi(6);
Qm.range;
Gu.range;
ix.range;
ox.range;
Qo.range;
lx.range;
sx.range;
var Gf = ha(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Gf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ha(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setFullYear(t.getFullYear() + n * e);
  });
};
const ks = Gf;
Gf.range;
var Jm = ha(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / qf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const eg = Jm;
Jm.range;
function Vi(e) {
  return ha(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, function(t, n) {
    return (n - t) / qm;
  });
}
var tg = Vi(0), Zu = Vi(1), ux = Vi(2), cx = Vi(3), Jo = Vi(4), dx = Vi(5), fx = Vi(6);
tg.range;
Zu.range;
ux.range;
cx.range;
Jo.range;
dx.range;
fx.range;
var Zf = ha(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
Zf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ha(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
};
const ws = Zf;
Zf.range;
function zd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Bd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function as(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function hx(e) {
  var t = e.dateTime, n = e.date, i = e.time, r = e.periods, o = e.days, d = e.shortDays, u = e.months, s = e.shortMonths, h = is(r), m = os(r), y = is(o), v = os(o), w = is(d), E = os(d), R = is(u), C = os(u), g = is(s), _ = os(s), P = {
    a: Q,
    A: ae,
    b: te,
    B: re,
    c: null,
    d: vp,
    e: vp,
    f: Fx,
    g: Kx,
    G: Xx,
    H: Mx,
    I: _x,
    j: Nx,
    L: ng,
    m: zx,
    M: Bx,
    p: ie,
    q: ge,
    Q: Sp,
    s: Ep,
    S: $x,
    u: Ix,
    U: Hx,
    V: Wx,
    w: Vx,
    W: jx,
    x: null,
    X: null,
    y: Ux,
    Y: Yx,
    Z: qx,
    "%": bp
  }, M = {
    a: ve,
    A: Se,
    b: ye,
    B: ee,
    c: null,
    d: xp,
    e: xp,
    f: Jx,
    g: ub,
    G: db,
    H: Gx,
    I: Zx,
    j: Qx,
    L: ag,
    m: eb,
    M: tb,
    p: Ee,
    q: He,
    Q: Sp,
    s: Ep,
    S: nb,
    u: rb,
    U: ab,
    V: ib,
    w: ob,
    W: lb,
    x: null,
    X: null,
    y: sb,
    Y: cb,
    Z: fb,
    "%": bp
  }, N = {
    a: ue,
    A: Z,
    b: $,
    B: H,
    c: j,
    d: gp,
    e: gp,
    f: Lx,
    g: mp,
    G: pp,
    H: yp,
    I: yp,
    j: Tx,
    L: Px,
    m: wx,
    M: Cx,
    p: G,
    q: kx,
    Q: Dx,
    s: Ox,
    S: Ax,
    u: vx,
    U: xx,
    V: bx,
    w: yx,
    W: Sx,
    x: F,
    X,
    y: mp,
    Y: pp,
    Z: Ex,
    "%": Rx
  };
  P.x = T(n, P), P.X = T(i, P), P.c = T(t, P), M.x = T(n, M), M.X = T(i, M), M.c = T(t, M);
  function T(we, fe) {
    return function(Ae) {
      var ne = [], $e = -1, Le = 0, Ke = we.length, Ge, et, Ze;
      for (Ae instanceof Date || (Ae = /* @__PURE__ */ new Date(+Ae)); ++$e < Ke; )
        we.charCodeAt($e) === 37 && (ne.push(we.slice(Le, $e)), (et = hp[Ge = we.charAt(++$e)]) != null ? Ge = we.charAt(++$e) : et = Ge === "e" ? " " : "0", (Ze = fe[Ge]) && (Ge = Ze(Ae, et)), ne.push(Ge), Le = $e + 1);
      return ne.push(we.slice(Le, $e)), ne.join("");
    };
  }
  function U(we, fe) {
    return function(Ae) {
      var ne = as(1900, void 0, 1), $e = V(ne, we, Ae += "", 0), Le, Ke;
      if ($e != Ae.length)
        return null;
      if ("Q" in ne)
        return new Date(ne.Q);
      if ("s" in ne)
        return new Date(ne.s * 1e3 + ("L" in ne ? ne.L : 0));
      if (fe && !("Z" in ne) && (ne.Z = 0), "p" in ne && (ne.H = ne.H % 12 + ne.p * 12), ne.m === void 0 && (ne.m = "q" in ne ? ne.q : 0), "V" in ne) {
        if (ne.V < 1 || ne.V > 53)
          return null;
        "w" in ne || (ne.w = 1), "Z" in ne ? (Le = Bd(as(ne.y, 0, 1)), Ke = Le.getUTCDay(), Le = Ke > 4 || Ke === 0 ? Zu.ceil(Le) : Zu(Le), Le = eg.offset(Le, (ne.V - 1) * 7), ne.y = Le.getUTCFullYear(), ne.m = Le.getUTCMonth(), ne.d = Le.getUTCDate() + (ne.w + 6) % 7) : (Le = zd(as(ne.y, 0, 1)), Ke = Le.getDay(), Le = Ke > 4 || Ke === 0 ? Gu.ceil(Le) : Gu(Le), Le = Zm.offset(Le, (ne.V - 1) * 7), ne.y = Le.getFullYear(), ne.m = Le.getMonth(), ne.d = Le.getDate() + (ne.w + 6) % 7);
      } else
        ("W" in ne || "U" in ne) && ("w" in ne || (ne.w = "u" in ne ? ne.u % 7 : "W" in ne ? 1 : 0), Ke = "Z" in ne ? Bd(as(ne.y, 0, 1)).getUTCDay() : zd(as(ne.y, 0, 1)).getDay(), ne.m = 0, ne.d = "W" in ne ? (ne.w + 6) % 7 + ne.W * 7 - (Ke + 5) % 7 : ne.w + ne.U * 7 - (Ke + 6) % 7);
      return "Z" in ne ? (ne.H += ne.Z / 100 | 0, ne.M += ne.Z % 100, Bd(ne)) : zd(ne);
    };
  }
  function V(we, fe, Ae, ne) {
    for (var $e = 0, Le = fe.length, Ke = Ae.length, Ge, et; $e < Le; ) {
      if (ne >= Ke)
        return -1;
      if (Ge = fe.charCodeAt($e++), Ge === 37) {
        if (Ge = fe.charAt($e++), et = N[Ge in hp ? fe.charAt($e++) : Ge], !et || (ne = et(we, Ae, ne)) < 0)
          return -1;
      } else if (Ge != Ae.charCodeAt(ne++))
        return -1;
    }
    return ne;
  }
  function G(we, fe, Ae) {
    var ne = h.exec(fe.slice(Ae));
    return ne ? (we.p = m.get(ne[0].toLowerCase()), Ae + ne[0].length) : -1;
  }
  function ue(we, fe, Ae) {
    var ne = w.exec(fe.slice(Ae));
    return ne ? (we.w = E.get(ne[0].toLowerCase()), Ae + ne[0].length) : -1;
  }
  function Z(we, fe, Ae) {
    var ne = y.exec(fe.slice(Ae));
    return ne ? (we.w = v.get(ne[0].toLowerCase()), Ae + ne[0].length) : -1;
  }
  function $(we, fe, Ae) {
    var ne = g.exec(fe.slice(Ae));
    return ne ? (we.m = _.get(ne[0].toLowerCase()), Ae + ne[0].length) : -1;
  }
  function H(we, fe, Ae) {
    var ne = R.exec(fe.slice(Ae));
    return ne ? (we.m = C.get(ne[0].toLowerCase()), Ae + ne[0].length) : -1;
  }
  function j(we, fe, Ae) {
    return V(we, t, fe, Ae);
  }
  function F(we, fe, Ae) {
    return V(we, n, fe, Ae);
  }
  function X(we, fe, Ae) {
    return V(we, i, fe, Ae);
  }
  function Q(we) {
    return d[we.getDay()];
  }
  function ae(we) {
    return o[we.getDay()];
  }
  function te(we) {
    return s[we.getMonth()];
  }
  function re(we) {
    return u[we.getMonth()];
  }
  function ie(we) {
    return r[+(we.getHours() >= 12)];
  }
  function ge(we) {
    return 1 + ~~(we.getMonth() / 3);
  }
  function ve(we) {
    return d[we.getUTCDay()];
  }
  function Se(we) {
    return o[we.getUTCDay()];
  }
  function ye(we) {
    return s[we.getUTCMonth()];
  }
  function ee(we) {
    return u[we.getUTCMonth()];
  }
  function Ee(we) {
    return r[+(we.getUTCHours() >= 12)];
  }
  function He(we) {
    return 1 + ~~(we.getUTCMonth() / 3);
  }
  return {
    format: function(we) {
      var fe = T(we += "", P);
      return fe.toString = function() {
        return we;
      }, fe;
    },
    parse: function(we) {
      var fe = U(we += "", !1);
      return fe.toString = function() {
        return we;
      }, fe;
    },
    utcFormat: function(we) {
      var fe = T(we += "", M);
      return fe.toString = function() {
        return we;
      }, fe;
    },
    utcParse: function(we) {
      var fe = U(we += "", !0);
      return fe.toString = function() {
        return we;
      }, fe;
    }
  };
}
var hp = { "-": "", _: " ", 0: "0" }, Wn = /^\s*\d+/, px = /^%/, mx = /[\\^$*+?|[\]().{}]/g;
function Zt(e, t, n) {
  var i = e < 0 ? "-" : "", r = (i ? -e : e) + "", o = r.length;
  return i + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function gx(e) {
  return e.replace(mx, "\\$&");
}
function is(e) {
  return new RegExp("^(?:" + e.map(gx).join("|") + ")", "i");
}
function os(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function yx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 1));
  return i ? (e.w = +i[0], n + i[0].length) : -1;
}
function vx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 1));
  return i ? (e.u = +i[0], n + i[0].length) : -1;
}
function xx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.U = +i[0], n + i[0].length) : -1;
}
function bx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.V = +i[0], n + i[0].length) : -1;
}
function Sx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.W = +i[0], n + i[0].length) : -1;
}
function pp(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 4));
  return i ? (e.y = +i[0], n + i[0].length) : -1;
}
function mp(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
}
function Ex(e, t, n) {
  var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
}
function kx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 1));
  return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
}
function wx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
}
function gp(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.d = +i[0], n + i[0].length) : -1;
}
function Tx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 3));
  return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
}
function yp(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.H = +i[0], n + i[0].length) : -1;
}
function Cx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.M = +i[0], n + i[0].length) : -1;
}
function Ax(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 2));
  return i ? (e.S = +i[0], n + i[0].length) : -1;
}
function Px(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 3));
  return i ? (e.L = +i[0], n + i[0].length) : -1;
}
function Lx(e, t, n) {
  var i = Wn.exec(t.slice(n, n + 6));
  return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
}
function Rx(e, t, n) {
  var i = px.exec(t.slice(n, n + 1));
  return i ? n + i[0].length : -1;
}
function Dx(e, t, n) {
  var i = Wn.exec(t.slice(n));
  return i ? (e.Q = +i[0], n + i[0].length) : -1;
}
function Ox(e, t, n) {
  var i = Wn.exec(t.slice(n));
  return i ? (e.s = +i[0], n + i[0].length) : -1;
}
function vp(e, t) {
  return Zt(e.getDate(), t, 2);
}
function Mx(e, t) {
  return Zt(e.getHours(), t, 2);
}
function _x(e, t) {
  return Zt(e.getHours() % 12 || 12, t, 2);
}
function Nx(e, t) {
  return Zt(1 + Zm.count(ks(e), e), t, 3);
}
function ng(e, t) {
  return Zt(e.getMilliseconds(), t, 3);
}
function Fx(e, t) {
  return ng(e, t) + "000";
}
function zx(e, t) {
  return Zt(e.getMonth() + 1, t, 2);
}
function Bx(e, t) {
  return Zt(e.getMinutes(), t, 2);
}
function $x(e, t) {
  return Zt(e.getSeconds(), t, 2);
}
function Ix(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Hx(e, t) {
  return Zt(Qm.count(ks(e) - 1, e), t, 2);
}
function rg(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Qo(e) : Qo.ceil(e);
}
function Wx(e, t) {
  return e = rg(e), Zt(Qo.count(ks(e), e) + (ks(e).getDay() === 4), t, 2);
}
function Vx(e) {
  return e.getDay();
}
function jx(e, t) {
  return Zt(Gu.count(ks(e) - 1, e), t, 2);
}
function Ux(e, t) {
  return Zt(e.getFullYear() % 100, t, 2);
}
function Kx(e, t) {
  return e = rg(e), Zt(e.getFullYear() % 100, t, 2);
}
function Yx(e, t) {
  return Zt(e.getFullYear() % 1e4, t, 4);
}
function Xx(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Qo(e) : Qo.ceil(e), Zt(e.getFullYear() % 1e4, t, 4);
}
function qx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Zt(t / 60 | 0, "0", 2) + Zt(t % 60, "0", 2);
}
function xp(e, t) {
  return Zt(e.getUTCDate(), t, 2);
}
function Gx(e, t) {
  return Zt(e.getUTCHours(), t, 2);
}
function Zx(e, t) {
  return Zt(e.getUTCHours() % 12 || 12, t, 2);
}
function Qx(e, t) {
  return Zt(1 + eg.count(ws(e), e), t, 3);
}
function ag(e, t) {
  return Zt(e.getUTCMilliseconds(), t, 3);
}
function Jx(e, t) {
  return ag(e, t) + "000";
}
function eb(e, t) {
  return Zt(e.getUTCMonth() + 1, t, 2);
}
function tb(e, t) {
  return Zt(e.getUTCMinutes(), t, 2);
}
function nb(e, t) {
  return Zt(e.getUTCSeconds(), t, 2);
}
function rb(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function ab(e, t) {
  return Zt(tg.count(ws(e) - 1, e), t, 2);
}
function ig(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Jo(e) : Jo.ceil(e);
}
function ib(e, t) {
  return e = ig(e), Zt(Jo.count(ws(e), e) + (ws(e).getUTCDay() === 4), t, 2);
}
function ob(e) {
  return e.getUTCDay();
}
function lb(e, t) {
  return Zt(Zu.count(ws(e) - 1, e), t, 2);
}
function sb(e, t) {
  return Zt(e.getUTCFullYear() % 100, t, 2);
}
function ub(e, t) {
  return e = ig(e), Zt(e.getUTCFullYear() % 100, t, 2);
}
function cb(e, t) {
  return Zt(e.getUTCFullYear() % 1e4, t, 4);
}
function db(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Jo(e) : Jo.ceil(e), Zt(e.getUTCFullYear() % 1e4, t, 4);
}
function fb() {
  return "+0000";
}
function bp() {
  return "%";
}
function Sp(e) {
  return +e;
}
function Ep(e) {
  return Math.floor(+e / 1e3);
}
var Vo, af, og;
hb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function hb(e) {
  return Vo = hx(e), af = Vo.format, og = Vo.parse, Vo.utcFormat, Vo.utcParse, Vo;
}
const Ct = ce.createContext({}), Wt = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (Wt.str(e) || Wt.num(e))
      return e === t;
    if (Wt.obj(e) && Wt.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let n;
    for (n in e)
      if (!(n in t))
        return !1;
    for (n in t)
      if (e[n] !== t[n])
        return !1;
    return Wt.und(n) ? e === t : !0;
  }
};
function pb(e, t) {
  return t === void 0 && (t = !0), (n) => (Wt.arr(n) ? n : Object.keys(n)).reduce((i, r) => {
    const o = t ? r[0].toLowerCase() + r.substring(1) : r;
    return i[o] = e(o), i;
  }, e);
}
function lg() {
  const e = ce.useState(!1), t = e[1];
  return ce.useCallback(() => t((i) => !i), []);
}
function Ai(e, t) {
  return Wt.und(e) || Wt.nul(e) ? t : e;
}
function Xo(e) {
  return Wt.und(e) ? [] : Wt.arr(e) ? e : [e];
}
function Mr(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Wt.fun(e) ? e(...n) : e;
}
function mb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, Xr(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function $d(e) {
  const t = mb(e);
  if (Wt.und(t))
    return pn({
      to: t
    }, e);
  const n = Object.keys(e).reduce((i, r) => Wt.und(t[r]) ? pn({}, i, {
    [r]: e[r]
  }) : i, {});
  return pn({
    to: t
  }, n);
}
function gb(e, t) {
  return t && (Wt.fun(t) ? t(e) : Wt.obj(t) && (t.current = e)), e;
}
class _r {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const n = this.children.indexOf(t);
    this.children.splice(n, 1), this.children.length === 0 && this.detach();
  }
}
class of extends _r {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof _r && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof _r && t.removeChild(this));
  }
}
class sg extends _r {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof _r && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof _r && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const n = {};
    for (const i in this.payload) {
      const r = this.payload[i];
      t && !(r instanceof _r) || (n[i] = r instanceof _r ? r[t ? "getAnimatedValue" : "getValue"]() : r);
    }
    return n;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let Qf;
function yb(e, t) {
  Qf = {
    fn: e,
    transform: t
  };
}
let ug;
function vb(e) {
  ug = e;
}
let cg = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, Qu;
function xb(e) {
  Qu = e;
}
let dg = () => Date.now(), bb = (e) => e.current, fg;
function Sb(e) {
  fg = e;
}
class Eb extends sg {
  constructor(t, n) {
    super(), this.update = void 0, this.payload = t.style ? pn({}, t, {
      style: fg(t.style)
    }) : t, this.update = n, this.attach();
  }
}
const kb = (e) => Wt.fun(e) && !(e.prototype instanceof a.Component), wb = (e) => ce.forwardRef((n, i) => {
  const r = lg(), o = ce.useRef(!0), d = ce.useRef(null), u = ce.useRef(null), s = ce.useCallback((v) => {
    const w = d.current, E = () => {
      let R = !1;
      u.current && (R = Qf.fn(u.current, d.current.getAnimatedValue())), (!u.current || R === !1) && r();
    };
    d.current = new Eb(v, E), w && w.detach();
  }, []);
  ce.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), ce.useImperativeHandle(i, () => bb(u)), s(n);
  const h = d.current.getValue();
  h.scrollTop, h.scrollLeft;
  const m = Xr(h, ["scrollTop", "scrollLeft"]), y = kb(e) ? void 0 : (v) => u.current = gb(v, i);
  return a.createElement(e, pn({}, m, {
    ref: y
  }));
});
let fs = !1;
const Bi = /* @__PURE__ */ new Set(), hg = () => {
  if (!fs)
    return !1;
  let e = dg();
  for (let t of Bi) {
    let n = !1;
    for (let i = 0; i < t.configs.length; i++) {
      let r = t.configs[i], o, d;
      for (let u = 0; u < r.animatedValues.length; u++) {
        let s = r.animatedValues[u];
        if (s.done)
          continue;
        let h = r.fromValues[u], m = r.toValues[u], y = s.lastPosition, v = m instanceof _r, w = Array.isArray(r.initialVelocity) ? r.initialVelocity[u] : r.initialVelocity;
        if (v && (m = m.getValue()), r.immediate) {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (typeof h == "string" || typeof m == "string") {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (r.duration !== void 0)
          y = h + r.easing((e - s.startTime) / r.duration) * (m - h), o = e >= s.startTime + r.duration;
        else if (r.decay)
          y = h + w / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - y) < 0.1, o && (m = y);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, w = s.lastVelocity !== void 0 ? s.lastVelocity : r.initialVelocity, e > d + 64 && (d = e);
          let E = Math.floor(e - d);
          for (let _ = 0; _ < E; ++_) {
            let P = -r.tension * (y - m), M = -r.friction * w, N = (P + M) / r.mass;
            w = w + N * 1 / 1e3, y = y + w * 1 / 1e3;
          }
          let R = r.clamp && r.tension !== 0 ? h < m ? y > m : y < m : !1, C = Math.abs(w) <= r.precision, g = r.tension !== 0 ? Math.abs(m - y) <= r.precision : !0;
          o = R || C && g, s.lastVelocity = w, s.lastTime = e;
        }
        v && !r.toValues[u].done && (o = !1), o ? (s.value !== m && (y = m), s.done = !0) : n = !0, s.setValue(y), s.lastPosition = y;
      }
      t.props.onFrame && (t.values[r.name] = r.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), n || (Bi.delete(t), t.stop(!0));
  }
  return Bi.size ? cg(hg) : fs = !1, fs;
}, Tb = (e) => {
  Bi.has(e) || Bi.add(e), fs || (fs = !0, cg(hg));
}, Cb = (e) => {
  Bi.has(e) && Bi.delete(e);
};
function Ju(e, t, n) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return Ju({
      range: e,
      output: t,
      extrapolate: n
    });
  if (Qu && typeof e.output[0] == "string")
    return Qu(e);
  const i = e, r = i.output, o = i.range || [0, 1], d = i.extrapolateLeft || i.extrapolate || "extend", u = i.extrapolateRight || i.extrapolate || "extend", s = i.easing || ((h) => h);
  return (h) => {
    const m = Pb(h, o);
    return Ab(h, o[m], o[m + 1], r[m], r[m + 1], s, d, u, i.map);
  };
}
function Ab(e, t, n, i, r, o, d, u, s) {
  let h = s ? s(e) : e;
  if (h < t) {
    if (d === "identity")
      return h;
    d === "clamp" && (h = t);
  }
  if (h > n) {
    if (u === "identity")
      return h;
    u === "clamp" && (h = n);
  }
  return i === r ? i : t === n ? e <= t ? i : r : (t === -1 / 0 ? h = -h : n === 1 / 0 ? h = h - t : h = (h - t) / (n - t), h = o(h), i === -1 / 0 ? h = -h : r === 1 / 0 ? h = h + i : h = h * (r - i) + i, h);
}
function Pb(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
class el extends of {
  constructor(t, n, i, r) {
    super(), this.calc = void 0, this.payload = t instanceof of && !(t instanceof el) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = Ju(n, i, r);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, n, i) {
    this.calc = Ju(t, n, i);
  }
  interpolate(t, n, i) {
    return new el(this, t, n, i);
  }
}
const Lb = (e, t, n) => e && new el(e, t, n);
function pg(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((n) => pg(n, t));
}
class lf extends _r {
  constructor(t) {
    var n;
    super(), n = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(i, r) {
      r === void 0 && (r = !0), n.value = i, r && n.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && pg(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, n, i) {
    return new el(this, t, n, i);
  }
}
class Rb extends of {
  constructor(t) {
    super(), this.payload = t.map((n) => new lf(n));
  }
  setValue(t, n) {
    n === void 0 && (n = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((i, r) => this.payload[r].setValue(i, n)) : this.payload.forEach((i) => i.setValue(t, n));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, n) {
    return new el(this, t, n);
  }
}
let Db = 0;
class Ob {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Db++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const n = $d(t), i = n.delay, r = i === void 0 ? 0 : i, o = n.to, d = Xr(n, ["delay", "to"]);
    if (Wt.arr(o) || Wt.fun(o))
      this.queue.push(pn({}, d, {
        delay: r,
        to: o
      }));
    else if (o) {
      let u = {};
      Object.entries(o).forEach((s) => {
        let h = s[0], m = s[1];
        const y = pn({
          to: {
            [h]: m
          },
          delay: Mr(r, h)
        }, d), v = u[y.delay] && u[y.delay].to;
        u[y.delay] = pn({}, u[y.delay], y, {
          to: pn({}, v, y.to)
        });
      }), this.queue = Object.values(u);
    }
    return this.queue = this.queue.sort((u, s) => u.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((r) => {
        let o = r.from, d = o === void 0 ? {} : o, u = r.to, s = u === void 0 ? {} : u;
        Wt.obj(d) && (this.merged = pn({}, d, this.merged)), Wt.obj(s) && (this.merged = pn({}, this.merged, s));
      });
      const n = this.local = ++this.guid, i = this.localQueue = this.queue;
      this.queue = [], i.forEach((r, o) => {
        let d = r.delay, u = Xr(r, ["delay"]);
        const s = (m) => {
          o === i.length - 1 && n === this.guid && m && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let h = Wt.arr(u.to) || Wt.fun(u.to);
        d ? setTimeout(() => {
          n === this.guid && (h ? this.runAsync(u, s) : this.diff(u).start(s));
        }, d) : h ? this.runAsync(u, s) : this.diff(u).start(s);
      });
    } else
      Wt.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), Tb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((n) => n(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Cb(this), this;
  }
  runAsync(t, n) {
    var i = this;
    t.delay;
    let r = Xr(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (Wt.arr(r.to))
      for (let u = 0; u < r.to.length; u++) {
        const s = u, h = pn({}, r, $d(r.to[s]));
        Wt.arr(h.config) && (h.config = h.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((m) => this.diff(h).start(m));
        });
      }
    else if (Wt.fun(r.to)) {
      let u = 0, s;
      d = d.then(() => r.to(
        // next(props)
        (h) => {
          const m = pn({}, r, $d(h));
          if (Wt.arr(m.config) && (m.config = m.config[u]), u++, o === this.guid)
            return s = new Promise((y) => this.diff(m).start(y));
        },
        // cancel()
        function(h) {
          return h === void 0 && (h = !0), i.stop(h);
        }
      ).then(() => s));
    }
    d.then(n);
  }
  diff(t) {
    this.props = pn({}, this.props, t);
    let n = this.props, i = n.from, r = i === void 0 ? {} : i, o = n.to, d = o === void 0 ? {} : o, u = n.config, s = u === void 0 ? {} : u, h = n.reverse, m = n.attach, y = n.reset, v = n.immediate;
    if (h) {
      var w = [d, r];
      r = w[0], d = w[1];
    }
    this.merged = pn({}, r, this.merged, d), this.hasChanged = !1;
    let E = m && m(this);
    if (this.animations = Object.entries(this.merged).reduce((R, C) => {
      let g = C[0], _ = C[1], P = R[g] || {};
      const M = Wt.num(_), N = Wt.str(_) && !_.startsWith("#") && !/\d/.test(_) && !ug[_], T = Wt.arr(_), U = !M && !T && !N;
      let V = Wt.und(r[g]) ? _ : r[g], G = M || T || N ? _ : 1, ue = Mr(s, g);
      E && (G = E.animations[g].parent);
      let Z = P.parent, $ = P.interpolation, H = Xo(E ? G.getPayload() : G), j, F = _;
      U && (F = Qu({
        range: [0, 1],
        output: [_, _]
      })(1));
      let X = $ && $.getValue();
      const ae = !Wt.und(Z) && P.animatedValues.some((ge) => !ge.done), te = !Wt.equ(F, X), re = !Wt.equ(F, P.previous), ie = !Wt.equ(ue, P.config);
      if (y || re && te || ie) {
        if (M || N)
          Z = $ = P.parent || new lf(V);
        else if (T)
          Z = $ = P.parent || new Rb(V);
        else if (U) {
          let ge = P.interpolation && P.interpolation.calc(P.parent.value);
          ge = ge !== void 0 && !y ? ge : V, P.parent ? (Z = P.parent, Z.setValue(0, !1)) : Z = new lf(0);
          const ve = {
            output: [ge, _]
          };
          P.interpolation ? ($ = P.interpolation, P.interpolation.updateConfig(ve)) : $ = Z.interpolate(ve);
        }
        return H = Xo(E ? G.getPayload() : G), j = Xo(Z.getPayload()), y && !U && Z.setValue(V, !1), this.hasChanged = !0, j.forEach((ge) => {
          ge.startPosition = ge.value, ge.lastPosition = ge.value, ge.lastVelocity = ae ? ge.lastVelocity : void 0, ge.lastTime = ae ? ge.lastTime : void 0, ge.startTime = dg(), ge.done = !1, ge.animatedStyles.clear();
        }), Mr(v, g) && Z.setValue(U ? G : _, !1), pn({}, R, {
          [g]: pn({}, P, {
            name: g,
            parent: Z,
            interpolation: $,
            animatedValues: j,
            toValues: H,
            previous: F,
            config: ue,
            fromValues: Xo(Z.getValue()),
            immediate: Mr(v, g),
            initialVelocity: Ai(ue.velocity, 0),
            clamp: Ai(ue.clamp, !1),
            precision: Ai(ue.precision, 0.01),
            tension: Ai(ue.tension, 170),
            friction: Ai(ue.friction, 26),
            mass: Ai(ue.mass, 1),
            duration: ue.duration,
            easing: Ai(ue.easing, (ge) => ge),
            decay: ue.decay
          })
        });
      } else
        return te ? R : (U && (Z.setValue(1, !1), $.updateConfig({
          output: [F, F]
        })), Z.done = !0, this.hasChanged = !0, pn({}, R, {
          [g]: pn({}, R[g], {
            previous: F
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let R in this.animations)
        this.interpolations[R] = this.animations[R].interpolation, this.values[R] = this.animations[R].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Mb = 0;
const Iu = "enter", Id = "leave", Hd = "update", _b = (e, t) => (typeof t == "function" ? e.map(t) : Xo(t)).map(String), sf = (e) => {
  let t = e.items, n = e.keys, i = n === void 0 ? (o) => o : n, r = Xr(e, ["items", "keys"]);
  return t = Xo(t !== void 0 ? t : null), pn({
    items: t,
    keys: _b(t, i)
  }, r);
};
function Nb(e, t, n) {
  const i = pn({
    items: e,
    keys: t || ((_) => _)
  }, n), r = sf(i), o = r.lazy, d = o === void 0 ? !1 : o;
  r.unique;
  const u = r.reset, s = u === void 0 ? !1 : u;
  r.enter, r.leave, r.update;
  const h = r.onDestroyed;
  r.keys, r.items;
  const m = r.onFrame, y = r.onRest, v = r.onStart, w = r.ref, E = Xr(r, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), R = lg(), C = ce.useRef(!1), g = ce.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!i.ref,
    instances: !C.current && /* @__PURE__ */ new Map(),
    forceUpdate: R
  });
  return ce.useImperativeHandle(i.ref, () => ({
    start: () => Promise.all(Array.from(g.current.instances).map((_) => {
      let P = _[1];
      return new Promise((M) => P.start(M));
    })),
    stop: (_) => Array.from(g.current.instances).forEach((P) => P[1].stop(_)),
    get controllers() {
      return Array.from(g.current.instances).map((_) => _[1]);
    }
  })), g.current = Fb(g.current, i), g.current.changed && g.current.transitions.forEach((_) => {
    const P = _.slot, M = _.from, N = _.to, T = _.config, U = _.trail, V = _.key, G = _.item;
    g.current.instances.has(V) || g.current.instances.set(V, new Ob());
    const ue = g.current.instances.get(V), Z = pn({}, E, {
      to: N,
      from: M,
      config: T,
      ref: w,
      onRest: ($) => {
        g.current.mounted && (_.destroyed && (!w && !d && kp(g, V), h && h(G)), !Array.from(g.current.instances).some((F) => !F[1].idle) && (w || d) && g.current.deleted.length > 0 && kp(g), y && y(G, P, $));
      },
      onStart: v && (() => v(G, P)),
      onFrame: m && (($) => m(G, P, $)),
      delay: U,
      reset: s && P === Iu
      // Update controller
    });
    ue.update(Z), g.current.paused || ue.start();
  }), ce.useEffect(() => (g.current.mounted = C.current = !0, () => {
    g.current.mounted = C.current = !1, Array.from(g.current.instances).map((_) => _[1].destroy()), g.current.instances.clear();
  }), []), g.current.transitions.map((_) => {
    let P = _.item, M = _.slot, N = _.key;
    return {
      item: P,
      key: N,
      state: M,
      props: g.current.instances.get(N).getValues()
    };
  });
}
function kp(e, t) {
  const n = e.current.deleted;
  for (let i of n) {
    let r = i.key;
    const o = (d) => d.key !== r;
    (Wt.und(t) || t === r) && (e.current.instances.delete(r), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Fb(e, t) {
  let n = e.first, i = e.prevProps, r = Xr(e, ["first", "prevProps"]), o = sf(t), d = o.items, u = o.keys, s = o.initial, h = o.from, m = o.enter, y = o.leave, v = o.update, w = o.trail, E = w === void 0 ? 0 : w, R = o.unique, C = o.config, g = o.order, _ = g === void 0 ? [Iu, Id, Hd] : g, P = sf(i), M = P.keys, N = P.items, T = pn({}, r.current), U = [...r.deleted], V = Object.keys(T), G = new Set(V), ue = new Set(u), Z = u.filter((X) => !G.has(X)), $ = r.transitions.filter((X) => !X.destroyed && !ue.has(X.originalKey)).map((X) => X.originalKey), H = u.filter((X) => G.has(X)), j = -E;
  for (; _.length; )
    switch (_.shift()) {
      case Iu: {
        Z.forEach((Q, ae) => {
          R && U.find((ge) => ge.originalKey === Q) && (U = U.filter((ge) => ge.originalKey !== Q));
          const te = u.indexOf(Q), re = d[te], ie = n && s !== void 0 ? "initial" : Iu;
          T[Q] = {
            slot: ie,
            originalKey: Q,
            key: R ? String(Q) : Mb++,
            item: re,
            trail: j = j + E,
            config: Mr(C, re, ie),
            from: Mr(n && s !== void 0 ? s || {} : h, re),
            to: Mr(m, re)
          };
        });
        break;
      }
      case Id: {
        $.forEach((Q) => {
          const ae = M.indexOf(Q), te = N[ae], re = Id;
          U.unshift(pn({}, T[Q], {
            slot: re,
            destroyed: !0,
            left: M[Math.max(0, ae - 1)],
            right: M[Math.min(M.length, ae + 1)],
            trail: j = j + E,
            config: Mr(C, te, re),
            to: Mr(y, te)
          })), delete T[Q];
        });
        break;
      }
      case Hd: {
        H.forEach((Q) => {
          const ae = u.indexOf(Q), te = d[ae], re = Hd;
          T[Q] = pn({}, T[Q], {
            item: te,
            slot: re,
            trail: j = j + E,
            config: Mr(C, te, re),
            to: Mr(v, te)
          });
        });
        break;
      }
    }
  let F = u.map((X) => T[X]);
  return U.forEach((X) => {
    let Q = X.left;
    X.right;
    let ae = Xr(X, ["left", "right"]), te;
    (te = F.findIndex((re) => re.originalKey === Q)) !== -1 && (te += 1), te = Math.max(0, te), F = [...F.slice(0, te), ae, ...F.slice(te)];
  }), pn({}, r, {
    changed: Z.length || $.length || H.length,
    first: n && Z.length === 0,
    transitions: F,
    current: T,
    deleted: U,
    prevProps: t
  });
}
class zb extends sg {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof _r) && (t = Qf.transform(t)), this.payload = t;
  }
}
const ec = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, Nr = "[-+]?\\d*\\.?\\d+", tc = Nr + "%";
function Tc() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Bb = new RegExp("rgb" + Tc(Nr, Nr, Nr)), $b = new RegExp("rgba" + Tc(Nr, Nr, Nr, Nr)), Ib = new RegExp("hsl" + Tc(Nr, tc, tc)), Hb = new RegExp("hsla" + Tc(Nr, tc, tc, Nr)), Wb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Vb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, jb = /^#([0-9a-fA-F]{6})$/, Ub = /^#([0-9a-fA-F]{8})$/;
function Kb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = jb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : ec.hasOwnProperty(e) ? ec[e] : (t = Bb.exec(e)) ? (jo(t[1]) << 24 | // r
  jo(t[2]) << 16 | // g
  jo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = $b.exec(e)) ? (jo(t[1]) << 24 | // r
  jo(t[2]) << 16 | // g
  jo(t[3]) << 8 | // b
  Cp(t[4])) >>> // a
  0 : (t = Wb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Ub.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Vb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Ib.exec(e)) ? (wp(
    Tp(t[1]),
    // h
    Au(t[2]),
    // s
    Au(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Hb.exec(e)) ? (wp(
    Tp(t[1]),
    // h
    Au(t[2]),
    // s
    Au(t[3])
    // l
  ) | Cp(t[4])) >>> // a
  0 : null;
}
function Wd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function wp(e, t, n) {
  const i = n < 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i, o = Wd(r, i, e + 1 / 3), d = Wd(r, i, e), u = Wd(r, i, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(u * 255) << 8;
}
function jo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function Tp(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function Cp(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Au(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function Ap(e) {
  let t = Kb(e);
  if (t === null)
    return e;
  t = t || 0;
  let n = (t & 4278190080) >>> 24, i = (t & 16711680) >>> 16, r = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${n}, ${i}, ${r}, ${o})`;
}
const Pu = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Yb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Xb = new RegExp(`(${Object.keys(ec).join("|")})`, "g"), qb = (e) => {
  const t = e.output.map((r) => r.replace(Yb, Ap)).map((r) => r.replace(Xb, Ap)), n = t[0].match(Pu).map(() => []);
  t.forEach((r) => {
    r.match(Pu).forEach((o, d) => n[d].push(+o));
  });
  const i = t[0].match(Pu).map((r, o) => Ju(pn({}, e, {
    output: n[o]
  })));
  return (r) => {
    let o = 0;
    return t[0].replace(Pu, () => i[o++](r)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, u, s, h, m) => `rgba(${Math.round(u)}, ${Math.round(s)}, ${Math.round(h)}, ${m})`);
  };
};
let hs = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Gb = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Zb = ["Webkit", "Ms", "Moz", "O"];
hs = Object.keys(hs).reduce((e, t) => (Zb.forEach((n) => e[Gb(n, t)] = e[t]), e), hs);
function Qb(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !n && typeof t == "number" && t !== 0 && !(hs.hasOwnProperty(e) && hs[e]) ? t + "px" : ("" + t).trim();
}
const Pp = {};
Sb((e) => new zb(e));
xb(qb);
vb(ec);
yb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const r = t.style, o = t.children, d = t.scrollTop, u = t.scrollLeft, s = Xr(t, ["style", "children", "scrollTop", "scrollLeft"]), h = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), u !== void 0 && (e.scrollLeft = u), o !== void 0 && (e.textContent = o);
    for (let m in r)
      if (r.hasOwnProperty(m)) {
        var n = m.indexOf("--") === 0, i = Qb(m, r[m], n);
        m === "float" && (m = "cssFloat"), n ? e.style.setProperty(m, i) : e.style[m] = i;
      }
    for (let m in s) {
      const y = h ? m : Pp[m] || (Pp[m] = m.replace(/([A-Z])/g, (v) => "-" + v.toLowerCase()));
      typeof e.getAttribute(y) < "u" && e.setAttribute(y, s[m]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Jb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], e0 = pb(wb, !1), Lp = e0(Jb);
function t0(e) {
  return e.innerRadius;
}
function n0(e) {
  return e.outerRadius;
}
function r0(e) {
  return e.startAngle;
}
function a0(e) {
  return e.endAngle;
}
function i0(e) {
  return e && e.padAngle;
}
function o0(e, t, n, i, r, o, d, u) {
  var s = n - e, h = i - t, m = d - r, y = u - o, v = y * s - m * h;
  if (!(v * v < Gn))
    return v = (m * (t - o) - y * (e - r)) / v, [e + v * s, t + v * h];
}
function Lu(e, t, n, i, r, o, d) {
  var u = e - n, s = t - i, h = (d ? o : -o) / Ko(u * u + s * s), m = h * s, y = -h * u, v = e + m, w = t + y, E = n + m, R = i + y, C = (v + E) / 2, g = (w + R) / 2, _ = E - v, P = R - w, M = _ * _ + P * P, N = r - o, T = v * R - E * w, U = (P < 0 ? -1 : 1) * Ko(Ly(0, N * N * M - T * T)), V = (T * P - _ * U) / M, G = (-T * _ - P * U) / M, ue = (T * P + _ * U) / M, Z = (-T * _ + P * U) / M, $ = V - C, H = G - g, j = ue - C, F = Z - g;
  return $ * $ + H * H > j * j + F * F && (V = ue, G = Z), {
    cx: V,
    cy: G,
    x01: -m,
    y01: -y,
    x11: V * (r / N - 1),
    y11: G * (r / N - 1)
  };
}
function l0() {
  var e = t0, t = n0, n = Ut(0), i = null, r = r0, o = a0, d = i0, u = null;
  function s() {
    var h, m, y = +e.apply(this, arguments), v = +t.apply(this, arguments), w = r.apply(this, arguments) - Bh, E = o.apply(this, arguments) - Bh, R = $h(E - w), C = E > w;
    if (u || (u = h = kc()), v < y && (m = v, v = y, y = m), !(v > Gn))
      u.moveTo(0, 0);
    else if (R > Bu - Gn)
      u.moveTo(v * Ti(w), v * Wr(w)), u.arc(0, 0, v, w, E, !C), y > Gn && (u.moveTo(y * Ti(E), y * Wr(E)), u.arc(0, 0, y, E, w, C));
    else {
      var g = w, _ = E, P = w, M = E, N = R, T = R, U = d.apply(this, arguments) / 2, V = U > Gn && (i ? +i.apply(this, arguments) : Ko(y * y + v * v)), G = Rd($h(v - y) / 2, +n.apply(this, arguments)), ue = G, Z = G, $, H;
      if (V > Gn) {
        var j = Ih(V / y * Wr(U)), F = Ih(V / v * Wr(U));
        (N -= j * 2) > Gn ? (j *= C ? 1 : -1, P += j, M -= j) : (N = 0, P = M = (w + E) / 2), (T -= F * 2) > Gn ? (F *= C ? 1 : -1, g += F, _ -= F) : (T = 0, g = _ = (w + E) / 2);
      }
      var X = v * Ti(g), Q = v * Wr(g), ae = y * Ti(M), te = y * Wr(M);
      if (G > Gn) {
        var re = v * Ti(_), ie = v * Wr(_), ge = y * Ti(P), ve = y * Wr(P), Se;
        if (R < zh && (Se = o0(X, Q, ge, ve, re, ie, ae, te))) {
          var ye = X - Se[0], ee = Q - Se[1], Ee = re - Se[0], He = ie - Se[1], we = 1 / Wr(Py((ye * Ee + ee * He) / (Ko(ye * ye + ee * ee) * Ko(Ee * Ee + He * He))) / 2), fe = Ko(Se[0] * Se[0] + Se[1] * Se[1]);
          ue = Rd(G, (y - fe) / (we - 1)), Z = Rd(G, (v - fe) / (we + 1));
        }
      }
      T > Gn ? Z > Gn ? ($ = Lu(ge, ve, X, Q, v, Z, C), H = Lu(re, ie, ae, te, v, Z, C), u.moveTo($.cx + $.x01, $.cy + $.y01), Z < G ? u.arc($.cx, $.cy, Z, qn($.y01, $.x01), qn(H.y01, H.x01), !C) : (u.arc($.cx, $.cy, Z, qn($.y01, $.x01), qn($.y11, $.x11), !C), u.arc(0, 0, v, qn($.cy + $.y11, $.cx + $.x11), qn(H.cy + H.y11, H.cx + H.x11), !C), u.arc(H.cx, H.cy, Z, qn(H.y11, H.x11), qn(H.y01, H.x01), !C))) : (u.moveTo(X, Q), u.arc(0, 0, v, g, _, !C)) : u.moveTo(X, Q), !(y > Gn) || !(N > Gn) ? u.lineTo(ae, te) : ue > Gn ? ($ = Lu(ae, te, re, ie, y, -ue, C), H = Lu(X, Q, ge, ve, y, -ue, C), u.lineTo($.cx + $.x01, $.cy + $.y01), ue < G ? u.arc($.cx, $.cy, ue, qn($.y01, $.x01), qn(H.y01, H.x01), !C) : (u.arc($.cx, $.cy, ue, qn($.y01, $.x01), qn($.y11, $.x11), !C), u.arc(0, 0, y, qn($.cy + $.y11, $.cx + $.x11), qn(H.cy + H.y11, H.cx + H.x11), C), u.arc(H.cx, H.cy, ue, qn(H.y11, H.x11), qn(H.y01, H.x01), !C))) : u.arc(0, 0, y, M, P, C);
    }
    if (u.closePath(), h)
      return u = null, h + "" || null;
  }
  return s.centroid = function() {
    var h = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - zh / 2;
    return [Ti(m) * h, Wr(m) * h];
  }, s.innerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : Ut(+h), s) : e;
  }, s.outerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : Ut(+h), s) : t;
  }, s.cornerRadius = function(h) {
    return arguments.length ? (n = typeof h == "function" ? h : Ut(+h), s) : n;
  }, s.padRadius = function(h) {
    return arguments.length ? (i = h == null ? null : typeof h == "function" ? h : Ut(+h), s) : i;
  }, s.startAngle = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : Ut(+h), s) : r;
  }, s.endAngle = function(h) {
    return arguments.length ? (o = typeof h == "function" ? h : Ut(+h), s) : o;
  }, s.padAngle = function(h) {
    return arguments.length ? (d = typeof h == "function" ? h : Ut(+h), s) : d;
  }, s.context = function(h) {
    return arguments.length ? (u = h ?? null, s) : u;
  }, s;
}
function mg(e) {
  this._context = e;
}
mg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Cc(e) {
  return new mg(e);
}
function Jf(e) {
  return e[0];
}
function eh(e) {
  return e[1];
}
function gg() {
  var e = Jf, t = eh, n = Ut(!0), i = null, r = Cc, o = null;
  function d(u) {
    var s, h = u.length, m, y = !1, v;
    for (i == null && (o = r(v = kc())), s = 0; s <= h; ++s)
      !(s < h && n(m = u[s], s, u)) === y && ((y = !y) ? o.lineStart() : o.lineEnd()), y && o.point(+e(m, s, u), +t(m, s, u));
    if (v)
      return o = null, v + "" || null;
  }
  return d.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Ut(+u), d) : e;
  }, d.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Ut(+u), d) : t;
  }, d.defined = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Ut(!!u), d) : n;
  }, d.curve = function(u) {
    return arguments.length ? (r = u, i != null && (o = r(i)), d) : r;
  }, d.context = function(u) {
    return arguments.length ? (u == null ? i = o = null : o = r(i = u), d) : i;
  }, d;
}
function s0() {
  var e = Jf, t = null, n = Ut(0), i = eh, r = Ut(!0), o = null, d = Cc, u = null;
  function s(m) {
    var y, v, w, E = m.length, R, C = !1, g, _ = new Array(E), P = new Array(E);
    for (o == null && (u = d(g = kc())), y = 0; y <= E; ++y) {
      if (!(y < E && r(R = m[y], y, m)) === C)
        if (C = !C)
          v = y, u.areaStart(), u.lineStart();
        else {
          for (u.lineEnd(), u.lineStart(), w = y - 1; w >= v; --w)
            u.point(_[w], P[w]);
          u.lineEnd(), u.areaEnd();
        }
      C && (_[y] = +e(R, y, m), P[y] = +n(R, y, m), u.point(t ? +t(R, y, m) : _[y], i ? +i(R, y, m) : P[y]));
    }
    if (g)
      return u = null, g + "" || null;
  }
  function h() {
    return gg().defined(r).curve(d).context(o);
  }
  return s.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Ut(+m), t = null, s) : e;
  }, s.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Ut(+m), s) : e;
  }, s.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : Ut(+m), s) : t;
  }, s.y = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Ut(+m), i = null, s) : n;
  }, s.y0 = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Ut(+m), s) : n;
  }, s.y1 = function(m) {
    return arguments.length ? (i = m == null ? null : typeof m == "function" ? m : Ut(+m), s) : i;
  }, s.lineX0 = s.lineY0 = function() {
    return h().x(e).y(n);
  }, s.lineY1 = function() {
    return h().x(e).y(i);
  }, s.lineX1 = function() {
    return h().x(t).y(n);
  }, s.defined = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : Ut(!!m), s) : r;
  }, s.curve = function(m) {
    return arguments.length ? (d = m, o != null && (u = d(o)), s) : d;
  }, s.context = function(m) {
    return arguments.length ? (m == null ? o = u = null : u = d(o = m), s) : o;
  }, s;
}
function u0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function c0(e) {
  return e;
}
function d0() {
  var e = c0, t = u0, n = null, i = Ut(0), r = Ut(Bu), o = Ut(0);
  function d(u) {
    var s, h = u.length, m, y, v = 0, w = new Array(h), E = new Array(h), R = +i.apply(this, arguments), C = Math.min(Bu, Math.max(-Bu, r.apply(this, arguments) - R)), g, _ = Math.min(Math.abs(C) / h, o.apply(this, arguments)), P = _ * (C < 0 ? -1 : 1), M;
    for (s = 0; s < h; ++s)
      (M = E[w[s] = s] = +e(u[s], s, u)) > 0 && (v += M);
    for (t != null ? w.sort(function(N, T) {
      return t(E[N], E[T]);
    }) : n != null && w.sort(function(N, T) {
      return n(u[N], u[T]);
    }), s = 0, y = v ? (C - h * P) / v : 0; s < h; ++s, R = g)
      m = w[s], M = E[m], g = R + (M > 0 ? M * y : 0) + P, E[m] = {
        data: u[m],
        index: s,
        value: M,
        startAngle: R,
        endAngle: g,
        padAngle: _
      };
    return E;
  }
  return d.value = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Ut(+u), d) : e;
  }, d.sortValues = function(u) {
    return arguments.length ? (t = u, n = null, d) : t;
  }, d.sort = function(u) {
    return arguments.length ? (n = u, t = null, d) : n;
  }, d.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Ut(+u), d) : i;
  }, d.endAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ut(+u), d) : r;
  }, d.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Ut(+u), d) : o;
  }, d;
}
var uf = Array.prototype.slice;
function f0(e) {
  return e.source;
}
function h0(e) {
  return e.target;
}
function p0(e) {
  var t = f0, n = h0, i = Jf, r = eh, o = null;
  function d() {
    var u, s = uf.call(arguments), h = t.apply(this, s), m = n.apply(this, s);
    if (o || (o = u = kc()), e(o, +i.apply(this, (s[0] = h, s)), +r.apply(this, s), +i.apply(this, (s[0] = m, s)), +r.apply(this, s)), u)
      return o = null, u + "" || null;
  }
  return d.source = function(u) {
    return arguments.length ? (t = u, d) : t;
  }, d.target = function(u) {
    return arguments.length ? (n = u, d) : n;
  }, d.x = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Ut(+u), d) : i;
  }, d.y = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ut(+u), d) : r;
  }, d.context = function(u) {
    return arguments.length ? (o = u ?? null, d) : o;
  }, d;
}
function m0(e, t, n, i, r) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + i) / 2, n, t, r, i, r);
}
function g0() {
  return p0(m0);
}
function Wa() {
}
function nc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Ac(e) {
  this._context = e;
}
Ac.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        nc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        nc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function y0(e) {
  return new Ac(e);
}
function yg(e) {
  this._context = e;
}
yg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        nc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function v0(e) {
  return new yg(e);
}
function vg(e) {
  this._context = e;
}
vg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
        break;
      case 3:
        this._point = 4;
      default:
        nc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function x0(e) {
  return new vg(e);
}
function xg(e, t) {
  this._basis = new Ac(e), this._beta = t;
}
xg.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var i = e[0], r = t[0], o = e[n] - i, d = t[n] - r, u = -1, s; ++u <= n; )
        s = u / n, this._basis.point(
          this._beta * e[u] + (1 - this._beta) * (i + s * o),
          this._beta * t[u] + (1 - this._beta) * (r + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const b0 = function e(t) {
  function n(i) {
    return t === 1 ? new Ac(i) : new xg(i, t);
  }
  return n.beta = function(i) {
    return e(+i);
  }, n;
}(0.85);
function rc(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function th(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
th.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        rc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function n(i) {
    return new th(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function nh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
nh.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const E0 = function e(t) {
  function n(i) {
    return new nh(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function rh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
rh.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const k0 = function e(t) {
  function n(i) {
    return new rh(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function ah(e, t, n) {
  var i = e._x1, r = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > Gn) {
    var u = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    i = (i * u - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, r = (r * u - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > Gn) {
    var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * h + e._x1 * e._l23_2a - t * e._l12_2a) / m, d = (d * h + e._y1 * e._l23_2a - n * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(i, r, o, d, e._x2, e._y2);
}
function bg(e, t) {
  this._context = e, this._alpha = t;
}
bg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const w0 = function e(t) {
  function n(i) {
    return t ? new bg(i, t) : new th(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function Sg(e, t) {
  this._context = e, this._alpha = t;
}
Sg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const T0 = function e(t) {
  function n(i) {
    return t ? new Sg(i, t) : new nh(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function Eg(e, t) {
  this._context = e, this._alpha = t;
}
Eg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const C0 = function e(t) {
  function n(i) {
    return t ? new Eg(i, t) : new rh(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function kg(e) {
  this._context = e;
}
kg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function cf(e) {
  return new kg(e);
}
function Rp(e) {
  return e < 0 ? -1 : 1;
}
function Dp(e, t, n) {
  var i = e._x1 - e._x0, r = t - e._x1, o = (e._y1 - e._y0) / (i || r < 0 && -0), d = (n - e._y1) / (r || i < 0 && -0), u = (o * r + d * i) / (i + r);
  return (Rp(o) + Rp(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(u)) || 0;
}
function Op(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Vd(e, t, n) {
  var i = e._x0, r = e._y0, o = e._x1, d = e._y1, u = (o - i) / 3;
  e._context.bezierCurveTo(i + u, r + u * t, o - u, d - u * n, o, d);
}
function ac(e) {
  this._context = e;
}
ac.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Vd(this, this._t0, Op(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Vd(this, Op(this, n = Dp(this, e, t)), n);
          break;
        default:
          Vd(this, this._t0, n = Dp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function wg(e) {
  this._context = new Tg(e);
}
(wg.prototype = Object.create(ac.prototype)).point = function(e, t) {
  ac.prototype.point.call(this, t, e);
};
function Tg(e) {
  this._context = e;
}
Tg.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, i, r, o) {
    this._context.bezierCurveTo(t, e, i, n, o, r);
  }
};
function Hu(e) {
  return new ac(e);
}
function A0(e) {
  return new wg(e);
}
function Cg(e) {
  this._context = e;
}
Cg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var i = Mp(e), r = Mp(t), o = 0, d = 1; d < n; ++o, ++d)
          this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Mp(e) {
  var t, n = e.length - 1, i, r = new Array(n), o = new Array(n), d = new Array(n);
  for (r[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    r[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (r[n - 1] = 2, o[n - 1] = 7, d[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    i = r[t] / o[t - 1], o[t] -= i, d[t] -= i * d[t - 1];
  for (r[n - 1] = d[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    r[t] = (d[t] - r[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - r[t + 1];
  return [r, o];
}
function P0(e) {
  return new Cg(e);
}
function Pc(e, t) {
  this._context = e, this._t = t;
}
Pc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function L0(e) {
  return new Pc(e, 0.5);
}
function R0(e) {
  return new Pc(e, 0);
}
function D0(e) {
  return new Pc(e, 1);
}
function tl(e, t) {
  if ((d = e.length) > 1)
    for (var n = 1, i, r, o = e[t[0]], d, u = o.length; n < d; ++n)
      for (r = o, o = e[t[n]], i = 0; i < u; ++i)
        o[i][1] += o[i][0] = isNaN(r[i][1]) ? r[i][0] : r[i][1];
}
function nl(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function O0(e, t) {
  return e[t];
}
function ih() {
  var e = Ut([]), t = nl, n = tl, i = O0;
  function r(o) {
    var d = e.apply(this, arguments), u, s = o.length, h = d.length, m = new Array(h), y;
    for (u = 0; u < h; ++u) {
      for (var v = d[u], w = m[u] = new Array(s), E = 0, R; E < s; ++E)
        w[E] = R = [0, +i(o[E], v, E, o)], R.data = o[E];
      w.key = v;
    }
    for (u = 0, y = t(m); u < h; ++u)
      m[y[u]].index = u;
    return n(m, y), m;
  }
  return r.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Ut(uf.call(o)), r) : e;
  }, r.value = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : Ut(+o), r) : i;
  }, r.order = function(o) {
    return arguments.length ? (t = o == null ? nl : typeof o == "function" ? o : Ut(uf.call(o)), r) : t;
  }, r.offset = function(o) {
    return arguments.length ? (n = o ?? tl, r) : n;
  }, r;
}
function M0(e, t) {
  if ((i = e.length) > 0) {
    for (var n, i, r = 0, o = e[0].length, d; r < o; ++r) {
      for (d = n = 0; n < i; ++n)
        d += e[n][r][1] || 0;
      if (d)
        for (n = 0; n < i; ++n)
          e[n][r][1] /= d;
    }
    tl(e, t);
  }
}
function _0(e, t) {
  if ((s = e.length) > 0)
    for (var n, i = 0, r, o, d, u, s, h = e[t[0]].length; i < h; ++i)
      for (d = u = 0, n = 0; n < s; ++n)
        (o = (r = e[t[n]][i])[1] - r[0]) > 0 ? (r[0] = d, r[1] = d += o) : o < 0 ? (r[1] = u, r[0] = u += o) : (r[0] = 0, r[1] = o);
}
function N0(e, t) {
  if ((r = e.length) > 0) {
    for (var n = 0, i = e[t[0]], r, o = i.length; n < o; ++n) {
      for (var d = 0, u = 0; d < r; ++d)
        u += e[d][n][1] || 0;
      i[n][1] += i[n][0] = -u / 2;
    }
    tl(e, t);
  }
}
function F0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (r = e[t[0]]).length) > 0))) {
    for (var n = 0, i = 1, r, o, d; i < o; ++i) {
      for (var u = 0, s = 0, h = 0; u < d; ++u) {
        for (var m = e[t[u]], y = m[i][1] || 0, v = m[i - 1][1] || 0, w = (y - v) / 2, E = 0; E < u; ++E) {
          var R = e[t[E]], C = R[i][1] || 0, g = R[i - 1][1] || 0;
          w += C - g;
        }
        s += y, h += w * y;
      }
      r[i - 1][1] += r[i - 1][0] = n, s && (n -= h / s);
    }
    r[i - 1][1] += r[i - 1][0] = n, tl(e, t);
  }
}
function z0(e) {
  var t = e.map(B0);
  return nl(e).sort(function(n, i) {
    return t[n] - t[i];
  });
}
function B0(e) {
  for (var t = -1, n = 0, i = e.length, r, o = -1 / 0; ++t < i; )
    (r = +e[t][1]) > o && (o = r, n = t);
  return n;
}
function Ag(e) {
  var t = e.map(Pg);
  return nl(e).sort(function(n, i) {
    return t[n] - t[i];
  });
}
function Pg(e) {
  for (var t = 0, n = -1, i = e.length, r; ++n < i; )
    (r = +e[n][1]) && (t += r);
  return t;
}
function $0(e) {
  return Ag(e).reverse();
}
function I0(e) {
  var t = e.length, n, i, r = e.map(Pg), o = z0(e), d = 0, u = 0, s = [], h = [];
  for (n = 0; n < t; ++n)
    i = o[n], d < u ? (d += r[i], s.push(i)) : (u += r[i], h.push(i));
  return h.reverse().concat(s);
}
function H0(e) {
  return nl(e).reverse();
}
function kn(e, t) {
  e(t);
}
var _p = {
  ascending: Ag,
  descending: $0,
  insideout: I0,
  none: nl,
  reverse: H0
};
function oh(e) {
  return e && _p[e] || _p.none;
}
var Np = {
  expand: M0,
  diverging: _0,
  none: tl,
  silhouette: N0,
  wiggle: F0
};
function lh(e) {
  return e && Np[e] || Np.none;
}
function W0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, i = t.outerRadius, r = t.cornerRadius, o = t.startAngle, d = t.endAngle, u = t.padAngle, s = t.padRadius, h = l0();
  return n != null && kn(h.innerRadius, n), i != null && kn(h.outerRadius, i), r != null && kn(h.cornerRadius, r), o != null && kn(h.startAngle, o), d != null && kn(h.endAngle, d), u != null && kn(h.padAngle, u), s != null && kn(h.padRadius, s), h;
}
function sh(e) {
  var t = e === void 0 ? {} : e, n = t.x, i = t.x0, r = t.x1, o = t.y, d = t.y0, u = t.y1, s = t.defined, h = t.curve, m = s0();
  return n && kn(m.x, n), i && kn(m.x0, i), r && kn(m.x1, r), o && kn(m.y, o), d && kn(m.y0, d), u && kn(m.y1, u), s && m.defined(s), h && m.curve(h), m;
}
function Lg(e) {
  var t = e === void 0 ? {} : e, n = t.x, i = t.y, r = t.defined, o = t.curve, d = gg();
  return n && kn(d.x, n), i && kn(d.y, i), r && d.defined(r), o && d.curve(o), d;
}
function V0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, i = t.endAngle, r = t.padAngle, o = t.value, d = t.sort, u = t.sortValues, s = d0();
  return (d === null || d != null) && s.sort(d), (u === null || u != null) && s.sortValues(u), o != null && s.value(o), r != null && kn(s.padAngle, r), n != null && kn(s.startAngle, n), i != null && kn(s.endAngle, i), s;
}
function j0(e) {
  var t = e.keys, n = e.value, i = e.order, r = e.offset, o = ih();
  return t && o.keys(t), n && kn(o.value, n), i && o.order(oh(i)), r && o.offset(lh(r)), o;
}
var U0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function df() {
  return df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, df.apply(this, arguments);
}
function K0(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Y0(e) {
  var t = e.className, n = e.top, i = e.left, r = e.data, o = r === void 0 ? [] : r, d = e.centroid, u = e.innerRadius, s = u === void 0 ? 0 : u, h = e.outerRadius, m = e.cornerRadius, y = e.startAngle, v = e.endAngle, w = e.padAngle, E = e.padRadius, R = e.pieSort, C = e.pieSortValues, g = e.pieValue, _ = e.children, P = e.fill, M = P === void 0 ? "" : P, N = K0(e, U0), T = W0({
    innerRadius: s,
    outerRadius: h,
    cornerRadius: m,
    padRadius: E
  }), U = V0({
    startAngle: y,
    endAngle: v,
    padAngle: w,
    value: g,
    sort: R,
    sortValues: C
  }), V = U(o);
  return _ ? /* @__PURE__ */ a.createElement(a.Fragment, null, _({
    arcs: V,
    path: T,
    pie: U
  })) : /* @__PURE__ */ a.createElement(nt, {
    className: "visx-pie-arcs-group",
    top: n,
    left: i
  }, V.map(function(G, ue) {
    return /* @__PURE__ */ a.createElement("g", {
      key: "pie-arc-" + ue
    }, /* @__PURE__ */ a.createElement("path", df({
      className: On("visx-pie-arc", t),
      d: T(G) || "",
      fill: M == null || typeof M == "string" ? M : M(G)
    }, N)), d == null ? void 0 : d(T.centroid(G), G));
  }));
}
var X0 = ["from", "to", "fill", "className", "innerRef"];
function ff() {
  return ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ff.apply(this, arguments);
}
function q0(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function on(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, i = e.to, r = i === void 0 ? {
    x: 1,
    y: 1
  } : i, o = e.fill, d = o === void 0 ? "transparent" : o, u = e.className, s = e.innerRef, h = q0(e, X0), m = n.x === r.x || n.y === r.y;
  return /* @__PURE__ */ a.createElement("line", ff({
    ref: s,
    className: On("visx-line", u),
    x1: n.x,
    y1: n.y,
    x2: r.x,
    y2: r.y,
    fill: d,
    shapeRendering: m ? "crispEdges" : "auto"
  }, h));
}
var G0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function hf() {
  return hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, hf.apply(this, arguments);
}
function Z0(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function qr(e) {
  var t = e.children, n = e.data, i = n === void 0 ? [] : n, r = e.x, o = e.y, d = e.fill, u = d === void 0 ? "transparent" : d, s = e.className, h = e.curve, m = e.innerRef, y = e.defined, v = y === void 0 ? function() {
    return !0;
  } : y, w = Z0(e, G0), E = Lg({
    x: r,
    y: o,
    defined: v,
    curve: h
  });
  return t ? /* @__PURE__ */ a.createElement(a.Fragment, null, t({
    path: E
  })) : /* @__PURE__ */ a.createElement("path", hf({
    ref: m,
    className: On("visx-linepath", s),
    d: E(i) || "",
    fill: u,
    strokeLinecap: "round"
  }, w));
}
var Q0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function pf() {
  return pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, pf.apply(this, arguments);
}
function J0(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function eS(e) {
  var t = e.children, n = e.x, i = e.x0, r = e.x1, o = e.y, d = e.y0, u = e.y1, s = e.data, h = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, v = e.className, w = e.curve, E = e.innerRef, R = J0(e, Q0), C = sh({
    x: n,
    x0: i,
    x1: r,
    y: o,
    y0: d,
    y1: u,
    defined: y,
    curve: w
  });
  return t ? /* @__PURE__ */ a.createElement(a.Fragment, null, t({
    path: C
  })) : /* @__PURE__ */ a.createElement("path", pf({
    ref: E,
    className: On("visx-area", v),
    d: C(h) || ""
  }, R));
}
var tS = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function mf() {
  return mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, mf.apply(this, arguments);
}
function nS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function rS(e) {
  var t = e.x, n = e.x0, i = e.x1, r = e.y, o = e.y1, d = e.y0, u = e.yScale, s = e.data, h = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, v = e.className, w = e.curve, E = e.innerRef, R = e.children, C = nS(e, tS), g = sh({
    x: t,
    x0: n,
    x1: i,
    defined: y,
    curve: w
  });
  return d == null ? g.y0(u.range()[0]) : kn(g.y0, d), r && !o && kn(g.y1, r), o && !r && kn(g.y1, o), R ? /* @__PURE__ */ a.createElement(a.Fragment, null, R({
    path: g
  })) : /* @__PURE__ */ a.createElement("path", mf({
    ref: E,
    className: On("visx-area-closed", v),
    d: g(h) || ""
  }, C));
}
var aS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function gf() {
  return gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, gf.apply(this, arguments);
}
function iS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function oS(e) {
  var t = e.className, n = e.top, i = e.left, r = e.keys, o = e.data, d = e.curve, u = e.defined, s = e.x, h = e.x0, m = e.x1, y = e.y0, v = e.y1, w = e.value, E = e.order, R = e.offset, C = e.color, g = e.children, _ = iS(e, aS), P = j0({
    keys: r,
    value: w,
    order: E,
    offset: R
  }), M = sh({
    x: s,
    x0: h,
    x1: m,
    y0: y,
    y1: v,
    curve: d,
    defined: u
  }), N = P(o);
  return g ? /* @__PURE__ */ a.createElement(a.Fragment, null, g({
    stacks: N,
    path: M,
    stack: P
  })) : /* @__PURE__ */ a.createElement(nt, {
    top: n,
    left: i
  }, N.map(function(T, U) {
    return /* @__PURE__ */ a.createElement("path", gf({
      className: On("visx-stack", t),
      key: "stack-" + U + "-" + (T.key || ""),
      d: M(T) || "",
      fill: C == null ? void 0 : C(T.key, U)
    }, _));
  }));
}
var lS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function ic() {
  return ic = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ic.apply(this, arguments);
}
function sS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function uS(e) {
  var t = e.className, n = e.top, i = e.left, r = e.keys, o = e.data, d = e.curve, u = e.defined, s = e.x, h = e.x0, m = e.x1, y = e.y0, v = e.y1, w = e.value, E = e.order, R = e.offset, C = e.color, g = e.children, _ = sS(e, lS);
  return /* @__PURE__ */ a.createElement(oS, ic({
    className: t,
    top: n,
    left: i,
    keys: r,
    data: o,
    curve: d,
    defined: u,
    x: s,
    x0: h,
    x1: m,
    y0: y,
    y1: v,
    value: w,
    order: E,
    offset: R,
    color: C
  }, _), g || function(P) {
    var M = P.stacks, N = P.path;
    return M.map(function(T, U) {
      return /* @__PURE__ */ a.createElement("path", ic({
        className: On("visx-area-stack", t),
        key: "area-stack-" + U + "-" + (T.key || ""),
        d: N(T) || "",
        fill: C == null ? void 0 : C(T.key, U)
      }, _));
    });
  });
}
function uh(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var cS = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function yf() {
  return yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, yf.apply(this, arguments);
}
function dS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Rg(e) {
  var t = e.data, n = e.className, i = e.top, r = e.left, o = e.x0, d = e.x0Scale, u = e.x1Scale, s = e.yScale, h = e.color, m = e.keys, y = e.height, v = e.children, w = dS(e, cS), E = uh(u), R = t.map(function(C, g) {
    return {
      index: g,
      x0: d(o(C)),
      bars: m.map(function(_, P) {
        var M = C[_];
        return {
          index: P,
          key: _,
          value: M,
          width: E,
          x: u(_) || 0,
          y: s(M) || 0,
          color: h(_, P),
          height: y - (s(M) || 0)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ a.createElement(a.Fragment, null, v(R)) : /* @__PURE__ */ a.createElement(nt, {
    className: On("visx-bar-group", n),
    top: i,
    left: r
  }, R.map(function(C) {
    return /* @__PURE__ */ a.createElement(nt, {
      key: "bar-group-" + C.index + "-" + C.x0,
      left: C.x0
    }, C.bars.map(function(g) {
      return /* @__PURE__ */ a.createElement(gr, yf({
        key: "bar-group-bar-" + C.index + "-" + g.index + "-" + g.value + "-" + g.key,
        x: g.x,
        y: g.y,
        width: g.width,
        height: g.height,
        fill: g.color
      }, w));
    }));
  }));
}
function Dg(e) {
  return e == null ? void 0 : e[0];
}
function Og(e) {
  return e == null ? void 0 : e[1];
}
var fS = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function vf() {
  return vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, vf.apply(this, arguments);
}
function hS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function pS(e) {
  var t = e.data, n = e.className, i = e.top, r = e.left, o = e.x, d = e.y0, u = d === void 0 ? Dg : d, s = e.y1, h = s === void 0 ? Og : s, m = e.xScale, y = e.yScale, v = e.color, w = e.keys, E = e.value, R = e.order, C = e.offset, g = e.children, _ = hS(e, fS), P = ih();
  w && P.keys(w), E && kn(P.value, E), R && P.order(oh(R)), C && P.offset(lh(C));
  var M = P(t), N = uh(m), T = M.map(function(U, V) {
    var G = U.key;
    return {
      index: V,
      key: G,
      bars: U.map(function(ue, Z) {
        var $ = (y(u(ue)) || 0) - (y(h(ue)) || 0), H = y(h(ue)), j = "bandwidth" in m ? m(o(ue.data)) : Math.max((m(o(ue.data)) || 0) - N / 2);
        return {
          bar: ue,
          key: G,
          index: Z,
          height: $,
          width: N,
          x: j || 0,
          y: H || 0,
          color: v(U.key, Z)
        };
      })
    };
  });
  return g ? /* @__PURE__ */ a.createElement(a.Fragment, null, g(T)) : /* @__PURE__ */ a.createElement(nt, {
    className: On("visx-bar-stack", n),
    top: i,
    left: r
  }, T.map(function(U) {
    return U.bars.map(function(V) {
      return /* @__PURE__ */ a.createElement(gr, vf({
        key: "bar-stack-" + U.index + "-" + V.index,
        x: V.x,
        y: V.y,
        height: V.height,
        width: V.width,
        fill: V.color
      }, _));
    });
  }));
}
var mS = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function xf() {
  return xf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, xf.apply(this, arguments);
}
function gS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function yS(e) {
  var t = e.data, n = e.className, i = e.top, r = e.left, o = e.y, d = e.x0, u = d === void 0 ? Dg : d, s = e.x1, h = s === void 0 ? Og : s, m = e.xScale, y = e.yScale, v = e.color, w = e.keys, E = e.value, R = e.order, C = e.offset, g = e.children, _ = gS(e, mS), P = ih();
  w && P.keys(w), E && kn(P.value, E), R && P.order(oh(R)), C && P.offset(lh(C));
  var M = P(t), N = uh(y), T = M.map(function(U, V) {
    var G = U.key;
    return {
      index: V,
      key: G,
      bars: U.map(function(ue, Z) {
        var $ = (m(h(ue)) || 0) - (m(u(ue)) || 0), H = m(u(ue)), j = "bandwidth" in y ? y(o(ue.data)) : Math.max((y(o(ue.data)) || 0) - $ / 2);
        return {
          bar: ue,
          key: G,
          index: Z,
          height: N,
          width: $,
          x: H || 0,
          y: j || 0,
          color: v(U.key, Z)
        };
      })
    };
  });
  return g ? /* @__PURE__ */ a.createElement(a.Fragment, null, g(T)) : /* @__PURE__ */ a.createElement(nt, {
    className: On("visx-bar-stack-horizontal", n),
    top: i,
    left: r
  }, T.map(function(U) {
    return U.bars.map(function(V) {
      return /* @__PURE__ */ a.createElement(gr, xf({
        key: "bar-stack-" + U.index + "-" + V.index,
        x: V.x,
        y: V.y,
        height: V.height,
        width: V.width,
        fill: V.color
      }, _));
    });
  }));
}
var Fp = "http://www.w3.org/2000/svg";
function vS(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Fp, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Fp, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var xS = "__visx_splitpath_svg_path_measurement_id", zp = function() {
  return !0;
};
function bS(e) {
  var t = e.path, n = e.pointsInSegments, i = e.segmentation, r = i === void 0 ? "x" : i, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var u = vS(xS);
    u.setAttribute("d", t);
    var s = u.getTotalLength(), h = n.length, m = n.map(function() {
      return [];
    });
    if (r === "x" || r === "y")
      for (var y = n.map(function(H) {
        var j;
        return (j = H.find(function(F) {
          return typeof F[r] == "number";
        })) == null ? void 0 : j[r];
      }), v = u.getPointAtLength(0), w = u.getPointAtLength(s), E = w[r] > v[r], R = E ? y.map(function(H) {
        return typeof H > "u" ? zp : function(j) {
          return j >= H;
        };
      }) : y.map(function(H) {
        return typeof H > "u" ? zp : function(j) {
          return j <= H;
        };
      }), C = 0, g = 0; g <= s; g += d) {
        for (var _ = u.getPointAtLength(g), P = _[r]; C < h - 1 && R[C + 1](P); )
          C += 1;
        m[C].push(_);
      }
    else {
      var M = n.map(function(H) {
        return H.length;
      }), N = M.reduce(function(H, j) {
        return H + j;
      }, 0), T = s / Math.max(1, N - 1), U = M.slice(0, h - 1);
      U.unshift(0);
      for (var V = 2; V < h; V += 1)
        U[V] += U[V - 1];
      for (var G = 0; G < h; G += 1)
        U[G] *= T;
      for (var ue = 0, Z = 0; Z <= s; Z += d) {
        for (var $ = u.getPointAtLength(Z); ue < h - 1 && Z >= U[ue + 1]; )
          ue += 1;
        m[ue].push($);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function bf() {
  return bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, bf.apply(this, arguments);
}
var SS = function(t) {
  return t.x || 0;
}, ES = function(t) {
  return t.y || 0;
};
function Mg(e) {
  var t = e.children, n = e.className, i = e.curve, r = e.defined, o = e.segmentation, d = e.sampleRate, u = e.segments, s = e.x, h = e.y, m = e.styles, y = ce.useMemo(function() {
    var E = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, R = typeof h == "number" || typeof h > "u" ? function() {
      return h;
    } : h;
    return u.map(function(C) {
      return C.map(function(g, _) {
        return {
          x: E(g, _, C),
          y: R(g, _, C)
        };
      });
    });
  }, [s, h, u]), v = ce.useMemo(function() {
    var E = Lg({
      x: s,
      y: h,
      defined: r,
      curve: i
    });
    return E(u.flat()) || "";
  }, [s, h, r, i, u]), w = ce.useMemo(function() {
    return bS({
      path: v,
      segmentation: o,
      pointsInSegments: y,
      sampleRate: d
    });
  }, [v, o, y, d]);
  return /* @__PURE__ */ a.createElement("g", null, w.map(function(E, R) {
    return t ? /* @__PURE__ */ a.createElement(a.Fragment, {
      key: R
    }, t({
      index: R,
      segment: E,
      styles: m[R] || m[R % m.length]
    })) : /* @__PURE__ */ a.createElement(qr, bf({
      key: R,
      className: n,
      data: E,
      x: SS,
      y: ES
    }, m[R] || m[R % m.length]));
  }));
}
Mg.propTypes = {
  segments: he.arrayOf(he.array).isRequired,
  styles: he.array.isRequired,
  children: he.func,
  className: he.string
};
var kS = ["tooltipOpen"];
function wS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function oc() {
  return oc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, oc.apply(this, arguments);
}
function _g(e) {
  var t = ce.useState(oc({
    tooltipOpen: !1
  }, e)), n = t[0], i = t[1], r = ce.useCallback(function(d) {
    return i(typeof d == "function" ? function(u) {
      u.tooltipOpen;
      var s = wS(u, kS);
      return oc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [i]), o = ce.useCallback(function() {
    return i({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [i]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: i,
    showTooltip: r,
    hideTooltip: o
  };
}
var TS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function CS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var Ng = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, ch = /* @__PURE__ */ a.forwardRef(function(e, t) {
  var n = e.className, i = e.top, r = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, u = e.offsetTop, s = u === void 0 ? 10 : u, h = e.style, m = h === void 0 ? Ng : h, y = e.children, v = e.unstyled, w = v === void 0 ? !1 : v, E = e.applyPositionStyle, R = E === void 0 ? !1 : E, C = CS(e, TS);
  return /* @__PURE__ */ a.createElement("div", lc({
    ref: t,
    className: On("visx-tooltip", n),
    style: lc({
      top: i == null || s == null ? i : i + s,
      left: r == null || d == null ? r : r + d
    }, R && {
      position: "absolute"
    }, !w && m)
  }, C), y);
});
ch.propTypes = {
  children: he.node,
  className: he.string,
  left: he.number,
  offsetLeft: he.number,
  offsetTop: he.number,
  top: he.number,
  applyPositionStyle: he.bool,
  unstyled: he.bool
};
ch.displayName = "Tooltip";
const AS = ch;
function Sf() {
  return Sf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Sf.apply(this, arguments);
}
function PS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function LS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ef(e, t);
}
function Ef(e, t) {
  return Ef = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, Ef(e, t);
}
var Bp = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function RS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    LS(i, n);
    function i(o) {
      var d;
      return d = n.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ a.createRef(), d.getRects = d.getRects.bind(PS(d)), d;
    }
    var r = i.prototype;
    return r.componentDidMount = function() {
      var d, u = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : Hy.findDOMNode(this), this.setState(function() {
        return u.getRects();
      });
    }, r.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, u = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : Bp, h = u != null && u.getBoundingClientRect ? u.getBoundingClientRect() : Bp;
      return {
        rect: s,
        parentRect: h
      };
    }, r.render = function() {
      return /* @__PURE__ */ a.createElement(e, Sf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, i;
  }(a.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Fg = /* @__PURE__ */ ce.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), DS = Fg.Provider;
Fg.Consumer;
var OS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function sc() {
  return sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, sc.apply(this, arguments);
}
function MS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function zg(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, i = n === void 0 ? 0 : n, r = e.offsetLeft, o = r === void 0 ? 10 : r, d = e.offsetTop, u = d === void 0 ? 10 : d, s = e.parentRect, h = e.rect, m = e.style, y = m === void 0 ? Ng : m, v = e.top, w = v === void 0 ? 0 : v, E = e.unstyled, R = E === void 0 ? !1 : E, C = e.nodeRef, g = MS(e, OS), _, P = !1, M = !1;
  if (h && s) {
    var N = i, T = w;
    if (s.width) {
      var U = N + o + h.width - s.width, V = h.width - N - o;
      P = U > 0 && U > V;
    } else {
      var G = N + o + h.width - window.innerWidth, ue = h.width - N - o;
      P = G > 0 && G > ue;
    }
    if (s.height) {
      var Z = T + u + h.height - s.height, $ = h.height - T - u;
      M = Z > 0 && Z > $;
    } else
      M = T + u + h.height > window.innerHeight;
    N = P ? N - h.width - o : N + o, T = M ? T - h.height - u : T + u, N = Math.round(N), T = Math.round(T), _ = "translate(" + N + "px, " + T + "px)";
  }
  return /* @__PURE__ */ a.createElement(AS, sc({
    ref: C,
    style: sc({
      left: 0,
      top: 0,
      transform: _
    }, !R && y)
  }, g), /* @__PURE__ */ a.createElement(DS, {
    value: {
      isFlippedVertically: !M,
      isFlippedHorizontally: !P
    }
  }, t));
}
zg.propTypes = {
  nodeRef: he.oneOfType([he.string, he.func, he.object])
};
const Bg = RS(zg);
var rl = /* @__PURE__ */ function() {
  function e(n) {
    var i = n.x, r = i === void 0 ? 0 : i, o = n.y, d = o === void 0 ? 0 : o;
    this.x = 0, this.y = 0, this.x = r, this.y = d;
  }
  var t = e.prototype;
  return t.value = function() {
    return {
      x: this.x,
      y: this.y
    };
  }, t.toArray = function() {
    return [this.x, this.y];
  }, e;
}();
function _S(e, t) {
  return new rl({
    x: e.x + t.x,
    y: e.y + t.y
  });
}
function NS(e, t) {
  return new rl({
    x: e.x - t.x,
    y: e.y - t.y
  });
}
const FS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Point: rl,
  subtractPoints: NS,
  sumPoints: _S
}, Symbol.toStringTag, { value: "Module" }));
function zS(e) {
  return !!e && e instanceof Element;
}
function BS(e) {
  return !!e && (e instanceof SVGElement || "ownerSVGElement" in e);
}
function $S(e) {
  return !!e && "createSVGPoint" in e;
}
function IS(e) {
  return !!e && "getScreenCTM" in e;
}
function HS(e) {
  return !!e && "changedTouches" in e;
}
function WS(e) {
  return !!e && "clientX" in e;
}
function VS(e) {
  return !!e && (e instanceof Event || "nativeEvent" in e && e.nativeEvent instanceof Event);
}
function ps() {
  return ps = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ps.apply(this, arguments);
}
var jd = {
  x: 0,
  y: 0
};
function jS(e) {
  if (!e)
    return ps({}, jd);
  if (HS(e))
    return e.changedTouches.length > 0 ? {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    } : ps({}, jd);
  if (WS(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  var t = e == null ? void 0 : e.target, n = t && "getBoundingClientRect" in t ? t.getBoundingClientRect() : null;
  return n ? {
    x: n.x + n.width / 2,
    y: n.y + n.height / 2
  } : ps({}, jd);
}
function kf(e, t) {
  if (!e || !t)
    return null;
  var n = jS(t), i = BS(e) ? e.ownerSVGElement : e, r = IS(i) ? i.getScreenCTM() : null;
  if ($S(i) && r) {
    var o = i.createSVGPoint();
    return o.x = n.x, o.y = n.y, o = o.matrixTransform(r.inverse()), new rl({
      x: o.x,
      y: o.y
    });
  }
  var d = e.getBoundingClientRect();
  return new rl({
    x: n.x - d.left - e.clientLeft,
    y: n.y - d.top - e.clientTop
  });
}
function wf(e, t) {
  if (zS(e) && t)
    return kf(e, t);
  if (VS(e)) {
    var n = e, i = n.target;
    if (i)
      return kf(i, n);
  }
  return null;
}
const US = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  localPoint: wf,
  touchPoint: kf
}, Symbol.toStringTag, { value: "Module" })), $g = (e) => {
  const { tableData: t, config: n, formatNumber: i, capitalize: r, formatDate: o, formatTooltipsDate: d, parseDate: u, setSharedFilter: s } = ce.useContext(Ct), { xScale: h, yScale: m, showTooltip: y, hideTooltip: v } = e, { xAxis: w, visualizationType: E, orientation: R, yAxis: C, runtime: g } = n, _ = (j, F) => {
    const { x: X, y: Q } = F, te = {
      data: j || {},
      dataXPosition: X + 10,
      dataYPosition: Q
    };
    return {
      tooltipLeft: te.dataXPosition,
      tooltipTop: te.dataYPosition,
      tooltipData: te
    };
  }, P = (j, F) => {
    j.stopPropagation();
    const X = wf(j), { x: Q, y: ae } = X, { data: te, arc: re } = F ?? {}, ie = T(Q - Number(n.yAxis.size || 0)), ge = E !== "Pie" ? n.series.filter((Ae) => Ae.tooltip === !0).map((Ae) => Ae.dataKey) : n.series.map((Ae) => Ae.dataKey);
    ge.push(n.xAxis.dataKey), n.visualizationType === "Forecasting" && n.series.map((Ae) => {
      Ae.confidenceIntervals.map((ne) => {
        ne.showInTooltip && (ge.push(ne.high), ge.push(ne.low));
      });
    });
    function ve(Ae) {
      let ne = [];
      for (let $e in Ae)
        Ae.hasOwnProperty($e) && ne.push(Ae[$e].name);
      return ne;
    }
    ge.push(...ve(n.columns)), ge.push(...ve(n.columns));
    const Se = G(ie, ge), ye = t.filter((Ae) => Ae[w.dataKey] === U(ae)), ee = R === "vertical" ? Se : ye, Ee = (Ae) => {
      const ne = n.series.filter((Le) => Le.dataKey === Ae)[0];
      return ne != null && ne.axis ? String(ne.axis).toLowerCase() : "left";
    }, we = (() => {
      var Ke, Ge, et;
      const Ae = n.columns, ne = [], $e = [];
      for (const [Ze, Et] of Object.entries(Ae)) {
        const qe = {
          addColPrefix: n.columns[Ze].prefix,
          addColSuffix: n.columns[Ze].suffix,
          addColRoundTo: n.columns[Ze].roundToPlace ? n.columns[Ze].roundToPlace : "",
          addColCommas: n.columns[Ze].commas
        };
        let Be = null;
        n.visualizationType === "Pie" ? Be = re == null ? void 0 : re.data[Et.name] : Be = (Ke = ee[0]) == null ? void 0 : Ke[Et.name];
        const Ie = Sm(Be, "left", !0, n, qe);
        Et.tooltips && ne.push([Et.label, Ie]);
      }
      const Le = [];
      return ne.forEach((Ze) => {
        Le.push([Ze[0], Ze[1]]);
      }), E === "Pie" && $e.push(
        // ignore
        [n.xAxis.dataKey, te],
        [n.runtime.yAxis.dataKey, i(re == null ? void 0 : re.data[n.runtime.yAxis.dataKey])],
        ["Percent", `${Math.round(((re == null ? void 0 : re.endAngle) - (re == null ? void 0 : re.startAngle)) * 180 / Math.PI / 360 * 100) + "%"}`]
      ), E === "Forest Plot" && $e.push([n.xAxis.dataKey, U(ae)]), E !== "Pie" && E !== "Forest Plot" && $e.push(
        ...(et = (Ge = ue()) == null ? void 0 : Ge.filter((Ze) => {
          var Et, qe;
          return ((Et = n.series) == null ? void 0 : Et.find((Be) => Be.dataKey === Ze && (Be == null ? void 0 : Be.tooltip))) || ((qe = n.xAxis) == null ? void 0 : qe.dataKey) == Ze;
        })) == null ? void 0 : et.flatMap((Ze) => {
          var Ie, Fe, lt, Ue;
          const Et = n.general.showMissingDataLabel && !((Ie = ee[0]) != null && Ie[Ze]);
          let qe = Ze === n.xAxis.dataKey ? (Fe = ee[0]) == null ? void 0 : Fe[Ze] : i((lt = ee[0]) == null ? void 0 : lt[Ze], Ee(Ze));
          qe = Et ? "N/A" : qe;
          const Be = (Ue = n.preliminaryData) == null ? void 0 : Ue.find((ct) => {
            var ht;
            return ct.label && ct.type === "suppression" && ct.displayTooltip && ((ht = ee[0]) == null ? void 0 : ht[Ze]) === ct.value && (!ct.column || Ze === ct.column);
          });
          return Be && (qe = Be.label), [[Ze, qe, Ee(Ze)]];
        })
      ), [...$e, ...Le];
    })();
    if (!we)
      return;
    const fe = _(we, X);
    y(fe);
  }, M = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      v();
    }, 3e3) : v();
  }, N = (j) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let F = h.step();
      const Q = Math.floor(Number(j) / F);
      return h.domain()[Q - 1];
    }
    if (Pn(n.xAxis) && n.visualizationType !== "Combo") {
      const F = Gh((te) => u(te[n.xAxis.dataKey])).left, X = h.invert(h(j)), Q = F(n.data, X, 1);
      return u(n.data[Q - 1][n.xAxis.dataKey]);
    }
  }, T = (j, F = !1) => {
    if (E !== "Pie" && R !== "horizontal") {
      if (h.type === "point" || w.type === "continuous" || Pn(w)) {
        let X = null, Q = Number.MAX_VALUE, ae = j;
        return t.forEach((te) => {
          const re = Pn(w) ? h(u(te[w.dataKey])) : h(te[w.dataKey]);
          let ie = n.barHeight;
          const ge = Math.abs(Number(re - ae + (F ? ie * 2 : 0)));
          ge <= Q && (Q = ge, X = (Pn(w), te[w.dataKey]));
        }), X;
      }
      if (n.xAxis.type === "categorical" || E === "Combo" && R !== "horizontal" && E !== "Forest Plot") {
        let Q = (h.range()[1] - h.range()[0]) / (h.domain().length + 1);
        const te = Math.floor((Number(j) - Q / 2) / Q);
        return h.domain()[te];
      }
      if (Pn(w) && E !== "Combo" && R !== "horizontal") {
        const X = Gh((re) => u(re[n.xAxis.dataKey])).left, Q = h.invert(j), ae = X(n.data, Q, 1);
        return u(n.data[ae - 1][n.xAxis.dataKey]);
      }
    }
  }, U = (j, F) => {
    if (E === "Pie")
      return;
    let X = Number.MAX_VALUE, Q = null;
    return t.forEach((ae, te) => {
      const re = m(E !== "Forest Plot" ? ae[n.xAxis.dataKey] : te), ie = Math.abs(re - j);
      ie < X && (X = ie, Q = F ? ae[F] : ae[n.xAxis.dataKey]);
    }), Q;
  }, V = (j) => {
    var F, X;
    try {
      const Q = wf(j), { x: ae } = Q;
      if (!ae)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let te = T(ae, !0), re = (F = n.data) == null ? void 0 : F.filter((ie) => ie[n.xAxis.dataKey] === te);
      if (!te)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Pn(w) && te && (te = new Date(te), te = o(te), re = (X = n.data) == null ? void 0 : X.filter((ie) => o(new Date(ie[n.xAxis.dataKey])) === te)), !re[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${te}`);
      s && (n != null && n.uid) && (re != null && re[0]) && s(n.uid, re[0]);
    } catch (Q) {
      console.error(Q.message);
    }
  }, G = (j, F) => {
    try {
      let X;
      return w.type === "categorical" ? X = t.filter((ae) => ae[w.dataKey] === j) : X = t.filter((ae) => ae[w.dataKey] === j), !X || X.length === 0 ? [] : X.map((ae) => Object.fromEntries(Object.entries(ae).filter(([te, re]) => F.includes(te))));
    } catch (X) {
      console.error("COVE", X);
    }
  }, ue = () => {
    var j;
    try {
      let F, X = [], Q = [];
      if ((j = n.series) == null || j.forEach((ae) => {
        ae.type === "Forecasting" && (X.push(ae.stageColumn), ae == null || ae.confidenceIntervals.forEach((te) => {
          te.showInTooltip === !0 && (Q.push(te.low), Q.push(te.high));
        }));
      }), !n.dashboard)
        switch (E) {
          case "Combo":
            F = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys, ...Q];
            break;
          case "Forecasting":
            F = [g.xAxis.dataKey, ...X, ...Q];
            break;
          case "Line":
            F = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Area Chart":
            F = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Bar":
            F = R === "vertical" ? [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys] : [g.yAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Pie":
            F = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return n.dashboard && (F = [g.xAxis.dataKey, ...g == null ? void 0 : g.barSeriesKeys, ...g == null ? void 0 : g.lineSeriesKeys, ...X, ...Q]), F;
    } catch (F) {
      console.error("COVE", F);
    }
  }, Z = (j) => {
    const { dataXPosition: F, dataYPosition: X } = j;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${F}px, ${Number(X)}px)`
    };
  }, $ = (j) => {
    var X, Q;
    let F = n.series.filter((ae) => ae.dataKey === j);
    return (X = F[0]) != null && X.name ? (Q = F[0]) == null ? void 0 : Q.name : j;
  };
  return {
    getIncludedTooltipSeries: ue,
    getXValueFromCoordinate: T,
    getXValueFromCoordinateDate: N,
    getYScaleValues: G,
    handleTooltipClick: V,
    handleTooltipMouseOff: M,
    handleTooltipMouseOver: P,
    TooltipListItem: ({ item: j }) => {
      const [F, X] = j, [Q, ae, te] = X;
      if (E === "Forest Plot")
        return Q === n.xAxis.dataKey ? /* @__PURE__ */ a.createElement("li", { className: "tooltip-heading" }, `${r(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${Pn(C) ? o(u(Q, !1)) : ae}`) : /* @__PURE__ */ a.createElement("li", { className: "tooltip-body" }, `${$(Q)}: ${i(ae, "left")}`);
      const re = n.tooltips.dateDisplayFormat ? d(u(ae, !1)) : o(u(ae, !1));
      return E === "Bar" && R === "horizontal" && Q === n.xAxis.dataKey ? /* @__PURE__ */ a.createElement("li", { className: "tooltip-heading" }, `${r(n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : "")} ${n.xAxis.type === "date" ? re : ae}`) : Q === n.xAxis.dataKey ? /* @__PURE__ */ a.createElement("li", { className: "tooltip-heading" }, `${r(n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : "")} ${Pn(w) ? re : ae}`) : /* @__PURE__ */ a.createElement("li", { className: "tooltip-body" }, `${$(Q)}: ${ae}`);
    },
    tooltipStyles: Z
  };
};
function dh(e, { threshold: t = 0, root: n = null, rootMargin: i = "0%", freezeOnceVisible: r = !1 }) {
  const [o, d] = ce.useState(), u = (o == null ? void 0 : o.isIntersecting) && r, s = ([h]) => {
    d(h);
  };
  return ce.useEffect(() => {
    setTimeout(() => {
      const h = e == null ? void 0 : e.current;
      if (!!!window.IntersectionObserver || u || !h)
        return;
      const y = { threshold: t, root: n, rootMargin: i }, v = new IntersectionObserver(s, y);
      return v.observe(h), () => v.disconnect();
    }, 500);
  }, [e, t, n, i, u]), o;
}
const Tf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
};
var KS = ["flexDirection", "alignItems", "margin", "display", "children"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function YS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function uc(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, i = e.alignItems, r = i === void 0 ? "center" : i, o = e.margin, d = o === void 0 ? "0" : o, u = e.display, s = u === void 0 ? "flex" : u, h = e.children, m = YS(e, KS);
  return /* @__PURE__ */ a.createElement("div", Cf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: r,
      flexDirection: n,
      margin: d
    }
  }, m), h);
}
uc.propTypes = {
  alignItems: he.string,
  margin: he.oneOfType([he.string, he.number]),
  children: he.node,
  display: he.string
};
var XS = ["flex", "label", "margin", "align", "children"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function qS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function cc(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, i = e.label, r = e.margin, o = r === void 0 ? "5px 0" : r, d = e.align, u = d === void 0 ? "left" : d, s = e.children, h = qS(e, XS);
  return /* @__PURE__ */ a.createElement("div", Af({
    className: "visx-legend-label",
    style: {
      justifyContent: u,
      display: "flex",
      flex: n,
      margin: o
    }
  }, h), s || i);
}
cc.propTypes = {
  align: he.string,
  label: he.node,
  flex: he.oneOfType([he.string, he.number]),
  margin: he.oneOfType([he.string, he.number]),
  children: he.node
};
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function fh(e) {
  var t = e.fill, n = e.width, i = e.height, r = e.style;
  return /* @__PURE__ */ a.createElement("div", {
    style: Pf({
      width: n,
      height: i,
      background: t
    }, r)
  });
}
fh.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Ig(e) {
  var t = e.fill, n = e.width, i = e.height, r = e.style, o = typeof n == "string" || typeof n > "u" ? 0 : n, d = typeof i == "string" || typeof i > "u" ? 0 : i, u = Math.max(o, d), s = u / 2;
  return /* @__PURE__ */ a.createElement("svg", {
    width: u,
    height: u
  }, /* @__PURE__ */ a.createElement(nt, {
    top: s,
    left: s
  }, /* @__PURE__ */ a.createElement("circle", {
    r: s,
    fill: t,
    style: r
  })));
}
Ig.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Hg(e) {
  var t = e.fill, n = e.width, i = e.height, r = e.style, o = typeof i == "string" || typeof i > "u" ? 0 : i, d = typeof (r == null ? void 0 : r.strokeWidth) == "number" ? r == null ? void 0 : r.strokeWidth : 2;
  return /* @__PURE__ */ a.createElement("svg", {
    width: n,
    height: i
  }, /* @__PURE__ */ a.createElement(nt, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ a.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: r
  })));
}
Hg.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function ms() {
  return ms = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ms.apply(this, arguments);
}
var Ud = function() {
};
function GS(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, i = e.fill, r = i === void 0 ? Ud : i, o = e.size, d = o === void 0 ? Ud : o, u = e.width, s = e.height, h = e.label, m = e.item, y = e.itemIndex, v = e.shapeStyle, w = v === void 0 ? Ud : v, E = {
    width: u,
    height: s,
    item: m,
    itemIndex: y,
    label: h,
    fill: r(ms({}, h)),
    size: d(ms({}, h)),
    style: w(ms({}, h))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ a.createElement(Ig, E) : n === "line" ? /* @__PURE__ */ a.createElement(Hg, E) : /* @__PURE__ */ a.createElement(fh, E) : /* @__PURE__ */ a.isValidElement(n) ? /* @__PURE__ */ a.cloneElement(n, E) : n ? /* @__PURE__ */ a.createElement(n, E) : null;
}
function dc() {
  return dc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, dc.apply(this, arguments);
}
function Wg(e) {
  var t = e.shape, n = t === void 0 ? fh : t, i = e.width, r = e.height, o = e.margin, d = e.label, u = e.item, s = e.itemIndex, h = e.fill, m = e.size, y = e.shapeStyle;
  return /* @__PURE__ */ a.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(dc({}, d)) : i,
      height: m ? m(dc({}, d)) : r,
      margin: o
    }
  }, GS({
    shape: n,
    item: u,
    itemIndex: s,
    label: d,
    width: i,
    height: r,
    fill: h,
    shapeStyle: y
  }));
}
Wg.propTypes = {
  itemIndex: he.number.isRequired,
  margin: he.oneOfType([he.string, he.number]),
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Vg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function $p(e) {
  return String(Vg(e));
}
function ZS(e) {
  var t = e.scale, n = e.labelFormat;
  return function(i, r) {
    return {
      datum: i,
      index: r,
      text: "" + n(i, r),
      value: t(i)
    };
  };
}
var QS = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function gs() {
  return gs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, gs.apply(this, arguments);
}
function JS(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var eE = {
  display: "flex"
};
function jg(e) {
  var t = e.className, n = e.style, i = n === void 0 ? eE : n, r = e.scale, o = e.shape, d = e.domain, u = e.fill, s = u === void 0 ? $p : u, h = e.size, m = h === void 0 ? $p : h, y = e.labelFormat, v = y === void 0 ? Vg : y, w = e.labelTransform, E = w === void 0 ? ZS : w, R = e.shapeWidth, C = R === void 0 ? 15 : R, g = e.shapeHeight, _ = g === void 0 ? 15 : g, P = e.shapeMargin, M = P === void 0 ? "2px 4px 2px 0" : P, N = e.shapeStyle, T = e.labelAlign, U = T === void 0 ? "left" : T, V = e.labelFlex, G = V === void 0 ? "1" : V, ue = e.labelMargin, Z = ue === void 0 ? "0 4px" : ue, $ = e.itemMargin, H = $ === void 0 ? "0" : $, j = e.direction, F = j === void 0 ? "column" : j, X = e.itemDirection, Q = X === void 0 ? "row" : X, ae = e.legendLabelProps, te = e.children, re = JS(e, QS), ie = d || ("domain" in r ? r.domain() : []), ge = E({
    scale: r,
    labelFormat: v
  }), ve = ie.map(ge);
  return te ? /* @__PURE__ */ a.createElement(a.Fragment, null, te(ve)) : /* @__PURE__ */ a.createElement("div", {
    className: On("visx-legend", t),
    style: gs({}, i, {
      flexDirection: F
    })
  }, ve.map(function(Se, ye) {
    return /* @__PURE__ */ a.createElement(uc, gs({
      key: "legend-" + Se.text + "-" + ye,
      margin: H,
      flexDirection: Q
    }, re), /* @__PURE__ */ a.createElement(Wg, {
      shape: o,
      height: _,
      width: C,
      margin: M,
      item: ie[ye],
      itemIndex: ye,
      label: Se,
      fill: s,
      size: m,
      shapeStyle: N
    }), /* @__PURE__ */ a.createElement(cc, gs({
      label: Se.text,
      flex: G,
      margin: Z,
      align: U
    }, ae)));
  }));
}
jg.propTypes = {
  children: he.func,
  className: he.string,
  domain: he.array,
  shapeWidth: he.oneOfType([he.string, he.number]),
  shapeHeight: he.oneOfType([he.string, he.number]),
  shapeMargin: he.oneOfType([he.string, he.number]),
  labelAlign: he.string,
  labelFlex: he.oneOfType([he.string, he.number]),
  labelMargin: he.oneOfType([he.string, he.number]),
  itemMargin: he.oneOfType([he.string, he.number]),
  fill: he.func,
  size: he.func,
  shapeStyle: he.func
};
function tE(e) {
  return /* @__PURE__ */ a.createElement(jg, e);
}
function nE(e) {
  let t = ["legend-container"], n = ["legend-container__inner"];
  return e.legend.position === "left" && t.push("left"), e.legend.position === "bottom" && (t.push("bottom"), n.push("bottom")), e.legend.position === "bottom" && e.legend.singleRow && n.push("single-row"), e.legend.reverseLabelOrder && (n.push("d-flex"), n.push("flex-column-reverse")), e.legend.position === "bottom" && e.legend.verticalSorted && n.push("vertical-sorted"), {
    containerClasses: t,
    innerClasses: n
  };
}
const Lc = (e, t) => {
  var R;
  const { formatDate: n, parseDate: i } = ce.useContext(Ct);
  let r = [], o = "", d = [], u = [];
  ((R = e.series) == null ? void 0 : R.length) > 0 && e.data ? (r = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, u = e.data.map((C) => C[e.xAxis.dataKey])) : (r = [], o = "", d = [], u = []);
  const s = (C, g) => {
    const _ = [...e.highlightedBarValues];
    _[g].borderWidth = C.target.value, t({
      ...e,
      highlightedBarValues: _
    });
  }, h = (C, g) => {
    C.preventDefault();
    const _ = [...e.highlightedBarValues];
    _[g].value = C.target.value, _[g].dataKey = o, t({
      ...e,
      highlightedBarValues: _
    });
  }, m = (C, g) => {
    C.preventDefault();
    const _ = [...e.highlightedBarValues];
    _.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: _
    });
  }, y = (C, g) => {
    C.preventDefault();
    const _ = [...e.highlightedBarValues];
    _.splice(g, 1), t({
      ...e,
      highlightedBarValues: _
    });
  }, v = (C, g) => {
    const _ = [...e.highlightedBarValues];
    _[g].color = C.target.value, t({
      ...e
    });
  }, w = (C, g) => {
    const _ = [...e.highlightedBarValues];
    _[g].legendLabel = C.target.value, t({
      ...e,
      copyOfHighlightedBarValues: _
    });
  }, E = () => {
  };
  return E.checkFontColor = (C, g, _) => {
    if (e.xAxis.type === "date") {
      if (E.formatDates(g).includes(C))
        return "#000";
    } else if (g.includes(C))
      return "#000";
    return _;
  }, E.formatDates = (C) => C.map((g) => g ? n(i(g)) : !1), E.findDuplicates = (C) => {
    const g = {};
    return C == null ? void 0 : C.filter((P) => {
      const { legendLabel: M } = P;
      return g[M] ? !1 : (g[M] = !0, !0);
    });
  }, {
    HighLightedBarUtils: E,
    highlightedSeries: r,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: u,
    handleUpdateHighlightedBar: h,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: y,
    handleUpdateHighlightedBarColor: v,
    handleHighlightedBarLegendLabel: w,
    handleUpdateHighlightedBorderWidth: s
  };
}, Ug = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, rE = (e, t) => e ? t ? "35px" : "15px" : "0px", Kg = ce.forwardRef(({ config: e, colorScale: t, seriesHighlight: n, highlight: i, highlightReset: r, currentViewport: o, formatLabels: d, skipId: u = "legend" }, s) => {
  const { innerClasses: h, containerClasses: m } = nE(e), { runtime: y, legend: v } = e;
  if (!v)
    return null;
  const w = (v == null ? void 0 : v.position) === "bottom" || ["sm", "xs", "xxs"].includes(o) && !v.hide, E = {
    marginBottom: w ? "15px" : "0px",
    marginTop: w && e.orientation === "horizontal" ? `${e.yAxis.label && e.isResponsiveTicks ? e.dynamicMarginTop : e.runtime.xAxis.size}px` : rE(w, e.brush.active)
  }, { HighLightedBarUtils: R } = Lc(e);
  let C = R.findDuplicates(e.highlightedBarValues);
  return /* @__PURE__ */ a.createElement("aside", { ref: s, style: E, id: u || "legend", className: m.join(" "), role: "region", "aria-label": "legend", tabIndex: 0 }, v.label && /* @__PURE__ */ a.createElement("h3", null, Mi(v.label)), v.description && /* @__PURE__ */ a.createElement("p", null, Mi(v.description)), /* @__PURE__ */ a.createElement(tE, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (g) => {
    var _, P, M, N;
    return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("div", { className: h.join(" ") }, d(g).map((T, U) => {
      var ue, Z, $, H;
      let V = ["legend-item", `legend-text--${T.text.replace(" ", "").toLowerCase()}`], G = T.datum;
      if (e.exclusions.active && ((ue = e.exclusions.keys) != null && ue.includes(G)))
        return null;
      if (y.seriesLabels) {
        let j = e.runtime.seriesLabelsAll.indexOf(G);
        G = e.runtime.seriesKeys[j], ((Z = y == null ? void 0 : y.forecastingSeriesKeys) == null ? void 0 : Z.length) > 0 && (G = T.text);
      }
      return n.length > 0 && n.includes(G) === !1 && V.push("inactive"), /* @__PURE__ */ a.createElement(
        uc,
        {
          className: V.join(" "),
          tabIndex: 0,
          key: `legend-quantile-${U}`,
          onKeyDown: (j) => {
            j.key === "Enter" && (j.preventDefault(), i(T));
          },
          onClick: (j) => {
            j.preventDefault(), i(T);
          },
          role: "button"
        },
        /* @__PURE__ */ a.createElement("div", null, e.visualizationType === "Line" && e.legend.lineMode ? /* @__PURE__ */ a.createElement("svg", { width: 40, height: 20 }, /* @__PURE__ */ a.createElement(on, { from: { x: 10, y: 10 }, to: { x: 40, y: 10 }, stroke: T.value, strokeWidth: 2, strokeDasharray: Ug(($ = e.series[U]) != null && $.type ? (H = e.series[U]) == null ? void 0 : H.type : "") })) : /* @__PURE__ */ a.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ a.createElement(Wh, { viewport: o, margin: "0", fill: T.value, display: !0 }))),
        /* @__PURE__ */ a.createElement(cc, { align: "left", margin: "0 0 0 4px" }, T.text)
      );
    }), C.map((T, U) => {
      let V = "legend-item", G = T.legendLabel;
      return G ? (n.length > 0 && n.includes(G) === !1 && (V += " inactive"), /* @__PURE__ */ a.createElement(
        uc,
        {
          className: V,
          tabIndex: 0,
          key: `legend-quantile-${U}`,
          onKeyDown: (ue) => {
            ue.key === "Enter" && (ue.preventDefault(), i(T.legendLabel));
          },
          onClick: (ue) => {
            ue.preventDefault(), i(T.legendLabel);
          }
        },
        /* @__PURE__ */ a.createElement(Wh, { fill: "transparent", borderColor: T.color ? T.color : "rgba(255, 102, 1)" }),
        " ",
        /* @__PURE__ */ a.createElement(cc, { align: "left", margin: "0 0 0 4px" }, T.legendLabel ? T.legendLabel : T.value)
      )) : !1;
    })), /* @__PURE__ */ a.createElement(a.Fragment, null, ((_ = e == null ? void 0 : e.preliminaryData) == null ? void 0 : _.some((T) => T.label && T.type === "effect" && T.style)) && ["Line", "Combo"].includes(e.visualizationType) && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("div", { className: e.legend.singleRow && w ? "legend-container__inner bottom single-row" : "" }, (P = e == null ? void 0 : e.preliminaryData) == null ? void 0 : P.map((T, U) => /* @__PURE__ */ a.createElement(a.Fragment, null, T.label && T.type === "effect" && T.style && /* @__PURE__ */ a.createElement("div", { key: U, className: "legend-preliminary" }, /* @__PURE__ */ a.createElement("span", { className: T.symbol }, T.lineCode), /* @__PURE__ */ a.createElement("p", null, " ", T.label)))))), !e.legend.hideSuppressedLabels && ((M = e == null ? void 0 : e.preliminaryData) == null ? void 0 : M.some((T) => T.label && T.displayLegend && T.type === "suppression" && T.value && ((T == null ? void 0 : T.style) || T.symbol))) && (e.visualizationType === "Bar" && e.visualizationSubType === "regular" || e.visualizationType === "Line" || e.visualizationType === "Combo") && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("div", { className: e.legend.singleRow && w ? "legend-container__inner bottom single-row" : "" }, (N = e == null ? void 0 : e.preliminaryData) == null ? void 0 : N.map(
      (T, U) => T.displayLegend && T.type === "suppression" && /* @__PURE__ */ a.createElement(a.Fragment, null, e.visualizationType === "Bar" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("div", { key: U + "Bar", className: `legend-preliminary ${T.symbol}` }, /* @__PURE__ */ a.createElement("span", { className: T.symbol }, T.iconCode), /* @__PURE__ */ a.createElement("p", { className: T.type }, T.label))), e.visualizationType === "Line" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("div", { key: U + "Line", className: "legend-preliminary " }, /* @__PURE__ */ a.createElement("span", null, T.lineCode), /* @__PURE__ */ a.createElement("p", { className: T.type }, T.label))), e.visualizationType === "Combo" && /* @__PURE__ */ a.createElement(a.Fragment, null, T.symbol && T.iconCode && /* @__PURE__ */ a.createElement("div", { key: U + "Combo", className: `legend-preliminary ${T.symbol}` }, /* @__PURE__ */ a.createElement("span", { className: T.symbol }, T.iconCode), /* @__PURE__ */ a.createElement("p", { className: T.type }, T.label)), T.style && T.lineCode && /* @__PURE__ */ a.createElement("div", { key: U + "Combo", className: "legend-preliminary" }, /* @__PURE__ */ a.createElement("span", null, T.lineCode), /* @__PURE__ */ a.createElement("p", null, T.label))))
    )))));
  }), n.length > 0 && /* @__PURE__ */ a.createElement(Vf, { onClick: (g) => r(g), style: { marginTop: "1rem" } }, "Reset"));
});
function aE(e) {
  return Ry({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Yg = (e, t, n, i) => (r) => {
  var v, w, E, R, C;
  const { visualizationType: o, visualizationSubType: d, series: u, runtime: s } = e, h = (g) => {
    var _;
    return e.legend.reverseLabelOrder && ((_ = e.legend) == null ? void 0 : _.position) === "bottom" ? g.reverse() : g;
  }, m = (v = e.legend) == null ? void 0 : v.colorCode;
  if (o === "Deviation Bar") {
    const [g, _] = Uu[e.twoColor.palette], P = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: g
    }, M = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: _
    };
    return h([P, M]);
  }
  if (o === "Bar" && d === "regular" && m && (u == null ? void 0 : u.length) === 1) {
    let g = dr[e.palette];
    for (; t.length > g.length; )
      g = g.concat(g);
    g = g.slice(0, n.length);
    const _ = /* @__PURE__ */ new Set();
    t.forEach((M) => _.add(M[m]));
    const P = Array.from(_).map((M, N) => ({
      datum: M,
      index: N,
      text: M,
      value: g[N]
    }));
    return h(P);
  }
  if (((w = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : w.length) > 0) {
    let g = [];
    return (R = (E = e.runtime) == null ? void 0 : E.forecastingSeriesKeys) == null || R.map((_, P) => {
      var M;
      return (M = _ == null ? void 0 : _.stages) == null ? void 0 : M.map((N, T) => {
        var G, ue, Z, $;
        let U = (G = Ku[N.color]) != null && G[2] ? (ue = Ku[N.color]) == null ? void 0 : ue[2] : (Z = dr[N.color]) != null && Z[2] ? ($ = dr[N.color]) == null ? void 0 : $[2] : "#ccc";
        const V = {
          datum: N.key,
          index: T,
          text: N.key,
          value: U
        };
        g.push(V);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((_, P) => {
      let M = dr[e.palette][P] ? dr[e.palette][P] : "#ccc";
      const N = {
        datum: _,
        index: P,
        text: _,
        value: M
      };
      g.push(N);
    }), h(g);
  }
  if (e.series.filter((g) => !!g.name).length > 0) {
    const g = /* @__PURE__ */ new Set();
    e.series.forEach((P) => {
      g.add(P.name || P.dataKey);
    });
    const _ = Array.from(g).map((P, M) => ({
      datum: P,
      index: M,
      text: P,
      value: i(P)
    }));
    return h(_);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const g = r.length - 1;
    let _ = [];
    return (C = e.suppressedData) == null || C.forEach(({ label: P, icon: M }, N) => {
      if (P && M) {
        const T = {
          datum: P,
          index: g + N,
          text: P,
          icon: /* @__PURE__ */ a.createElement(aE, { color: "#000", size: 15 })
        };
        _.push(T);
      }
    }), [...r, ..._];
  }
  return h(r);
}, Ru = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), iE = (e) => {
  const { transformedData: t, config: n, colorScale: i, currentViewport: r, dimensions: o, highlight: d, highlightReset: u, seriesHighlight: s } = ce.useContext(Ct), { tooltipData: h, showTooltip: m, hideTooltip: y, tooltipOpen: v, tooltipLeft: w, tooltipTop: E } = _g(), { handleTooltipMouseOver: R, handleTooltipMouseOff: C, TooltipListItem: g } = $g({
    xScale: !1,
    yScale: !1,
    showTooltip: m,
    hideTooltip: y
  }), [_, P] = ce.useState(void 0), [M, N] = ce.useState(!1), T = Object.values(n.columns).filter((re) => re.showInViz), U = T.length > 0, V = U ? "pivotColumn" : void 0, G = ce.useMemo(() => {
    if (U) {
      let re = [];
      const ie = n.yAxis.dataKey, ge = T.map((ye) => ye.name), ve = [ie, ...ge], Se = n.xAxis.dataKey;
      return t.forEach((ye) => {
        ve.forEach((ee) => {
          const Ee = ye[ee];
          Ee && re.push({
            [V]: Ee,
            [Se]: `${ye[Se]} - ${ee}`
          });
        });
      }), re;
    }
    return t;
  }, [t, U]), ue = ce.useMemo(() => {
    if (U) {
      const re = {};
      G.forEach((ve) => {
        re[ve[n.xAxis.dataKey]] || (re[ve[n.xAxis.dataKey]] = !0);
      });
      const ie = Object.entries(re).length;
      let ge = n.customColors || dr[n.palette];
      return ge = ge.slice(0, ie), zm({
        domain: Object.keys(re),
        range: ge,
        unknown: null
      });
    }
    return i;
  }, [i, U]), Z = ce.useRef(), $ = dh(Z, {
    freezeOnceVisible: !1
  });
  ce.useEffect(() => {
    document.querySelector(".isEditor") && N((ie) => !0);
  }), ce.useEffect(() => {
    $ != null && $.isIntersecting && n.animate && !M && setTimeout(() => {
      N(!0);
    }, 500);
  }, [$ == null ? void 0 : $.isIntersecting, n.animate]);
  const H = ({ arcs: re, path: ie, getKey: ge }) => {
    const ve = Nb(re, ge, {
      from: Ru,
      enter: Ru,
      update: Ru,
      leave: Ru
    });
    return ce.useEffect(() => {
      const Se = setTimeout(() => {
        y();
      }, 500);
      return () => {
        clearTimeout(Se);
      };
    }, [h]), /* @__PURE__ */ a.createElement(a.Fragment, null, ve.map(({ item: Se, props: ye, key: ee }, Ee) => /* @__PURE__ */ a.createElement(nt, { className: Se.data[n.xAxis.dataKey], key: `${ee}-${Ee}`, style: { opacity: n.legend.behavior === "highlight" && s.length > 0 && s.indexOf(Se.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1 } }, /* @__PURE__ */ a.createElement(
      Lp.path,
      {
        d: Lb(
          [ye.startAngle, ye.endAngle],
          (He, we) => ie({
            ...Se,
            startAngle: He,
            endAngle: we
          })
        ),
        fill: ue(Se.data[n.runtime.xAxis.dataKey]),
        onMouseEnter: (He) => R(He, { data: Se.data[n.runtime.xAxis.dataKey], arc: Se }),
        onMouseLeave: (He) => C()
      }
    ))), ve.map(({ item: Se, key: ye }, ee) => {
      const [Ee, He] = ie.centroid(Se), we = Se.endAngle - Se.startAngle >= 0.1;
      let fe = "#FFF";
      return ue(Se.data[n.runtime.xAxis.dataKey]) && (fe = Zo(fe, ue(Se.data[n.runtime.xAxis.dataKey]))), /* @__PURE__ */ a.createElement(Lp.g, { key: `${ye}${ee}` }, we && /* @__PURE__ */ a.createElement(vt, { style: { fill: fe }, x: Ee, y: He, dy: ".33em", textAnchor: "middle", pointerEvents: "none" }, Math.round((Se.endAngle - Se.startAngle) * 180 / Math.PI / 360 * 100) + "%"));
    }));
  };
  let [j] = o;
  n && n.legend && !n.legend.hide && r === "lg" && (j = j * 0.73);
  const F = n.heights.vertical, X = Math.min(j, F) / 2, Q = F / 2, ae = n.pieType === "Donut" ? 75 : X;
  ce.useEffect(() => {
    if (s.length > 0 && n.legend.behavior !== "highlight") {
      let re = [];
      G.forEach((ie) => {
        s.indexOf(ie[n.runtime.xAxis.dataKey]) !== -1 && re.push(ie);
      }), P(re);
    } else
      P(void 0);
  }, [s]);
  const te = Yg(n, [], G, ue);
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Cr, { component: "PieChart" }, /* @__PURE__ */ a.createElement("svg", { width: X * 2, height: F, className: `animated-pie group ${n.animate === !1 || M ? "animated" : ""}`, role: "img", "aria-label": Tf(n) }, /* @__PURE__ */ a.createElement(nt, { top: Q, left: X }, /* @__PURE__ */ a.createElement(
    Y0,
    {
      data: _ || G,
      pieValue: (re) => re[V || n.runtime.yAxis.dataKey],
      pieSortValues: () => -1,
      innerRadius: X - ae,
      outerRadius: X
    },
    (re) => /* @__PURE__ */ a.createElement(H, { ...re, getKey: (ie) => ie.data[n.runtime.xAxis.dataKey] })
  ))), /* @__PURE__ */ a.createElement("div", { ref: Z }), h && Object.entries(h.data).length > 0 && v && m && h.dataYPosition && h.dataXPosition && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important`), /* @__PURE__ */ a.createElement(Bg, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: w, top: E }, /* @__PURE__ */ a.createElement("ul", null, typeof h == "object" && Object.entries(h.data).map((re, ie) => /* @__PURE__ */ a.createElement(g, { item: re, key: ie })))))), /* @__PURE__ */ a.createElement(Kg, { config: n, colorScale: ue, seriesHighlight: s, highlight: d, highlightReset: u, currentViewport: r, formatLabels: te }));
};
function Ps(e) {
  return e.split("-")[1];
}
function hh(e) {
  return e === "y" ? "height" : "width";
}
function $i(e) {
  return e.split("-")[0];
}
function Ls(e) {
  return ["top", "bottom"].includes($i(e)) ? "x" : "y";
}
function Ip(e, t, n) {
  let { reference: i, floating: r } = e;
  const o = i.x + i.width / 2 - r.width / 2, d = i.y + i.height / 2 - r.height / 2, u = Ls(t), s = hh(u), h = i[s] / 2 - r[s] / 2, m = u === "x";
  let y;
  switch ($i(t)) {
    case "top":
      y = { x: o, y: i.y - r.height };
      break;
    case "bottom":
      y = { x: o, y: i.y + i.height };
      break;
    case "right":
      y = { x: i.x + i.width, y: d };
      break;
    case "left":
      y = { x: i.x - r.width, y: d };
      break;
    default:
      y = { x: i.x, y: i.y };
  }
  switch (Ps(t)) {
    case "start":
      y[u] -= h * (n && m ? -1 : 1);
      break;
    case "end":
      y[u] += h * (n && m ? -1 : 1);
  }
  return y;
}
function Xg(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ys(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function qg(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: i, y: r, platform: o, rects: d, elements: u, strategy: s } = e, { boundary: h = "clippingAncestors", rootBoundary: m = "viewport", elementContext: y = "floating", altBoundary: v = !1, padding: w = 0 } = t, E = Xg(w), R = u[v ? y === "floating" ? "reference" : "floating" : y], C = ys(await o.getClippingRect({ element: (n = await (o.isElement == null ? void 0 : o.isElement(R))) == null || n ? R : R.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(u.floating)), boundary: h, rootBoundary: m, strategy: s })), g = y === "floating" ? { ...d.floating, x: i, y: r } : d.reference, _ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u.floating)), P = await (o.isElement == null ? void 0 : o.isElement(_)) && await (o.getScale == null ? void 0 : o.getScale(_)) || { x: 1, y: 1 }, M = ys(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: g, offsetParent: _, strategy: s }) : g);
  return { top: (C.top - M.top + E.top) / P.y, bottom: (M.bottom - C.bottom + E.bottom) / P.y, left: (C.left - M.left + E.left) / P.x, right: (M.right - C.right + E.right) / P.x };
}
const oE = Math.min, lE = Math.max;
function Lf(e, t, n) {
  return lE(e, oE(t, n));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const sE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function fc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => sE[t]);
}
function uE(e, t, n) {
  n === void 0 && (n = !1);
  const i = Ps(e), r = Ls(e), o = hh(r);
  let d = r === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = fc(d)), { main: d, cross: fc(d) };
}
const cE = { start: "end", end: "start" };
function Kd(e) {
  return e.replace(/start|end/g, (t) => cE[t]);
}
const dE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: i, middlewareData: r, rects: o, initialPlacement: d, platform: u, elements: s } = t, { mainAxis: h = !0, crossAxis: m = !0, fallbackPlacements: y, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: E = !0, ...R } = e, C = $i(i), g = $i(d) === d, _ = await (u.isRTL == null ? void 0 : u.isRTL(s.floating)), P = y || (g || !E ? [fc(d)] : function(Z) {
      const $ = fc(Z);
      return [Kd(Z), $, Kd($)];
    }(d));
    y || w === "none" || P.push(...function(Z, $, H, j) {
      const F = Ps(Z);
      let X = function(Q, ae, te) {
        const re = ["left", "right"], ie = ["right", "left"], ge = ["top", "bottom"], ve = ["bottom", "top"];
        switch (Q) {
          case "top":
          case "bottom":
            return te ? ae ? ie : re : ae ? re : ie;
          case "left":
          case "right":
            return ae ? ge : ve;
          default:
            return [];
        }
      }($i(Z), H === "start", j);
      return F && (X = X.map((Q) => Q + "-" + F), $ && (X = X.concat(X.map(Kd)))), X;
    }(d, E, w, _));
    const M = [d, ...P], N = await qg(t, R), T = [];
    let U = ((n = r.flip) == null ? void 0 : n.overflows) || [];
    if (h && T.push(N[C]), m) {
      const { main: Z, cross: $ } = uE(i, o, _);
      T.push(N[Z], N[$]);
    }
    if (U = [...U, { placement: i, overflows: T }], !T.every((Z) => Z <= 0)) {
      var V, G;
      const Z = (((V = r.flip) == null ? void 0 : V.index) || 0) + 1, $ = M[Z];
      if ($)
        return { data: { index: Z, overflows: U }, reset: { placement: $ } };
      let H = (G = U.find((j) => j.overflows[0] <= 0)) == null ? void 0 : G.placement;
      if (!H)
        switch (v) {
          case "bestFit": {
            var ue;
            const j = (ue = U.map((F) => [F.placement, F.overflows.filter((X) => X > 0).reduce((X, Q) => X + Q, 0)]).sort((F, X) => F[1] - X[1])[0]) == null ? void 0 : ue[0];
            j && (H = j);
            break;
          }
          case "initialPlacement":
            H = d;
        }
      if (i !== H)
        return { reset: { placement: H } };
    }
    return {};
  } };
}, fE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: i } = t, r = await async function(o, d) {
      const { placement: u, platform: s, elements: h } = o, m = await (s.isRTL == null ? void 0 : s.isRTL(h.floating)), y = $i(u), v = Ps(u), w = Ls(u) === "x", E = ["left", "top"].includes(y) ? -1 : 1, R = m && w ? -1 : 1, C = typeof d == "function" ? d(o) : d;
      let { mainAxis: g, crossAxis: _, alignmentAxis: P } = typeof C == "number" ? { mainAxis: C, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...C };
      return v && typeof P == "number" && (_ = v === "end" ? -1 * P : P), w ? { x: _ * R, y: g * E } : { x: g * E, y: _ * R };
    }(t, e);
    return { x: n + r.x, y: i + r.y, data: r };
  } };
}, hE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: i, placement: r } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: u = { fn: (C) => {
      let { x: g, y: _ } = C;
      return { x: g, y: _ };
    } }, ...s } = e, h = { x: n, y: i }, m = await qg(t, s), y = Ls($i(r)), v = y === "x" ? "y" : "x";
    let w = h[y], E = h[v];
    if (o) {
      const C = y === "y" ? "bottom" : "right";
      w = Lf(w + m[y === "y" ? "top" : "left"], w, w - m[C]);
    }
    if (d) {
      const C = v === "y" ? "bottom" : "right";
      E = Lf(E + m[v === "y" ? "top" : "left"], E, E - m[C]);
    }
    const R = u.fn({ ...t, [y]: w, [v]: E });
    return { ...R, data: { x: R.x - n, y: R.y - i } };
  } };
};
function Tr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Gr(e) {
  return Tr(e).getComputedStyle(e);
}
const Hp = Math.min, vs = Math.max, hc = Math.round;
function Gg(e) {
  const t = Gr(e);
  let n = parseFloat(t.width), i = parseFloat(t.height);
  const r = e.offsetWidth, o = e.offsetHeight, d = hc(n) !== r || hc(i) !== o;
  return d && (n = r, i = o), { width: n, height: i, fallback: d };
}
function Va(e) {
  return Qg(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Du;
function Zg() {
  if (Du)
    return Du;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Du = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Du) : navigator.userAgent;
}
function Zr(e) {
  return e instanceof Tr(e).HTMLElement;
}
function $a(e) {
  return e instanceof Tr(e).Element;
}
function Qg(e) {
  return e instanceof Tr(e).Node;
}
function Wp(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Tr(e).ShadowRoot || e instanceof ShadowRoot;
}
function Rc(e) {
  const { overflow: t, overflowX: n, overflowY: i, display: r } = Gr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !["inline", "contents"].includes(r);
}
function pE(e) {
  return ["table", "td", "th"].includes(Va(e));
}
function Rf(e) {
  const t = /firefox/i.test(Zg()), n = Gr(e), i = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!i && i !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((r) => n.willChange.includes(r)) || ["paint", "layout", "strict", "content"].some((r) => {
    const o = n.contain;
    return o != null && o.includes(r);
  });
}
function Jg() {
  return !/^((?!chrome|android).)*safari/i.test(Zg());
}
function ph(e) {
  return ["html", "body", "#document"].includes(Va(e));
}
function ey(e) {
  return $a(e) ? e : e.contextElement;
}
const ty = { x: 1, y: 1 };
function Go(e) {
  const t = ey(e);
  if (!Zr(t))
    return ty;
  const n = t.getBoundingClientRect(), { width: i, height: r, fallback: o } = Gg(t);
  let d = (o ? hc(n.width) : n.width) / i, u = (o ? hc(n.height) : n.height) / r;
  return d && Number.isFinite(d) || (d = 1), u && Number.isFinite(u) || (u = 1), { x: d, y: u };
}
function Ts(e, t, n, i) {
  var r, o;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const d = e.getBoundingClientRect(), u = ey(e);
  let s = ty;
  t && (i ? $a(i) && (s = Go(i)) : s = Go(e));
  const h = u ? Tr(u) : window, m = !Jg() && n;
  let y = (d.left + (m && ((r = h.visualViewport) == null ? void 0 : r.offsetLeft) || 0)) / s.x, v = (d.top + (m && ((o = h.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, w = d.width / s.x, E = d.height / s.y;
  if (u) {
    const R = Tr(u), C = i && $a(i) ? Tr(i) : i;
    let g = R.frameElement;
    for (; g && i && C !== R; ) {
      const _ = Go(g), P = g.getBoundingClientRect(), M = getComputedStyle(g);
      P.x += (g.clientLeft + parseFloat(M.paddingLeft)) * _.x, P.y += (g.clientTop + parseFloat(M.paddingTop)) * _.y, y *= _.x, v *= _.y, w *= _.x, E *= _.y, y += P.x, v += P.y, g = Tr(g).frameElement;
    }
  }
  return { width: w, height: E, top: v, right: y + w, bottom: v + E, left: y, x: y, y: v };
}
function Ia(e) {
  return ((Qg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Dc(e) {
  return $a(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ny(e) {
  return Ts(Ia(e)).left + Dc(e).scrollLeft;
}
function Cs(e) {
  if (Va(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Wp(e) && e.host || Ia(e);
  return Wp(t) ? t.host : t;
}
function ry(e) {
  const t = Cs(e);
  return ph(t) ? t.ownerDocument.body : Zr(t) && Rc(t) ? t : ry(t);
}
function ay(e, t) {
  var n;
  t === void 0 && (t = []);
  const i = ry(e), r = i === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Tr(i);
  return r ? t.concat(o, o.visualViewport || [], Rc(i) ? i : []) : t.concat(i, ay(i));
}
function Vp(e, t, n) {
  return t === "viewport" ? ys(function(i, r) {
    const o = Tr(i), d = Ia(i), u = o.visualViewport;
    let s = d.clientWidth, h = d.clientHeight, m = 0, y = 0;
    if (u) {
      s = u.width, h = u.height;
      const v = Jg();
      (v || !v && r === "fixed") && (m = u.offsetLeft, y = u.offsetTop);
    }
    return { width: s, height: h, x: m, y };
  }(e, n)) : $a(t) ? ys(function(i, r) {
    const o = Ts(i, !0, r === "fixed"), d = o.top + i.clientTop, u = o.left + i.clientLeft, s = Zr(i) ? Go(i) : { x: 1, y: 1 };
    return { width: i.clientWidth * s.x, height: i.clientHeight * s.y, x: u * s.x, y: d * s.y };
  }(t, n)) : ys(function(i) {
    const r = Ia(i), o = Dc(i), d = i.ownerDocument.body, u = vs(r.scrollWidth, r.clientWidth, d.scrollWidth, d.clientWidth), s = vs(r.scrollHeight, r.clientHeight, d.scrollHeight, d.clientHeight);
    let h = -o.scrollLeft + ny(i);
    const m = -o.scrollTop;
    return Gr(d).direction === "rtl" && (h += vs(r.clientWidth, d.clientWidth) - u), { width: u, height: s, x: h, y: m };
  }(Ia(e)));
}
function jp(e) {
  return Zr(e) && Gr(e).position !== "fixed" ? e.offsetParent : null;
}
function Up(e) {
  const t = Tr(e);
  let n = jp(e);
  for (; n && pE(n) && Gr(n).position === "static"; )
    n = jp(n);
  return n && (Va(n) === "html" || Va(n) === "body" && Gr(n).position === "static" && !Rf(n)) ? t : n || function(i) {
    let r = Cs(i);
    for (; Zr(r) && !ph(r); ) {
      if (Rf(r))
        return r;
      r = Cs(r);
    }
    return null;
  }(e) || t;
}
function mE(e, t, n) {
  const i = Zr(t), r = Ia(t), o = Ts(e, !0, n === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const u = { x: 0, y: 0 };
  if (i || !i && n !== "fixed")
    if ((Va(t) !== "body" || Rc(r)) && (d = Dc(t)), Zr(t)) {
      const s = Ts(t, !0);
      u.x = s.x + t.clientLeft, u.y = s.y + t.clientTop;
    } else
      r && (u.x = ny(r));
  return { x: o.left + d.scrollLeft - u.x, y: o.top + d.scrollTop - u.y, width: o.width, height: o.height };
}
const gE = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: i, strategy: r } = e;
  const o = n === "clippingAncestors" ? function(h, m) {
    const y = m.get(h);
    if (y)
      return y;
    let v = ay(h).filter((C) => $a(C) && Va(C) !== "body"), w = null;
    const E = Gr(h).position === "fixed";
    let R = E ? Cs(h) : h;
    for (; $a(R) && !ph(R); ) {
      const C = Gr(R), g = Rf(R);
      (E ? g || w : g || C.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = C : v = v.filter((_) => _ !== R), R = Cs(R);
    }
    return m.set(h, v), v;
  }(t, this._c) : [].concat(n), d = [...o, i], u = d[0], s = d.reduce((h, m) => {
    const y = Vp(t, m, r);
    return h.top = vs(y.top, h.top), h.right = Hp(y.right, h.right), h.bottom = Hp(y.bottom, h.bottom), h.left = vs(y.left, h.left), h;
  }, Vp(t, u, r));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: i } = e;
  const r = Zr(n), o = Ia(n);
  if (n === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, u = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((r || !r && i !== "fixed") && ((Va(n) !== "body" || Rc(o)) && (d = Dc(n)), Zr(n))) {
    const h = Ts(n);
    u = Go(n), s.x = h.x + n.clientLeft, s.y = h.y + n.clientTop;
  }
  return { width: t.width * u.x, height: t.height * u.y, x: t.x * u.x - d.scrollLeft * u.x + s.x, y: t.y * u.y - d.scrollTop * u.y + s.y };
}, isElement: $a, getDimensions: function(e) {
  return Zr(e) ? Gg(e) : e.getBoundingClientRect();
}, getOffsetParent: Up, getDocumentElement: Ia, getScale: Go, async getElementRects(e) {
  let { reference: t, floating: n, strategy: i } = e;
  const r = this.getOffsetParent || Up, o = this.getDimensions;
  return { reference: mE(t, await r(n), i), floating: { x: 0, y: 0, ...await o(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Gr(e).direction === "rtl" }, Kp = (e, t, n) => {
  const i = /* @__PURE__ */ new Map(), r = { platform: gE, ...n }, o = { ...r.platform, _c: i };
  return (async (d, u, s) => {
    const { placement: h = "bottom", strategy: m = "absolute", middleware: y = [], platform: v } = s, w = y.filter(Boolean), E = await (v.isRTL == null ? void 0 : v.isRTL(u));
    if (v == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), w.filter((N) => {
      let { name: T } = N;
      return T === "autoPlacement" || T === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && u || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let R = await v.getElementRects({ reference: d, floating: u, strategy: m }), { x: C, y: g } = Ip(R, h, E), _ = h, P = {}, M = 0;
    for (let N = 0; N < w.length; N++) {
      const { name: T, fn: U } = w[N], { x: V, y: G, data: ue, reset: Z } = await U({ x: C, y: g, initialPlacement: h, placement: _, strategy: m, middlewareData: P, rects: R, platform: v, elements: { reference: d, floating: u } });
      C = V ?? C, g = G ?? g, P = { ...P, [T]: { ...P[T], ...ue } }, M > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), Z && M <= 50 && (M++, typeof Z == "object" && (Z.placement && (_ = Z.placement), Z.rects && (R = Z.rects === !0 ? await v.getElementRects({ reference: d, floating: u, strategy: m }) : Z.rects), { x: C, y: g } = Ip(R, _, E)), N = -1);
    }
    return { x: C, y: g, placement: _, strategy: m, middlewareData: P };
  })(e, t, { ...r, platform: o });
};
var Na, Ii = { exports: {} }, Yp = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Na = Yp, function() {
  var e = a, t = 60103, n = 60106;
  Na.Fragment = 60107;
  var i = 60108, r = 60114, o = 60109, d = 60110, u = 60112, s = 60113, h = 60120, m = 60115, y = 60116, v = 60121, w = 60122, E = 60117, R = 60129, C = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var g = Symbol.for;
    t = g("react.element"), n = g("react.portal"), Na.Fragment = g("react.fragment"), i = g("react.strict_mode"), r = g("react.profiler"), o = g("react.provider"), d = g("react.context"), u = g("react.forward_ref"), s = g("react.suspense"), h = g("react.suspense_list"), m = g("react.memo"), y = g("react.lazy"), v = g("react.block"), w = g("react.server.block"), E = g("react.fundamental"), g("react.scope"), g("react.opaque.id"), R = g("react.debug_trace_mode"), g("react.offscreen"), C = g("react.legacy_hidden");
  }
  var _ = typeof Symbol == "function" && Symbol.iterator, P = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function M(fe) {
    for (var Ae = arguments.length, ne = new Array(Ae > 1 ? Ae - 1 : 0), $e = 1; $e < Ae; $e++)
      ne[$e - 1] = arguments[$e];
    N("error", fe, ne);
  }
  function N(fe, Ae, ne) {
    var $e = P.ReactDebugCurrentFrame, Le = "";
    if (G) {
      var Ke = U(G.type), Ge = G._owner;
      Le += function(Ze, Et, qe) {
        var Be = "";
        if (Et) {
          var Ie = Et.fileName, Fe = Ie.replace(T, "");
          if (/^index\./.test(Fe)) {
            var lt = Ie.match(T);
            if (lt) {
              var Ue = lt[1];
              Ue && (Fe = Ue.replace(T, "") + "/" + Fe);
            }
          }
          Be = " (at " + Fe + ":" + Et.lineNumber + ")";
        } else
          qe && (Be = " (created by " + qe + ")");
        return `
    in ` + (Ze || "Unknown") + Be;
      }(Ke, G._source, Ge && U(Ge.type));
    }
    (Le += $e.getStackAddendum()) !== "" && (Ae += "%s", ne = ne.concat([Le]));
    var et = ne.map(function(Ze) {
      return "" + Ze;
    });
    et.unshift("Warning: " + Ae), Function.prototype.apply.call(console[fe], console, et);
  }
  var T = /^(.*)[\\\/]/;
  function U(fe) {
    if (fe == null)
      return null;
    if (typeof fe.tag == "number" && M("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof fe == "function")
      return fe.displayName || fe.name || null;
    if (typeof fe == "string")
      return fe;
    switch (fe) {
      case Na.Fragment:
        return "Fragment";
      case n:
        return "Portal";
      case r:
        return "Profiler";
      case i:
        return "StrictMode";
      case s:
        return "Suspense";
      case h:
        return "SuspenseList";
    }
    if (typeof fe == "object")
      switch (fe.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case u:
          return $e = fe, Le = fe.render, Ke = "ForwardRef", Ge = Le.displayName || Le.name || "", $e.displayName || (Ge !== "" ? Ke + "(" + Ge + ")" : Ke);
        case m:
          return U(fe.type);
        case v:
          return U(fe.render);
        case y:
          var Ae = (ne = fe)._status === 1 ? ne._result : null;
          if (Ae)
            return U(Ae);
      }
    var ne, $e, Le, Ke, Ge;
    return null;
  }
  var V = {};
  P.ReactDebugCurrentFrame;
  var G = null;
  function ue(fe) {
    G = fe;
  }
  var Z, $, H, j = P.ReactCurrentOwner, F = Object.prototype.hasOwnProperty, X = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Q(fe, Ae, ne, $e, Le) {
    var Ke, Ge = {}, et = null, Ze = null;
    for (Ke in ne !== void 0 && (et = "" + ne), function(Be) {
      if (F.call(Be, "key")) {
        var Ie = Object.getOwnPropertyDescriptor(Be, "key").get;
        if (Ie && Ie.isReactWarning)
          return !1;
      }
      return Be.key !== void 0;
    }(Ae) && (et = "" + Ae.key), function(Be) {
      if (F.call(Be, "ref")) {
        var Ie = Object.getOwnPropertyDescriptor(Be, "ref").get;
        if (Ie && Ie.isReactWarning)
          return !1;
      }
      return Be.ref !== void 0;
    }(Ae) && (Ze = Ae.ref, function(Be, Ie) {
      if (typeof Be.ref == "string" && j.current && Ie && j.current.stateNode !== Ie) {
        var Fe = U(j.current.type);
        H[Fe] || (M('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(j.current.type), Be.ref), H[Fe] = !0);
      }
    }(Ae, Le)), Ae)
      F.call(Ae, Ke) && !X.hasOwnProperty(Ke) && (Ge[Ke] = Ae[Ke]);
    if (fe && fe.defaultProps) {
      var Et = fe.defaultProps;
      for (Ke in Et)
        Ge[Ke] === void 0 && (Ge[Ke] = Et[Ke]);
    }
    if (et || Ze) {
      var qe = typeof fe == "function" ? fe.displayName || fe.name || "Unknown" : fe;
      et && function(Be, Ie) {
        var Fe = function() {
          Z || (Z = !0, M("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie));
        };
        Fe.isReactWarning = !0, Object.defineProperty(Be, "key", { get: Fe, configurable: !0 });
      }(Ge, qe), Ze && function(Be, Ie) {
        var Fe = function() {
          $ || ($ = !0, M("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie));
        };
        Fe.isReactWarning = !0, Object.defineProperty(Be, "ref", { get: Fe, configurable: !0 });
      }(Ge, qe);
    }
    return function(Be, Ie, Fe, lt, Ue, ct, ht) {
      var gt = { $$typeof: t, type: Be, key: Ie, ref: Fe, props: ht, _owner: ct, _store: {} };
      return Object.defineProperty(gt._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(gt, "_self", { configurable: !1, enumerable: !1, writable: !1, value: lt }), Object.defineProperty(gt, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Ue }), Object.freeze && (Object.freeze(gt.props), Object.freeze(gt)), gt;
    }(fe, et, Ze, Le, $e, j.current, Ge);
  }
  H = {};
  var ae, te = P.ReactCurrentOwner;
  function re(fe) {
    G = fe;
  }
  function ie(fe) {
    return typeof fe == "object" && fe !== null && fe.$$typeof === t;
  }
  function ge() {
    if (te.current) {
      var fe = U(te.current.type);
      if (fe)
        return `

Check the render method of \`` + fe + "`.";
    }
    return "";
  }
  P.ReactDebugCurrentFrame, ae = !1;
  var ve = {};
  function Se(fe, Ae) {
    if (fe._store && !fe._store.validated && fe.key == null) {
      fe._store.validated = !0;
      var ne = function(Le) {
        var Ke = ge();
        if (!Ke) {
          var Ge = typeof Le == "string" ? Le : Le.displayName || Le.name;
          Ge && (Ke = `

Check the top-level render call using <` + Ge + ">.");
        }
        return Ke;
      }(Ae);
      if (!ve[ne]) {
        ve[ne] = !0;
        var $e = "";
        fe && fe._owner && fe._owner !== te.current && ($e = " It was passed a child from " + U(fe._owner.type) + "."), re(fe), M('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ne, $e), re(null);
      }
    }
  }
  function ye(fe, Ae) {
    if (typeof fe == "object") {
      if (Array.isArray(fe))
        for (var ne = 0; ne < fe.length; ne++) {
          var $e = fe[ne];
          ie($e) && Se($e, Ae);
        }
      else if (ie(fe))
        fe._store && (fe._store.validated = !0);
      else if (fe) {
        var Le = function(et) {
          if (et === null || typeof et != "object")
            return null;
          var Ze = _ && et[_] || et["@@iterator"];
          return typeof Ze == "function" ? Ze : null;
        }(fe);
        if (typeof Le == "function" && Le !== fe.entries)
          for (var Ke, Ge = Le.call(fe); !(Ke = Ge.next()).done; )
            ie(Ke.value) && Se(Ke.value, Ae);
      }
    }
  }
  function ee(fe) {
    var Ae, ne = fe.type;
    if (ne != null && typeof ne != "string") {
      if (typeof ne == "function")
        Ae = ne.propTypes;
      else {
        if (typeof ne != "object" || ne.$$typeof !== u && ne.$$typeof !== m)
          return;
        Ae = ne.propTypes;
      }
      if (Ae) {
        var $e = U(ne);
        (function(Le, Ke, Ge, et, Ze) {
          var Et = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var qe in Le)
            if (Et(Le, qe)) {
              var Be = void 0;
              try {
                if (typeof Le[qe] != "function") {
                  var Ie = Error((et || "React class") + ": " + Ge + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Le[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ie.name = "Invariant Violation", Ie;
                }
                Be = Le[qe](Ke, qe, et, Ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Fe) {
                Be = Fe;
              }
              !Be || Be instanceof Error || (ue(Ze), M("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", et || "React class", Ge, qe, typeof Be), ue(null)), Be instanceof Error && !(Be.message in V) && (V[Be.message] = !0, ue(Ze), M("Failed %s type: %s", Ge, Be.message), ue(null));
            }
        })(Ae, fe.props, "prop", $e, fe);
      } else
        ne.PropTypes === void 0 || ae || (ae = !0, M("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", U(ne) || "Unknown"));
      typeof ne.getDefaultProps != "function" || ne.getDefaultProps.isReactClassApproved || M("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Ee(fe, Ae, ne, $e, Le, Ke) {
    var Ge = function(Fe) {
      return typeof Fe == "string" || typeof Fe == "function" || Fe === Na.Fragment || Fe === r || Fe === R || Fe === i || Fe === s || Fe === h || Fe === C || typeof Fe == "object" && Fe !== null && (Fe.$$typeof === y || Fe.$$typeof === m || Fe.$$typeof === o || Fe.$$typeof === d || Fe.$$typeof === u || Fe.$$typeof === E || Fe.$$typeof === v || Fe[0] === w);
    }(fe);
    if (!Ge) {
      var et = "";
      (fe === void 0 || typeof fe == "object" && fe !== null && Object.keys(fe).length === 0) && (et += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Ze, Et = function(Fe) {
        return Fe !== void 0 ? `

Check your code at ` + Fe.fileName.replace(/^.*[\\\/]/, "") + ":" + Fe.lineNumber + "." : "";
      }(Le);
      et += Et || ge(), fe === null ? Ze = "null" : Array.isArray(fe) ? Ze = "array" : fe !== void 0 && fe.$$typeof === t ? (Ze = "<" + (U(fe.type) || "Unknown") + " />", et = " Did you accidentally export a JSX literal instead of a component?") : Ze = typeof fe, M("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ze, et);
    }
    var qe = Q(fe, Ae, ne, Le, Ke);
    if (qe == null)
      return qe;
    if (Ge) {
      var Be = Ae.children;
      if (Be !== void 0)
        if ($e)
          if (Array.isArray(Be)) {
            for (var Ie = 0; Ie < Be.length; Ie++)
              ye(Be[Ie], fe);
            Object.freeze && Object.freeze(Be);
          } else
            M("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          ye(Be, fe);
    }
    return fe === Na.Fragment ? function(Fe) {
      for (var lt = Object.keys(Fe.props), Ue = 0; Ue < lt.length; Ue++) {
        var ct = lt[Ue];
        if (ct !== "children" && ct !== "key") {
          re(Fe), M("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ct), re(null);
          break;
        }
      }
      Fe.ref !== null && (re(Fe), M("Invalid attribute `ref` supplied to `React.Fragment`."), re(null));
    }(qe) : ee(qe), qe;
  }
  var He = function(fe, Ae, ne) {
    return Ee(fe, Ae, ne, !1);
  }, we = function(fe, Ae, ne) {
    return Ee(fe, Ae, ne, !0);
  };
  Na.jsx = He, Na.jsxs = we;
}(), Ii.exports = Yp;
var Yd, iy = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Yd = iy, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], i = 0; i < arguments.length; i++) {
      var r = arguments[i];
      if (r) {
        var o = typeof r;
        if (o === "string" || o === "number")
          n.push(r);
        else if (Array.isArray(r)) {
          if (r.length) {
            var d = t.apply(null, r);
            d && n.push(d);
          }
        } else if (o === "object") {
          if (r.toString !== Object.prototype.toString && !r.toString.toString().includes("[native code]")) {
            n.push(r.toString());
            continue;
          }
          for (var u in r)
            e.call(r, u) && r[u] && n.push(u);
        }
      }
    }
    return n.join(" ");
  }
  Yd.exports ? (t.default = t, Yd.exports = t) : window.classNames = t;
}();
var Xp = iy.exports;
const qp = (e, t, n) => {
  let i = null;
  return function(...r) {
    i && clearTimeout(i), i = setTimeout(() => {
      i = null, n || e.apply(this, r);
    }, t);
  };
}, yE = ({ content: e }) => Ii.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), vE = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, xE = ce.createContext({ getTooltipData: () => vE });
function oy(e = "DEFAULT_TOOLTIP_ID") {
  return ce.useContext(xE).getTooltipData(e);
}
const Gp = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: n = null, place: i = "top", offset: r = 10, strategy: o = "absolute", middlewares: d = [fE(Number(r)), dE(), hE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const u = d;
  return n ? (u.push({ name: "arrow", options: s = { element: n, padding: 5 }, async fn(h) {
    const { element: m, padding: y = 0 } = s || {}, { x: v, y: w, placement: E, rects: R, platform: C } = h;
    if (m == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const g = Xg(y), _ = { x: v, y: w }, P = Ls(E), M = hh(P), N = await C.getDimensions(m), T = P === "y" ? "top" : "left", U = P === "y" ? "bottom" : "right", V = R.reference[M] + R.reference[P] - _[P] - R.floating[M], G = _[P] - R.reference[P], ue = await (C.getOffsetParent == null ? void 0 : C.getOffsetParent(m));
    let Z = ue ? P === "y" ? ue.clientHeight || 0 : ue.clientWidth || 0 : 0;
    Z === 0 && (Z = R.floating[M]);
    const $ = V / 2 - G / 2, H = g[T], j = Z - N[M] - g[U], F = Z / 2 - N[M] / 2 + $, X = Lf(H, F, j), Q = Ps(E) != null && F != X && R.reference[M] / 2 - (F < H ? g[T] : g[U]) - N[M] / 2 < 0;
    return { [P]: _[P] - (Q ? F < H ? H - F : j - F : 0), data: { [P]: X, centerOffset: F - X } };
  } }), Kp(e, t, { placement: i, strategy: o, middleware: u }).then(({ x: h, y: m, placement: y, middlewareData: v }) => {
    var w, E;
    const R = { left: `${h}px`, top: `${m}px` }, { x: C, y: g } = (w = v.arrow) !== null && w !== void 0 ? w : { x: 0, y: 0 };
    return { tooltipStyles: R, tooltipArrowStyles: { left: C != null ? `${C}px` : "", top: g != null ? `${g}px` : "", right: "", bottom: "", [(E = { top: "bottom", right: "left", bottom: "top", left: "right" }[y.split("-")[0]]) !== null && E !== void 0 ? E : "bottom"]: "-4px" } };
  })) : Kp(e, t, { placement: "bottom", strategy: o, middleware: u }).then(({ x: h, y: m }) => ({ tooltipStyles: { left: `${h}px`, top: `${m}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Pi = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Zp = ({ id: e, className: t, classNameArrow: n, variant: i = "dark", anchorId: r, anchorSelect: o, place: d = "top", offset: u = 10, events: s = ["hover"], positionStrategy: h = "absolute", middlewares: m, wrapper: y, children: v = null, delayShow: w = 0, delayHide: E = 0, float: R = !1, noArrow: C = !1, clickable: g = !1, closeOnEsc: _ = !1, style: P, position: M, afterShow: N, afterHide: T, content: U, html: V, isOpen: G, setIsOpen: ue, activeAnchor: Z, setActiveAnchor: $ }) => {
  const H = ce.useRef(null), j = ce.useRef(null), F = ce.useRef(null), X = ce.useRef(null), [Q, ae] = ce.useState({}), [te, re] = ce.useState({}), [ie, ge] = ce.useState(!1), [ve, Se] = ce.useState(!1), ye = ce.useRef(!1), ee = ce.useRef(null), { anchorRefs: Ee, setActiveAnchor: He } = oy(e), we = ce.useRef(!1), [fe, Ae] = ce.useState([]), ne = ce.useRef(!1);
  ce.useLayoutEffect(() => (ne.current = !0, () => {
    ne.current = !1;
  }), []), ce.useEffect(() => {
    if (!ie) {
      const Ue = setTimeout(() => {
        Se(!1);
      }, 150);
      return () => {
        clearTimeout(Ue);
      };
    }
    return () => null;
  }, [ie]);
  const $e = (Ue) => {
    ne.current && (Ue && Se(!0), setTimeout(() => {
      ne.current && (ue == null || ue(Ue), G === void 0 && ge(Ue));
    }, 10));
  };
  ce.useEffect(() => {
    if (G === void 0)
      return () => null;
    G && Se(!0);
    const Ue = setTimeout(() => {
      ge(G);
    }, 10);
    return () => {
      clearTimeout(Ue);
    };
  }, [G]), ce.useEffect(() => {
    ie !== ye.current && (ye.current = ie, ie ? N == null || N() : T == null || T());
  }, [ie]);
  const Le = (Ue = E) => {
    X.current && clearTimeout(X.current), X.current = setTimeout(() => {
      we.current || $e(!1);
    }, Ue);
  }, Ke = (Ue) => {
    var ct;
    if (!Ue)
      return;
    w ? (F.current && clearTimeout(F.current), F.current = setTimeout(() => {
      $e(!0);
    }, w)) : $e(!0);
    const ht = (ct = Ue.currentTarget) !== null && ct !== void 0 ? ct : Ue.target;
    $(ht), He({ current: ht }), X.current && clearTimeout(X.current);
  }, Ge = () => {
    g ? Le(E || 100) : E ? Le() : $e(!1), F.current && clearTimeout(F.current);
  }, et = ({ x: Ue, y: ct }) => {
    Gp({ place: d, offset: u, elementReference: { getBoundingClientRect: () => ({ x: Ue, y: ct, width: 0, height: 0, top: ct, left: Ue, right: Ue, bottom: ct }) }, tooltipReference: H.current, tooltipArrowReference: j.current, strategy: h, middlewares: m }).then((ht) => {
      Object.keys(ht.tooltipStyles).length && ae(ht.tooltipStyles), Object.keys(ht.tooltipArrowStyles).length && re(ht.tooltipArrowStyles);
    });
  }, Ze = (Ue) => {
    if (!Ue)
      return;
    const ct = Ue, ht = { x: ct.clientX, y: ct.clientY };
    et(ht), ee.current = ht;
  }, Et = (Ue) => {
    Ke(Ue), E && Le();
  }, qe = (Ue) => {
    const ct = document.querySelector(`[id='${r}']`);
    ct != null && ct.contains(Ue.target) || fe.some((ht) => ht.contains(Ue.target)) || $e(!1);
  }, Be = (Ue) => {
    Ue.key === "Escape" && $e(!1);
  }, Ie = qp(Ke, 50), Fe = qp(Ge, 50);
  ce.useEffect(() => {
    var Ue, ct;
    const ht = new Set(Ee);
    fe.forEach((kt) => {
      ht.add({ current: kt });
    });
    const gt = document.querySelector(`[id='${r}']`);
    gt && ht.add({ current: gt }), _ && window.addEventListener("keydown", Be);
    const Dt = [];
    s.find((kt) => kt === "click") && (window.addEventListener("click", qe), Dt.push({ event: "click", listener: Et })), s.find((kt) => kt === "hover") && (Dt.push({ event: "mouseenter", listener: Ie }, { event: "mouseleave", listener: Fe }, { event: "focus", listener: Ie }, { event: "blur", listener: Fe }), R && Dt.push({ event: "mousemove", listener: Ze }));
    const qt = () => {
      we.current = !0;
    }, Vt = () => {
      we.current = !1, Ge();
    };
    return g && ((Ue = H.current) === null || Ue === void 0 || Ue.addEventListener("mouseenter", qt), (ct = H.current) === null || ct === void 0 || ct.addEventListener("mouseleave", Vt)), Dt.forEach(({ event: kt, listener: zt }) => {
      ht.forEach((ln) => {
        var en;
        (en = ln.current) === null || en === void 0 || en.addEventListener(kt, zt);
      });
    }), () => {
      var kt, zt;
      s.find((ln) => ln === "click") && window.removeEventListener("click", qe), _ && window.removeEventListener("keydown", Be), g && ((kt = H.current) === null || kt === void 0 || kt.removeEventListener("mouseenter", qt), (zt = H.current) === null || zt === void 0 || zt.removeEventListener("mouseleave", Vt)), Dt.forEach(({ event: ln, listener: en }) => {
        ht.forEach((cn) => {
          var ze;
          (ze = cn.current) === null || ze === void 0 || ze.removeEventListener(ln, en);
        });
      });
    };
  }, [ve, Ee, fe, _, s]), ce.useEffect(() => {
    let Ue = o ?? "";
    !Ue && e && (Ue = `[data-tooltip-id='${e}']`);
    const ct = new MutationObserver((ht) => {
      const gt = [];
      ht.forEach((Dt) => {
        if (Dt.type === "attributes" && Dt.attributeName === "data-tooltip-id" && Dt.target.getAttribute("data-tooltip-id") === e && gt.push(Dt.target), Dt.type === "childList" && (Z && [...Dt.removedNodes].some((qt) => !!qt.contains(Z) && (Se(!1), $e(!1), $(null), !0)), Ue))
          try {
            const qt = [...Dt.addedNodes].filter((Vt) => Vt.nodeType === 1);
            gt.push(...qt.filter((Vt) => Vt.matches(Ue))), gt.push(...qt.flatMap((Vt) => [...Vt.querySelectorAll(Ue)]));
          } catch {
          }
      }), gt.length && Ae((Dt) => [...Dt, ...gt]);
    });
    return ct.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      ct.disconnect();
    };
  }, [e, o, Z]), ce.useEffect(() => {
    M ? et(M) : R ? ee.current && et(ee.current) : Gp({ place: d, offset: u, elementReference: Z, tooltipReference: H.current, tooltipArrowReference: j.current, strategy: h, middlewares: m }).then((Ue) => {
      ne.current && (Object.keys(Ue.tooltipStyles).length && ae(Ue.tooltipStyles), Object.keys(Ue.tooltipArrowStyles).length && re(Ue.tooltipArrowStyles));
    });
  }, [ie, Z, U, V, d, u, h, M]), ce.useEffect(() => {
    var Ue;
    const ct = document.querySelector(`[id='${r}']`), ht = [...fe, ct];
    Z && ht.includes(Z) || $((Ue = fe[0]) !== null && Ue !== void 0 ? Ue : ct);
  }, [r, fe, Z]), ce.useEffect(() => () => {
    F.current && clearTimeout(F.current), X.current && clearTimeout(X.current);
  }, []), ce.useEffect(() => {
    let Ue = o;
    if (!Ue && e && (Ue = `[data-tooltip-id='${e}']`), Ue)
      try {
        const ct = Array.from(document.querySelectorAll(Ue));
        Ae(ct);
      } catch {
        Ae([]);
      }
  }, [e, o]);
  const lt = !!(V || U || v) && ie && Object.keys(Q).length > 0;
  return ve ? Ii.exports.jsxs(y, { id: e, role: "tooltip", className: Xp("react-tooltip", Pi.tooltip, Pi[i], t, { [Pi.show]: lt, [Pi.fixed]: h === "fixed", [Pi.clickable]: g }), style: { ...P, ...Q }, ref: H, children: [V && Ii.exports.jsx(yE, { content: V }) || U || v, Ii.exports.jsx(y, { className: Xp("react-tooltip-arrow", Pi.arrow, n, { [Pi["no-arrow"]]: C }), style: te, ref: j })] }) : null;
}, ly = ({ id: e, anchorId: t, anchorSelect: n, content: i, html: r, className: o, classNameArrow: d, variant: u = "dark", place: s = "top", offset: h = 10, wrapper: m = "div", children: y = null, events: v = ["hover"], positionStrategy: w = "absolute", middlewares: E, delayShow: R = 0, delayHide: C = 0, float: g = !1, noArrow: _ = !1, clickable: P = !1, closeOnEsc: M = !1, style: N, position: T, isOpen: U, setIsOpen: V, afterShow: G, afterHide: ue }) => {
  const [Z, $] = ce.useState(i), [H, j] = ce.useState(r), [F, X] = ce.useState(s), [Q, ae] = ce.useState(u), [te, re] = ce.useState(h), [ie, ge] = ce.useState(R), [ve, Se] = ce.useState(C), [ye, ee] = ce.useState(g), [Ee, He] = ce.useState(m), [we, fe] = ce.useState(v), [Ae, ne] = ce.useState(w), [$e, Le] = ce.useState(null), { anchorRefs: Ke, activeAnchor: Ge } = oy(e), et = (qe) => qe == null ? void 0 : qe.getAttributeNames().reduce((Be, Ie) => {
    var Fe;
    return Ie.startsWith("data-tooltip-") && (Be[Ie.replace(/^data-tooltip-/, "")] = (Fe = qe == null ? void 0 : qe.getAttribute(Ie)) !== null && Fe !== void 0 ? Fe : null), Be;
  }, {}), Ze = (qe) => {
    const Be = { place: (Ie) => {
      var Fe;
      X((Fe = Ie) !== null && Fe !== void 0 ? Fe : s);
    }, content: (Ie) => {
      $(Ie ?? i);
    }, html: (Ie) => {
      j(Ie ?? r);
    }, variant: (Ie) => {
      var Fe;
      ae((Fe = Ie) !== null && Fe !== void 0 ? Fe : u);
    }, offset: (Ie) => {
      re(Ie === null ? h : Number(Ie));
    }, wrapper: (Ie) => {
      var Fe;
      He((Fe = Ie) !== null && Fe !== void 0 ? Fe : m);
    }, events: (Ie) => {
      const Fe = Ie == null ? void 0 : Ie.split(" ");
      fe(Fe ?? v);
    }, "position-strategy": (Ie) => {
      var Fe;
      ne((Fe = Ie) !== null && Fe !== void 0 ? Fe : w);
    }, "delay-show": (Ie) => {
      ge(Ie === null ? R : Number(Ie));
    }, "delay-hide": (Ie) => {
      Se(Ie === null ? C : Number(Ie));
    }, float: (Ie) => {
      ee(Ie === null ? g : !!Ie);
    } };
    Object.values(Be).forEach((Ie) => Ie(null)), Object.entries(qe).forEach(([Ie, Fe]) => {
      var lt;
      (lt = Be[Ie]) === null || lt === void 0 || lt.call(Be, Fe);
    });
  };
  ce.useEffect(() => {
    $(i);
  }, [i]), ce.useEffect(() => {
    j(r);
  }, [r]), ce.useEffect(() => {
    X(s);
  }, [s]), ce.useEffect(() => {
    var qe;
    const Be = new Set(Ke);
    let Ie = n;
    if (!Ie && e && (Ie = `[data-tooltip-id='${e}']`), Ie)
      try {
        document.querySelectorAll(Ie).forEach((ht) => {
          Be.add({ current: ht });
        });
      } catch {
        console.warn(`[react-tooltip] "${n}" is not a valid CSS selector`);
      }
    const Fe = document.querySelector(`[id='${t}']`);
    if (Fe && Be.add({ current: Fe }), !Be.size)
      return () => null;
    const lt = (qe = $e ?? Fe) !== null && qe !== void 0 ? qe : Ge.current, Ue = new MutationObserver((ht) => {
      ht.forEach((gt) => {
        var Dt;
        if (!lt || gt.type !== "attributes" || !(!((Dt = gt.attributeName) === null || Dt === void 0) && Dt.startsWith("data-tooltip-")))
          return;
        const qt = et(lt);
        Ze(qt);
      });
    }), ct = { attributes: !0, childList: !1, subtree: !1 };
    if (lt) {
      const ht = et(lt);
      Ze(ht), Ue.observe(lt, ct);
    }
    return () => {
      Ue.disconnect();
    };
  }, [Ke, Ge, $e, t, n]);
  const Et = { id: e, anchorId: t, anchorSelect: n, className: o, classNameArrow: d, content: Z, html: H, place: F, variant: Q, offset: te, wrapper: Ee, events: we, positionStrategy: Ae, middlewares: E, delayShow: ie, delayHide: ve, float: ye, noArrow: _, clickable: P, closeOnEsc: M, style: N, position: T, isOpen: U, setIsOpen: V, afterShow: G, afterHide: ue, activeAnchor: $e, setActiveAnchor: (qe) => Le(qe) };
  return y ? Ii.exports.jsx(Zp, { ...Et, children: y }) : Ii.exports.jsx(Zp, { ...Et });
};
function Qp(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n < i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function bE(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n > i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Xd(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      (i = +i) && (n += i);
  else {
    let i = -1;
    for (let r of e)
      (r = +t(r, ++i, e)) && (n += r);
  }
  return n;
}
function SE(e) {
  return e.depth;
}
function EE(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Ou(e) {
  return function() {
    return e;
  };
}
function Jp(e, t) {
  return pc(e.source, t.source) || e.index - t.index;
}
function em(e, t) {
  return pc(e.target, t.target) || e.index - t.index;
}
function pc(e, t) {
  return e.y0 - t.y0;
}
function qd(e) {
  return e.value;
}
function kE(e) {
  return e.index;
}
function wE(e) {
  return e.nodes;
}
function TE(e) {
  return e.links;
}
function tm(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function nm({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, i = n;
    for (const r of t.sourceLinks)
      r.y0 = n + r.width / 2, n += r.width;
    for (const r of t.targetLinks)
      r.y1 = i + r.width / 2, i += r.width;
  }
}
function CE() {
  let e = 0, t = 0, n = 1, i = 1, r = 24, o = 8, d, u = kE, s = EE, h, m, y = wE, v = TE, w = 6;
  function E() {
    const F = { nodes: y.apply(null, arguments), links: v.apply(null, arguments) };
    return R(F), C(F), g(F), _(F), N(F), nm(F), F;
  }
  E.update = function(F) {
    return nm(F), F;
  }, E.nodeId = function(F) {
    return arguments.length ? (u = typeof F == "function" ? F : Ou(F), E) : u;
  }, E.nodeAlign = function(F) {
    return arguments.length ? (s = typeof F == "function" ? F : Ou(F), E) : s;
  }, E.nodeSort = function(F) {
    return arguments.length ? (h = F, E) : h;
  }, E.nodeWidth = function(F) {
    return arguments.length ? (r = +F, E) : r;
  }, E.nodePadding = function(F) {
    return arguments.length ? (o = d = +F, E) : o;
  }, E.nodes = function(F) {
    return arguments.length ? (y = typeof F == "function" ? F : Ou(F), E) : y;
  }, E.links = function(F) {
    return arguments.length ? (v = typeof F == "function" ? F : Ou(F), E) : v;
  }, E.linkSort = function(F) {
    return arguments.length ? (m = F, E) : m;
  }, E.size = function(F) {
    return arguments.length ? (e = t = 0, n = +F[0], i = +F[1], E) : [n - e, i - t];
  }, E.extent = function(F) {
    return arguments.length ? (e = +F[0][0], n = +F[1][0], t = +F[0][1], i = +F[1][1], E) : [[e, t], [n, i]];
  }, E.iterations = function(F) {
    return arguments.length ? (w = +F, E) : w;
  };
  function R({ nodes: F, links: X }) {
    for (const [ae, te] of F.entries())
      te.index = ae, te.sourceLinks = [], te.targetLinks = [];
    const Q = new Map(F.map((ae, te) => [u(ae, te, F), ae]));
    for (const [ae, te] of X.entries()) {
      te.index = ae;
      let { source: re, target: ie } = te;
      typeof re != "object" && (re = te.source = tm(Q, re)), typeof ie != "object" && (ie = te.target = tm(Q, ie)), re.sourceLinks.push(te), ie.targetLinks.push(te);
    }
    if (m != null)
      for (const { sourceLinks: ae, targetLinks: te } of F)
        ae.sort(m), te.sort(m);
  }
  function C({ nodes: F }) {
    for (const X of F)
      X.value = X.fixedValue === void 0 ? Math.max(Xd(X.sourceLinks, qd), Xd(X.targetLinks, qd)) : X.fixedValue;
  }
  function g({ nodes: F }) {
    const X = F.length;
    let Q = new Set(F), ae = /* @__PURE__ */ new Set(), te = 0;
    for (; Q.size; ) {
      for (const re of Q) {
        re.depth = te;
        for (const { target: ie } of re.sourceLinks)
          ae.add(ie);
      }
      if (++te > X)
        throw new Error("circular link");
      Q = ae, ae = /* @__PURE__ */ new Set();
    }
  }
  function _({ nodes: F }) {
    const X = F.length;
    let Q = new Set(F), ae = /* @__PURE__ */ new Set(), te = 0;
    for (; Q.size; ) {
      for (const re of Q) {
        re.height = te;
        for (const { source: ie } of re.targetLinks)
          ae.add(ie);
      }
      if (++te > X)
        throw new Error("circular link");
      Q = ae, ae = /* @__PURE__ */ new Set();
    }
  }
  function P({ nodes: F }) {
    const X = Qp(F, (te) => te.depth) + 1, Q = (n - e - r) / (X - 1), ae = new Array(X);
    for (const te of F) {
      const re = Math.max(0, Math.min(X - 1, Math.floor(s.call(null, te, X))));
      te.layer = re, te.x0 = e + re * Q, te.x1 = te.x0 + r, ae[re] ? ae[re].push(te) : ae[re] = [te];
    }
    if (h)
      for (const te of ae)
        te.sort(h);
    return ae;
  }
  function M(F) {
    const X = bE(F, (Q) => (i - t - (Q.length - 1) * d) / Xd(Q, qd));
    for (const Q of F) {
      let ae = t;
      for (const te of Q) {
        te.y0 = ae, te.y1 = ae + te.value * X, ae = te.y1 + d;
        for (const re of te.sourceLinks)
          re.width = re.value * X;
      }
      ae = (i - ae + d) / (Q.length + 1);
      for (let te = 0; te < Q.length; ++te) {
        const re = Q[te];
        re.y0 += ae * (te + 1), re.y1 += ae * (te + 1);
      }
      $(Q);
    }
  }
  function N(F) {
    const X = P(F);
    d = Math.min(o, (i - t) / (Qp(X, (Q) => Q.length) - 1)), M(X);
    for (let Q = 0; Q < w; ++Q) {
      const ae = Math.pow(0.99, Q), te = Math.max(1 - ae, (Q + 1) / w);
      U(X, ae, te), T(X, ae, te);
    }
  }
  function T(F, X, Q) {
    for (let ae = 1, te = F.length; ae < te; ++ae) {
      const re = F[ae];
      for (const ie of re) {
        let ge = 0, ve = 0;
        for (const { source: ye, value: ee } of ie.targetLinks) {
          let Ee = ee * (ie.layer - ye.layer);
          ge += H(ye, ie) * Ee, ve += Ee;
        }
        if (!(ve > 0))
          continue;
        let Se = (ge / ve - ie.y0) * X;
        ie.y0 += Se, ie.y1 += Se, Z(ie);
      }
      h === void 0 && re.sort(pc), V(re, Q);
    }
  }
  function U(F, X, Q) {
    for (let ae = F.length, te = ae - 2; te >= 0; --te) {
      const re = F[te];
      for (const ie of re) {
        let ge = 0, ve = 0;
        for (const { target: ye, value: ee } of ie.sourceLinks) {
          let Ee = ee * (ye.layer - ie.layer);
          ge += j(ie, ye) * Ee, ve += Ee;
        }
        if (!(ve > 0))
          continue;
        let Se = (ge / ve - ie.y0) * X;
        ie.y0 += Se, ie.y1 += Se, Z(ie);
      }
      h === void 0 && re.sort(pc), V(re, Q);
    }
  }
  function V(F, X) {
    const Q = F.length >> 1, ae = F[Q];
    ue(F, ae.y0 - d, Q - 1, X), G(F, ae.y1 + d, Q + 1, X), ue(F, i, F.length - 1, X), G(F, t, 0, X);
  }
  function G(F, X, Q, ae) {
    for (; Q < F.length; ++Q) {
      const te = F[Q], re = (X - te.y0) * ae;
      re > 1e-6 && (te.y0 += re, te.y1 += re), X = te.y1 + d;
    }
  }
  function ue(F, X, Q, ae) {
    for (; Q >= 0; --Q) {
      const te = F[Q], re = (te.y1 - X) * ae;
      re > 1e-6 && (te.y0 -= re, te.y1 -= re), X = te.y0 - d;
    }
  }
  function Z({ sourceLinks: F, targetLinks: X }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: Q } } of X)
        Q.sort(em);
      for (const { target: { targetLinks: Q } } of F)
        Q.sort(Jp);
    }
  }
  function $(F) {
    if (m === void 0)
      for (const { sourceLinks: X, targetLinks: Q } of F)
        X.sort(em), Q.sort(Jp);
  }
  function H(F, X) {
    let Q = F.y0 - (F.sourceLinks.length - 1) * d / 2;
    for (const { target: ae, width: te } of F.sourceLinks) {
      if (ae === X)
        break;
      Q += te + d;
    }
    for (const { source: ae, width: te } of X.targetLinks) {
      if (ae === F)
        break;
      Q -= te;
    }
    return Q;
  }
  function j(F, X) {
    let Q = X.y0 - (X.targetLinks.length - 1) * d / 2;
    for (const { source: ae, width: te } of X.targetLinks) {
      if (ae === F)
        break;
      Q += te + d;
    }
    for (const { target: ae, width: te } of F.sourceLinks) {
      if (ae === X)
        break;
      Q -= te;
    }
    return Q;
  }
  return E;
}
function AE(e) {
  return [e.source.x1, e.y0];
}
function PE(e) {
  return [e.target.x0, e.y1];
}
function LE() {
  return g0().source(AE).target(PE);
}
var ja = {}, Li = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rm;
function RE() {
  if (rm)
    return Li;
  rm = 1;
  var e = ce;
  function t(x) {
    for (var L = "https://reactjs.org/docs/error-decoder.html?invariant=" + x, I = 1; I < arguments.length; I++)
      L += "&args[]=" + encodeURIComponent(arguments[I]);
    return "Minified React error #" + x + "; visit " + L + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, i = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, r = {}, o = {};
  function d(x) {
    return n.call(o, x) ? !0 : n.call(r, x) ? !1 : i.test(x) ? o[x] = !0 : (r[x] = !0, !1);
  }
  function u(x, L, I, Y, Te, xe, De) {
    this.acceptsBooleans = L === 2 || L === 3 || L === 4, this.attributeName = Y, this.attributeNamespace = Te, this.mustUseProperty = I, this.propertyName = x, this.type = L, this.sanitizeURL = xe, this.removeEmptyString = De;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(x) {
    s[x] = new u(x, 0, !1, x, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(x) {
    var L = x[0];
    s[L] = new u(L, 1, !1, x[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(x) {
    s[x] = new u(x, 2, !1, x.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(x) {
    s[x] = new u(x, 2, !1, x, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(x) {
    s[x] = new u(x, 3, !1, x.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(x) {
    s[x] = new u(x, 3, !0, x, null, !1, !1);
  }), ["capture", "download"].forEach(function(x) {
    s[x] = new u(x, 4, !1, x, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(x) {
    s[x] = new u(x, 6, !1, x, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(x) {
    s[x] = new u(x, 5, !1, x.toLowerCase(), null, !1, !1);
  });
  var h = /[\-:]([a-z])/g;
  function m(x) {
    return x[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(x) {
    var L = x.replace(
      h,
      m
    );
    s[L] = new u(L, 1, !1, x, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(x) {
    var L = x.replace(h, m);
    s[L] = new u(L, 1, !1, x, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(x) {
    var L = x.replace(h, m);
    s[L] = new u(L, 1, !1, x, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(x) {
    s[x] = new u(x, 1, !1, x.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new u("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(x) {
    s[x] = new u(x, 1, !1, x.toLowerCase(), null, !0, !0);
  });
  var y = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, v = ["Webkit", "ms", "Moz", "O"];
  Object.keys(y).forEach(function(x) {
    v.forEach(function(L) {
      L = L + x.charAt(0).toUpperCase() + x.substring(1), y[L] = y[x];
    });
  });
  var w = /["'&<>]/;
  function E(x) {
    if (typeof x == "boolean" || typeof x == "number")
      return "" + x;
    x = "" + x;
    var L = w.exec(x);
    if (L) {
      var I = "", Y, Te = 0;
      for (Y = L.index; Y < x.length; Y++) {
        switch (x.charCodeAt(Y)) {
          case 34:
            L = "&quot;";
            break;
          case 38:
            L = "&amp;";
            break;
          case 39:
            L = "&#x27;";
            break;
          case 60:
            L = "&lt;";
            break;
          case 62:
            L = "&gt;";
            break;
          default:
            continue;
        }
        Te !== Y && (I += x.substring(Te, Y)), Te = Y + 1, I += L;
      }
      x = Te !== Y ? I + x.substring(Te, Y) : I;
    }
    return x;
  }
  var R = /([A-Z])/g, C = /^ms-/, g = Array.isArray;
  function _(x, L) {
    return { insertionMode: x, selectedValue: L };
  }
  function P(x, L, I) {
    switch (L) {
      case "select":
        return _(1, I.value != null ? I.value : I.defaultValue);
      case "svg":
        return _(2, null);
      case "math":
        return _(3, null);
      case "foreignObject":
        return _(1, null);
      case "table":
        return _(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return _(5, null);
      case "colgroup":
        return _(7, null);
      case "tr":
        return _(6, null);
    }
    return 4 <= x.insertionMode || x.insertionMode === 0 ? _(1, null) : x;
  }
  var M = /* @__PURE__ */ new Map();
  function N(x, L, I) {
    if (typeof I != "object")
      throw Error(t(62));
    L = !0;
    for (var Y in I)
      if (n.call(I, Y)) {
        var Te = I[Y];
        if (Te != null && typeof Te != "boolean" && Te !== "") {
          if (Y.indexOf("--") === 0) {
            var xe = E(Y);
            Te = E(("" + Te).trim());
          } else {
            xe = Y;
            var De = M.get(xe);
            De !== void 0 || (De = E(xe.replace(R, "-$1").toLowerCase().replace(C, "-ms-")), M.set(xe, De)), xe = De, Te = typeof Te == "number" ? Te === 0 || n.call(y, Y) ? "" + Te : Te + "px" : E(("" + Te).trim());
          }
          L ? (L = !1, x.push(' style="', xe, ":", Te)) : x.push(";", xe, ":", Te);
        }
      }
    L || x.push('"');
  }
  function T(x, L, I, Y) {
    switch (I) {
      case "style":
        N(x, L, Y);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < I.length) || I[0] !== "o" && I[0] !== "O" || I[1] !== "n" && I[1] !== "N") {
      if (L = s.hasOwnProperty(I) ? s[I] : null, L !== null) {
        switch (typeof Y) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!L.acceptsBooleans)
              return;
        }
        switch (I = L.attributeName, L.type) {
          case 3:
            Y && x.push(" ", I, '=""');
            break;
          case 4:
            Y === !0 ? x.push(" ", I, '=""') : Y !== !1 && x.push(" ", I, '="', E(Y), '"');
            break;
          case 5:
            isNaN(Y) || x.push(" ", I, '="', E(Y), '"');
            break;
          case 6:
            !isNaN(Y) && 1 <= Y && x.push(" ", I, '="', E(Y), '"');
            break;
          default:
            L.sanitizeURL && (Y = "" + Y), x.push(" ", I, '="', E(Y), '"');
        }
      } else if (d(I)) {
        switch (typeof Y) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (L = I.toLowerCase().slice(0, 5), L !== "data-" && L !== "aria-")
              return;
        }
        x.push(" ", I, '="', E(Y), '"');
      }
    }
  }
  function U(x, L, I) {
    if (L != null) {
      if (I != null)
        throw Error(t(60));
      if (typeof L != "object" || !("__html" in L))
        throw Error(t(61));
      L = L.__html, L != null && x.push("" + L);
    }
  }
  function V(x) {
    var L = "";
    return e.Children.forEach(x, function(I) {
      I != null && (L += I);
    }), L;
  }
  function G(x, L, I, Y) {
    x.push($(I));
    var Te = I = null, xe;
    for (xe in L)
      if (n.call(L, xe)) {
        var De = L[xe];
        if (De != null)
          switch (xe) {
            case "children":
              I = De;
              break;
            case "dangerouslySetInnerHTML":
              Te = De;
              break;
            default:
              T(x, Y, xe, De);
          }
      }
    return x.push(">"), U(x, Te, I), typeof I == "string" ? (x.push(E(I)), null) : I;
  }
  var ue = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Z = /* @__PURE__ */ new Map();
  function $(x) {
    var L = Z.get(x);
    if (L === void 0) {
      if (!ue.test(x))
        throw Error(t(65, x));
      L = "<" + x, Z.set(x, L);
    }
    return L;
  }
  function H(x, L, I, Y, Te) {
    switch (L) {
      case "select":
        x.push($("select"));
        var xe = null, De = null;
        for (le in I)
          if (n.call(I, le)) {
            var je = I[le];
            if (je != null)
              switch (le) {
                case "children":
                  xe = je;
                  break;
                case "dangerouslySetInnerHTML":
                  De = je;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  T(x, Y, le, je);
              }
          }
        return x.push(">"), U(x, De, xe), xe;
      case "option":
        De = Te.selectedValue, x.push($("option"));
        var at = je = null, yt = null, le = null;
        for (xe in I)
          if (n.call(I, xe)) {
            var se = I[xe];
            if (se != null)
              switch (xe) {
                case "children":
                  je = se;
                  break;
                case "selected":
                  yt = se;
                  break;
                case "dangerouslySetInnerHTML":
                  le = se;
                  break;
                case "value":
                  at = se;
                default:
                  T(x, Y, xe, se);
              }
          }
        if (De != null)
          if (I = at !== null ? "" + at : V(je), g(De)) {
            for (Y = 0; Y < De.length; Y++)
              if ("" + De[Y] === I) {
                x.push(' selected=""');
                break;
              }
          } else
            "" + De === I && x.push(' selected=""');
        else
          yt && x.push(' selected=""');
        return x.push(">"), U(x, le, je), je;
      case "textarea":
        x.push($("textarea")), le = De = xe = null;
        for (je in I)
          if (n.call(I, je) && (at = I[je], at != null))
            switch (je) {
              case "children":
                le = at;
                break;
              case "value":
                xe = at;
                break;
              case "defaultValue":
                De = at;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                T(
                  x,
                  Y,
                  je,
                  at
                );
            }
        if (xe === null && De !== null && (xe = De), x.push(">"), le != null) {
          if (xe != null)
            throw Error(t(92));
          if (g(le) && 1 < le.length)
            throw Error(t(93));
          xe = "" + le;
        }
        return typeof xe == "string" && xe[0] === `
` && x.push(`
`), xe !== null && x.push(E("" + xe)), null;
      case "input":
        x.push($("input")), at = le = je = xe = null;
        for (De in I)
          if (n.call(I, De) && (yt = I[De], yt != null))
            switch (De) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                at = yt;
                break;
              case "defaultValue":
                je = yt;
                break;
              case "checked":
                le = yt;
                break;
              case "value":
                xe = yt;
                break;
              default:
                T(x, Y, De, yt);
            }
        return le !== null ? T(x, Y, "checked", le) : at !== null && T(x, Y, "checked", at), xe !== null ? T(x, Y, "value", xe) : je !== null && T(x, Y, "value", je), x.push("/>"), null;
      case "menuitem":
        x.push($("menuitem"));
        for (var me in I)
          if (n.call(I, me) && (xe = I[me], xe != null))
            switch (me) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                T(x, Y, me, xe);
            }
        return x.push(">"), null;
      case "title":
        x.push($("title")), xe = null;
        for (se in I)
          if (n.call(I, se) && (De = I[se], De != null))
            switch (se) {
              case "children":
                xe = De;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                T(x, Y, se, De);
            }
        return x.push(">"), xe;
      case "listing":
      case "pre":
        x.push($(L)), De = xe = null;
        for (at in I)
          if (n.call(I, at) && (je = I[at], je != null))
            switch (at) {
              case "children":
                xe = je;
                break;
              case "dangerouslySetInnerHTML":
                De = je;
                break;
              default:
                T(x, Y, at, je);
            }
        if (x.push(">"), De != null) {
          if (xe != null)
            throw Error(t(60));
          if (typeof De != "object" || !("__html" in De))
            throw Error(t(61));
          I = De.__html, I != null && (typeof I == "string" && 0 < I.length && I[0] === `
` ? x.push(`
`, I) : x.push("" + I));
        }
        return typeof xe == "string" && xe[0] === `
` && x.push(`
`), xe;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        x.push($(L));
        for (var Oe in I)
          if (n.call(I, Oe) && (xe = I[Oe], xe != null))
            switch (Oe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, L));
              default:
                T(x, Y, Oe, xe);
            }
        return x.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return G(
          x,
          I,
          L,
          Y
        );
      case "html":
        return Te.insertionMode === 0 && x.push("<!DOCTYPE html>"), G(x, I, L, Y);
      default:
        if (L.indexOf("-") === -1 && typeof I.is != "string")
          return G(x, I, L, Y);
        x.push($(L)), De = xe = null;
        for (yt in I)
          if (n.call(I, yt) && (je = I[yt], je != null))
            switch (yt) {
              case "children":
                xe = je;
                break;
              case "dangerouslySetInnerHTML":
                De = je;
                break;
              case "style":
                N(x, Y, je);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(yt) && typeof je != "function" && typeof je != "symbol" && x.push(" ", yt, '="', E(je), '"');
            }
        return x.push(">"), U(x, De, xe), xe;
    }
  }
  function j(x, L, I) {
    if (x.push('<!--$?--><template id="'), I === null)
      throw Error(t(395));
    return x.push(I), x.push('"></template>');
  }
  function F(x, L, I, Y) {
    switch (I.insertionMode) {
      case 0:
      case 1:
        return x.push('<div hidden id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 2:
        return x.push('<svg aria-hidden="true" style="display:none" id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 3:
        return x.push('<math aria-hidden="true" style="display:none" id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 4:
        return x.push('<table hidden id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 5:
        return x.push('<table hidden><tbody id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 6:
        return x.push('<table hidden><tr id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      case 7:
        return x.push('<table hidden><colgroup id="'), x.push(L.segmentPrefix), L = Y.toString(16), x.push(L), x.push('">');
      default:
        throw Error(t(397));
    }
  }
  function X(x, L) {
    switch (L.insertionMode) {
      case 0:
      case 1:
        return x.push("</div>");
      case 2:
        return x.push("</svg>");
      case 3:
        return x.push("</math>");
      case 4:
        return x.push("</table>");
      case 5:
        return x.push("</tbody></table>");
      case 6:
        return x.push("</tr></table>");
      case 7:
        return x.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var Q = /[<\u2028\u2029]/g;
  function ae(x) {
    return JSON.stringify(x).replace(Q, function(L) {
      switch (L) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function te(x, L) {
    return L = L === void 0 ? "" : L, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: L + "P:", segmentPrefix: L + "S:", boundaryPrefix: L + "B:", idPrefix: L, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: x };
  }
  function re(x, L, I, Y) {
    return I.generateStaticMarkup ? (x.push(E(L)), !1) : (L === "" ? x = Y : (Y && x.push("<!-- -->"), x.push(E(L)), x = !0), x);
  }
  var ie = Object.assign, ge = Symbol.for("react.element"), ve = Symbol.for("react.portal"), Se = Symbol.for("react.fragment"), ye = Symbol.for("react.strict_mode"), ee = Symbol.for("react.profiler"), Ee = Symbol.for("react.provider"), He = Symbol.for("react.context"), we = Symbol.for("react.forward_ref"), fe = Symbol.for("react.suspense"), Ae = Symbol.for("react.suspense_list"), ne = Symbol.for("react.memo"), $e = Symbol.for("react.lazy"), Le = Symbol.for("react.scope"), Ke = Symbol.for("react.debug_trace_mode"), Ge = Symbol.for("react.legacy_hidden"), et = Symbol.for("react.default_value"), Ze = Symbol.iterator;
  function Et(x) {
    if (x == null)
      return null;
    if (typeof x == "function")
      return x.displayName || x.name || null;
    if (typeof x == "string")
      return x;
    switch (x) {
      case Se:
        return "Fragment";
      case ve:
        return "Portal";
      case ee:
        return "Profiler";
      case ye:
        return "StrictMode";
      case fe:
        return "Suspense";
      case Ae:
        return "SuspenseList";
    }
    if (typeof x == "object")
      switch (x.$$typeof) {
        case He:
          return (x.displayName || "Context") + ".Consumer";
        case Ee:
          return (x._context.displayName || "Context") + ".Provider";
        case we:
          var L = x.render;
          return x = x.displayName, x || (x = L.displayName || L.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
        case ne:
          return L = x.displayName || null, L !== null ? L : Et(x.type) || "Memo";
        case $e:
          L = x._payload, x = x._init;
          try {
            return Et(x(L));
          } catch {
          }
      }
    return null;
  }
  var qe = {};
  function Be(x, L) {
    if (x = x.contextTypes, !x)
      return qe;
    var I = {}, Y;
    for (Y in x)
      I[Y] = L[Y];
    return I;
  }
  var Ie = null;
  function Fe(x, L) {
    if (x !== L) {
      x.context._currentValue2 = x.parentValue, x = x.parent;
      var I = L.parent;
      if (x === null) {
        if (I !== null)
          throw Error(t(401));
      } else {
        if (I === null)
          throw Error(t(401));
        Fe(x, I);
      }
      L.context._currentValue2 = L.value;
    }
  }
  function lt(x) {
    x.context._currentValue2 = x.parentValue, x = x.parent, x !== null && lt(x);
  }
  function Ue(x) {
    var L = x.parent;
    L !== null && Ue(L), x.context._currentValue2 = x.value;
  }
  function ct(x, L) {
    if (x.context._currentValue2 = x.parentValue, x = x.parent, x === null)
      throw Error(t(402));
    x.depth === L.depth ? Fe(x, L) : ct(x, L);
  }
  function ht(x, L) {
    var I = L.parent;
    if (I === null)
      throw Error(t(402));
    x.depth === I.depth ? Fe(x, I) : ht(x, I), L.context._currentValue2 = L.value;
  }
  function gt(x) {
    var L = Ie;
    L !== x && (L === null ? Ue(x) : x === null ? lt(L) : L.depth === x.depth ? Fe(L, x) : L.depth > x.depth ? ct(L, x) : ht(L, x), Ie = x);
  }
  var Dt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(x, L) {
    x = x._reactInternals, x.queue !== null && x.queue.push(L);
  }, enqueueReplaceState: function(x, L) {
    x = x._reactInternals, x.replace = !0, x.queue = [L];
  }, enqueueForceUpdate: function() {
  } };
  function qt(x, L, I, Y) {
    var Te = x.state !== void 0 ? x.state : null;
    x.updater = Dt, x.props = I, x.state = Te;
    var xe = { queue: [], replace: !1 };
    x._reactInternals = xe;
    var De = L.contextType;
    if (x.context = typeof De == "object" && De !== null ? De._currentValue2 : Y, De = L.getDerivedStateFromProps, typeof De == "function" && (De = De(I, Te), Te = De == null ? Te : ie({}, Te, De), x.state = Te), typeof L.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function"))
      if (L = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), L !== x.state && Dt.enqueueReplaceState(x, x.state, null), xe.queue !== null && 0 < xe.queue.length)
        if (L = xe.queue, De = xe.replace, xe.queue = null, xe.replace = !1, De && L.length === 1)
          x.state = L[0];
        else {
          for (xe = De ? L[0] : x.state, Te = !0, De = De ? 1 : 0; De < L.length; De++) {
            var je = L[De];
            je = typeof je == "function" ? je.call(x, xe, I, Y) : je, je != null && (Te ? (Te = !1, xe = ie({}, xe, je)) : ie(xe, je));
          }
          x.state = xe;
        }
      else
        xe.queue = null;
  }
  var Vt = { id: 1, overflow: "" };
  function kt(x, L, I) {
    var Y = x.id;
    x = x.overflow;
    var Te = 32 - zt(Y) - 1;
    Y &= ~(1 << Te), I += 1;
    var xe = 32 - zt(L) + Te;
    if (30 < xe) {
      var De = Te - Te % 5;
      return xe = (Y & (1 << De) - 1).toString(32), Y >>= De, Te -= De, { id: 1 << 32 - zt(L) + Te | I << Te | Y, overflow: xe + x };
    }
    return { id: 1 << xe | I << Te | Y, overflow: x };
  }
  var zt = Math.clz32 ? Math.clz32 : cn, ln = Math.log, en = Math.LN2;
  function cn(x) {
    return x >>>= 0, x === 0 ? 32 : 31 - (ln(x) / en | 0) | 0;
  }
  function ze(x, L) {
    return x === L && (x !== 0 || 1 / x === 1 / L) || x !== x && L !== L;
  }
  var Nt = typeof Object.is == "function" ? Object.is : ze, Gt = null, Bt = null, yn = null, Lt = null, bn = !1, Mn = !1, mn = 0, dn = null, jt = 0;
  function wn() {
    if (Gt === null)
      throw Error(t(321));
    return Gt;
  }
  function Ft() {
    if (0 < jt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function pt() {
    return Lt === null ? yn === null ? (bn = !1, yn = Lt = Ft()) : (bn = !0, Lt = yn) : Lt.next === null ? (bn = !1, Lt = Lt.next = Ft()) : (bn = !0, Lt = Lt.next), Lt;
  }
  function Tn() {
    Bt = Gt = null, Mn = !1, yn = null, jt = 0, Lt = dn = null;
  }
  function tn(x, L) {
    return typeof L == "function" ? L(x) : L;
  }
  function $t(x, L, I) {
    if (Gt = wn(), Lt = pt(), bn) {
      var Y = Lt.queue;
      if (L = Y.dispatch, dn !== null && (I = dn.get(Y), I !== void 0)) {
        dn.delete(Y), Y = Lt.memoizedState;
        do
          Y = x(Y, I.action), I = I.next;
        while (I !== null);
        return Lt.memoizedState = Y, [Y, L];
      }
      return [Lt.memoizedState, L];
    }
    return x = x === tn ? typeof L == "function" ? L() : L : I !== void 0 ? I(L) : L, Lt.memoizedState = x, x = Lt.queue = { last: null, dispatch: null }, x = x.dispatch = En.bind(null, Gt, x), [Lt.memoizedState, x];
  }
  function Sn(x, L) {
    if (Gt = wn(), Lt = pt(), L = L === void 0 ? null : L, Lt !== null) {
      var I = Lt.memoizedState;
      if (I !== null && L !== null) {
        var Y = I[1];
        e:
          if (Y === null)
            Y = !1;
          else {
            for (var Te = 0; Te < Y.length && Te < L.length; Te++)
              if (!Nt(L[Te], Y[Te])) {
                Y = !1;
                break e;
              }
            Y = !0;
          }
        if (Y)
          return I[0];
      }
    }
    return x = x(), Lt.memoizedState = [x, L], x;
  }
  function En(x, L, I) {
    if (25 <= jt)
      throw Error(t(301));
    if (x === Gt)
      if (Mn = !0, x = { action: I, next: null }, dn === null && (dn = /* @__PURE__ */ new Map()), I = dn.get(L), I === void 0)
        dn.set(L, x);
      else {
        for (L = I; L.next !== null; )
          L = L.next;
        L.next = x;
      }
  }
  function Dn() {
    throw Error(t(394));
  }
  function Ln() {
  }
  var Me = { readContext: function(x) {
    return x._currentValue2;
  }, useContext: function(x) {
    return wn(), x._currentValue2;
  }, useMemo: Sn, useReducer: $t, useRef: function(x) {
    Gt = wn(), Lt = pt();
    var L = Lt.memoizedState;
    return L === null ? (x = { current: x }, Lt.memoizedState = x) : L;
  }, useState: function(x) {
    return $t(tn, x);
  }, useInsertionEffect: Ln, useLayoutEffect: function() {
  }, useCallback: function(x, L) {
    return Sn(function() {
      return x;
    }, L);
  }, useImperativeHandle: Ln, useEffect: Ln, useDebugValue: Ln, useDeferredValue: function(x) {
    return wn(), x;
  }, useTransition: function() {
    return wn(), [
      !1,
      Dn
    ];
  }, useId: function() {
    var x = Bt.treeContext, L = x.overflow;
    x = x.id, x = (x & ~(1 << 32 - zt(x) - 1)).toString(32) + L;
    var I = dt;
    if (I === null)
      throw Error(t(404));
    return L = mn++, x = ":" + I.idPrefix + "R" + x, 0 < L && (x += "H" + L.toString(32)), x + ":";
  }, useMutableSource: function(x, L) {
    return wn(), L(x._source);
  }, useSyncExternalStore: function(x, L, I) {
    if (I === void 0)
      throw Error(t(407));
    return I();
  } }, dt = null, it = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function W(x) {
    return console.error(x), null;
  }
  function _e() {
  }
  function Xe(x, L, I, Y, Te, xe, De, je, at) {
    var yt = [], le = /* @__PURE__ */ new Set();
    return L = { destination: null, responseState: L, progressiveChunkSize: Y === void 0 ? 12800 : Y, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: le, pingedTasks: yt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Te === void 0 ? W : Te, onAllReady: xe === void 0 ? _e : xe, onShellReady: De === void 0 ? _e : De, onShellError: je === void 0 ? _e : je, onFatalError: at === void 0 ? _e : at }, I = ot(L, 0, null, I, !1, !1), I.parentFlushed = !0, x = Ve(L, x, null, I, le, qe, null, Vt), yt.push(x), L;
  }
  function Ve(x, L, I, Y, Te, xe, De, je) {
    x.allPendingTasks++, I === null ? x.pendingRootTasks++ : I.pendingTasks++;
    var at = { node: L, ping: function() {
      var yt = x.pingedTasks;
      yt.push(at), yt.length === 1 && fn(x);
    }, blockedBoundary: I, blockedSegment: Y, abortSet: Te, legacyContext: xe, context: De, treeContext: je };
    return Te.add(at), at;
  }
  function ot(x, L, I, Y, Te, xe) {
    return { status: 0, id: -1, index: L, parentFlushed: !1, chunks: [], children: [], formatContext: Y, boundary: I, lastPushedText: Te, textEmbedded: xe };
  }
  function rt(x, L) {
    if (x = x.onError(L), x != null && typeof x != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof x + '" instead');
    return x;
  }
  function xt(x, L) {
    var I = x.onShellError;
    I(L), I = x.onFatalError, I(L), x.destination !== null ? (x.status = 2, x.destination.destroy(L)) : (x.status = 1, x.fatalError = L);
  }
  function Mt(x, L, I, Y, Te) {
    for (Gt = {}, Bt = L, mn = 0, x = I(Y, Te); Mn; )
      Mn = !1, mn = 0, jt += 1, Lt = null, x = I(Y, Te);
    return Tn(), x;
  }
  function Qe(x, L, I, Y) {
    var Te = I.render(), xe = Y.childContextTypes;
    if (xe != null) {
      var De = L.legacyContext;
      if (typeof I.getChildContext != "function")
        Y = De;
      else {
        I = I.getChildContext();
        for (var je in I)
          if (!(je in xe))
            throw Error(t(108, Et(Y) || "Unknown", je));
        Y = ie({}, De, I);
      }
      L.legacyContext = Y, _t(x, L, Te), L.legacyContext = De;
    } else
      _t(x, L, Te);
  }
  function Kt(x, L) {
    if (x && x.defaultProps) {
      L = ie({}, L), x = x.defaultProps;
      for (var I in x)
        L[I] === void 0 && (L[I] = x[I]);
      return L;
    }
    return L;
  }
  function It(x, L, I, Y, Te) {
    if (typeof I == "function")
      if (I.prototype && I.prototype.isReactComponent) {
        Te = Be(I, L.legacyContext);
        var xe = I.contextType;
        xe = new I(Y, typeof xe == "object" && xe !== null ? xe._currentValue2 : Te), qt(xe, I, Y, Te), Qe(x, L, xe, I);
      } else {
        xe = Be(I, L.legacyContext), Te = Mt(x, L, I, Y, xe);
        var De = mn !== 0;
        if (typeof Te == "object" && Te !== null && typeof Te.render == "function" && Te.$$typeof === void 0)
          qt(Te, I, Y, xe), Qe(x, L, Te, I);
        else if (De) {
          Y = L.treeContext, L.treeContext = kt(Y, 1, 0);
          try {
            _t(x, L, Te);
          } finally {
            L.treeContext = Y;
          }
        } else
          _t(x, L, Te);
      }
    else if (typeof I == "string") {
      switch (Te = L.blockedSegment, xe = H(Te.chunks, I, Y, x.responseState, Te.formatContext), Te.lastPushedText = !1, De = Te.formatContext, Te.formatContext = P(De, I, Y), Rt(x, L, xe), Te.formatContext = De, I) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Te.chunks.push("</", I, ">");
      }
      Te.lastPushedText = !1;
    } else {
      switch (I) {
        case Ge:
        case Ke:
        case ye:
        case ee:
        case Se:
          _t(x, L, Y.children);
          return;
        case Ae:
          _t(x, L, Y.children);
          return;
        case Le:
          throw Error(t(343));
        case fe:
          e: {
            I = L.blockedBoundary, Te = L.blockedSegment, xe = Y.fallback, Y = Y.children, De = /* @__PURE__ */ new Set();
            var je = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: De, errorDigest: null }, at = ot(x, Te.chunks.length, je, Te.formatContext, !1, !1);
            Te.children.push(at), Te.lastPushedText = !1;
            var yt = ot(x, 0, null, Te.formatContext, !1, !1);
            yt.parentFlushed = !0, L.blockedBoundary = je, L.blockedSegment = yt;
            try {
              if (Rt(
                x,
                L,
                Y
              ), x.responseState.generateStaticMarkup || yt.lastPushedText && yt.textEmbedded && yt.chunks.push("<!-- -->"), yt.status = 1, Xt(je, yt), je.pendingTasks === 0)
                break e;
            } catch (le) {
              yt.status = 4, je.forceClientRender = !0, je.errorDigest = rt(x, le);
            } finally {
              L.blockedBoundary = I, L.blockedSegment = Te;
            }
            L = Ve(x, xe, I, at, De, L.legacyContext, L.context, L.treeContext), x.pingedTasks.push(L);
          }
          return;
      }
      if (typeof I == "object" && I !== null)
        switch (I.$$typeof) {
          case we:
            if (Y = Mt(x, L, I.render, Y, Te), mn !== 0) {
              I = L.treeContext, L.treeContext = kt(I, 1, 0);
              try {
                _t(x, L, Y);
              } finally {
                L.treeContext = I;
              }
            } else
              _t(x, L, Y);
            return;
          case ne:
            I = I.type, Y = Kt(I, Y), It(x, L, I, Y, Te);
            return;
          case Ee:
            if (Te = Y.children, I = I._context, Y = Y.value, xe = I._currentValue2, I._currentValue2 = Y, De = Ie, Ie = Y = { parent: De, depth: De === null ? 0 : De.depth + 1, context: I, parentValue: xe, value: Y }, L.context = Y, _t(x, L, Te), x = Ie, x === null)
              throw Error(t(403));
            Y = x.parentValue, x.context._currentValue2 = Y === et ? x.context._defaultValue : Y, x = Ie = x.parent, L.context = x;
            return;
          case He:
            Y = Y.children, Y = Y(I._currentValue2), _t(x, L, Y);
            return;
          case $e:
            Te = I._init, I = Te(I._payload), Y = Kt(I, Y), It(
              x,
              L,
              I,
              Y,
              void 0
            );
            return;
        }
      throw Error(t(130, I == null ? I : typeof I, ""));
    }
  }
  function _t(x, L, I) {
    if (L.node = I, typeof I == "object" && I !== null) {
      switch (I.$$typeof) {
        case ge:
          It(x, L, I.type, I.props, I.ref);
          return;
        case ve:
          throw Error(t(257));
        case $e:
          var Y = I._init;
          I = Y(I._payload), _t(x, L, I);
          return;
      }
      if (g(I)) {
        mt(x, L, I);
        return;
      }
      if (I === null || typeof I != "object" ? Y = null : (Y = Ze && I[Ze] || I["@@iterator"], Y = typeof Y == "function" ? Y : null), Y && (Y = Y.call(I))) {
        if (I = Y.next(), !I.done) {
          var Te = [];
          do
            Te.push(I.value), I = Y.next();
          while (!I.done);
          mt(x, L, Te);
        }
        return;
      }
      throw x = Object.prototype.toString.call(I), Error(t(31, x === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : x));
    }
    typeof I == "string" ? (Y = L.blockedSegment, Y.lastPushedText = re(L.blockedSegment.chunks, I, x.responseState, Y.lastPushedText)) : typeof I == "number" && (Y = L.blockedSegment, Y.lastPushedText = re(L.blockedSegment.chunks, "" + I, x.responseState, Y.lastPushedText));
  }
  function mt(x, L, I) {
    for (var Y = I.length, Te = 0; Te < Y; Te++) {
      var xe = L.treeContext;
      L.treeContext = kt(xe, Y, Te);
      try {
        Rt(x, L, I[Te]);
      } finally {
        L.treeContext = xe;
      }
    }
  }
  function Rt(x, L, I) {
    var Y = L.blockedSegment.formatContext, Te = L.legacyContext, xe = L.context;
    try {
      return _t(x, L, I);
    } catch (at) {
      if (Tn(), typeof at == "object" && at !== null && typeof at.then == "function") {
        I = at;
        var De = L.blockedSegment, je = ot(x, De.chunks.length, null, De.formatContext, De.lastPushedText, !0);
        De.children.push(je), De.lastPushedText = !1, x = Ve(x, L.node, L.blockedBoundary, je, L.abortSet, L.legacyContext, L.context, L.treeContext).ping, I.then(x, x), L.blockedSegment.formatContext = Y, L.legacyContext = Te, L.context = xe, gt(xe);
      } else
        throw L.blockedSegment.formatContext = Y, L.legacyContext = Te, L.context = xe, gt(xe), at;
    }
  }
  function wt(x) {
    var L = x.blockedBoundary;
    x = x.blockedSegment, x.status = 3, sn(this, L, x);
  }
  function Yt(x, L, I) {
    var Y = x.blockedBoundary;
    x.blockedSegment.status = 3, Y === null ? (L.allPendingTasks--, L.status !== 2 && (L.status = 2, L.destination !== null && L.destination.push(null))) : (Y.pendingTasks--, Y.forceClientRender || (Y.forceClientRender = !0, x = I === void 0 ? Error(t(432)) : I, Y.errorDigest = L.onError(x), Y.parentFlushed && L.clientRenderedBoundaries.push(Y)), Y.fallbackAbortableTasks.forEach(function(Te) {
      return Yt(Te, L, I);
    }), Y.fallbackAbortableTasks.clear(), L.allPendingTasks--, L.allPendingTasks === 0 && (Y = L.onAllReady, Y()));
  }
  function Xt(x, L) {
    if (L.chunks.length === 0 && L.children.length === 1 && L.children[0].boundary === null) {
      var I = L.children[0];
      I.id = L.id, I.parentFlushed = !0, I.status === 1 && Xt(x, I);
    } else
      x.completedSegments.push(L);
  }
  function sn(x, L, I) {
    if (L === null) {
      if (I.parentFlushed) {
        if (x.completedRootSegment !== null)
          throw Error(t(389));
        x.completedRootSegment = I;
      }
      x.pendingRootTasks--, x.pendingRootTasks === 0 && (x.onShellError = _e, L = x.onShellReady, L());
    } else
      L.pendingTasks--, L.forceClientRender || (L.pendingTasks === 0 ? (I.parentFlushed && I.status === 1 && Xt(L, I), L.parentFlushed && x.completedBoundaries.push(L), L.fallbackAbortableTasks.forEach(wt, x), L.fallbackAbortableTasks.clear()) : I.parentFlushed && I.status === 1 && (Xt(L, I), L.completedSegments.length === 1 && L.parentFlushed && x.partialBoundaries.push(L)));
    x.allPendingTasks--, x.allPendingTasks === 0 && (x = x.onAllReady, x());
  }
  function fn(x) {
    if (x.status !== 2) {
      var L = Ie, I = it.current;
      it.current = Me;
      var Y = dt;
      dt = x.responseState;
      try {
        var Te = x.pingedTasks, xe;
        for (xe = 0; xe < Te.length; xe++) {
          var De = Te[xe], je = x, at = De.blockedSegment;
          if (at.status === 0) {
            gt(De.context);
            try {
              _t(je, De, De.node), je.responseState.generateStaticMarkup || at.lastPushedText && at.textEmbedded && at.chunks.push("<!-- -->"), De.abortSet.delete(De), at.status = 1, sn(je, De.blockedBoundary, at);
            } catch (bt) {
              if (Tn(), typeof bt == "object" && bt !== null && typeof bt.then == "function") {
                var yt = De.ping;
                bt.then(yt, yt);
              } else {
                De.abortSet.delete(De), at.status = 4;
                var le = De.blockedBoundary, se = bt, me = rt(je, se);
                if (le === null ? xt(je, se) : (le.pendingTasks--, le.forceClientRender || (le.forceClientRender = !0, le.errorDigest = me, le.parentFlushed && je.clientRenderedBoundaries.push(le))), je.allPendingTasks--, je.allPendingTasks === 0) {
                  var Oe = je.onAllReady;
                  Oe();
                }
              }
            } finally {
            }
          }
        }
        Te.splice(0, xe), x.destination !== null && In(x, x.destination);
      } catch (bt) {
        rt(x, bt), xt(x, bt);
      } finally {
        dt = Y, it.current = I, I === Me && gt(L);
      }
    }
  }
  function nn(x, L, I) {
    switch (I.parentFlushed = !0, I.status) {
      case 0:
        var Y = I.id = x.nextSegmentId++;
        return I.lastPushedText = !1, I.textEmbedded = !1, x = x.responseState, L.push('<template id="'), L.push(x.placeholderPrefix), x = Y.toString(16), L.push(x), L.push('"></template>');
      case 1:
        I.status = 2;
        var Te = !0;
        Y = I.chunks;
        var xe = 0;
        I = I.children;
        for (var De = 0; De < I.length; De++) {
          for (Te = I[De]; xe < Te.index; xe++)
            L.push(Y[xe]);
          Te = Qt(x, L, Te);
        }
        for (; xe < Y.length - 1; xe++)
          L.push(Y[xe]);
        return xe < Y.length && (Te = L.push(Y[xe])), Te;
      default:
        throw Error(t(390));
    }
  }
  function Qt(x, L, I) {
    var Y = I.boundary;
    if (Y === null)
      return nn(x, L, I);
    if (Y.parentFlushed = !0, Y.forceClientRender)
      return x.responseState.generateStaticMarkup || (Y = Y.errorDigest, L.push("<!--$!-->"), L.push("<template"), Y && (L.push(' data-dgst="'), Y = E(Y), L.push(Y), L.push('"')), L.push("></template>")), nn(x, L, I), x = x.responseState.generateStaticMarkup ? !0 : L.push("<!--/$-->"), x;
    if (0 < Y.pendingTasks) {
      Y.rootSegmentID = x.nextSegmentId++, 0 < Y.completedSegments.length && x.partialBoundaries.push(Y);
      var Te = x.responseState, xe = Te.nextSuspenseID++;
      return Te = Te.boundaryPrefix + xe.toString(16), Y = Y.id = Te, j(L, x.responseState, Y), nn(x, L, I), L.push("<!--/$-->");
    }
    if (Y.byteSize > x.progressiveChunkSize)
      return Y.rootSegmentID = x.nextSegmentId++, x.completedBoundaries.push(Y), j(L, x.responseState, Y.id), nn(x, L, I), L.push("<!--/$-->");
    if (x.responseState.generateStaticMarkup || L.push("<!--$-->"), I = Y.completedSegments, I.length !== 1)
      throw Error(t(391));
    return Qt(x, L, I[0]), x = x.responseState.generateStaticMarkup ? !0 : L.push("<!--/$-->"), x;
  }
  function Cn(x, L, I) {
    return F(L, x.responseState, I.formatContext, I.id), Qt(x, L, I), X(L, I.formatContext);
  }
  function un(x, L, I) {
    for (var Y = I.completedSegments, Te = 0; Te < Y.length; Te++)
      An(x, L, I, Y[Te]);
    if (Y.length = 0, x = x.responseState, Y = I.id, I = I.rootSegmentID, L.push(x.startInlineScript), x.sentCompleteBoundaryFunction ? L.push('$RC("') : (x.sentCompleteBoundaryFunction = !0, L.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), Y === null)
      throw Error(t(395));
    return I = I.toString(16), L.push(Y), L.push('","'), L.push(x.segmentPrefix), L.push(I), L.push('")<\/script>');
  }
  function An(x, L, I, Y) {
    if (Y.status === 2)
      return !0;
    var Te = Y.id;
    if (Te === -1) {
      if ((Y.id = I.rootSegmentID) === -1)
        throw Error(t(392));
      return Cn(x, L, Y);
    }
    return Cn(x, L, Y), x = x.responseState, L.push(x.startInlineScript), x.sentCompleteSegmentFunction ? L.push('$RS("') : (x.sentCompleteSegmentFunction = !0, L.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), L.push(x.segmentPrefix), Te = Te.toString(16), L.push(Te), L.push('","'), L.push(x.placeholderPrefix), L.push(Te), L.push('")<\/script>');
  }
  function In(x, L) {
    try {
      var I = x.completedRootSegment;
      if (I !== null && x.pendingRootTasks === 0) {
        Qt(x, L, I), x.completedRootSegment = null;
        var Y = x.responseState.bootstrapChunks;
        for (I = 0; I < Y.length - 1; I++)
          L.push(Y[I]);
        I < Y.length && L.push(Y[I]);
      }
      var Te = x.clientRenderedBoundaries, xe;
      for (xe = 0; xe < Te.length; xe++) {
        var De = Te[xe];
        Y = L;
        var je = x.responseState, at = De.id, yt = De.errorDigest, le = De.errorMessage, se = De.errorComponentStack;
        if (Y.push(je.startInlineScript), je.sentClientRenderFunction ? Y.push('$RX("') : (je.sentClientRenderFunction = !0, Y.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), at === null)
          throw Error(t(395));
        if (Y.push(at), Y.push('"'), yt || le || se) {
          Y.push(",");
          var me = ae(yt || "");
          Y.push(me);
        }
        if (le || se) {
          Y.push(",");
          var Oe = ae(le || "");
          Y.push(Oe);
        }
        if (se) {
          Y.push(",");
          var bt = ae(se);
          Y.push(bt);
        }
        if (!Y.push(")<\/script>")) {
          x.destination = null, xe++, Te.splice(0, xe);
          return;
        }
      }
      Te.splice(0, xe);
      var vn = x.completedBoundaries;
      for (xe = 0; xe < vn.length; xe++)
        if (!un(x, L, vn[xe])) {
          x.destination = null, xe++, vn.splice(0, xe);
          return;
        }
      vn.splice(0, xe);
      var Rn = x.partialBoundaries;
      for (xe = 0; xe < Rn.length; xe++) {
        var fr = Rn[xe];
        e: {
          Te = x, De = L;
          var Hn = fr.completedSegments;
          for (je = 0; je < Hn.length; je++)
            if (!An(Te, De, fr, Hn[je])) {
              je++, Hn.splice(0, je);
              var Ar = !1;
              break e;
            }
          Hn.splice(0, je), Ar = !0;
        }
        if (!Ar) {
          x.destination = null, xe++, Rn.splice(0, xe);
          return;
        }
      }
      Rn.splice(0, xe);
      var hr = x.completedBoundaries;
      for (xe = 0; xe < hr.length; xe++)
        if (!un(x, L, hr[xe])) {
          x.destination = null, xe++, hr.splice(0, xe);
          return;
        }
      hr.splice(0, xe);
    } finally {
      x.allPendingTasks === 0 && x.pingedTasks.length === 0 && x.clientRenderedBoundaries.length === 0 && x.completedBoundaries.length === 0 && L.push(null);
    }
  }
  function Yn(x, L) {
    try {
      var I = x.abortableTasks;
      I.forEach(function(Y) {
        return Yt(Y, x, L);
      }), I.clear(), x.destination !== null && In(x, x.destination);
    } catch (Y) {
      rt(x, Y), xt(x, Y);
    }
  }
  function Zn() {
  }
  function Xn(x, L, I, Y) {
    var Te = !1, xe = null, De = "", je = { push: function(yt) {
      return yt !== null && (De += yt), !0;
    }, destroy: function(yt) {
      Te = !0, xe = yt;
    } }, at = !1;
    if (x = Xe(x, te(I, L ? L.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Zn, void 0, function() {
      at = !0;
    }, void 0, void 0), fn(x), Yn(x, Y), x.status === 1)
      x.status = 2, je.destroy(x.fatalError);
    else if (x.status !== 2 && x.destination === null) {
      x.destination = je;
      try {
        In(x, je);
      } catch (yt) {
        rt(x, yt), xt(x, yt);
      }
    }
    if (Te)
      throw xe;
    if (!at)
      throw Error(t(426));
    return De;
  }
  return Li.renderToNodeStream = function() {
    throw Error(t(207));
  }, Li.renderToStaticMarkup = function(x, L) {
    return Xn(x, L, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Li.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Li.renderToString = function(x, L) {
    return Xn(x, L, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Li.version = "18.2.0", Li;
}
var Mu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var am;
function DE() {
  if (am)
    return Mu;
  am = 1;
  var e = ce;
  function t(b) {
    for (var D = "https://reactjs.org/docs/error-decoder.html?invariant=" + b, B = 1; B < arguments.length; B++)
      D += "&args[]=" + encodeURIComponent(arguments[B]);
    return "Minified React error #" + b + "; visit " + D + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, i = 0;
  function r(b, D) {
    if (D.length !== 0)
      if (512 < D.length)
        0 < i && (b.enqueue(new Uint8Array(n.buffer, 0, i)), n = new Uint8Array(512), i = 0), b.enqueue(D);
      else {
        var B = n.length - i;
        B < D.length && (B === 0 ? b.enqueue(n) : (n.set(D.subarray(0, B), i), b.enqueue(n), D = D.subarray(B)), n = new Uint8Array(512), i = 0), n.set(D, i), i += D.length;
      }
  }
  function o(b, D) {
    return r(b, D), !0;
  }
  function d(b) {
    n && 0 < i && (b.enqueue(new Uint8Array(n.buffer, 0, i)), n = null, i = 0);
  }
  var u = new TextEncoder();
  function s(b) {
    return u.encode(b);
  }
  function h(b) {
    return u.encode(b);
  }
  function m(b, D) {
    typeof b.error == "function" ? b.error(D) : b.close();
  }
  var y = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, E = {};
  function R(b) {
    return y.call(E, b) ? !0 : y.call(w, b) ? !1 : v.test(b) ? E[b] = !0 : (w[b] = !0, !1);
  }
  function C(b, D, B, q, Ce, ke, Ne) {
    this.acceptsBooleans = D === 2 || D === 3 || D === 4, this.attributeName = q, this.attributeNamespace = Ce, this.mustUseProperty = B, this.propertyName = b, this.type = D, this.sanitizeURL = ke, this.removeEmptyString = Ne;
  }
  var g = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(b) {
    g[b] = new C(b, 0, !1, b, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(b) {
    var D = b[0];
    g[D] = new C(D, 1, !1, b[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(b) {
    g[b] = new C(b, 2, !1, b.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(b) {
    g[b] = new C(b, 2, !1, b, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(b) {
    g[b] = new C(b, 3, !1, b.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(b) {
    g[b] = new C(b, 3, !0, b, null, !1, !1);
  }), ["capture", "download"].forEach(function(b) {
    g[b] = new C(b, 4, !1, b, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(b) {
    g[b] = new C(b, 6, !1, b, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(b) {
    g[b] = new C(b, 5, !1, b.toLowerCase(), null, !1, !1);
  });
  var _ = /[\-:]([a-z])/g;
  function P(b) {
    return b[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(b) {
    var D = b.replace(
      _,
      P
    );
    g[D] = new C(D, 1, !1, b, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(b) {
    var D = b.replace(_, P);
    g[D] = new C(D, 1, !1, b, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(b) {
    var D = b.replace(_, P);
    g[D] = new C(D, 1, !1, b, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(b) {
    g[b] = new C(b, 1, !1, b.toLowerCase(), null, !1, !1);
  }), g.xlinkHref = new C("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(b) {
    g[b] = new C(b, 1, !1, b.toLowerCase(), null, !0, !0);
  });
  var M = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, N = ["Webkit", "ms", "Moz", "O"];
  Object.keys(M).forEach(function(b) {
    N.forEach(function(D) {
      D = D + b.charAt(0).toUpperCase() + b.substring(1), M[D] = M[b];
    });
  });
  var T = /["'&<>]/;
  function U(b) {
    if (typeof b == "boolean" || typeof b == "number")
      return "" + b;
    b = "" + b;
    var D = T.exec(b);
    if (D) {
      var B = "", q, Ce = 0;
      for (q = D.index; q < b.length; q++) {
        switch (b.charCodeAt(q)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        Ce !== q && (B += b.substring(Ce, q)), Ce = q + 1, B += D;
      }
      b = Ce !== q ? B + b.substring(Ce, q) : B;
    }
    return b;
  }
  var V = /([A-Z])/g, G = /^ms-/, ue = Array.isArray, Z = h("<script>"), $ = h("<\/script>"), H = h('<script src="'), j = h('<script type="module" src="'), F = h('" async=""><\/script>'), X = /(<\/|<)(s)(cript)/gi;
  function Q(b, D, B, q) {
    return "" + D + (B === "s" ? "\\u0073" : "\\u0053") + q;
  }
  function ae(b, D, B, q, Ce) {
    b = b === void 0 ? "" : b, D = D === void 0 ? Z : h('<script nonce="' + U(D) + '">');
    var ke = [];
    if (B !== void 0 && ke.push(D, s(("" + B).replace(X, Q)), $), q !== void 0)
      for (B = 0; B < q.length; B++)
        ke.push(H, s(U(q[B])), F);
    if (Ce !== void 0)
      for (q = 0; q < Ce.length; q++)
        ke.push(j, s(U(Ce[q])), F);
    return { bootstrapChunks: ke, startInlineScript: D, placeholderPrefix: h(b + "P:"), segmentPrefix: h(b + "S:"), boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function te(b, D) {
    return { insertionMode: b, selectedValue: D };
  }
  function re(b) {
    return te(b === "http://www.w3.org/2000/svg" ? 2 : b === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function ie(b, D, B) {
    switch (D) {
      case "select":
        return te(1, B.value != null ? B.value : B.defaultValue);
      case "svg":
        return te(2, null);
      case "math":
        return te(3, null);
      case "foreignObject":
        return te(1, null);
      case "table":
        return te(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return te(5, null);
      case "colgroup":
        return te(7, null);
      case "tr":
        return te(6, null);
    }
    return 4 <= b.insertionMode || b.insertionMode === 0 ? te(1, null) : b;
  }
  var ge = h("<!-- -->");
  function ve(b, D, B, q) {
    return D === "" ? q : (q && b.push(ge), b.push(s(U(D))), !0);
  }
  var Se = /* @__PURE__ */ new Map(), ye = h(' style="'), ee = h(":"), Ee = h(";");
  function He(b, D, B) {
    if (typeof B != "object")
      throw Error(t(62));
    D = !0;
    for (var q in B)
      if (y.call(B, q)) {
        var Ce = B[q];
        if (Ce != null && typeof Ce != "boolean" && Ce !== "") {
          if (q.indexOf("--") === 0) {
            var ke = s(U(q));
            Ce = s(U(("" + Ce).trim()));
          } else {
            ke = q;
            var Ne = Se.get(ke);
            Ne !== void 0 || (Ne = h(U(ke.replace(V, "-$1").toLowerCase().replace(G, "-ms-"))), Se.set(ke, Ne)), ke = Ne, Ce = typeof Ce == "number" ? Ce === 0 || y.call(M, q) ? s("" + Ce) : s(Ce + "px") : s(U(("" + Ce).trim()));
          }
          D ? (D = !1, b.push(ye, ke, ee, Ce)) : b.push(Ee, ke, ee, Ce);
        }
      }
    D || b.push(Ae);
  }
  var we = h(" "), fe = h('="'), Ae = h('"'), ne = h('=""');
  function $e(b, D, B, q) {
    switch (B) {
      case "style":
        He(b, D, q);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < B.length) || B[0] !== "o" && B[0] !== "O" || B[1] !== "n" && B[1] !== "N") {
      if (D = g.hasOwnProperty(B) ? g[B] : null, D !== null) {
        switch (typeof q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!D.acceptsBooleans)
              return;
        }
        switch (B = s(D.attributeName), D.type) {
          case 3:
            q && b.push(we, B, ne);
            break;
          case 4:
            q === !0 ? b.push(we, B, ne) : q !== !1 && b.push(we, B, fe, s(U(q)), Ae);
            break;
          case 5:
            isNaN(q) || b.push(we, B, fe, s(U(q)), Ae);
            break;
          case 6:
            !isNaN(q) && 1 <= q && b.push(we, B, fe, s(U(q)), Ae);
            break;
          default:
            D.sanitizeURL && (q = "" + q), b.push(we, B, fe, s(U(q)), Ae);
        }
      } else if (R(B)) {
        switch (typeof q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (D = B.toLowerCase().slice(0, 5), D !== "data-" && D !== "aria-")
              return;
        }
        b.push(we, s(B), fe, s(U(q)), Ae);
      }
    }
  }
  var Le = h(">"), Ke = h("/>");
  function Ge(b, D, B) {
    if (D != null) {
      if (B != null)
        throw Error(t(60));
      if (typeof D != "object" || !("__html" in D))
        throw Error(t(61));
      D = D.__html, D != null && b.push(s("" + D));
    }
  }
  function et(b) {
    var D = "";
    return e.Children.forEach(b, function(B) {
      B != null && (D += B);
    }), D;
  }
  var Ze = h(' selected=""');
  function Et(b, D, B, q) {
    b.push(Fe(B));
    var Ce = B = null, ke;
    for (ke in D)
      if (y.call(D, ke)) {
        var Ne = D[ke];
        if (Ne != null)
          switch (ke) {
            case "children":
              B = Ne;
              break;
            case "dangerouslySetInnerHTML":
              Ce = Ne;
              break;
            default:
              $e(b, q, ke, Ne);
          }
      }
    return b.push(Le), Ge(b, Ce, B), typeof B == "string" ? (b.push(s(U(B))), null) : B;
  }
  var qe = h(`
`), Be = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Ie = /* @__PURE__ */ new Map();
  function Fe(b) {
    var D = Ie.get(b);
    if (D === void 0) {
      if (!Be.test(b))
        throw Error(t(65, b));
      D = h("<" + b), Ie.set(b, D);
    }
    return D;
  }
  var lt = h("<!DOCTYPE html>");
  function Ue(b, D, B, q, Ce) {
    switch (D) {
      case "select":
        b.push(Fe("select"));
        var ke = null, Ne = null;
        for (Pt in B)
          if (y.call(B, Pt)) {
            var Ye = B[Pt];
            if (Ye != null)
              switch (Pt) {
                case "children":
                  ke = Ye;
                  break;
                case "dangerouslySetInnerHTML":
                  Ne = Ye;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  $e(b, q, Pt, Ye);
              }
          }
        return b.push(Le), Ge(b, Ne, ke), ke;
      case "option":
        Ne = Ce.selectedValue, b.push(Fe("option"));
        var St = Ye = null, Ot = null, Pt = null;
        for (ke in B)
          if (y.call(B, ke)) {
            var an = B[ke];
            if (an != null)
              switch (ke) {
                case "children":
                  Ye = an;
                  break;
                case "selected":
                  Ot = an;
                  break;
                case "dangerouslySetInnerHTML":
                  Pt = an;
                  break;
                case "value":
                  St = an;
                default:
                  $e(b, q, ke, an);
              }
          }
        if (Ne != null)
          if (B = St !== null ? "" + St : et(Ye), ue(Ne)) {
            for (q = 0; q < Ne.length; q++)
              if ("" + Ne[q] === B) {
                b.push(Ze);
                break;
              }
          } else
            "" + Ne === B && b.push(Ze);
        else
          Ot && b.push(Ze);
        return b.push(Le), Ge(b, Pt, Ye), Ye;
      case "textarea":
        b.push(Fe("textarea")), Pt = Ne = ke = null;
        for (Ye in B)
          if (y.call(B, Ye) && (St = B[Ye], St != null))
            switch (Ye) {
              case "children":
                Pt = St;
                break;
              case "value":
                ke = St;
                break;
              case "defaultValue":
                Ne = St;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                $e(b, q, Ye, St);
            }
        if (ke === null && Ne !== null && (ke = Ne), b.push(Le), Pt != null) {
          if (ke != null)
            throw Error(t(92));
          if (ue(Pt) && 1 < Pt.length)
            throw Error(t(93));
          ke = "" + Pt;
        }
        return typeof ke == "string" && ke[0] === `
` && b.push(qe), ke !== null && b.push(s(U("" + ke))), null;
      case "input":
        b.push(Fe("input")), St = Pt = Ye = ke = null;
        for (Ne in B)
          if (y.call(B, Ne) && (Ot = B[Ne], Ot != null))
            switch (Ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                St = Ot;
                break;
              case "defaultValue":
                Ye = Ot;
                break;
              case "checked":
                Pt = Ot;
                break;
              case "value":
                ke = Ot;
                break;
              default:
                $e(b, q, Ne, Ot);
            }
        return Pt !== null ? $e(
          b,
          q,
          "checked",
          Pt
        ) : St !== null && $e(b, q, "checked", St), ke !== null ? $e(b, q, "value", ke) : Ye !== null && $e(b, q, "value", Ye), b.push(Ke), null;
      case "menuitem":
        b.push(Fe("menuitem"));
        for (var Un in B)
          if (y.call(B, Un) && (ke = B[Un], ke != null))
            switch (Un) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                $e(b, q, Un, ke);
            }
        return b.push(Le), null;
      case "title":
        b.push(Fe("title")), ke = null;
        for (an in B)
          if (y.call(B, an) && (Ne = B[an], Ne != null))
            switch (an) {
              case "children":
                ke = Ne;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                $e(b, q, an, Ne);
            }
        return b.push(Le), ke;
      case "listing":
      case "pre":
        b.push(Fe(D)), Ne = ke = null;
        for (St in B)
          if (y.call(B, St) && (Ye = B[St], Ye != null))
            switch (St) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Ne = Ye;
                break;
              default:
                $e(b, q, St, Ye);
            }
        if (b.push(Le), Ne != null) {
          if (ke != null)
            throw Error(t(60));
          if (typeof Ne != "object" || !("__html" in Ne))
            throw Error(t(61));
          B = Ne.__html, B != null && (typeof B == "string" && 0 < B.length && B[0] === `
` ? b.push(qe, s(B)) : b.push(s("" + B)));
        }
        return typeof ke == "string" && ke[0] === `
` && b.push(qe), ke;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        b.push(Fe(D));
        for (var Jn in B)
          if (y.call(B, Jn) && (ke = B[Jn], ke != null))
            switch (Jn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, D));
              default:
                $e(b, q, Jn, ke);
            }
        return b.push(Ke), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Et(b, B, D, q);
      case "html":
        return Ce.insertionMode === 0 && b.push(lt), Et(b, B, D, q);
      default:
        if (D.indexOf("-") === -1 && typeof B.is != "string")
          return Et(b, B, D, q);
        b.push(Fe(D)), Ne = ke = null;
        for (Ot in B)
          if (y.call(B, Ot) && (Ye = B[Ot], Ye != null))
            switch (Ot) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Ne = Ye;
                break;
              case "style":
                He(b, q, Ye);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                R(Ot) && typeof Ye != "function" && typeof Ye != "symbol" && b.push(we, s(Ot), fe, s(U(Ye)), Ae);
            }
        return b.push(Le), Ge(b, Ne, ke), ke;
    }
  }
  var ct = h("</"), ht = h(">"), gt = h('<template id="'), Dt = h('"></template>'), qt = h("<!--$-->"), Vt = h('<!--$?--><template id="'), kt = h('"></template>'), zt = h("<!--$!-->"), ln = h("<!--/$-->"), en = h("<template"), cn = h('"'), ze = h(' data-dgst="');
  h(' data-msg="'), h(' data-stck="');
  var Nt = h("></template>");
  function Gt(b, D, B) {
    if (r(b, Vt), B === null)
      throw Error(t(395));
    return r(b, B), o(b, kt);
  }
  var Bt = h('<div hidden id="'), yn = h('">'), Lt = h("</div>"), bn = h('<svg aria-hidden="true" style="display:none" id="'), Mn = h('">'), mn = h("</svg>"), dn = h('<math aria-hidden="true" style="display:none" id="'), jt = h('">'), wn = h("</math>"), Ft = h('<table hidden id="'), pt = h('">'), Tn = h("</table>"), tn = h('<table hidden><tbody id="'), $t = h('">'), Sn = h("</tbody></table>"), En = h('<table hidden><tr id="'), Dn = h('">'), Ln = h("</tr></table>"), Me = h('<table hidden><colgroup id="'), dt = h('">'), it = h("</colgroup></table>");
  function W(b, D, B, q) {
    switch (B.insertionMode) {
      case 0:
      case 1:
        return r(b, Bt), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, yn);
      case 2:
        return r(b, bn), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, Mn);
      case 3:
        return r(b, dn), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, jt);
      case 4:
        return r(b, Ft), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, pt);
      case 5:
        return r(b, tn), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, $t);
      case 6:
        return r(b, En), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, Dn);
      case 7:
        return r(
          b,
          Me
        ), r(b, D.segmentPrefix), r(b, s(q.toString(16))), o(b, dt);
      default:
        throw Error(t(397));
    }
  }
  function _e(b, D) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return o(b, Lt);
      case 2:
        return o(b, mn);
      case 3:
        return o(b, wn);
      case 4:
        return o(b, Tn);
      case 5:
        return o(b, Sn);
      case 6:
        return o(b, Ln);
      case 7:
        return o(b, it);
      default:
        throw Error(t(397));
    }
  }
  var Xe = h('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Ve = h('$RS("'), ot = h('","'), rt = h('")<\/script>'), xt = h('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Mt = h('$RC("'), Qe = h('","'), Kt = h('")<\/script>'), It = h('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), _t = h('$RX("'), mt = h('"'), Rt = h(")<\/script>"), wt = h(","), Yt = /[<\u2028\u2029]/g;
  function Xt(b) {
    return JSON.stringify(b).replace(Yt, function(D) {
      switch (D) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var sn = Object.assign, fn = Symbol.for("react.element"), nn = Symbol.for("react.portal"), Qt = Symbol.for("react.fragment"), Cn = Symbol.for("react.strict_mode"), un = Symbol.for("react.profiler"), An = Symbol.for("react.provider"), In = Symbol.for("react.context"), Yn = Symbol.for("react.forward_ref"), Zn = Symbol.for("react.suspense"), Xn = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), L = Symbol.for("react.lazy"), I = Symbol.for("react.scope"), Y = Symbol.for("react.debug_trace_mode"), Te = Symbol.for("react.legacy_hidden"), xe = Symbol.for("react.default_value"), De = Symbol.iterator;
  function je(b) {
    if (b == null)
      return null;
    if (typeof b == "function")
      return b.displayName || b.name || null;
    if (typeof b == "string")
      return b;
    switch (b) {
      case Qt:
        return "Fragment";
      case nn:
        return "Portal";
      case un:
        return "Profiler";
      case Cn:
        return "StrictMode";
      case Zn:
        return "Suspense";
      case Xn:
        return "SuspenseList";
    }
    if (typeof b == "object")
      switch (b.$$typeof) {
        case In:
          return (b.displayName || "Context") + ".Consumer";
        case An:
          return (b._context.displayName || "Context") + ".Provider";
        case Yn:
          var D = b.render;
          return b = b.displayName, b || (b = D.displayName || D.name || "", b = b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef"), b;
        case x:
          return D = b.displayName || null, D !== null ? D : je(b.type) || "Memo";
        case L:
          D = b._payload, b = b._init;
          try {
            return je(b(D));
          } catch {
          }
      }
    return null;
  }
  var at = {};
  function yt(b, D) {
    if (b = b.contextTypes, !b)
      return at;
    var B = {}, q;
    for (q in b)
      B[q] = D[q];
    return B;
  }
  var le = null;
  function se(b, D) {
    if (b !== D) {
      b.context._currentValue = b.parentValue, b = b.parent;
      var B = D.parent;
      if (b === null) {
        if (B !== null)
          throw Error(t(401));
      } else {
        if (B === null)
          throw Error(t(401));
        se(b, B);
      }
      D.context._currentValue = D.value;
    }
  }
  function me(b) {
    b.context._currentValue = b.parentValue, b = b.parent, b !== null && me(b);
  }
  function Oe(b) {
    var D = b.parent;
    D !== null && Oe(D), b.context._currentValue = b.value;
  }
  function bt(b, D) {
    if (b.context._currentValue = b.parentValue, b = b.parent, b === null)
      throw Error(t(402));
    b.depth === D.depth ? se(b, D) : bt(b, D);
  }
  function vn(b, D) {
    var B = D.parent;
    if (B === null)
      throw Error(t(402));
    b.depth === B.depth ? se(b, B) : vn(b, B), D.context._currentValue = D.value;
  }
  function Rn(b) {
    var D = le;
    D !== b && (D === null ? Oe(b) : b === null ? me(D) : D.depth === b.depth ? se(D, b) : D.depth > b.depth ? bt(D, b) : vn(D, b), le = b);
  }
  var fr = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(b, D) {
    b = b._reactInternals, b.queue !== null && b.queue.push(D);
  }, enqueueReplaceState: function(b, D) {
    b = b._reactInternals, b.replace = !0, b.queue = [D];
  }, enqueueForceUpdate: function() {
  } };
  function Hn(b, D, B, q) {
    var Ce = b.state !== void 0 ? b.state : null;
    b.updater = fr, b.props = B, b.state = Ce;
    var ke = { queue: [], replace: !1 };
    b._reactInternals = ke;
    var Ne = D.contextType;
    if (b.context = typeof Ne == "object" && Ne !== null ? Ne._currentValue : q, Ne = D.getDerivedStateFromProps, typeof Ne == "function" && (Ne = Ne(B, Ce), Ce = Ne == null ? Ce : sn({}, Ce, Ne), b.state = Ce), typeof D.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function"))
      if (D = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), D !== b.state && fr.enqueueReplaceState(b, b.state, null), ke.queue !== null && 0 < ke.queue.length)
        if (D = ke.queue, Ne = ke.replace, ke.queue = null, ke.replace = !1, Ne && D.length === 1)
          b.state = D[0];
        else {
          for (ke = Ne ? D[0] : b.state, Ce = !0, Ne = Ne ? 1 : 0; Ne < D.length; Ne++) {
            var Ye = D[Ne];
            Ye = typeof Ye == "function" ? Ye.call(b, ke, B, q) : Ye, Ye != null && (Ce ? (Ce = !1, ke = sn({}, ke, Ye)) : sn(ke, Ye));
          }
          b.state = ke;
        }
      else
        ke.queue = null;
  }
  var Ar = { id: 1, overflow: "" };
  function hr(b, D, B) {
    var q = b.id;
    b = b.overflow;
    var Ce = 32 - Qr(q) - 1;
    q &= ~(1 << Ce), B += 1;
    var ke = 32 - Qr(D) + Ce;
    if (30 < ke) {
      var Ne = Ce - Ce % 5;
      return ke = (q & (1 << Ne) - 1).toString(32), q >>= Ne, Ce -= Ne, { id: 1 << 32 - Qr(D) + Ce | B << Ce | q, overflow: ke + b };
    }
    return { id: 1 << ke | B << Ce | q, overflow: b };
  }
  var Qr = Math.clz32 ? Math.clz32 : Ua, il = Math.log, ol = Math.LN2;
  function Ua(b) {
    return b >>>= 0, b === 0 ? 32 : 31 - (il(b) / ol | 0) | 0;
  }
  function ll(b, D) {
    return b === D && (b !== 0 || 1 / b === 1 / D) || b !== b && D !== D;
  }
  var Ka = typeof Object.is == "function" ? Object.is : ll, pr = null, Jr = null, pa = null, rn = null, yr = !1, Vn = !1, Pr = 0, vr = null, ma = 0;
  function xr() {
    if (pr === null)
      throw Error(t(321));
    return pr;
  }
  function Qn() {
    if (0 < ma)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ya() {
    return rn === null ? pa === null ? (yr = !1, pa = rn = Qn()) : (yr = !0, rn = pa) : rn.next === null ? (yr = !1, rn = rn.next = Qn()) : (yr = !0, rn = rn.next), rn;
  }
  function Xa() {
    Jr = pr = null, Vn = !1, pa = null, ma = 0, rn = vr = null;
  }
  function ji(b, D) {
    return typeof D == "function" ? D(b) : D;
  }
  function Ui(b, D, B) {
    if (pr = xr(), rn = Ya(), yr) {
      var q = rn.queue;
      if (D = q.dispatch, vr !== null && (B = vr.get(q), B !== void 0)) {
        vr.delete(q), q = rn.memoizedState;
        do
          q = b(q, B.action), B = B.next;
        while (B !== null);
        return rn.memoizedState = q, [q, D];
      }
      return [rn.memoizedState, D];
    }
    return b = b === ji ? typeof D == "function" ? D() : D : B !== void 0 ? B(D) : D, rn.memoizedState = b, b = rn.queue = { last: null, dispatch: null }, b = b.dispatch = sl.bind(null, pr, b), [rn.memoizedState, b];
  }
  function Ki(b, D) {
    if (pr = xr(), rn = Ya(), D = D === void 0 ? null : D, rn !== null) {
      var B = rn.memoizedState;
      if (B !== null && D !== null) {
        var q = B[1];
        e:
          if (q === null)
            q = !1;
          else {
            for (var Ce = 0; Ce < q.length && Ce < D.length; Ce++)
              if (!Ka(D[Ce], q[Ce])) {
                q = !1;
                break e;
              }
            q = !0;
          }
        if (q)
          return B[0];
      }
    }
    return b = b(), rn.memoizedState = [b, D], b;
  }
  function sl(b, D, B) {
    if (25 <= ma)
      throw Error(t(301));
    if (b === pr)
      if (Vn = !0, b = { action: B, next: null }, vr === null && (vr = /* @__PURE__ */ new Map()), B = vr.get(D), B === void 0)
        vr.set(D, b);
      else {
        for (D = B; D.next !== null; )
          D = D.next;
        D.next = b;
      }
  }
  function ul() {
    throw Error(t(394));
  }
  function ga() {
  }
  var ya = { readContext: function(b) {
    return b._currentValue;
  }, useContext: function(b) {
    return xr(), b._currentValue;
  }, useMemo: Ki, useReducer: Ui, useRef: function(b) {
    pr = xr(), rn = Ya();
    var D = rn.memoizedState;
    return D === null ? (b = { current: b }, rn.memoizedState = b) : D;
  }, useState: function(b) {
    return Ui(ji, b);
  }, useInsertionEffect: ga, useLayoutEffect: function() {
  }, useCallback: function(b, D) {
    return Ki(function() {
      return b;
    }, D);
  }, useImperativeHandle: ga, useEffect: ga, useDebugValue: ga, useDeferredValue: function(b) {
    return xr(), b;
  }, useTransition: function() {
    return xr(), [!1, ul];
  }, useId: function() {
    var b = Jr.treeContext, D = b.overflow;
    b = b.id, b = (b & ~(1 << 32 - Qr(b) - 1)).toString(32) + D;
    var B = va;
    if (B === null)
      throw Error(t(404));
    return D = Pr++, b = ":" + B.idPrefix + "R" + b, 0 < D && (b += "H" + D.toString(32)), b + ":";
  }, useMutableSource: function(b, D) {
    return xr(), D(b._source);
  }, useSyncExternalStore: function(b, D, B) {
    if (B === void 0)
      throw Error(t(407));
    return B();
  } }, va = null, ea = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function cl(b) {
    return console.error(b), null;
  }
  function ta() {
  }
  function qa(b, D, B, q, Ce, ke, Ne, Ye, St) {
    var Ot = [], Pt = /* @__PURE__ */ new Set();
    return D = { destination: null, responseState: D, progressiveChunkSize: q === void 0 ? 12800 : q, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Pt, pingedTasks: Ot, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Ce === void 0 ? cl : Ce, onAllReady: ke === void 0 ? ta : ke, onShellReady: Ne === void 0 ? ta : Ne, onShellError: Ye === void 0 ? ta : Ye, onFatalError: St === void 0 ? ta : St }, B = Fr(D, 0, null, B, !1, !1), B.parentFlushed = !0, b = Ga(D, b, null, B, Pt, at, null, Ar), Ot.push(b), D;
  }
  function Ga(b, D, B, q, Ce, ke, Ne, Ye) {
    b.allPendingTasks++, B === null ? b.pendingRootTasks++ : B.pendingTasks++;
    var St = { node: D, ping: function() {
      var Ot = b.pingedTasks;
      Ot.push(St), Ot.length === 1 && Qi(b);
    }, blockedBoundary: B, blockedSegment: q, abortSet: Ce, legacyContext: ke, context: Ne, treeContext: Ye };
    return Ce.add(St), St;
  }
  function Fr(b, D, B, q, Ce, ke) {
    return { status: 0, id: -1, index: D, parentFlushed: !1, chunks: [], children: [], formatContext: q, boundary: B, lastPushedText: Ce, textEmbedded: ke };
  }
  function zr(b, D) {
    if (b = b.onError(D), b != null && typeof b != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b;
  }
  function xa(b, D) {
    var B = b.onShellError;
    B(D), B = b.onFatalError, B(D), b.destination !== null ? (b.status = 2, m(b.destination, D)) : (b.status = 1, b.fatalError = D);
  }
  function Yi(b, D, B, q, Ce) {
    for (pr = {}, Jr = D, Pr = 0, b = B(q, Ce); Vn; )
      Vn = !1, Pr = 0, ma += 1, rn = null, b = B(q, Ce);
    return Xa(), b;
  }
  function Za(b, D, B, q) {
    var Ce = B.render(), ke = q.childContextTypes;
    if (ke != null) {
      var Ne = D.legacyContext;
      if (typeof B.getChildContext != "function")
        q = Ne;
      else {
        B = B.getChildContext();
        for (var Ye in B)
          if (!(Ye in ke))
            throw Error(t(108, je(q) || "Unknown", Ye));
        q = sn({}, Ne, B);
      }
      D.legacyContext = q, jn(b, D, Ce), D.legacyContext = Ne;
    } else
      jn(b, D, Ce);
  }
  function Xi(b, D) {
    if (b && b.defaultProps) {
      D = sn({}, D), b = b.defaultProps;
      for (var B in b)
        D[B] === void 0 && (D[B] = b[B]);
      return D;
    }
    return D;
  }
  function ba(b, D, B, q, Ce) {
    if (typeof B == "function")
      if (B.prototype && B.prototype.isReactComponent) {
        Ce = yt(B, D.legacyContext);
        var ke = B.contextType;
        ke = new B(q, typeof ke == "object" && ke !== null ? ke._currentValue : Ce), Hn(ke, B, q, Ce), Za(b, D, ke, B);
      } else {
        ke = yt(B, D.legacyContext), Ce = Yi(b, D, B, q, ke);
        var Ne = Pr !== 0;
        if (typeof Ce == "object" && Ce !== null && typeof Ce.render == "function" && Ce.$$typeof === void 0)
          Hn(Ce, B, q, ke), Za(b, D, Ce, B);
        else if (Ne) {
          q = D.treeContext, D.treeContext = hr(q, 1, 0);
          try {
            jn(b, D, Ce);
          } finally {
            D.treeContext = q;
          }
        } else
          jn(b, D, Ce);
      }
    else if (typeof B == "string") {
      switch (Ce = D.blockedSegment, ke = Ue(Ce.chunks, B, q, b.responseState, Ce.formatContext), Ce.lastPushedText = !1, Ne = Ce.formatContext, Ce.formatContext = ie(Ne, B, q), Sa(b, D, ke), Ce.formatContext = Ne, B) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Ce.chunks.push(ct, s(B), ht);
      }
      Ce.lastPushedText = !1;
    } else {
      switch (B) {
        case Te:
        case Y:
        case Cn:
        case un:
        case Qt:
          jn(b, D, q.children);
          return;
        case Xn:
          jn(b, D, q.children);
          return;
        case I:
          throw Error(t(343));
        case Zn:
          e: {
            B = D.blockedBoundary, Ce = D.blockedSegment, ke = q.fallback, q = q.children, Ne = /* @__PURE__ */ new Set();
            var Ye = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Ne, errorDigest: null }, St = Fr(b, Ce.chunks.length, Ye, Ce.formatContext, !1, !1);
            Ce.children.push(St), Ce.lastPushedText = !1;
            var Ot = Fr(b, 0, null, Ce.formatContext, !1, !1);
            Ot.parentFlushed = !0, D.blockedBoundary = Ye, D.blockedSegment = Ot;
            try {
              if (Sa(
                b,
                D,
                q
              ), Ot.lastPushedText && Ot.textEmbedded && Ot.chunks.push(ge), Ot.status = 1, Ea(Ye, Ot), Ye.pendingTasks === 0)
                break e;
            } catch (Pt) {
              Ot.status = 4, Ye.forceClientRender = !0, Ye.errorDigest = zr(b, Pt);
            } finally {
              D.blockedBoundary = B, D.blockedSegment = Ce;
            }
            D = Ga(b, ke, B, St, Ne, D.legacyContext, D.context, D.treeContext), b.pingedTasks.push(D);
          }
          return;
      }
      if (typeof B == "object" && B !== null)
        switch (B.$$typeof) {
          case Yn:
            if (q = Yi(b, D, B.render, q, Ce), Pr !== 0) {
              B = D.treeContext, D.treeContext = hr(B, 1, 0);
              try {
                jn(b, D, q);
              } finally {
                D.treeContext = B;
              }
            } else
              jn(b, D, q);
            return;
          case x:
            B = B.type, q = Xi(B, q), ba(b, D, B, q, Ce);
            return;
          case An:
            if (Ce = q.children, B = B._context, q = q.value, ke = B._currentValue, B._currentValue = q, Ne = le, le = q = { parent: Ne, depth: Ne === null ? 0 : Ne.depth + 1, context: B, parentValue: ke, value: q }, D.context = q, jn(b, D, Ce), b = le, b === null)
              throw Error(t(403));
            q = b.parentValue, b.context._currentValue = q === xe ? b.context._defaultValue : q, b = le = b.parent, D.context = b;
            return;
          case In:
            q = q.children, q = q(B._currentValue), jn(b, D, q);
            return;
          case L:
            Ce = B._init, B = Ce(B._payload), q = Xi(B, q), ba(b, D, B, q, void 0);
            return;
        }
      throw Error(t(
        130,
        B == null ? B : typeof B,
        ""
      ));
    }
  }
  function jn(b, D, B) {
    if (D.node = B, typeof B == "object" && B !== null) {
      switch (B.$$typeof) {
        case fn:
          ba(b, D, B.type, B.props, B.ref);
          return;
        case nn:
          throw Error(t(257));
        case L:
          var q = B._init;
          B = q(B._payload), jn(b, D, B);
          return;
      }
      if (ue(B)) {
        qi(b, D, B);
        return;
      }
      if (B === null || typeof B != "object" ? q = null : (q = De && B[De] || B["@@iterator"], q = typeof q == "function" ? q : null), q && (q = q.call(B))) {
        if (B = q.next(), !B.done) {
          var Ce = [];
          do
            Ce.push(B.value), B = q.next();
          while (!B.done);
          qi(b, D, Ce);
        }
        return;
      }
      throw b = Object.prototype.toString.call(B), Error(t(31, b === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : b));
    }
    typeof B == "string" ? (q = D.blockedSegment, q.lastPushedText = ve(D.blockedSegment.chunks, B, b.responseState, q.lastPushedText)) : typeof B == "number" && (q = D.blockedSegment, q.lastPushedText = ve(D.blockedSegment.chunks, "" + B, b.responseState, q.lastPushedText));
  }
  function qi(b, D, B) {
    for (var q = B.length, Ce = 0; Ce < q; Ce++) {
      var ke = D.treeContext;
      D.treeContext = hr(ke, q, Ce);
      try {
        Sa(b, D, B[Ce]);
      } finally {
        D.treeContext = ke;
      }
    }
  }
  function Sa(b, D, B) {
    var q = D.blockedSegment.formatContext, Ce = D.legacyContext, ke = D.context;
    try {
      return jn(b, D, B);
    } catch (St) {
      if (Xa(), typeof St == "object" && St !== null && typeof St.then == "function") {
        B = St;
        var Ne = D.blockedSegment, Ye = Fr(b, Ne.chunks.length, null, Ne.formatContext, Ne.lastPushedText, !0);
        Ne.children.push(Ye), Ne.lastPushedText = !1, b = Ga(b, D.node, D.blockedBoundary, Ye, D.abortSet, D.legacyContext, D.context, D.treeContext).ping, B.then(b, b), D.blockedSegment.formatContext = q, D.legacyContext = Ce, D.context = ke, Rn(ke);
      } else
        throw D.blockedSegment.formatContext = q, D.legacyContext = Ce, D.context = ke, Rn(ke), St;
    }
  }
  function dl(b) {
    var D = b.blockedBoundary;
    b = b.blockedSegment, b.status = 3, Zi(this, D, b);
  }
  function Gi(b, D, B) {
    var q = b.blockedBoundary;
    b.blockedSegment.status = 3, q === null ? (D.allPendingTasks--, D.status !== 2 && (D.status = 2, D.destination !== null && D.destination.close())) : (q.pendingTasks--, q.forceClientRender || (q.forceClientRender = !0, b = B === void 0 ? Error(t(432)) : B, q.errorDigest = D.onError(b), q.parentFlushed && D.clientRenderedBoundaries.push(q)), q.fallbackAbortableTasks.forEach(function(Ce) {
      return Gi(Ce, D, B);
    }), q.fallbackAbortableTasks.clear(), D.allPendingTasks--, D.allPendingTasks === 0 && (q = D.onAllReady, q()));
  }
  function Ea(b, D) {
    if (D.chunks.length === 0 && D.children.length === 1 && D.children[0].boundary === null) {
      var B = D.children[0];
      B.id = D.id, B.parentFlushed = !0, B.status === 1 && Ea(b, B);
    } else
      b.completedSegments.push(D);
  }
  function Zi(b, D, B) {
    if (D === null) {
      if (B.parentFlushed) {
        if (b.completedRootSegment !== null)
          throw Error(t(389));
        b.completedRootSegment = B;
      }
      b.pendingRootTasks--, b.pendingRootTasks === 0 && (b.onShellError = ta, D = b.onShellReady, D());
    } else
      D.pendingTasks--, D.forceClientRender || (D.pendingTasks === 0 ? (B.parentFlushed && B.status === 1 && Ea(D, B), D.parentFlushed && b.completedBoundaries.push(D), D.fallbackAbortableTasks.forEach(dl, b), D.fallbackAbortableTasks.clear()) : B.parentFlushed && B.status === 1 && (Ea(D, B), D.completedSegments.length === 1 && D.parentFlushed && b.partialBoundaries.push(D)));
    b.allPendingTasks--, b.allPendingTasks === 0 && (b = b.onAllReady, b());
  }
  function Qi(b) {
    if (b.status !== 2) {
      var D = le, B = ea.current;
      ea.current = ya;
      var q = va;
      va = b.responseState;
      try {
        var Ce = b.pingedTasks, ke;
        for (ke = 0; ke < Ce.length; ke++) {
          var Ne = Ce[ke], Ye = b, St = Ne.blockedSegment;
          if (St.status === 0) {
            Rn(Ne.context);
            try {
              jn(Ye, Ne, Ne.node), St.lastPushedText && St.textEmbedded && St.chunks.push(ge), Ne.abortSet.delete(Ne), St.status = 1, Zi(Ye, Ne.blockedBoundary, St);
            } catch (er) {
              if (Xa(), typeof er == "object" && er !== null && typeof er.then == "function") {
                var Ot = Ne.ping;
                er.then(Ot, Ot);
              } else {
                Ne.abortSet.delete(Ne), St.status = 4;
                var Pt = Ne.blockedBoundary, an = er, Un = zr(Ye, an);
                if (Pt === null ? xa(Ye, an) : (Pt.pendingTasks--, Pt.forceClientRender || (Pt.forceClientRender = !0, Pt.errorDigest = Un, Pt.parentFlushed && Ye.clientRenderedBoundaries.push(Pt))), Ye.allPendingTasks--, Ye.allPendingTasks === 0) {
                  var Jn = Ye.onAllReady;
                  Jn();
                }
              }
            } finally {
            }
          }
        }
        Ce.splice(0, ke), b.destination !== null && Qa(b, b.destination);
      } catch (er) {
        zr(b, er), xa(b, er);
      } finally {
        va = q, ea.current = B, B === ya && Rn(D);
      }
    }
  }
  function ka(b, D, B) {
    switch (B.parentFlushed = !0, B.status) {
      case 0:
        var q = B.id = b.nextSegmentId++;
        return B.lastPushedText = !1, B.textEmbedded = !1, b = b.responseState, r(D, gt), r(D, b.placeholderPrefix), b = s(q.toString(16)), r(D, b), o(D, Dt);
      case 1:
        B.status = 2;
        var Ce = !0;
        q = B.chunks;
        var ke = 0;
        B = B.children;
        for (var Ne = 0; Ne < B.length; Ne++) {
          for (Ce = B[Ne]; ke < Ce.index; ke++)
            r(D, q[ke]);
          Ce = wa(b, D, Ce);
        }
        for (; ke < q.length - 1; ke++)
          r(D, q[ke]);
        return ke < q.length && (Ce = o(D, q[ke])), Ce;
      default:
        throw Error(t(390));
    }
  }
  function wa(b, D, B) {
    var q = B.boundary;
    if (q === null)
      return ka(b, D, B);
    if (q.parentFlushed = !0, q.forceClientRender)
      q = q.errorDigest, o(D, zt), r(D, en), q && (r(D, ze), r(D, s(U(q))), r(D, cn)), o(D, Nt), ka(b, D, B);
    else if (0 < q.pendingTasks) {
      q.rootSegmentID = b.nextSegmentId++, 0 < q.completedSegments.length && b.partialBoundaries.push(q);
      var Ce = b.responseState, ke = Ce.nextSuspenseID++;
      Ce = h(Ce.boundaryPrefix + ke.toString(16)), q = q.id = Ce, Gt(D, b.responseState, q), ka(b, D, B);
    } else if (q.byteSize > b.progressiveChunkSize)
      q.rootSegmentID = b.nextSegmentId++, b.completedBoundaries.push(q), Gt(D, b.responseState, q.id), ka(b, D, B);
    else {
      if (o(D, qt), B = q.completedSegments, B.length !== 1)
        throw Error(t(391));
      wa(b, D, B[0]);
    }
    return o(D, ln);
  }
  function Ji(b, D, B) {
    return W(D, b.responseState, B.formatContext, B.id), wa(b, D, B), _e(D, B.formatContext);
  }
  function eo(b, D, B) {
    for (var q = B.completedSegments, Ce = 0; Ce < q.length; Ce++)
      to(b, D, B, q[Ce]);
    if (q.length = 0, b = b.responseState, q = B.id, B = B.rootSegmentID, r(D, b.startInlineScript), b.sentCompleteBoundaryFunction ? r(D, Mt) : (b.sentCompleteBoundaryFunction = !0, r(D, xt)), q === null)
      throw Error(t(395));
    return B = s(B.toString(16)), r(D, q), r(D, Qe), r(D, b.segmentPrefix), r(D, B), o(D, Kt);
  }
  function to(b, D, B, q) {
    if (q.status === 2)
      return !0;
    var Ce = q.id;
    if (Ce === -1) {
      if ((q.id = B.rootSegmentID) === -1)
        throw Error(t(392));
      return Ji(b, D, q);
    }
    return Ji(b, D, q), b = b.responseState, r(D, b.startInlineScript), b.sentCompleteSegmentFunction ? r(D, Ve) : (b.sentCompleteSegmentFunction = !0, r(D, Xe)), r(D, b.segmentPrefix), Ce = s(Ce.toString(16)), r(D, Ce), r(D, ot), r(D, b.placeholderPrefix), r(D, Ce), o(D, rt);
  }
  function Qa(b, D) {
    n = new Uint8Array(512), i = 0;
    try {
      var B = b.completedRootSegment;
      if (B !== null && b.pendingRootTasks === 0) {
        wa(b, D, B), b.completedRootSegment = null;
        var q = b.responseState.bootstrapChunks;
        for (B = 0; B < q.length - 1; B++)
          r(D, q[B]);
        B < q.length && o(D, q[B]);
      }
      var Ce = b.clientRenderedBoundaries, ke;
      for (ke = 0; ke < Ce.length; ke++) {
        var Ne = Ce[ke];
        q = D;
        var Ye = b.responseState, St = Ne.id, Ot = Ne.errorDigest, Pt = Ne.errorMessage, an = Ne.errorComponentStack;
        if (r(q, Ye.startInlineScript), Ye.sentClientRenderFunction ? r(q, _t) : (Ye.sentClientRenderFunction = !0, r(
          q,
          It
        )), St === null)
          throw Error(t(395));
        r(q, St), r(q, mt), (Ot || Pt || an) && (r(q, wt), r(q, s(Xt(Ot || "")))), (Pt || an) && (r(q, wt), r(q, s(Xt(Pt || "")))), an && (r(q, wt), r(q, s(Xt(an)))), o(q, Rt);
      }
      Ce.splice(0, ke);
      var Un = b.completedBoundaries;
      for (ke = 0; ke < Un.length; ke++)
        eo(b, D, Un[ke]);
      Un.splice(0, ke), d(D), n = new Uint8Array(512), i = 0;
      var Jn = b.partialBoundaries;
      for (ke = 0; ke < Jn.length; ke++) {
        var er = Jn[ke];
        e: {
          Ce = b, Ne = D;
          var Ta = er.completedSegments;
          for (Ye = 0; Ye < Ta.length; Ye++)
            if (!to(
              Ce,
              Ne,
              er,
              Ta[Ye]
            )) {
              Ye++, Ta.splice(0, Ye);
              var ro = !1;
              break e;
            }
          Ta.splice(0, Ye), ro = !0;
        }
        if (!ro) {
          b.destination = null, ke++, Jn.splice(0, ke);
          return;
        }
      }
      Jn.splice(0, ke);
      var Ja = b.completedBoundaries;
      for (ke = 0; ke < Ja.length; ke++)
        eo(b, D, Ja[ke]);
      Ja.splice(0, ke);
    } finally {
      d(D), b.allPendingTasks === 0 && b.pingedTasks.length === 0 && b.clientRenderedBoundaries.length === 0 && b.completedBoundaries.length === 0 && D.close();
    }
  }
  function no(b, D) {
    try {
      var B = b.abortableTasks;
      B.forEach(function(q) {
        return Gi(q, b, D);
      }), B.clear(), b.destination !== null && Qa(b, b.destination);
    } catch (q) {
      zr(b, q), xa(b, q);
    }
  }
  return Mu.renderToReadableStream = function(b, D) {
    return new Promise(function(B, q) {
      var Ce, ke, Ne = new Promise(function(Pt, an) {
        ke = Pt, Ce = an;
      }), Ye = qa(b, ae(D ? D.identifierPrefix : void 0, D ? D.nonce : void 0, D ? D.bootstrapScriptContent : void 0, D ? D.bootstrapScripts : void 0, D ? D.bootstrapModules : void 0), re(D ? D.namespaceURI : void 0), D ? D.progressiveChunkSize : void 0, D ? D.onError : void 0, ke, function() {
        var Pt = new ReadableStream({ type: "bytes", pull: function(an) {
          if (Ye.status === 1)
            Ye.status = 2, m(an, Ye.fatalError);
          else if (Ye.status !== 2 && Ye.destination === null) {
            Ye.destination = an;
            try {
              Qa(Ye, an);
            } catch (Un) {
              zr(Ye, Un), xa(Ye, Un);
            }
          }
        }, cancel: function() {
          no(Ye);
        } }, { highWaterMark: 0 });
        Pt.allReady = Ne, B(Pt);
      }, function(Pt) {
        Ne.catch(function() {
        }), q(Pt);
      }, Ce);
      if (D && D.signal) {
        var St = D.signal, Ot = function() {
          no(Ye, St.reason), St.removeEventListener("abort", Ot);
        };
        St.addEventListener("abort", Ot);
      }
      Qi(Ye);
    });
  }, Mu.version = "18.2.0", Mu;
}
var Ri = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var im;
function OE() {
  return im || (im = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ce, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function i(l) {
      {
        for (var f = arguments.length, S = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          S[A - 1] = arguments[A];
        o("warn", l, S);
      }
    }
    function r(l) {
      {
        for (var f = arguments.length, S = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          S[A - 1] = arguments[A];
        o("error", l, S);
      }
    }
    function o(l, f, S) {
      {
        var A = n.ReactDebugCurrentFrame, z = A.getStackAddendum();
        z !== "" && (f += "%s", S = S.concat([z]));
        var J = S.map(function(de) {
          return String(de);
        });
        J.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, J);
      }
    }
    function d(l) {
      l();
    }
    function u(l) {
    }
    function s(l, f) {
      h(l, f);
    }
    function h(l, f) {
      return l.push(f);
    }
    function m(l) {
    }
    function y(l) {
      l.push(null);
    }
    function v(l) {
      return l;
    }
    function w(l) {
      return l;
    }
    function E(l, f) {
      l.destroy(f);
    }
    function R(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, S = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return S;
      }
    }
    function C(l) {
      try {
        return g(l), !1;
      } catch {
        return !0;
      }
    }
    function g(l) {
      return "" + l;
    }
    function _(l, f) {
      if (C(l))
        return r("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, R(l)), g(l);
    }
    function P(l, f) {
      if (C(l))
        return r("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, R(l)), g(l);
    }
    function M(l) {
      if (C(l))
        return r("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", R(l)), g(l);
    }
    var N = Object.prototype.hasOwnProperty, T = 0, U = 1, V = 2, G = 3, ue = 4, Z = 5, $ = 6, H = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", j = H + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", F = new RegExp("^[" + H + "][" + j + "]*$"), X = {}, Q = {};
    function ae(l) {
      return N.call(Q, l) ? !0 : N.call(X, l) ? !1 : F.test(l) ? (Q[l] = !0, !0) : (X[l] = !0, r("Invalid attribute name: `%s`", l), !1);
    }
    function te(l, f, S, A) {
      if (S !== null && S.type === T)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (A)
            return !1;
          if (S !== null)
            return !S.acceptsBooleans;
          var z = l.toLowerCase().slice(0, 5);
          return z !== "data-" && z !== "aria-";
        }
        default:
          return !1;
      }
    }
    function re(l) {
      return ge.hasOwnProperty(l) ? ge[l] : null;
    }
    function ie(l, f, S, A, z, J, de) {
      this.acceptsBooleans = f === V || f === G || f === ue, this.attributeName = A, this.attributeNamespace = z, this.mustUseProperty = S, this.propertyName = l, this.type = f, this.sanitizeURL = J, this.removeEmptyString = de;
    }
    var ge = {}, ve = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ve.forEach(function(l) {
      ge[l] = new ie(
        l,
        T,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], S = l[1];
      ge[f] = new ie(
        f,
        U,
        !1,
        // mustUseProperty
        S,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      ge[l] = new ie(
        l,
        V,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      ge[l] = new ie(
        l,
        V,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      ge[l] = new ie(
        l,
        G,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ge[l] = new ie(
        l,
        G,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ge[l] = new ie(
        l,
        ue,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ge[l] = new ie(
        l,
        $,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      ge[l] = new ie(
        l,
        Z,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Se = /[\-\:]([a-z])/g, ye = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Se, ye);
      ge[f] = new ie(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Se, ye);
      ge[f] = new ie(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Se, ye);
      ge[f] = new ie(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      ge[l] = new ie(
        l,
        U,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ee = "xlinkHref";
    ge[ee] = new ie(
      "xlinkHref",
      U,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      ge[l] = new ie(
        l,
        U,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ee = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function He(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var we = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ee).forEach(function(l) {
      we.forEach(function(f) {
        Ee[He(f, l)] = Ee[l];
      });
    });
    var fe = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ae(l, f) {
      fe[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || r("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || r("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ne(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var $e = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Le = {}, Ke = new RegExp("^(aria)-[" + j + "]*$"), Ge = new RegExp("^(aria)[A-Z][" + j + "]*$");
    function et(l, f) {
      {
        if (N.call(Le, f) && Le[f])
          return !0;
        if (Ge.test(f)) {
          var S = "aria-" + f.slice(4).toLowerCase(), A = $e.hasOwnProperty(S) ? S : null;
          if (A == null)
            return r("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), Le[f] = !0, !0;
          if (f !== A)
            return r("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, A), Le[f] = !0, !0;
        }
        if (Ke.test(f)) {
          var z = f.toLowerCase(), J = $e.hasOwnProperty(z) ? z : null;
          if (J == null)
            return Le[f] = !0, !1;
          if (f !== J)
            return r("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, J), Le[f] = !0, !0;
        }
      }
      return !0;
    }
    function Ze(l, f) {
      {
        var S = [];
        for (var A in f) {
          var z = et(l, A);
          z || S.push(A);
        }
        var J = S.map(function(de) {
          return "`" + de + "`";
        }).join(", ");
        S.length === 1 ? r("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", J, l) : S.length > 1 && r("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", J, l);
      }
    }
    function Et(l, f) {
      ne(l, f) || Ze(l, f);
    }
    var qe = !1;
    function Be(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !qe && (qe = !0, l === "select" && f.multiple ? r("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : r("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var Ie = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Fe = function() {
    };
    {
      var lt = {}, Ue = /^on./, ct = /^on[^A-Z]/, ht = new RegExp("^(aria)-[" + j + "]*$"), gt = new RegExp("^(aria)[A-Z][" + j + "]*$");
      Fe = function(l, f, S, A) {
        if (N.call(lt, f) && lt[f])
          return !0;
        var z = f.toLowerCase();
        if (z === "onfocusin" || z === "onfocusout")
          return r("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), lt[f] = !0, !0;
        if (A != null) {
          var J = A.registrationNameDependencies, de = A.possibleRegistrationNames;
          if (J.hasOwnProperty(f))
            return !0;
          var Pe = de.hasOwnProperty(z) ? de[z] : null;
          if (Pe != null)
            return r("Invalid event handler property `%s`. Did you mean `%s`?", f, Pe), lt[f] = !0, !0;
          if (Ue.test(f))
            return r("Unknown event handler property `%s`. It will be ignored.", f), lt[f] = !0, !0;
        } else if (Ue.test(f))
          return ct.test(f) && r("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), lt[f] = !0, !0;
        if (ht.test(f) || gt.test(f))
          return !0;
        if (z === "innerhtml")
          return r("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), lt[f] = !0, !0;
        if (z === "aria")
          return r("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), lt[f] = !0, !0;
        if (z === "is" && S !== null && S !== void 0 && typeof S != "string")
          return r("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof S), lt[f] = !0, !0;
        if (typeof S == "number" && isNaN(S))
          return r("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), lt[f] = !0, !0;
        var We = re(f), tt = We !== null && We.type === T;
        if (Ie.hasOwnProperty(z)) {
          var st = Ie[z];
          if (st !== f)
            return r("Invalid DOM property `%s`. Did you mean `%s`?", f, st), lt[f] = !0, !0;
        } else if (!tt && f !== z)
          return r("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, z), lt[f] = !0, !0;
        return typeof S == "boolean" && te(f, S, We, !1) ? (S ? r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', S, f, f, S, f) : r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', S, f, f, S, f, f, f), lt[f] = !0, !0) : tt ? !0 : te(f, S, We, !1) ? (lt[f] = !0, !1) : ((S === "false" || S === "true") && We !== null && We.type === G && (r("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", S, f, S === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, S), lt[f] = !0), !0);
      };
    }
    var Dt = function(l, f, S) {
      {
        var A = [];
        for (var z in f) {
          var J = Fe(l, z, f[z], S);
          J || A.push(z);
        }
        var de = A.map(function(Pe) {
          return "`" + Pe + "`";
        }).join(", ");
        A.length === 1 ? r("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", de, l) : A.length > 1 && r("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", de, l);
      }
    };
    function qt(l, f, S) {
      ne(l, f) || Dt(l, f, S);
    }
    var Vt = function() {
    };
    {
      var kt = /^(?:webkit|moz|o)[A-Z]/, zt = /^-ms-/, ln = /-(.)/g, en = /;\s*$/, cn = {}, ze = {}, Nt = !1, Gt = !1, Bt = function(l) {
        return l.replace(ln, function(f, S) {
          return S.toUpperCase();
        });
      }, yn = function(l) {
        cn.hasOwnProperty(l) && cn[l] || (cn[l] = !0, r(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Bt(l.replace(zt, "ms-"))
        ));
      }, Lt = function(l) {
        cn.hasOwnProperty(l) && cn[l] || (cn[l] = !0, r("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, bn = function(l, f) {
        ze.hasOwnProperty(f) && ze[f] || (ze[f] = !0, r(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(en, "")));
      }, Mn = function(l, f) {
        Nt || (Nt = !0, r("`NaN` is an invalid value for the `%s` css style property.", l));
      }, mn = function(l, f) {
        Gt || (Gt = !0, r("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Vt = function(l, f) {
        l.indexOf("-") > -1 ? yn(l) : kt.test(l) ? Lt(l) : en.test(f) && bn(l, f), typeof f == "number" && (isNaN(f) ? Mn(l, f) : isFinite(f) || mn(l, f));
      };
    }
    var dn = Vt, jt = /["'&<>]/;
    function wn(l) {
      M(l);
      var f = "" + l, S = jt.exec(f);
      if (!S)
        return f;
      var A, z = "", J, de = 0;
      for (J = S.index; J < f.length; J++) {
        switch (f.charCodeAt(J)) {
          case 34:
            A = "&quot;";
            break;
          case 38:
            A = "&amp;";
            break;
          case 39:
            A = "&#x27;";
            break;
          case 60:
            A = "&lt;";
            break;
          case 62:
            A = "&gt;";
            break;
          default:
            continue;
        }
        de !== J && (z += f.substring(de, J)), de = J + 1, z += A;
      }
      return de !== J ? z + f.substring(de, J) : z;
    }
    function Ft(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : wn(l);
    }
    var pt = /([A-Z])/g, Tn = /^ms-/;
    function tn(l) {
      return l.replace(pt, "-$1").toLowerCase().replace(Tn, "-ms-");
    }
    var $t = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Sn = !1;
    function En(l) {
      !Sn && $t.test(l) && (Sn = !0, r("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var Dn = Array.isArray;
    function Ln(l) {
      return Dn(l);
    }
    var Me = "<script>", dt = "<\/script>", it = '<script src="', W = '<script type="module" src="', _e = '" async=""><\/script>';
    function Xe(l) {
      return M(l), ("" + l).replace(Ve, ot);
    }
    var Ve = /(<\/|<)(s)(cript)/gi, ot = function(l, f, S, A) {
      return "" + f + (S === "s" ? "\\u0073" : "\\u0053") + A;
    };
    function rt(l, f, S, A, z) {
      var J = l === void 0 ? "" : l, de = f === void 0 ? Me : '<script nonce="' + Ft(f) + '">', Pe = [];
      if (S !== void 0 && Pe.push(de, Xe(S), dt), A !== void 0)
        for (var We = 0; We < A.length; We++)
          Pe.push(it, Ft(A[We]), _e);
      if (z !== void 0)
        for (var tt = 0; tt < z.length; tt++)
          Pe.push(W, Ft(z[tt]), _e);
      return {
        bootstrapChunks: Pe,
        startInlineScript: de,
        placeholderPrefix: J + "P:",
        segmentPrefix: J + "S:",
        boundaryPrefix: J + "B:",
        idPrefix: J,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var xt = 0, Mt = 1, Qe = 2, Kt = 3, It = 4, _t = 5, mt = 6, Rt = 7;
    function wt(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Yt(l, f, S) {
      switch (f) {
        case "select":
          return wt(Mt, S.value != null ? S.value : S.defaultValue);
        case "svg":
          return wt(Qe, null);
        case "math":
          return wt(Kt, null);
        case "foreignObject":
          return wt(Mt, null);
        case "table":
          return wt(It, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return wt(_t, null);
        case "colgroup":
          return wt(Rt, null);
        case "tr":
          return wt(mt, null);
      }
      return l.insertionMode >= It || l.insertionMode === xt ? wt(Mt, null) : l;
    }
    var Xt = null;
    function sn(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function fn(l, f, S) {
      var A = l.idPrefix, z = ":" + A + "R" + f;
      return S > 0 && (z += "H" + S.toString(32)), z + ":";
    }
    function nn(l) {
      return Ft(l);
    }
    var Qt = "<!-- -->";
    function Cn(l, f, S, A) {
      return f === "" ? A : (A && l.push(Qt), l.push(nn(f)), !0);
    }
    function un(l, f, S, A) {
      S && A && l.push(Qt);
    }
    var An = /* @__PURE__ */ new Map();
    function In(l) {
      var f = An.get(l);
      if (f !== void 0)
        return f;
      var S = Ft(tn(l));
      return An.set(l, S), S;
    }
    var Yn = ' style="', Zn = ":", Xn = ";";
    function x(l, f, S) {
      if (typeof S != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var A = !0;
      for (var z in S)
        if (N.call(S, z)) {
          var J = S[z];
          if (!(J == null || typeof J == "boolean" || J === "")) {
            var de = void 0, Pe = void 0, We = z.indexOf("--") === 0;
            We ? (de = Ft(z), P(J, z), Pe = Ft(("" + J).trim())) : (dn(z, J), de = In(z), typeof J == "number" ? J !== 0 && !N.call(Ee, z) ? Pe = J + "px" : Pe = "" + J : (P(J, z), Pe = Ft(("" + J).trim()))), A ? (A = !1, l.push(Yn, de, Zn, Pe)) : l.push(Xn, de, Zn, Pe);
          }
        }
      A || l.push(Y);
    }
    var L = " ", I = '="', Y = '"', Te = '=""';
    function xe(l, f, S, A) {
      switch (S) {
        case "style": {
          x(l, f, A);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(S.length > 2 && (S[0] === "o" || S[0] === "O") && (S[1] === "n" || S[1] === "N"))
      ) {
        var z = re(S);
        if (z !== null) {
          switch (typeof A) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!z.acceptsBooleans)
                return;
          }
          var J = z.attributeName, de = J;
          switch (z.type) {
            case G:
              A && l.push(L, de, Te);
              return;
            case ue:
              A === !0 ? l.push(L, de, Te) : A === !1 || l.push(L, de, I, Ft(A), Y);
              return;
            case Z:
              isNaN(A) || l.push(L, de, I, Ft(A), Y);
              break;
            case $:
              !isNaN(A) && A >= 1 && l.push(L, de, I, Ft(A), Y);
              break;
            default:
              z.sanitizeURL && (_(A, J), A = "" + A, En(A)), l.push(L, de, I, Ft(A), Y);
          }
        } else if (ae(S)) {
          switch (typeof A) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Pe = S.toLowerCase().slice(0, 5);
              if (Pe !== "data-" && Pe !== "aria-")
                return;
            }
          }
          l.push(L, S, I, Ft(A), Y);
        }
      }
    }
    var De = ">", je = "/>";
    function at(l, f, S) {
      if (f != null) {
        if (S != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var A = f.__html;
        A != null && (M(A), l.push("" + A));
      }
    }
    var yt = !1, le = !1, se = !1, me = !1, Oe = !1, bt = !1, vn = !1;
    function Rn(l, f) {
      {
        var S = l[f];
        if (S != null) {
          var A = Ln(S);
          l.multiple && !A ? r("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && A && r("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function fr(l, f, S) {
      Ae("select", f), Rn(f, "value"), Rn(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !se && (r("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), se = !0), l.push(Vn("select"));
      var A = null, z = null;
      for (var J in f)
        if (N.call(f, J)) {
          var de = f[J];
          if (de == null)
            continue;
          switch (J) {
            case "children":
              A = de;
              break;
            case "dangerouslySetInnerHTML":
              z = de;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              xe(l, S, J, de);
              break;
          }
        }
      return l.push(De), at(l, z, A), A;
    }
    function Hn(l) {
      var f = "";
      return e.Children.forEach(l, function(S) {
        S != null && (f += S, !Oe && typeof S != "string" && typeof S != "number" && (Oe = !0, r("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var Ar = ' selected=""';
    function hr(l, f, S, A) {
      var z = A.selectedValue;
      l.push(Vn("option"));
      var J = null, de = null, Pe = null, We = null;
      for (var tt in f)
        if (N.call(f, tt)) {
          var st = f[tt];
          if (st == null)
            continue;
          switch (tt) {
            case "children":
              J = st;
              break;
            case "selected":
              Pe = st, vn || (r("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), vn = !0);
              break;
            case "dangerouslySetInnerHTML":
              We = st;
              break;
            case "value":
              de = st;
            default:
              xe(l, S, tt, st);
              break;
          }
        }
      if (z != null) {
        var Tt;
        if (de !== null ? (_(de, "value"), Tt = "" + de) : (We !== null && (bt || (bt = !0, r("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Tt = Hn(J)), Ln(z))
          for (var hn = 0; hn < z.length; hn++) {
            _(z[hn], "value");
            var $n = "" + z[hn];
            if ($n === Tt) {
              l.push(Ar);
              break;
            }
          }
        else
          _(z, "select.value"), "" + z === Tt && l.push(Ar);
      } else
        Pe && l.push(Ar);
      return l.push(De), at(l, We, J), J;
    }
    function Qr(l, f, S) {
      Ae("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !le && (r("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), le = !0), f.value !== void 0 && f.defaultValue !== void 0 && !yt && (r("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), yt = !0), l.push(Vn("input"));
      var A = null, z = null, J = null, de = null;
      for (var Pe in f)
        if (N.call(f, Pe)) {
          var We = f[Pe];
          if (We == null)
            continue;
          switch (Pe) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              de = We;
              break;
            case "defaultValue":
              z = We;
              break;
            case "checked":
              J = We;
              break;
            case "value":
              A = We;
              break;
            default:
              xe(l, S, Pe, We);
              break;
          }
        }
      return J !== null ? xe(l, S, "checked", J) : de !== null && xe(l, S, "checked", de), A !== null ? xe(l, S, "value", A) : z !== null && xe(l, S, "value", z), l.push(je), null;
    }
    function il(l, f, S) {
      Ae("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !me && (r("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), me = !0), l.push(Vn("textarea"));
      var A = null, z = null, J = null;
      for (var de in f)
        if (N.call(f, de)) {
          var Pe = f[de];
          if (Pe == null)
            continue;
          switch (de) {
            case "children":
              J = Pe;
              break;
            case "value":
              A = Pe;
              break;
            case "defaultValue":
              z = Pe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              xe(l, S, de, Pe);
              break;
          }
        }
      if (A === null && z !== null && (A = z), l.push(De), J != null) {
        if (r("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), A != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Ln(J)) {
          if (J.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          M(J[0]), A = "" + J[0];
        }
        M(J), A = "" + J;
      }
      return typeof A == "string" && A[0] === `
` && l.push(Jr), A !== null && (_(A, "value"), l.push(nn("" + A))), null;
    }
    function ol(l, f, S, A) {
      l.push(Vn(S));
      for (var z in f)
        if (N.call(f, z)) {
          var J = f[z];
          if (J == null)
            continue;
          switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(S + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              xe(l, A, z, J);
              break;
          }
        }
      return l.push(je), null;
    }
    function Ua(l, f, S) {
      l.push(Vn("menuitem"));
      for (var A in f)
        if (N.call(f, A)) {
          var z = f[A];
          if (z == null)
            continue;
          switch (A) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              xe(l, S, A, z);
              break;
          }
        }
      return l.push(De), null;
    }
    function ll(l, f, S) {
      l.push(Vn("title"));
      var A = null;
      for (var z in f)
        if (N.call(f, z)) {
          var J = f[z];
          if (J == null)
            continue;
          switch (z) {
            case "children":
              A = J;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              xe(l, S, z, J);
              break;
          }
        }
      l.push(De);
      {
        var de = Array.isArray(A) && A.length < 2 ? A[0] || null : A;
        Array.isArray(A) && A.length > 1 ? r("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : de != null && de.$$typeof != null ? r("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : de != null && typeof de != "string" && typeof de != "number" && r("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return A;
    }
    function Ka(l, f, S, A) {
      l.push(Vn(S));
      var z = null, J = null;
      for (var de in f)
        if (N.call(f, de)) {
          var Pe = f[de];
          if (Pe == null)
            continue;
          switch (de) {
            case "children":
              z = Pe;
              break;
            case "dangerouslySetInnerHTML":
              J = Pe;
              break;
            default:
              xe(l, A, de, Pe);
              break;
          }
        }
      return l.push(De), at(l, J, z), typeof z == "string" ? (l.push(nn(z)), null) : z;
    }
    function pr(l, f, S, A) {
      l.push(Vn(S));
      var z = null, J = null;
      for (var de in f)
        if (N.call(f, de)) {
          var Pe = f[de];
          if (Pe == null)
            continue;
          switch (de) {
            case "children":
              z = Pe;
              break;
            case "dangerouslySetInnerHTML":
              J = Pe;
              break;
            case "style":
              x(l, A, Pe);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ae(de) && typeof Pe != "function" && typeof Pe != "symbol" && l.push(L, de, I, Ft(Pe), Y);
              break;
          }
        }
      return l.push(De), at(l, J, z), z;
    }
    var Jr = `
`;
    function pa(l, f, S, A) {
      l.push(Vn(S));
      var z = null, J = null;
      for (var de in f)
        if (N.call(f, de)) {
          var Pe = f[de];
          if (Pe == null)
            continue;
          switch (de) {
            case "children":
              z = Pe;
              break;
            case "dangerouslySetInnerHTML":
              J = Pe;
              break;
            default:
              xe(l, A, de, Pe);
              break;
          }
        }
      if (l.push(De), J != null) {
        if (z != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof J != "object" || !("__html" in J))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var We = J.__html;
        We != null && (typeof We == "string" && We.length > 0 && We[0] === `
` ? l.push(Jr, We) : (M(We), l.push("" + We)));
      }
      return typeof z == "string" && z[0] === `
` && l.push(Jr), z;
    }
    var rn = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, yr = /* @__PURE__ */ new Map();
    function Vn(l) {
      var f = yr.get(l);
      if (f === void 0) {
        if (!rn.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, yr.set(l, f);
      }
      return f;
    }
    var Pr = "<!DOCTYPE html>";
    function vr(l, f, S, A, z) {
      switch (Et(f, S), Be(f, S), qt(f, S, null), !S.suppressContentEditableWarning && S.contentEditable && S.children != null && r("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), z.insertionMode !== Qe && z.insertionMode !== Kt && f.indexOf("-") === -1 && typeof S.is != "string" && f.toLowerCase() !== f && r("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return fr(l, S, A);
        case "option":
          return hr(l, S, A, z);
        case "textarea":
          return il(l, S, A);
        case "input":
          return Qr(l, S, A);
        case "menuitem":
          return Ua(l, S, A);
        case "title":
          return ll(l, S, A);
        case "listing":
        case "pre":
          return pa(l, S, f, A);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return ol(l, S, f, A);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(l, S, f, A);
        case "html":
          return z.insertionMode === xt && l.push(Pr), Ka(l, S, f, A);
        default:
          return f.indexOf("-") === -1 && typeof S.is != "string" ? Ka(l, S, f, A) : pr(l, S, f, A);
      }
    }
    var ma = "</", xr = ">";
    function Qn(l, f, S) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ma, f, xr);
      }
    }
    function Ya(l, f) {
      for (var S = f.bootstrapChunks, A = 0; A < S.length - 1; A++)
        s(l, S[A]);
      return A < S.length ? h(l, S[A]) : !0;
    }
    var Xa = '<template id="', ji = '"></template>';
    function Ui(l, f, S) {
      s(l, Xa), s(l, f.placeholderPrefix);
      var A = S.toString(16);
      return s(l, A), h(l, ji);
    }
    var Ki = "<!--$-->", sl = '<!--$?--><template id="', ul = '"></template>', ga = "<!--$!-->", ya = "<!--/$-->", va = "<template", ea = '"', cl = ' data-dgst="', ta = ' data-msg="', qa = ' data-stck="', Ga = "></template>";
    function Fr(l, f) {
      return h(l, Ki);
    }
    function zr(l, f, S) {
      if (s(l, sl), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, S), h(l, ul);
    }
    function xa(l, f, S, A, z) {
      var J;
      return J = h(l, ga), s(l, va), S && (s(l, cl), s(l, Ft(S)), s(l, ea)), A && (s(l, ta), s(l, Ft(A)), s(l, ea)), z && (s(l, qa), s(l, Ft(z)), s(l, ea)), J = h(l, Ga), J;
    }
    function Yi(l, f) {
      return h(l, ya);
    }
    function Za(l, f) {
      return h(l, ya);
    }
    function Xi(l, f) {
      return h(l, ya);
    }
    var ba = '<div hidden id="', jn = '">', qi = "</div>", Sa = '<svg aria-hidden="true" style="display:none" id="', dl = '">', Gi = "</svg>", Ea = '<math aria-hidden="true" style="display:none" id="', Zi = '">', Qi = "</math>", ka = '<table hidden id="', wa = '">', Ji = "</table>", eo = '<table hidden><tbody id="', to = '">', Qa = "</tbody></table>", no = '<table hidden><tr id="', b = '">', D = "</tr></table>", B = '<table hidden><colgroup id="', q = '">', Ce = "</colgroup></table>";
    function ke(l, f, S, A) {
      switch (S.insertionMode) {
        case xt:
        case Mt:
          return s(l, ba), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, jn);
        case Qe:
          return s(l, Sa), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, dl);
        case Kt:
          return s(l, Ea), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, Zi);
        case It:
          return s(l, ka), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, wa);
        case _t:
          return s(l, eo), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, to);
        case mt:
          return s(l, no), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, b);
        case Rt:
          return s(l, B), s(l, f.segmentPrefix), s(l, A.toString(16)), h(l, q);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ne(l, f) {
      switch (f.insertionMode) {
        case xt:
        case Mt:
          return h(l, qi);
        case Qe:
          return h(l, Gi);
        case Kt:
          return h(l, Qi);
        case It:
          return h(l, Ji);
        case _t:
          return h(l, Qa);
        case mt:
          return h(l, D);
        case Rt:
          return h(l, Ce);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ye = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", St = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Ot = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Pt = Ye + ';$RS("', an = '$RS("', Un = '","', Jn = '")<\/script>';
    function er(l, f, S) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, an) : (f.sentCompleteSegmentFunction = !0, s(l, Pt)), s(l, f.segmentPrefix);
      var A = S.toString(16);
      return s(l, A), s(l, Un), s(l, f.placeholderPrefix), s(l, A), h(l, Jn);
    }
    var Ta = St + ';$RC("', ro = '$RC("', Ja = '","', zc = '")<\/script>';
    function Bc(l, f, S, A) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, ro) : (f.sentCompleteBoundaryFunction = !0, s(l, Ta)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var z = A.toString(16);
      return s(l, S), s(l, Ja), s(l, f.segmentPrefix), s(l, z), h(l, zc);
    }
    var $c = Ot + ';$RX("', Ic = '$RX("', Hc = '"', Wc = ")<\/script>", fl = ",";
    function Vc(l, f, S, A, z, J) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Ic) : (f.sentClientRenderFunction = !0, s(l, $c)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, S), s(l, Hc), (A || z || J) && (s(l, fl), s(l, hl(A || ""))), (z || J) && (s(l, fl), s(l, hl(z || ""))), J && (s(l, fl), s(l, hl(J))), h(l, Wc);
    }
    var jc = /[<\u2028\u2029]/g;
    function hl(l) {
      var f = JSON.stringify(l);
      return f.replace(jc, function(S) {
        switch (S) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Uc(l, f) {
      var S = rt(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: S.bootstrapChunks,
        startInlineScript: S.startInlineScript,
        placeholderPrefix: S.placeholderPrefix,
        segmentPrefix: S.segmentPrefix,
        boundaryPrefix: S.boundaryPrefix,
        idPrefix: S.idPrefix,
        nextSuspenseID: S.nextSuspenseID,
        sentCompleteSegmentFunction: S.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: S.sentCompleteBoundaryFunction,
        sentClientRenderFunction: S.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function pl() {
      return {
        insertionMode: Mt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Ms(l, f, S, A) {
      return S.generateStaticMarkup ? (l.push(Ft(f)), !1) : Cn(l, f, S, A);
    }
    function _s(l, f, S, A) {
      if (!f.generateStaticMarkup)
        return un(l, f, S, A);
    }
    function ml(l, f) {
      return f.generateStaticMarkup ? !0 : Fr(l);
    }
    function or(l, f, S, A, z) {
      return f.generateStaticMarkup ? !0 : xa(l, f, S, A, z);
    }
    function Kc(l, f) {
      return f.generateStaticMarkup ? !0 : Yi(l);
    }
    function Ns(l, f) {
      return f.generateStaticMarkup ? !0 : Xi(l);
    }
    var tr = Object.assign, Fs = Symbol.for("react.element"), gl = Symbol.for("react.portal"), ao = Symbol.for("react.fragment"), io = Symbol.for("react.strict_mode"), oo = Symbol.for("react.profiler"), ei = Symbol.for("react.provider"), ti = Symbol.for("react.context"), ni = Symbol.for("react.forward_ref"), Ca = Symbol.for("react.suspense"), yl = Symbol.for("react.suspense_list"), vl = Symbol.for("react.memo"), lo = Symbol.for("react.lazy"), Yc = Symbol.for("react.scope"), zs = Symbol.for("react.debug_trace_mode"), Xc = Symbol.for("react.legacy_hidden"), qc = Symbol.for("react.default_value"), Bs = Symbol.iterator, $s = "@@iterator";
    function xn(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Bs && l[Bs] || l[$s];
      return typeof f == "function" ? f : null;
    }
    function ri(l, f, S) {
      var A = l.displayName;
      if (A)
        return A;
      var z = f.displayName || f.name || "";
      return z !== "" ? S + "(" + z + ")" : S;
    }
    function xl(l) {
      return l.displayName || "Context";
    }
    function gn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && r("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case ao:
          return "Fragment";
        case gl:
          return "Portal";
        case oo:
          return "Profiler";
        case io:
          return "StrictMode";
        case Ca:
          return "Suspense";
        case yl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ti:
            var f = l;
            return xl(f) + ".Consumer";
          case ei:
            var S = l;
            return xl(S._context) + ".Provider";
          case ni:
            return ri(l, l.render, "ForwardRef");
          case vl:
            var A = l.displayName || null;
            return A !== null ? A : gn(l.type) || "Memo";
          case lo: {
            var z = l, J = z._payload, de = z._init;
            try {
              return gn(de(J));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Aa = 0, bl, Sl, El, kl, wl, Is, Hs;
    function so() {
    }
    so.__reactDisabledLog = !0;
    function Tl() {
      {
        if (Aa === 0) {
          bl = console.log, Sl = console.info, El = console.warn, kl = console.error, wl = console.group, Is = console.groupCollapsed, Hs = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: so,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Aa++;
      }
    }
    function ai() {
      {
        if (Aa--, Aa === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: tr({}, l, {
              value: bl
            }),
            info: tr({}, l, {
              value: Sl
            }),
            warn: tr({}, l, {
              value: El
            }),
            error: tr({}, l, {
              value: kl
            }),
            group: tr({}, l, {
              value: wl
            }),
            groupCollapsed: tr({}, l, {
              value: Is
            }),
            groupEnd: tr({}, l, {
              value: Hs
            })
          });
        }
        Aa < 0 && r("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ii = n.ReactCurrentDispatcher, Pa;
    function oi(l, f, S) {
      {
        if (Pa === void 0)
          try {
            throw Error();
          } catch (z) {
            var A = z.stack.trim().match(/\n( *(at )?)/);
            Pa = A && A[1] || "";
          }
        return `
` + Pa + l;
      }
    }
    var li = !1, uo;
    {
      var Ws = typeof WeakMap == "function" ? WeakMap : Map;
      uo = new Ws();
    }
    function Cl(l, f) {
      if (!l || li)
        return "";
      {
        var S = uo.get(l);
        if (S !== void 0)
          return S;
      }
      var A;
      li = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var J;
      J = ii.current, ii.current = null, Tl();
      try {
        if (f) {
          var de = function() {
            throw Error();
          };
          if (Object.defineProperty(de.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(de, []);
            } catch (cr) {
              A = cr;
            }
            Reflect.construct(l, [], de);
          } else {
            try {
              de.call();
            } catch (cr) {
              A = cr;
            }
            l.call(de.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (cr) {
            A = cr;
          }
          l();
        }
      } catch (cr) {
        if (cr && A && typeof cr.stack == "string") {
          for (var Pe = cr.stack.split(`
`), We = A.stack.split(`
`), tt = Pe.length - 1, st = We.length - 1; tt >= 1 && st >= 0 && Pe[tt] !== We[st]; )
            st--;
          for (; tt >= 1 && st >= 0; tt--, st--)
            if (Pe[tt] !== We[st]) {
              if (tt !== 1 || st !== 1)
                do
                  if (tt--, st--, st < 0 || Pe[tt] !== We[st]) {
                    var Tt = `
` + Pe[tt].replace(" at new ", " at ");
                    return l.displayName && Tt.includes("<anonymous>") && (Tt = Tt.replace("<anonymous>", l.displayName)), typeof l == "function" && uo.set(l, Tt), Tt;
                  }
                while (tt >= 1 && st >= 0);
              break;
            }
        }
      } finally {
        li = !1, ii.current = J, ai(), Error.prepareStackTrace = z;
      }
      var hn = l ? l.displayName || l.name : "", $n = hn ? oi(hn) : "";
      return typeof l == "function" && uo.set(l, $n), $n;
    }
    function Al(l, f, S) {
      return Cl(l, !0);
    }
    function Pl(l, f, S) {
      return Cl(l, !1);
    }
    function Vs(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function La(l, f, S) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Cl(l, Vs(l));
      if (typeof l == "string")
        return oi(l);
      switch (l) {
        case Ca:
          return oi("Suspense");
        case yl:
          return oi("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ni:
            return Pl(l.render);
          case vl:
            return La(l.type, f, S);
          case lo: {
            var A = l, z = A._payload, J = A._init;
            try {
              return La(J(z), f, S);
            } catch {
            }
          }
        }
      return "";
    }
    var Ll = {}, co = n.ReactDebugCurrentFrame;
    function na(l) {
      if (l) {
        var f = l._owner, S = La(l.type, l._source, f ? f.type : null);
        co.setExtraStackFrame(S);
      } else
        co.setExtraStackFrame(null);
    }
    function Rl(l, f, S, A, z) {
      {
        var J = Function.call.bind(N);
        for (var de in l)
          if (J(l, de)) {
            var Pe = void 0;
            try {
              if (typeof l[de] != "function") {
                var We = Error((A || "React class") + ": " + S + " type `" + de + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[de] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw We.name = "Invariant Violation", We;
              }
              Pe = l[de](f, de, A, S, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              Pe = tt;
            }
            Pe && !(Pe instanceof Error) && (na(z), r("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", S, de, typeof Pe), na(null)), Pe instanceof Error && !(Pe.message in Ll) && (Ll[Pe.message] = !0, na(z), r("Failed %s type: %s", S, Pe.message), na(null));
          }
      }
    }
    var Dl;
    Dl = {};
    var Br = {};
    Object.freeze(Br);
    function js(l, f) {
      {
        var S = l.contextTypes;
        if (!S)
          return Br;
        var A = {};
        for (var z in S)
          A[z] = f[z];
        {
          var J = gn(l) || "Unknown";
          Rl(S, A, "context", J);
        }
        return A;
      }
    }
    function ra(l, f, S, A) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var z = gn(f) || "Unknown";
            Dl[z] || (Dl[z] = !0, r("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", z, z));
          }
          return S;
        }
        var J = l.getChildContext();
        for (var de in J)
          if (!(de in A))
            throw new Error((gn(f) || "Unknown") + '.getChildContext(): key "' + de + '" is not defined in childContextTypes.');
        {
          var Pe = gn(f) || "Unknown";
          Rl(A, J, "child context", Pe);
        }
        return tr({}, S, J);
      }
    }
    var aa;
    aa = {};
    var Ol = null, br = null;
    function fo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function ho(l) {
      l.context._currentValue2 = l.value;
    }
    function si(l, f) {
      if (l !== f) {
        fo(l);
        var S = l.parent, A = f.parent;
        if (S === null) {
          if (A !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (A === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          si(S, A);
        }
        ho(f);
      }
    }
    function Ml(l) {
      fo(l);
      var f = l.parent;
      f !== null && Ml(f);
    }
    function ui(l) {
      var f = l.parent;
      f !== null && ui(f), ho(l);
    }
    function Us(l, f) {
      fo(l);
      var S = l.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      S.depth === f.depth ? si(S, f) : Us(S, f);
    }
    function Ks(l, f) {
      var S = f.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === S.depth ? si(l, S) : Ks(l, S), ho(f);
    }
    function po(l) {
      var f = br, S = l;
      f !== S && (f === null ? ui(S) : S === null ? Ml(f) : f.depth === S.depth ? si(f, S) : f.depth > S.depth ? Us(f, S) : Ks(f, S), br = S);
    }
    function ci(l, f) {
      var S;
      S = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== aa && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = aa;
      var A = br, z = {
        parent: A,
        depth: A === null ? 0 : A.depth + 1,
        context: l,
        parentValue: S,
        value: f
      };
      return br = z, z;
    }
    function _l(l) {
      var f = br;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && r("The parent context is not the expected context. This is probably a bug in React.");
      {
        var S = f.parentValue;
        S === qc ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = S, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== aa && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = aa;
      }
      return br = f.parent;
    }
    function Gc() {
      return br;
    }
    function Ra(l) {
      var f = l._currentValue2;
      return f;
    }
    function mo(l) {
      return l._reactInternals;
    }
    function Nl(l, f) {
      l._reactInternals = f;
    }
    var go = {}, yo = {}, di, vo, Da, fi, xo, Oa, bo, So, Eo;
    {
      di = /* @__PURE__ */ new Set(), vo = /* @__PURE__ */ new Set(), Da = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), fi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set();
      var Ys = /* @__PURE__ */ new Set();
      Oa = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var S = f + "_" + l;
          Ys.has(S) || (Ys.add(S), r("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, xo = function(l, f) {
        if (f === void 0) {
          var S = gn(l) || "Component";
          fi.has(S) || (fi.add(S), r("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", S));
        }
      };
    }
    function Xs(l, f) {
      {
        var S = l.constructor, A = S && gn(S) || "ReactClass", z = A + "." + f;
        if (go[z])
          return;
        r(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, A), go[z] = !0;
      }
    }
    var qs = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, S) {
        var A = mo(l);
        A.queue === null ? Xs(l, "setState") : (A.queue.push(f), S != null && Oa(S, "setState"));
      },
      enqueueReplaceState: function(l, f, S) {
        var A = mo(l);
        A.replace = !0, A.queue = [f], S != null && Oa(S, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var S = mo(l);
        S.queue === null ? Xs(l, "forceUpdate") : f != null && Oa(f, "setState");
      }
    };
    function Zc(l, f, S, A, z) {
      var J = S(z, A);
      xo(f, J);
      var de = J == null ? A : tr({}, A, J);
      return de;
    }
    function Qc(l, f, S) {
      var A = Br, z = l.contextType;
      if ("contextType" in l) {
        var J = (
          // Allow null for conditional declaration
          z === null || z !== void 0 && z.$$typeof === ti && z._context === void 0
        );
        if (!J && !Eo.has(l)) {
          Eo.add(l);
          var de = "";
          z === void 0 ? de = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof z != "object" ? de = " However, it is set to a " + typeof z + "." : z.$$typeof === ei ? de = " Did you accidentally pass the Context.Provider instead?" : z._context !== void 0 ? de = " Did you accidentally pass the Context.Consumer instead?" : de = " However, it is set to an object with keys {" + Object.keys(z).join(", ") + "}.", r("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", gn(l) || "Component", de);
        }
      }
      typeof z == "object" && z !== null ? A = Ra(z) : A = S;
      var Pe = new l(f, A);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Pe.state === null || Pe.state === void 0)) {
          var We = gn(l) || "Component";
          di.has(We) || (di.add(We), r("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", We, Pe.state === null ? "null" : "undefined", We));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Pe.getSnapshotBeforeUpdate == "function") {
          var tt = null, st = null, Tt = null;
          if (typeof Pe.componentWillMount == "function" && Pe.componentWillMount.__suppressDeprecationWarning !== !0 ? tt = "componentWillMount" : typeof Pe.UNSAFE_componentWillMount == "function" && (tt = "UNSAFE_componentWillMount"), typeof Pe.componentWillReceiveProps == "function" && Pe.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? st = "componentWillReceiveProps" : typeof Pe.UNSAFE_componentWillReceiveProps == "function" && (st = "UNSAFE_componentWillReceiveProps"), typeof Pe.componentWillUpdate == "function" && Pe.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Tt = "componentWillUpdate" : typeof Pe.UNSAFE_componentWillUpdate == "function" && (Tt = "UNSAFE_componentWillUpdate"), tt !== null || st !== null || Tt !== null) {
            var hn = gn(l) || "Component", $n = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Da.has(hn) || (Da.add(hn), r(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, hn, $n, tt !== null ? `
  ` + tt : "", st !== null ? `
  ` + st : "", Tt !== null ? `
  ` + Tt : ""));
          }
        }
      }
      return Pe;
    }
    function Gs(l, f, S) {
      {
        var A = gn(f) || "Component", z = l.render;
        z || (f.prototype && typeof f.prototype.render == "function" ? r("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", A) : r("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", A)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && r("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", A), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && r("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", A), l.propTypes && r("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", A), l.contextType && r("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", A), l.contextTypes && r("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", A), f.contextType && f.contextTypes && !So.has(f) && (So.add(f), r("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", A)), typeof l.componentShouldUpdate == "function" && r("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", A), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && r("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", gn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && r("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", A), typeof l.componentDidReceiveProps == "function" && r("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", A), typeof l.componentWillRecieveProps == "function" && r("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", A), typeof l.UNSAFE_componentWillRecieveProps == "function" && r("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", A);
        var J = l.props !== S;
        l.props !== void 0 && J && r("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", A, A), l.defaultProps && r("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", A, A), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !vo.has(f) && (vo.add(f), r("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", gn(f))), typeof l.getDerivedStateFromProps == "function" && r("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof l.getDerivedStateFromError == "function" && r("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof f.getSnapshotBeforeUpdate == "function" && r("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", A);
        var de = l.state;
        de && (typeof de != "object" || Ln(de)) && r("%s.state: must be set to an object or null", A), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && r("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", A);
      }
    }
    function Jc(l, f) {
      var S = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var A = gn(l) || "Unknown";
          yo[A] || (i(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            A
          ), yo[A] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), S !== f.state && (r("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", gn(l) || "Component"), qs.enqueueReplaceState(f, f.state, null));
    }
    function ed(l, f, S, A) {
      if (l.queue !== null && l.queue.length > 0) {
        var z = l.queue, J = l.replace;
        if (l.queue = null, l.replace = !1, J && z.length === 1)
          f.state = z[0];
        else {
          for (var de = J ? z[0] : f.state, Pe = !0, We = J ? 1 : 0; We < z.length; We++) {
            var tt = z[We], st = typeof tt == "function" ? tt.call(f, de, S, A) : tt;
            st != null && (Pe ? (Pe = !1, de = tr({}, de, st)) : tr(de, st));
          }
          f.state = de;
        }
      } else
        l.queue = null;
    }
    function ko(l, f, S, A) {
      Gs(l, f, S);
      var z = l.state !== void 0 ? l.state : null;
      l.updater = qs, l.props = S, l.state = z;
      var J = {
        queue: [],
        replace: !1
      };
      Nl(l, J);
      var de = f.contextType;
      if (typeof de == "object" && de !== null ? l.context = Ra(de) : l.context = A, l.state === S) {
        var Pe = gn(f) || "Component";
        bo.has(Pe) || (bo.add(Pe), r("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Pe));
      }
      var We = f.getDerivedStateFromProps;
      typeof We == "function" && (l.state = Zc(l, f, We, z, S)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (Jc(f, l), ed(J, l, S, A));
    }
    var wo = {
      id: 1,
      overflow: ""
    };
    function td(l) {
      var f = l.overflow, S = l.id, A = S & ~nd(S);
      return A.toString(32) + f;
    }
    function Fl(l, f, S) {
      var A = l.id, z = l.overflow, J = To(A) - 1, de = A & ~(1 << J), Pe = S + 1, We = To(f) + J;
      if (We > 30) {
        var tt = J - J % 5, st = (1 << tt) - 1, Tt = (de & st).toString(32), hn = de >> tt, $n = J - tt, cr = To(f) + $n, vu = Pe << $n, xu = vu | hn, bu = Tt + z;
        return {
          id: 1 << cr | xu,
          overflow: bu
        };
      } else {
        var Ho = Pe << J, gy = Ho | de, yy = z;
        return {
          id: 1 << We | gy,
          overflow: yy
        };
      }
    }
    function To(l) {
      return 32 - rd(l);
    }
    function nd(l) {
      return 1 << To(l) - 1;
    }
    var rd = Math.clz32 ? Math.clz32 : Lr, ad = Math.log, id = Math.LN2;
    function Lr(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (ad(f) / id | 0) | 0;
    }
    function zl(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Co = typeof Object.is == "function" ? Object.is : zl, Ht = null, ia = null, oa = null, Jt = null, lr = !1, la = !1, Ao = 0, Bn = null, Rr = 0, sa = 25, Sr = !1, ua;
    function Dr() {
      if (Ht === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Sr && r("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Ht;
    }
    function od(l, f) {
      if (f === null)
        return r("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ua), !1;
      l.length !== f.length && r(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ua, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var S = 0; S < f.length && S < l.length; S++)
        if (!Co(l[S], f[S]))
          return !1;
      return !0;
    }
    function Zs() {
      if (Rr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Po() {
      return Jt === null ? oa === null ? (lr = !1, oa = Jt = Zs()) : (lr = !0, Jt = oa) : Jt.next === null ? (lr = !1, Jt = Jt.next = Zs()) : (lr = !0, Jt = Jt.next), Jt;
    }
    function Bl(l, f) {
      Ht = f, ia = l, Sr = !1, Ao = 0;
    }
    function ld(l, f, S, A) {
      for (; la; )
        la = !1, Ao = 0, Rr += 1, Jt = null, S = l(f, A);
      return hi(), S;
    }
    function Qs() {
      var l = Ao !== 0;
      return l;
    }
    function hi() {
      Sr = !1, Ht = null, ia = null, la = !1, oa = null, Rr = 0, Bn = null, Jt = null;
    }
    function sd(l) {
      return Sr && r("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Ra(l);
    }
    function Js(l) {
      return ua = "useContext", Dr(), Ra(l);
    }
    function Lo(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function ud(l) {
      return ua = "useState", eu(
        Lo,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function eu(l, f, S) {
      if (l !== Lo && (ua = "useReducer"), Ht = Dr(), Jt = Po(), lr) {
        var A = Jt.queue, z = A.dispatch;
        if (Bn !== null) {
          var J = Bn.get(A);
          if (J !== void 0) {
            Bn.delete(A);
            var de = Jt.memoizedState, Pe = J;
            do {
              var We = Pe.action;
              Sr = !0, de = l(de, We), Sr = !1, Pe = Pe.next;
            } while (Pe !== null);
            return Jt.memoizedState = de, [de, z];
          }
        }
        return [Jt.memoizedState, z];
      } else {
        Sr = !0;
        var tt;
        l === Lo ? tt = typeof f == "function" ? f() : f : tt = S !== void 0 ? S(f) : f, Sr = !1, Jt.memoizedState = tt;
        var st = Jt.queue = {
          last: null,
          dispatch: null
        }, Tt = st.dispatch = fd.bind(null, Ht, st);
        return [Jt.memoizedState, Tt];
      }
    }
    function tu(l, f) {
      Ht = Dr(), Jt = Po();
      var S = f === void 0 ? null : f;
      if (Jt !== null) {
        var A = Jt.memoizedState;
        if (A !== null && S !== null) {
          var z = A[1];
          if (od(S, z))
            return A[0];
        }
      }
      Sr = !0;
      var J = l();
      return Sr = !1, Jt.memoizedState = [J, S], J;
    }
    function cd(l) {
      Ht = Dr(), Jt = Po();
      var f = Jt.memoizedState;
      if (f === null) {
        var S = {
          current: l
        };
        return Object.seal(S), Jt.memoizedState = S, S;
      } else
        return f;
    }
    function dd(l, f) {
      ua = "useLayoutEffect", r("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function fd(l, f, S) {
      if (Rr >= sa)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Ht) {
        la = !0;
        var A = {
          action: S,
          next: null
        };
        Bn === null && (Bn = /* @__PURE__ */ new Map());
        var z = Bn.get(f);
        if (z === void 0)
          Bn.set(f, A);
        else {
          for (var J = z; J.next !== null; )
            J = J.next;
          J.next = A;
        }
      }
    }
    function hd(l, f) {
      return tu(function() {
        return l;
      }, f);
    }
    function pd(l, f, S) {
      return Dr(), f(l._source);
    }
    function md(l, f, S) {
      if (S === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return S();
    }
    function gd(l) {
      return Dr(), l;
    }
    function Ro() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function nu() {
      return Dr(), [!1, Ro];
    }
    function $l() {
      var l = ia, f = td(l.treeContext), S = mi;
      if (S === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var A = Ao++;
      return fn(S, f, A);
    }
    function pi() {
    }
    var ru = {
      readContext: sd,
      useContext: Js,
      useMemo: tu,
      useReducer: eu,
      useRef: cd,
      useState: ud,
      useInsertionEffect: pi,
      useLayoutEffect: dd,
      useCallback: hd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: pi,
      // Effects are not run in the server environment.
      useEffect: pi,
      // Debugging effect
      useDebugValue: pi,
      useDeferredValue: gd,
      useTransition: nu,
      useId: $l,
      // Subscriptions are not setup in a server environment.
      useMutableSource: pd,
      useSyncExternalStore: md
    }, mi = null;
    function Do(l) {
      mi = l;
    }
    function Il(l) {
      try {
        var f = "", S = l;
        do {
          switch (S.tag) {
            case 0:
              f += oi(S.type, null, null);
              break;
            case 1:
              f += Pl(S.type, null, null);
              break;
            case 2:
              f += Al(S.type, null, null);
              break;
          }
          S = S.parent;
        } while (S);
        return f;
      } catch (A) {
        return `
Error generating stack: ` + A.message + `
` + A.stack;
      }
    }
    var $r = n.ReactCurrentDispatcher, Oo = n.ReactDebugCurrentFrame, Mo = 0, ca = 1, au = 2, Hl = 3, da = 4, yd = 0, iu = 1, Er = 2, vd = 12800;
    function xd(l) {
      return console.error(l), null;
    }
    function gi() {
    }
    function Wl(l, f, S, A, z, J, de, Pe, We) {
      var tt = [], st = /* @__PURE__ */ new Set(), Tt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: A === void 0 ? vd : A,
        status: yd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: st,
        pingedTasks: tt,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: z === void 0 ? xd : z,
        onAllReady: J === void 0 ? gi : J,
        onShellReady: de === void 0 ? gi : de,
        onShellError: Pe === void 0 ? gi : Pe,
        onFatalError: We === void 0 ? gi : We
      }, hn = Ir(
        Tt,
        0,
        null,
        S,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      hn.parentFlushed = !0;
      var $n = yi(Tt, l, null, hn, st, Br, Ol, wo);
      return tt.push($n), Tt;
    }
    function _o(l, f) {
      var S = l.pingedTasks;
      S.push(f), S.length === 1 && d(function() {
        return gu(l);
      });
    }
    function Or(l, f) {
      return {
        id: Xt,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function yi(l, f, S, A, z, J, de, Pe) {
      l.allPendingTasks++, S === null ? l.pendingRootTasks++ : S.pendingTasks++;
      var We = {
        node: f,
        ping: function() {
          return _o(l, We);
        },
        blockedBoundary: S,
        blockedSegment: A,
        abortSet: z,
        legacyContext: J,
        context: de,
        treeContext: Pe
      };
      return We.componentStack = null, z.add(We), We;
    }
    function Ir(l, f, S, A, z, J) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: A,
        boundary: S,
        lastPushedText: z,
        textEmbedded: J
      };
    }
    var kr = null;
    function Vl() {
      return kr === null || kr.componentStack === null ? "" : Il(kr.componentStack);
    }
    function sr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Ma(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function jl(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function ur(l) {
      l.componentStack === null ? r("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Hr = null;
    function Ul(l, f) {
      {
        var S;
        typeof f == "string" ? S = f : f && typeof f.message == "string" ? S = f.message : S = String(f);
        var A = Hr || Vl();
        Hr = null, l.errorMessage = S, l.errorComponentStack = A;
      }
    }
    function vi(l, f) {
      var S = l.onError(f);
      if (S != null && typeof S != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
      return S;
    }
    function No(l, f) {
      var S = l.onShellError;
      S(f);
      var A = l.onFatalError;
      A(f), l.destination !== null ? (l.status = Er, E(l.destination, f)) : (l.status = iu, l.fatalError = f);
    }
    function ou(l, f, S) {
      sr(f, "Suspense");
      var A = f.blockedBoundary, z = f.blockedSegment, J = S.fallback, de = S.children, Pe = /* @__PURE__ */ new Set(), We = Or(l, Pe), tt = z.chunks.length, st = Ir(
        l,
        tt,
        We,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      z.children.push(st), z.lastPushedText = !1;
      var Tt = Ir(
        l,
        0,
        null,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Tt.parentFlushed = !0, f.blockedBoundary = We, f.blockedSegment = Tt;
      try {
        if (Fo(l, f, de), _s(Tt.chunks, l.responseState, Tt.lastPushedText, Tt.textEmbedded), Tt.status = ca, Si(We, Tt), We.pendingTasks === 0) {
          ur(f);
          return;
        }
      } catch ($n) {
        Tt.status = da, We.forceClientRender = !0, We.errorDigest = vi(l, $n), Ul(We, $n);
      } finally {
        f.blockedBoundary = A, f.blockedSegment = z;
      }
      var hn = yi(l, J, A, st, Pe, f.legacyContext, f.context, f.treeContext);
      hn.componentStack = f.componentStack, l.pingedTasks.push(hn), ur(f);
    }
    function lu(l, f, S, A) {
      sr(f, S);
      var z = f.blockedSegment, J = vr(z.chunks, S, A, l.responseState, z.formatContext);
      z.lastPushedText = !1;
      var de = z.formatContext;
      z.formatContext = Yt(de, S, A), Fo(l, f, J), z.formatContext = de, Qn(z.chunks, S), z.lastPushedText = !1, ur(f);
    }
    function bd(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function Kl(l, f, S, A, z) {
      var J = {};
      Bl(f, J);
      var de = S(A, z);
      return ld(S, A, de, z);
    }
    function xi(l, f, S, A, z) {
      var J = S.render();
      S.props !== z && (Gl || r("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", gn(A) || "a component"), Gl = !0);
      {
        var de = A.childContextTypes;
        if (de != null) {
          var Pe = f.legacyContext, We = ra(S, A, Pe, de);
          f.legacyContext = We, rr(l, f, J), f.legacyContext = Pe;
          return;
        }
      }
      rr(l, f, J);
    }
    function su(l, f, S, A) {
      jl(f, S);
      var z = js(S, f.legacyContext), J = Qc(S, A, z);
      ko(J, S, A, z), xi(l, f, J, S, A), ur(f);
    }
    var Yl = {}, bi = {}, Xl = {}, ql = {}, Gl = !1, uu = !1, cu = !1, Zl = !1;
    function Sd(l, f, S, A) {
      var z;
      if (z = js(S, f.legacyContext), Ma(f, S), S.prototype && typeof S.prototype.render == "function") {
        var J = gn(S) || "Unknown";
        Yl[J] || (r("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", J, J), Yl[J] = !0);
      }
      var de = Kl(l, f, S, A, z), Pe = Qs();
      if (typeof de == "object" && de !== null && typeof de.render == "function" && de.$$typeof === void 0) {
        var We = gn(S) || "Unknown";
        bi[We] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", We, We, We), bi[We] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof de == "object" && de !== null && typeof de.render == "function" && de.$$typeof === void 0
      ) {
        {
          var tt = gn(S) || "Unknown";
          bi[tt] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", tt, tt, tt), bi[tt] = !0);
        }
        ko(de, S, A, z), xi(l, f, de, S, A);
      } else if (Ed(S), Pe) {
        var st = f.treeContext, Tt = 1, hn = 0;
        f.treeContext = Fl(st, Tt, hn);
        try {
          rr(l, f, de);
        } finally {
          f.treeContext = st;
        }
      } else
        rr(l, f, de);
      ur(f);
    }
    function Ed(l) {
      {
        if (l && l.childContextTypes && r("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = gn(l) || "Unknown";
          ql[f] || (r("%s: Function components do not support getDerivedStateFromProps.", f), ql[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var S = gn(l) || "Unknown";
          Xl[S] || (r("%s: Function components do not support contextType.", S), Xl[S] = !0);
        }
      }
    }
    function du(l, f) {
      if (l && l.defaultProps) {
        var S = tr({}, f), A = l.defaultProps;
        for (var z in A)
          S[z] === void 0 && (S[z] = A[z]);
        return S;
      }
      return f;
    }
    function kd(l, f, S, A, z) {
      Ma(f, S.render);
      var J = Kl(l, f, S.render, A, z), de = Qs();
      if (de) {
        var Pe = f.treeContext, We = 1, tt = 0;
        f.treeContext = Fl(Pe, We, tt);
        try {
          rr(l, f, J);
        } finally {
          f.treeContext = Pe;
        }
      } else
        rr(l, f, J);
      ur(f);
    }
    function wd(l, f, S, A, z) {
      var J = S.type, de = du(J, A);
      Jl(l, f, J, de, z);
    }
    function Ql(l, f, S, A) {
      S._context === void 0 ? S !== S.Consumer && (Zl || (Zl = !0, r("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var z = A.children;
      typeof z != "function" && r("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var J = Ra(S), de = z(J);
      rr(l, f, de);
    }
    function Td(l, f, S, A) {
      var z = S._context, J = A.value, de = A.children, Pe;
      Pe = f.context, f.context = ci(z, J), rr(l, f, de), f.context = _l(z), Pe !== f.context && r("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function nr(l, f, S, A, z) {
      sr(f, "Lazy");
      var J = S._payload, de = S._init, Pe = de(J), We = du(Pe, A);
      Jl(l, f, Pe, We, z), ur(f);
    }
    function Jl(l, f, S, A, z) {
      if (typeof S == "function")
        if (bd(S)) {
          su(l, f, S, A);
          return;
        } else {
          Sd(l, f, S, A);
          return;
        }
      if (typeof S == "string") {
        lu(l, f, S, A);
        return;
      }
      switch (S) {
        case Xc:
        case zs:
        case io:
        case oo:
        case ao: {
          rr(l, f, A.children);
          return;
        }
        case yl: {
          sr(f, "SuspenseList"), rr(l, f, A.children), ur(f);
          return;
        }
        case Yc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ca: {
          ou(l, f, A);
          return;
        }
      }
      if (typeof S == "object" && S !== null)
        switch (S.$$typeof) {
          case ni: {
            kd(l, f, S, A, z);
            return;
          }
          case vl: {
            wd(l, f, S, A, z);
            return;
          }
          case ei: {
            Td(l, f, S, A);
            return;
          }
          case ti: {
            Ql(l, f, S, A);
            return;
          }
          case lo: {
            nr(l, f, S, A);
            return;
          }
        }
      var J = "";
      throw (S === void 0 || typeof S == "object" && S !== null && Object.keys(S).length === 0) && (J += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (S == null ? S : typeof S) + "." + J));
    }
    function fu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (uu || r("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), uu = !0), l.entries === f && (cu || r("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), cu = !0);
    }
    function rr(l, f, S) {
      try {
        return es(l, f, S);
      } catch (A) {
        throw typeof A == "object" && A !== null && typeof A.then == "function" || (Hr = Hr !== null ? Hr : Vl()), A;
      }
    }
    function es(l, f, S) {
      if (f.node = S, typeof S == "object" && S !== null) {
        switch (S.$$typeof) {
          case Fs: {
            var A = S, z = A.type, J = A.props, de = A.ref;
            Jl(l, f, z, J, de);
            return;
          }
          case gl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case lo: {
            var Pe = S, We = Pe._payload, tt = Pe._init, st;
            try {
              st = tt(We);
            } catch (Ho) {
              throw typeof Ho == "object" && Ho !== null && typeof Ho.then == "function" && sr(f, "Lazy"), Ho;
            }
            rr(l, f, st);
            return;
          }
        }
        if (Ln(S)) {
          hu(l, f, S);
          return;
        }
        var Tt = xn(S);
        if (Tt) {
          fu(S, Tt);
          var hn = Tt.call(S);
          if (hn) {
            var $n = hn.next();
            if (!$n.done) {
              var cr = [];
              do
                cr.push($n.value), $n = hn.next();
              while (!$n.done);
              hu(l, f, cr);
              return;
            }
            return;
          }
        }
        var vu = Object.prototype.toString.call(S);
        throw new Error("Objects are not valid as a React child (found: " + (vu === "[object Object]" ? "object with keys {" + Object.keys(S).join(", ") + "}" : vu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof S == "string") {
        var xu = f.blockedSegment;
        xu.lastPushedText = Ms(f.blockedSegment.chunks, S, l.responseState, xu.lastPushedText);
        return;
      }
      if (typeof S == "number") {
        var bu = f.blockedSegment;
        bu.lastPushedText = Ms(f.blockedSegment.chunks, "" + S, l.responseState, bu.lastPushedText);
        return;
      }
      typeof S == "function" && r("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hu(l, f, S) {
      for (var A = S.length, z = 0; z < A; z++) {
        var J = f.treeContext;
        f.treeContext = Fl(J, A, z);
        try {
          Fo(l, f, S[z]);
        } finally {
          f.treeContext = J;
        }
      }
    }
    function Cd(l, f, S) {
      var A = f.blockedSegment, z = A.chunks.length, J = Ir(
        l,
        z,
        null,
        A.formatContext,
        // Adopt the parent segment's leading text embed
        A.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      A.children.push(J), A.lastPushedText = !1;
      var de = yi(l, f.node, f.blockedBoundary, J, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (de.componentStack = f.componentStack.parent);
      var Pe = de.ping;
      S.then(Pe, Pe);
    }
    function Fo(l, f, S) {
      var A = f.blockedSegment.formatContext, z = f.legacyContext, J = f.context, de = null;
      de = f.componentStack;
      try {
        return rr(l, f, S);
      } catch (Pe) {
        if (hi(), typeof Pe == "object" && Pe !== null && typeof Pe.then == "function") {
          Cd(l, f, Pe), f.blockedSegment.formatContext = A, f.legacyContext = z, f.context = J, po(J), f.componentStack = de;
          return;
        } else
          throw f.blockedSegment.formatContext = A, f.legacyContext = z, f.context = J, po(J), f.componentStack = de, Pe;
      }
    }
    function zo(l, f, S, A) {
      var z = vi(l, A);
      if (f === null ? No(l, A) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = z, Ul(f, A), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var J = l.onAllReady;
        J();
      }
    }
    function pu(l) {
      var f = this, S = l.blockedBoundary, A = l.blockedSegment;
      A.status = Hl, Ei(f, S, A);
    }
    function mu(l, f, S) {
      var A = l.blockedBoundary, z = l.blockedSegment;
      if (z.status = Hl, A === null)
        f.allPendingTasks--, f.status !== Er && (f.status = Er, f.destination !== null && y(f.destination));
      else {
        if (A.pendingTasks--, !A.forceClientRender) {
          A.forceClientRender = !0;
          var J = S === void 0 ? new Error("The render was aborted by the server without a reason.") : S;
          A.errorDigest = f.onError(J);
          {
            var de = "The server did not finish this Suspense boundary: ";
            J && typeof J.message == "string" ? J = de + J.message : J = de + String(J);
            var Pe = kr;
            kr = l;
            try {
              Ul(A, J);
            } finally {
              kr = Pe;
            }
          }
          A.parentFlushed && f.clientRenderedBoundaries.push(A);
        }
        if (A.fallbackAbortableTasks.forEach(function(tt) {
          return mu(tt, f, S);
        }), A.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var We = f.onAllReady;
          We();
        }
      }
    }
    function Si(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var S = f.children[0];
        S.id = f.id, S.parentFlushed = !0, S.status === ca && Si(l, S);
      } else {
        var A = l.completedSegments;
        A.push(f);
      }
    }
    function Ei(l, f, S) {
      if (f === null) {
        if (S.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = S;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = gi;
          var A = l.onShellReady;
          A();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          S.parentFlushed && S.status === ca && Si(f, S), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(pu, l), f.fallbackAbortableTasks.clear();
        else if (S.parentFlushed && S.status === ca) {
          Si(f, S);
          var z = f.completedSegments;
          z.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var J = l.onAllReady;
        J();
      }
    }
    function Bo(l, f) {
      var S = f.blockedSegment;
      if (S.status === Mo) {
        po(f.context);
        var A = null;
        A = kr, kr = f;
        try {
          rr(l, f, f.node), _s(S.chunks, l.responseState, S.lastPushedText, S.textEmbedded), f.abortSet.delete(f), S.status = ca, Ei(l, f.blockedBoundary, S);
        } catch (J) {
          if (hi(), typeof J == "object" && J !== null && typeof J.then == "function") {
            var z = f.ping;
            J.then(z, z);
          } else
            f.abortSet.delete(f), S.status = da, zo(l, f.blockedBoundary, S, J);
        } finally {
          kr = A;
        }
      }
    }
    function gu(l) {
      if (l.status !== Er) {
        var f = Gc(), S = $r.current;
        $r.current = ru;
        var A;
        A = Oo.getCurrentStack, Oo.getCurrentStack = Vl;
        var z = mi;
        Do(l.responseState);
        try {
          var J = l.pingedTasks, de;
          for (de = 0; de < J.length; de++) {
            var Pe = J[de];
            Bo(l, Pe);
          }
          J.splice(0, de), l.destination !== null && Io(l, l.destination);
        } catch (We) {
          vi(l, We), No(l, We);
        } finally {
          Do(z), $r.current = S, Oo.getCurrentStack = A, S === ru && po(f);
        }
      }
    }
    function ki(l, f, S) {
      switch (S.parentFlushed = !0, S.status) {
        case Mo: {
          var A = S.id = l.nextSegmentId++;
          return S.lastPushedText = !1, S.textEmbedded = !1, Ui(f, l.responseState, A);
        }
        case ca: {
          S.status = au;
          for (var z = !0, J = S.chunks, de = 0, Pe = S.children, We = 0; We < Pe.length; We++) {
            for (var tt = Pe[We]; de < tt.index; de++)
              s(f, J[de]);
            z = wi(l, f, tt);
          }
          for (; de < J.length - 1; de++)
            s(f, J[de]);
          return de < J.length && (z = h(f, J[de])), z;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function wi(l, f, S) {
      var A = S.boundary;
      if (A === null)
        return ki(l, f, S);
      if (A.parentFlushed = !0, A.forceClientRender)
        return or(f, l.responseState, A.errorDigest, A.errorMessage, A.errorComponentStack), ki(l, f, S), Ns(f, l.responseState);
      if (A.pendingTasks > 0) {
        A.rootSegmentID = l.nextSegmentId++, A.completedSegments.length > 0 && l.partialBoundaries.push(A);
        var z = A.id = sn(l.responseState);
        return zr(f, l.responseState, z), ki(l, f, S), Za(f, l.responseState);
      } else {
        if (A.byteSize > l.progressiveChunkSize)
          return A.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(A), zr(f, l.responseState, A.id), ki(l, f, S), Za(f, l.responseState);
        ml(f, l.responseState);
        var J = A.completedSegments;
        if (J.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var de = J[0];
        return wi(l, f, de), Kc(f, l.responseState);
      }
    }
    function Ad(l, f, S) {
      return Vc(f, l.responseState, S.id, S.errorDigest, S.errorMessage, S.errorComponentStack);
    }
    function ts(l, f, S) {
      return ke(f, l.responseState, S.formatContext, S.id), wi(l, f, S), Ne(f, S.formatContext);
    }
    function $o(l, f, S) {
      for (var A = S.completedSegments, z = 0; z < A.length; z++) {
        var J = A[z];
        yu(l, f, S, J);
      }
      return A.length = 0, Bc(f, l.responseState, S.id, S.rootSegmentID);
    }
    function Pd(l, f, S) {
      for (var A = S.completedSegments, z = 0; z < A.length; z++) {
        var J = A[z];
        if (!yu(l, f, S, J))
          return z++, A.splice(0, z), !1;
      }
      return A.splice(0, z), !0;
    }
    function yu(l, f, S, A) {
      if (A.status === au)
        return !0;
      var z = A.id;
      if (z === -1) {
        var J = A.id = S.rootSegmentID;
        if (J === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ts(l, f, A);
      } else
        return ts(l, f, A), er(f, l.responseState, z);
    }
    function Io(l, f) {
      try {
        var S = l.completedRootSegment;
        S !== null && l.pendingRootTasks === 0 && (wi(l, f, S), l.completedRootSegment = null, Ya(f, l.responseState));
        var A = l.clientRenderedBoundaries, z;
        for (z = 0; z < A.length; z++) {
          var J = A[z];
          if (!Ad(l, f, J)) {
            l.destination = null, z++, A.splice(0, z);
            return;
          }
        }
        A.splice(0, z);
        var de = l.completedBoundaries;
        for (z = 0; z < de.length; z++) {
          var Pe = de[z];
          if (!$o(l, f, Pe)) {
            l.destination = null, z++, de.splice(0, z);
            return;
          }
        }
        de.splice(0, z);
        var We = l.partialBoundaries;
        for (z = 0; z < We.length; z++) {
          var tt = We[z];
          if (!Pd(l, f, tt)) {
            l.destination = null, z++, We.splice(0, z);
            return;
          }
        }
        We.splice(0, z);
        var st = l.completedBoundaries;
        for (z = 0; z < st.length; z++) {
          var Tt = st[z];
          if (!$o(l, f, Tt)) {
            l.destination = null, z++, st.splice(0, z);
            return;
          }
        }
        st.splice(0, z);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && r("There was still abortable task at the root when we closed. This is a bug in React."), y(f));
      }
    }
    function Ld(l) {
      d(function() {
        return gu(l);
      });
    }
    function c(l, f) {
      if (l.status === iu) {
        l.status = Er, E(f, l.fatalError);
        return;
      }
      if (l.status !== Er && l.destination === null) {
        l.destination = f;
        try {
          Io(l, f);
        } catch (S) {
          vi(l, S), No(l, S);
        }
      }
    }
    function p(l, f) {
      try {
        var S = l.abortableTasks;
        S.forEach(function(A) {
          return mu(A, l, f);
        }), S.clear(), l.destination !== null && Io(l, l.destination);
      } catch (A) {
        vi(l, A), No(l, A);
      }
    }
    function k() {
    }
    function O(l, f, S, A) {
      var z = !1, J = null, de = "", Pe = {
        push: function(Tt) {
          return Tt !== null && (de += Tt), !0;
        },
        destroy: function(Tt) {
          z = !0, J = Tt;
        }
      }, We = !1;
      function tt() {
        We = !0;
      }
      var st = Wl(l, Uc(S, f ? f.identifierPrefix : void 0), pl(), 1 / 0, k, void 0, tt, void 0, void 0);
      if (Ld(st), p(st, A), c(st, Pe), z)
        throw J;
      if (!We)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return de;
    }
    function K(l, f) {
      return O(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function oe(l, f) {
      return O(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function pe() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Re() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Ri.renderToNodeStream = pe, Ri.renderToStaticMarkup = oe, Ri.renderToStaticNodeStream = Re, Ri.renderToString = K, Ri.version = t;
  }()), Ri;
}
var _u = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var om;
function ME() {
  return om || (om = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ce, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function i(c) {
      {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), O = 1; O < p; O++)
          k[O - 1] = arguments[O];
        o("warn", c, k);
      }
    }
    function r(c) {
      {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), O = 1; O < p; O++)
          k[O - 1] = arguments[O];
        o("error", c, k);
      }
    }
    function o(c, p, k) {
      {
        var O = n.ReactDebugCurrentFrame, K = O.getStackAddendum();
        K !== "" && (p += "%s", k = k.concat([K]));
        var oe = k.map(function(pe) {
          return String(pe);
        });
        oe.unshift("Warning: " + p), Function.prototype.apply.call(console[c], console, oe);
      }
    }
    function d(c) {
      c();
    }
    var u = 512, s = null, h = 0;
    function m(c) {
      s = new Uint8Array(u), h = 0;
    }
    function y(c, p) {
      if (p.length !== 0) {
        if (p.length > u) {
          h > 0 && (c.enqueue(new Uint8Array(s.buffer, 0, h)), s = new Uint8Array(u), h = 0), c.enqueue(p);
          return;
        }
        var k = p, O = s.length - h;
        O < k.length && (O === 0 ? c.enqueue(s) : (s.set(k.subarray(0, O), h), c.enqueue(s), k = k.subarray(O)), s = new Uint8Array(u), h = 0), s.set(k, h), h += k.length;
      }
    }
    function v(c, p) {
      return y(c, p), !0;
    }
    function w(c) {
      s && h > 0 && (c.enqueue(new Uint8Array(s.buffer, 0, h)), s = null, h = 0);
    }
    function E(c) {
      c.close();
    }
    var R = new TextEncoder();
    function C(c) {
      return R.encode(c);
    }
    function g(c) {
      return R.encode(c);
    }
    function _(c, p) {
      typeof c.error == "function" ? c.error(p) : c.close();
    }
    function P(c) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, k = p && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return k;
      }
    }
    function M(c) {
      try {
        return N(c), !1;
      } catch {
        return !0;
      }
    }
    function N(c) {
      return "" + c;
    }
    function T(c, p) {
      if (M(c))
        return r("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", p, P(c)), N(c);
    }
    function U(c, p) {
      if (M(c))
        return r("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", p, P(c)), N(c);
    }
    function V(c) {
      if (M(c))
        return r("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", P(c)), N(c);
    }
    var G = Object.prototype.hasOwnProperty, ue = 0, Z = 1, $ = 2, H = 3, j = 4, F = 5, X = 6, Q = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ae = Q + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", te = new RegExp("^[" + Q + "][" + ae + "]*$"), re = {}, ie = {};
    function ge(c) {
      return G.call(ie, c) ? !0 : G.call(re, c) ? !1 : te.test(c) ? (ie[c] = !0, !0) : (re[c] = !0, r("Invalid attribute name: `%s`", c), !1);
    }
    function ve(c, p, k, O) {
      if (k !== null && k.type === ue)
        return !1;
      switch (typeof p) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (O)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var K = c.toLowerCase().slice(0, 5);
          return K !== "data-" && K !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Se(c) {
      return ee.hasOwnProperty(c) ? ee[c] : null;
    }
    function ye(c, p, k, O, K, oe, pe) {
      this.acceptsBooleans = p === $ || p === H || p === j, this.attributeName = O, this.attributeNamespace = K, this.mustUseProperty = k, this.propertyName = c, this.type = p, this.sanitizeURL = oe, this.removeEmptyString = pe;
    }
    var ee = {}, Ee = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ee.forEach(function(c) {
      ee[c] = new ye(
        c,
        ue,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
      var p = c[0], k = c[1];
      ee[p] = new ye(
        p,
        Z,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
      ee[c] = new ye(
        c,
        $,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
      ee[c] = new ye(
        c,
        $,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(c) {
      ee[c] = new ye(
        c,
        H,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ee[c] = new ye(
        c,
        H,
        !0,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ee[c] = new ye(
        c,
        j,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ee[c] = new ye(
        c,
        X,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(c) {
      ee[c] = new ye(
        c,
        F,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var He = /[\-\:]([a-z])/g, we = function(c) {
      return c[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ee[p] = new ye(
        p,
        Z,
        !1,
        // mustUseProperty
        c,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ee[p] = new ye(
        p,
        Z,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ee[p] = new ye(
        p,
        Z,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(c) {
      ee[c] = new ye(
        c,
        Z,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var fe = "xlinkHref";
    ee[fe] = new ye(
      "xlinkHref",
      Z,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(c) {
      ee[c] = new ye(
        c,
        Z,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ae = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function ne(c, p) {
      return c + p.charAt(0).toUpperCase() + p.substring(1);
    }
    var $e = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ae).forEach(function(c) {
      $e.forEach(function(p) {
        Ae[ne(p, c)] = Ae[c];
      });
    });
    var Le = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ke(c, p) {
      Le[p.type] || p.onChange || p.onInput || p.readOnly || p.disabled || p.value == null || r("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), p.onChange || p.readOnly || p.disabled || p.checked == null || r("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ge(c, p) {
      if (c.indexOf("-") === -1)
        return typeof p.is == "string";
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var et = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ze = {}, Et = new RegExp("^(aria)-[" + ae + "]*$"), qe = new RegExp("^(aria)[A-Z][" + ae + "]*$");
    function Be(c, p) {
      {
        if (G.call(Ze, p) && Ze[p])
          return !0;
        if (qe.test(p)) {
          var k = "aria-" + p.slice(4).toLowerCase(), O = et.hasOwnProperty(k) ? k : null;
          if (O == null)
            return r("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", p), Ze[p] = !0, !0;
          if (p !== O)
            return r("Invalid ARIA attribute `%s`. Did you mean `%s`?", p, O), Ze[p] = !0, !0;
        }
        if (Et.test(p)) {
          var K = p.toLowerCase(), oe = et.hasOwnProperty(K) ? K : null;
          if (oe == null)
            return Ze[p] = !0, !1;
          if (p !== oe)
            return r("Unknown ARIA attribute `%s`. Did you mean `%s`?", p, oe), Ze[p] = !0, !0;
        }
      }
      return !0;
    }
    function Ie(c, p) {
      {
        var k = [];
        for (var O in p) {
          var K = Be(c, O);
          K || k.push(O);
        }
        var oe = k.map(function(pe) {
          return "`" + pe + "`";
        }).join(", ");
        k.length === 1 ? r("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, c) : k.length > 1 && r("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, c);
      }
    }
    function Fe(c, p) {
      Ge(c, p) || Ie(c, p);
    }
    var lt = !1;
    function Ue(c, p) {
      {
        if (c !== "input" && c !== "textarea" && c !== "select")
          return;
        p != null && p.value === null && !lt && (lt = !0, c === "select" && p.multiple ? r("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : r("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c));
      }
    }
    var ct = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ht = function() {
    };
    {
      var gt = {}, Dt = /^on./, qt = /^on[^A-Z]/, Vt = new RegExp("^(aria)-[" + ae + "]*$"), kt = new RegExp("^(aria)[A-Z][" + ae + "]*$");
      ht = function(c, p, k, O) {
        if (G.call(gt, p) && gt[p])
          return !0;
        var K = p.toLowerCase();
        if (K === "onfocusin" || K === "onfocusout")
          return r("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), gt[p] = !0, !0;
        if (O != null) {
          var oe = O.registrationNameDependencies, pe = O.possibleRegistrationNames;
          if (oe.hasOwnProperty(p))
            return !0;
          var Re = pe.hasOwnProperty(K) ? pe[K] : null;
          if (Re != null)
            return r("Invalid event handler property `%s`. Did you mean `%s`?", p, Re), gt[p] = !0, !0;
          if (Dt.test(p))
            return r("Unknown event handler property `%s`. It will be ignored.", p), gt[p] = !0, !0;
        } else if (Dt.test(p))
          return qt.test(p) && r("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", p), gt[p] = !0, !0;
        if (Vt.test(p) || kt.test(p))
          return !0;
        if (K === "innerhtml")
          return r("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), gt[p] = !0, !0;
        if (K === "aria")
          return r("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), gt[p] = !0, !0;
        if (K === "is" && k !== null && k !== void 0 && typeof k != "string")
          return r("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), gt[p] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return r("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", p), gt[p] = !0, !0;
        var l = Se(p), f = l !== null && l.type === ue;
        if (ct.hasOwnProperty(K)) {
          var S = ct[K];
          if (S !== p)
            return r("Invalid DOM property `%s`. Did you mean `%s`?", p, S), gt[p] = !0, !0;
        } else if (!f && p !== K)
          return r("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", p, K), gt[p] = !0, !0;
        return typeof k == "boolean" && ve(p, k, l, !1) ? (k ? r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, p, p, k, p) : r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, p, p, k, p, p, p), gt[p] = !0, !0) : f ? !0 : ve(p, k, l, !1) ? (gt[p] = !0, !1) : ((k === "false" || k === "true") && l !== null && l.type === H && (r("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, p, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', p, k), gt[p] = !0), !0);
      };
    }
    var zt = function(c, p, k) {
      {
        var O = [];
        for (var K in p) {
          var oe = ht(c, K, p[K], k);
          oe || O.push(K);
        }
        var pe = O.map(function(Re) {
          return "`" + Re + "`";
        }).join(", ");
        O.length === 1 ? r("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, c) : O.length > 1 && r("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, c);
      }
    };
    function ln(c, p, k) {
      Ge(c, p) || zt(c, p, k);
    }
    var en = function() {
    };
    {
      var cn = /^(?:webkit|moz|o)[A-Z]/, ze = /^-ms-/, Nt = /-(.)/g, Gt = /;\s*$/, Bt = {}, yn = {}, Lt = !1, bn = !1, Mn = function(c) {
        return c.replace(Nt, function(p, k) {
          return k.toUpperCase();
        });
      }, mn = function(c) {
        Bt.hasOwnProperty(c) && Bt[c] || (Bt[c] = !0, r(
          "Unsupported style property %s. Did you mean %s?",
          c,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Mn(c.replace(ze, "ms-"))
        ));
      }, dn = function(c) {
        Bt.hasOwnProperty(c) && Bt[c] || (Bt[c] = !0, r("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)));
      }, jt = function(c, p) {
        yn.hasOwnProperty(p) && yn[p] || (yn[p] = !0, r(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, p.replace(Gt, "")));
      }, wn = function(c, p) {
        Lt || (Lt = !0, r("`NaN` is an invalid value for the `%s` css style property.", c));
      }, Ft = function(c, p) {
        bn || (bn = !0, r("`Infinity` is an invalid value for the `%s` css style property.", c));
      };
      en = function(c, p) {
        c.indexOf("-") > -1 ? mn(c) : cn.test(c) ? dn(c) : Gt.test(p) && jt(c, p), typeof p == "number" && (isNaN(p) ? wn(c, p) : isFinite(p) || Ft(c, p));
      };
    }
    var pt = en, Tn = /["'&<>]/;
    function tn(c) {
      V(c);
      var p = "" + c, k = Tn.exec(p);
      if (!k)
        return p;
      var O, K = "", oe, pe = 0;
      for (oe = k.index; oe < p.length; oe++) {
        switch (p.charCodeAt(oe)) {
          case 34:
            O = "&quot;";
            break;
          case 38:
            O = "&amp;";
            break;
          case 39:
            O = "&#x27;";
            break;
          case 60:
            O = "&lt;";
            break;
          case 62:
            O = "&gt;";
            break;
          default:
            continue;
        }
        pe !== oe && (K += p.substring(pe, oe)), pe = oe + 1, K += O;
      }
      return pe !== oe ? K + p.substring(pe, oe) : K;
    }
    function $t(c) {
      return typeof c == "boolean" || typeof c == "number" ? "" + c : tn(c);
    }
    var Sn = /([A-Z])/g, En = /^ms-/;
    function Dn(c) {
      return c.replace(Sn, "-$1").toLowerCase().replace(En, "-ms-");
    }
    var Ln = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Me = !1;
    function dt(c) {
      !Me && Ln.test(c) && (Me = !0, r("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)));
    }
    var it = Array.isArray;
    function W(c) {
      return it(c);
    }
    var _e = g("<script>"), Xe = g("<\/script>"), Ve = g('<script src="'), ot = g('<script type="module" src="'), rt = g('" async=""><\/script>');
    function xt(c) {
      return V(c), ("" + c).replace(Mt, Qe);
    }
    var Mt = /(<\/|<)(s)(cript)/gi, Qe = function(c, p, k, O) {
      return "" + p + (k === "s" ? "\\u0073" : "\\u0053") + O;
    };
    function Kt(c, p, k, O, K) {
      var oe = c === void 0 ? "" : c, pe = p === void 0 ? _e : g('<script nonce="' + $t(p) + '">'), Re = [];
      if (k !== void 0 && Re.push(pe, C(xt(k)), Xe), O !== void 0)
        for (var l = 0; l < O.length; l++)
          Re.push(Ve, C($t(O[l])), rt);
      if (K !== void 0)
        for (var f = 0; f < K.length; f++)
          Re.push(ot, C($t(K[f])), rt);
      return {
        bootstrapChunks: Re,
        startInlineScript: pe,
        placeholderPrefix: g(oe + "P:"),
        segmentPrefix: g(oe + "S:"),
        boundaryPrefix: oe + "B:",
        idPrefix: oe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var It = 0, _t = 1, mt = 2, Rt = 3, wt = 4, Yt = 5, Xt = 6, sn = 7;
    function fn(c, p) {
      return {
        insertionMode: c,
        selectedValue: p
      };
    }
    function nn(c) {
      var p = c === "http://www.w3.org/2000/svg" ? mt : c === "http://www.w3.org/1998/Math/MathML" ? Rt : It;
      return fn(p, null);
    }
    function Qt(c, p, k) {
      switch (p) {
        case "select":
          return fn(_t, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return fn(mt, null);
        case "math":
          return fn(Rt, null);
        case "foreignObject":
          return fn(_t, null);
        case "table":
          return fn(wt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return fn(Yt, null);
        case "colgroup":
          return fn(sn, null);
        case "tr":
          return fn(Xt, null);
      }
      return c.insertionMode >= wt || c.insertionMode === It ? fn(_t, null) : c;
    }
    var Cn = null;
    function un(c) {
      var p = c.nextSuspenseID++;
      return g(c.boundaryPrefix + p.toString(16));
    }
    function An(c, p, k) {
      var O = c.idPrefix, K = ":" + O + "R" + p;
      return k > 0 && (K += "H" + k.toString(32)), K + ":";
    }
    function In(c) {
      return $t(c);
    }
    var Yn = g("<!-- -->");
    function Zn(c, p, k, O) {
      return p === "" ? O : (O && c.push(Yn), c.push(C(In(p))), !0);
    }
    function Xn(c, p, k, O) {
      k && O && c.push(Yn);
    }
    var x = /* @__PURE__ */ new Map();
    function L(c) {
      var p = x.get(c);
      if (p !== void 0)
        return p;
      var k = g($t(Dn(c)));
      return x.set(c, k), k;
    }
    var I = g(' style="'), Y = g(":"), Te = g(";");
    function xe(c, p, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var O = !0;
      for (var K in k)
        if (G.call(k, K)) {
          var oe = k[K];
          if (!(oe == null || typeof oe == "boolean" || oe === "")) {
            var pe = void 0, Re = void 0, l = K.indexOf("--") === 0;
            l ? (pe = C($t(K)), U(oe, K), Re = C($t(("" + oe).trim()))) : (pt(K, oe), pe = L(K), typeof oe == "number" ? oe !== 0 && !G.call(Ae, K) ? Re = C(oe + "px") : Re = C("" + oe) : (U(oe, K), Re = C($t(("" + oe).trim())))), O ? (O = !1, c.push(I, pe, Y, Re)) : c.push(Te, pe, Y, Re);
          }
        }
      O || c.push(at);
    }
    var De = g(" "), je = g('="'), at = g('"'), yt = g('=""');
    function le(c, p, k, O) {
      switch (k) {
        case "style": {
          xe(c, p, O);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var K = Se(k);
        if (K !== null) {
          switch (typeof O) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!K.acceptsBooleans)
                return;
          }
          var oe = K.attributeName, pe = C(oe);
          switch (K.type) {
            case H:
              O && c.push(De, pe, yt);
              return;
            case j:
              O === !0 ? c.push(De, pe, yt) : O === !1 || c.push(De, pe, je, C($t(O)), at);
              return;
            case F:
              isNaN(O) || c.push(De, pe, je, C($t(O)), at);
              break;
            case X:
              !isNaN(O) && O >= 1 && c.push(De, pe, je, C($t(O)), at);
              break;
            default:
              K.sanitizeURL && (T(O, oe), O = "" + O, dt(O)), c.push(De, pe, je, C($t(O)), at);
          }
        } else if (ge(k)) {
          switch (typeof O) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Re = k.toLowerCase().slice(0, 5);
              if (Re !== "data-" && Re !== "aria-")
                return;
            }
          }
          c.push(De, C(k), je, C($t(O)), at);
        }
      }
    }
    var se = g(">"), me = g("/>");
    function Oe(c, p, k) {
      if (p != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof p != "object" || !("__html" in p))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var O = p.__html;
        O != null && (V(O), c.push(C("" + O)));
      }
    }
    var bt = !1, vn = !1, Rn = !1, fr = !1, Hn = !1, Ar = !1, hr = !1;
    function Qr(c, p) {
      {
        var k = c[p];
        if (k != null) {
          var O = W(k);
          c.multiple && !O ? r("The `%s` prop supplied to <select> must be an array if `multiple` is true.", p) : !c.multiple && O && r("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", p);
        }
      }
    }
    function il(c, p, k) {
      Ke("select", p), Qr(p, "value"), Qr(p, "defaultValue"), p.value !== void 0 && p.defaultValue !== void 0 && !Rn && (r("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Rn = !0), c.push(Qn("select"));
      var O = null, K = null;
      for (var oe in p)
        if (G.call(p, oe)) {
          var pe = p[oe];
          if (pe == null)
            continue;
          switch (oe) {
            case "children":
              O = pe;
              break;
            case "dangerouslySetInnerHTML":
              K = pe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              le(c, k, oe, pe);
              break;
          }
        }
      return c.push(se), Oe(c, K, O), O;
    }
    function ol(c) {
      var p = "";
      return e.Children.forEach(c, function(k) {
        k != null && (p += k, !Hn && typeof k != "string" && typeof k != "number" && (Hn = !0, r("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), p;
    }
    var Ua = g(' selected=""');
    function ll(c, p, k, O) {
      var K = O.selectedValue;
      c.push(Qn("option"));
      var oe = null, pe = null, Re = null, l = null;
      for (var f in p)
        if (G.call(p, f)) {
          var S = p[f];
          if (S == null)
            continue;
          switch (f) {
            case "children":
              oe = S;
              break;
            case "selected":
              Re = S, hr || (r("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), hr = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = S;
              break;
            case "value":
              pe = S;
            default:
              le(c, k, f, S);
              break;
          }
        }
      if (K != null) {
        var A;
        if (pe !== null ? (T(pe, "value"), A = "" + pe) : (l !== null && (Ar || (Ar = !0, r("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), A = ol(oe)), W(K))
          for (var z = 0; z < K.length; z++) {
            T(K[z], "value");
            var J = "" + K[z];
            if (J === A) {
              c.push(Ua);
              break;
            }
          }
        else
          T(K, "select.value"), "" + K === A && c.push(Ua);
      } else
        Re && c.push(Ua);
      return c.push(se), Oe(c, l, oe), oe;
    }
    function Ka(c, p, k) {
      Ke("input", p), p.checked !== void 0 && p.defaultChecked !== void 0 && !vn && (r("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", p.type), vn = !0), p.value !== void 0 && p.defaultValue !== void 0 && !bt && (r("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", p.type), bt = !0), c.push(Qn("input"));
      var O = null, K = null, oe = null, pe = null;
      for (var Re in p)
        if (G.call(p, Re)) {
          var l = p[Re];
          if (l == null)
            continue;
          switch (Re) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              pe = l;
              break;
            case "defaultValue":
              K = l;
              break;
            case "checked":
              oe = l;
              break;
            case "value":
              O = l;
              break;
            default:
              le(c, k, Re, l);
              break;
          }
        }
      return oe !== null ? le(c, k, "checked", oe) : pe !== null && le(c, k, "checked", pe), O !== null ? le(c, k, "value", O) : K !== null && le(c, k, "value", K), c.push(me), null;
    }
    function pr(c, p, k) {
      Ke("textarea", p), p.value !== void 0 && p.defaultValue !== void 0 && !fr && (r("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), fr = !0), c.push(Qn("textarea"));
      var O = null, K = null, oe = null;
      for (var pe in p)
        if (G.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              oe = Re;
              break;
            case "value":
              O = Re;
              break;
            case "defaultValue":
              K = Re;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              le(c, k, pe, Re);
              break;
          }
        }
      if (O === null && K !== null && (O = K), c.push(se), oe != null) {
        if (r("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), O != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (W(oe)) {
          if (oe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          V(oe[0]), O = "" + oe[0];
        }
        V(oe), O = "" + oe;
      }
      return typeof O == "string" && O[0] === `
` && c.push(Pr), O !== null && (T(O, "value"), c.push(C(In("" + O)))), null;
    }
    function Jr(c, p, k, O) {
      c.push(Qn(k));
      for (var K in p)
        if (G.call(p, K)) {
          var oe = p[K];
          if (oe == null)
            continue;
          switch (K) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              le(c, O, K, oe);
              break;
          }
        }
      return c.push(me), null;
    }
    function pa(c, p, k) {
      c.push(Qn("menuitem"));
      for (var O in p)
        if (G.call(p, O)) {
          var K = p[O];
          if (K == null)
            continue;
          switch (O) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              le(c, k, O, K);
              break;
          }
        }
      return c.push(se), null;
    }
    function rn(c, p, k) {
      c.push(Qn("title"));
      var O = null;
      for (var K in p)
        if (G.call(p, K)) {
          var oe = p[K];
          if (oe == null)
            continue;
          switch (K) {
            case "children":
              O = oe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              le(c, k, K, oe);
              break;
          }
        }
      c.push(se);
      {
        var pe = Array.isArray(O) && O.length < 2 ? O[0] || null : O;
        Array.isArray(O) && O.length > 1 ? r("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && pe.$$typeof != null ? r("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && typeof pe != "string" && typeof pe != "number" && r("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return O;
    }
    function yr(c, p, k, O) {
      c.push(Qn(k));
      var K = null, oe = null;
      for (var pe in p)
        if (G.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              K = Re;
              break;
            case "dangerouslySetInnerHTML":
              oe = Re;
              break;
            default:
              le(c, O, pe, Re);
              break;
          }
        }
      return c.push(se), Oe(c, oe, K), typeof K == "string" ? (c.push(C(In(K))), null) : K;
    }
    function Vn(c, p, k, O) {
      c.push(Qn(k));
      var K = null, oe = null;
      for (var pe in p)
        if (G.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              K = Re;
              break;
            case "dangerouslySetInnerHTML":
              oe = Re;
              break;
            case "style":
              xe(c, O, Re);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ge(pe) && typeof Re != "function" && typeof Re != "symbol" && c.push(De, C(pe), je, C($t(Re)), at);
              break;
          }
        }
      return c.push(se), Oe(c, oe, K), K;
    }
    var Pr = g(`
`);
    function vr(c, p, k, O) {
      c.push(Qn(k));
      var K = null, oe = null;
      for (var pe in p)
        if (G.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              K = Re;
              break;
            case "dangerouslySetInnerHTML":
              oe = Re;
              break;
            default:
              le(c, O, pe, Re);
              break;
          }
        }
      if (c.push(se), oe != null) {
        if (K != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof oe != "object" || !("__html" in oe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = oe.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? c.push(Pr, C(l)) : (V(l), c.push(C("" + l))));
      }
      return typeof K == "string" && K[0] === `
` && c.push(Pr), K;
    }
    var ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, xr = /* @__PURE__ */ new Map();
    function Qn(c) {
      var p = xr.get(c);
      if (p === void 0) {
        if (!ma.test(c))
          throw new Error("Invalid tag: " + c);
        p = g("<" + c), xr.set(c, p);
      }
      return p;
    }
    var Ya = g("<!DOCTYPE html>");
    function Xa(c, p, k, O, K) {
      switch (Fe(p, k), Ue(p, k), ln(p, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && r("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), K.insertionMode !== mt && K.insertionMode !== Rt && p.indexOf("-") === -1 && typeof k.is != "string" && p.toLowerCase() !== p && r("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", p), p) {
        case "select":
          return il(c, k, O);
        case "option":
          return ll(c, k, O, K);
        case "textarea":
          return pr(c, k, O);
        case "input":
          return Ka(c, k, O);
        case "menuitem":
          return pa(c, k, O);
        case "title":
          return rn(c, k, O);
        case "listing":
        case "pre":
          return vr(c, k, p, O);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Jr(c, k, p, O);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return yr(c, k, p, O);
        case "html":
          return K.insertionMode === It && c.push(Ya), yr(c, k, p, O);
        default:
          return p.indexOf("-") === -1 && typeof k.is != "string" ? yr(c, k, p, O) : Vn(c, k, p, O);
      }
    }
    var ji = g("</"), Ui = g(">");
    function Ki(c, p, k) {
      switch (p) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          c.push(ji, C(p), Ui);
      }
    }
    function sl(c, p) {
      for (var k = p.bootstrapChunks, O = 0; O < k.length - 1; O++)
        y(c, k[O]);
      return O < k.length ? v(c, k[O]) : !0;
    }
    var ul = g('<template id="'), ga = g('"></template>');
    function ya(c, p, k) {
      y(c, ul), y(c, p.placeholderPrefix);
      var O = C(k.toString(16));
      return y(c, O), v(c, ga);
    }
    var va = g("<!--$-->"), ea = g('<!--$?--><template id="'), cl = g('"></template>'), ta = g("<!--$!-->"), qa = g("<!--/$-->"), Ga = g("<template"), Fr = g('"'), zr = g(' data-dgst="'), xa = g(' data-msg="'), Yi = g(' data-stck="'), Za = g("></template>");
    function Xi(c, p) {
      return v(c, va);
    }
    function ba(c, p, k) {
      if (y(c, ea), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(c, k), v(c, cl);
    }
    function jn(c, p, k, O, K) {
      var oe;
      return oe = v(c, ta), y(c, Ga), k && (y(c, zr), y(c, C($t(k))), y(c, Fr)), O && (y(c, xa), y(c, C($t(O))), y(c, Fr)), K && (y(c, Yi), y(c, C($t(K))), y(c, Fr)), oe = v(c, Za), oe;
    }
    function qi(c, p) {
      return v(c, qa);
    }
    function Sa(c, p) {
      return v(c, qa);
    }
    function dl(c, p) {
      return v(c, qa);
    }
    var Gi = g('<div hidden id="'), Ea = g('">'), Zi = g("</div>"), Qi = g('<svg aria-hidden="true" style="display:none" id="'), ka = g('">'), wa = g("</svg>"), Ji = g('<math aria-hidden="true" style="display:none" id="'), eo = g('">'), to = g("</math>"), Qa = g('<table hidden id="'), no = g('">'), b = g("</table>"), D = g('<table hidden><tbody id="'), B = g('">'), q = g("</tbody></table>"), Ce = g('<table hidden><tr id="'), ke = g('">'), Ne = g("</tr></table>"), Ye = g('<table hidden><colgroup id="'), St = g('">'), Ot = g("</colgroup></table>");
    function Pt(c, p, k, O) {
      switch (k.insertionMode) {
        case It:
        case _t:
          return y(c, Gi), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, Ea);
        case mt:
          return y(c, Qi), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, ka);
        case Rt:
          return y(c, Ji), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, eo);
        case wt:
          return y(c, Qa), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, no);
        case Yt:
          return y(c, D), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, B);
        case Xt:
          return y(c, Ce), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, ke);
        case sn:
          return y(c, Ye), y(c, p.segmentPrefix), y(c, C(O.toString(16))), v(c, St);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function an(c, p) {
      switch (p.insertionMode) {
        case It:
        case _t:
          return v(c, Zi);
        case mt:
          return v(c, wa);
        case Rt:
          return v(c, to);
        case wt:
          return v(c, b);
        case Yt:
          return v(c, q);
        case Xt:
          return v(c, Ne);
        case sn:
          return v(c, Ot);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Un = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", Jn = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', er = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ta = g(Un + ';$RS("'), ro = g('$RS("'), Ja = g('","'), zc = g('")<\/script>');
    function Bc(c, p, k) {
      y(c, p.startInlineScript), p.sentCompleteSegmentFunction ? y(c, ro) : (p.sentCompleteSegmentFunction = !0, y(c, Ta)), y(c, p.segmentPrefix);
      var O = C(k.toString(16));
      return y(c, O), y(c, Ja), y(c, p.placeholderPrefix), y(c, O), v(c, zc);
    }
    var $c = g(Jn + ';$RC("'), Ic = g('$RC("'), Hc = g('","'), Wc = g('")<\/script>');
    function fl(c, p, k, O) {
      if (y(c, p.startInlineScript), p.sentCompleteBoundaryFunction ? y(c, Ic) : (p.sentCompleteBoundaryFunction = !0, y(c, $c)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var K = C(O.toString(16));
      return y(c, k), y(c, Hc), y(c, p.segmentPrefix), y(c, K), v(c, Wc);
    }
    var Vc = g(er + ';$RX("'), jc = g('$RX("'), hl = g('"'), Uc = g(")<\/script>"), pl = g(",");
    function Ms(c, p, k, O, K, oe) {
      if (y(c, p.startInlineScript), p.sentClientRenderFunction ? y(c, jc) : (p.sentClientRenderFunction = !0, y(c, Vc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(c, k), y(c, hl), (O || K || oe) && (y(c, pl), y(c, C(ml(O || "")))), (K || oe) && (y(c, pl), y(c, C(ml(K || "")))), oe && (y(c, pl), y(c, C(ml(oe)))), v(c, Uc);
    }
    var _s = /[<\u2028\u2029]/g;
    function ml(c) {
      var p = JSON.stringify(c);
      return p.replace(_s, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var or = Object.assign, Kc = Symbol.for("react.element"), Ns = Symbol.for("react.portal"), tr = Symbol.for("react.fragment"), Fs = Symbol.for("react.strict_mode"), gl = Symbol.for("react.profiler"), ao = Symbol.for("react.provider"), io = Symbol.for("react.context"), oo = Symbol.for("react.forward_ref"), ei = Symbol.for("react.suspense"), ti = Symbol.for("react.suspense_list"), ni = Symbol.for("react.memo"), Ca = Symbol.for("react.lazy"), yl = Symbol.for("react.scope"), vl = Symbol.for("react.debug_trace_mode"), lo = Symbol.for("react.legacy_hidden"), Yc = Symbol.for("react.default_value"), zs = Symbol.iterator, Xc = "@@iterator";
    function qc(c) {
      if (c === null || typeof c != "object")
        return null;
      var p = zs && c[zs] || c[Xc];
      return typeof p == "function" ? p : null;
    }
    function Bs(c, p, k) {
      var O = c.displayName;
      if (O)
        return O;
      var K = p.displayName || p.name || "";
      return K !== "" ? k + "(" + K + ")" : k;
    }
    function $s(c) {
      return c.displayName || "Context";
    }
    function xn(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && r("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case tr:
          return "Fragment";
        case Ns:
          return "Portal";
        case gl:
          return "Profiler";
        case Fs:
          return "StrictMode";
        case ei:
          return "Suspense";
        case ti:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case io:
            var p = c;
            return $s(p) + ".Consumer";
          case ao:
            var k = c;
            return $s(k._context) + ".Provider";
          case oo:
            return Bs(c, c.render, "ForwardRef");
          case ni:
            var O = c.displayName || null;
            return O !== null ? O : xn(c.type) || "Memo";
          case Ca: {
            var K = c, oe = K._payload, pe = K._init;
            try {
              return xn(pe(oe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ri = 0, xl, gn, Aa, bl, Sl, El, kl;
    function wl() {
    }
    wl.__reactDisabledLog = !0;
    function Is() {
      {
        if (ri === 0) {
          xl = console.log, gn = console.info, Aa = console.warn, bl = console.error, Sl = console.group, El = console.groupCollapsed, kl = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: wl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        ri++;
      }
    }
    function Hs() {
      {
        if (ri--, ri === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: or({}, c, {
              value: xl
            }),
            info: or({}, c, {
              value: gn
            }),
            warn: or({}, c, {
              value: Aa
            }),
            error: or({}, c, {
              value: bl
            }),
            group: or({}, c, {
              value: Sl
            }),
            groupCollapsed: or({}, c, {
              value: El
            }),
            groupEnd: or({}, c, {
              value: kl
            })
          });
        }
        ri < 0 && r("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var so = n.ReactCurrentDispatcher, Tl;
    function ai(c, p, k) {
      {
        if (Tl === void 0)
          try {
            throw Error();
          } catch (K) {
            var O = K.stack.trim().match(/\n( *(at )?)/);
            Tl = O && O[1] || "";
          }
        return `
` + Tl + c;
      }
    }
    var ii = !1, Pa;
    {
      var oi = typeof WeakMap == "function" ? WeakMap : Map;
      Pa = new oi();
    }
    function li(c, p) {
      if (!c || ii)
        return "";
      {
        var k = Pa.get(c);
        if (k !== void 0)
          return k;
      }
      var O;
      ii = !0;
      var K = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var oe;
      oe = so.current, so.current = null, Is();
      try {
        if (p) {
          var pe = function() {
            throw Error();
          };
          if (Object.defineProperty(pe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pe, []);
            } catch (de) {
              O = de;
            }
            Reflect.construct(c, [], pe);
          } else {
            try {
              pe.call();
            } catch (de) {
              O = de;
            }
            c.call(pe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (de) {
            O = de;
          }
          c();
        }
      } catch (de) {
        if (de && O && typeof de.stack == "string") {
          for (var Re = de.stack.split(`
`), l = O.stack.split(`
`), f = Re.length - 1, S = l.length - 1; f >= 1 && S >= 0 && Re[f] !== l[S]; )
            S--;
          for (; f >= 1 && S >= 0; f--, S--)
            if (Re[f] !== l[S]) {
              if (f !== 1 || S !== 1)
                do
                  if (f--, S--, S < 0 || Re[f] !== l[S]) {
                    var A = `
` + Re[f].replace(" at new ", " at ");
                    return c.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", c.displayName)), typeof c == "function" && Pa.set(c, A), A;
                  }
                while (f >= 1 && S >= 0);
              break;
            }
        }
      } finally {
        ii = !1, so.current = oe, Hs(), Error.prepareStackTrace = K;
      }
      var z = c ? c.displayName || c.name : "", J = z ? ai(z) : "";
      return typeof c == "function" && Pa.set(c, J), J;
    }
    function uo(c, p, k) {
      return li(c, !0);
    }
    function Ws(c, p, k) {
      return li(c, !1);
    }
    function Cl(c) {
      var p = c.prototype;
      return !!(p && p.isReactComponent);
    }
    function Al(c, p, k) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return li(c, Cl(c));
      if (typeof c == "string")
        return ai(c);
      switch (c) {
        case ei:
          return ai("Suspense");
        case ti:
          return ai("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case oo:
            return Ws(c.render);
          case ni:
            return Al(c.type, p, k);
          case Ca: {
            var O = c, K = O._payload, oe = O._init;
            try {
              return Al(oe(K), p, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Pl = {}, Vs = n.ReactDebugCurrentFrame;
    function La(c) {
      if (c) {
        var p = c._owner, k = Al(c.type, c._source, p ? p.type : null);
        Vs.setExtraStackFrame(k);
      } else
        Vs.setExtraStackFrame(null);
    }
    function Ll(c, p, k, O, K) {
      {
        var oe = Function.call.bind(G);
        for (var pe in c)
          if (oe(c, pe)) {
            var Re = void 0;
            try {
              if (typeof c[pe] != "function") {
                var l = Error((O || "React class") + ": " + k + " type `" + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Re = c[pe](p, pe, O, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Re = f;
            }
            Re && !(Re instanceof Error) && (La(K), r("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", O || "React class", k, pe, typeof Re), La(null)), Re instanceof Error && !(Re.message in Pl) && (Pl[Re.message] = !0, La(K), r("Failed %s type: %s", k, Re.message), La(null));
          }
      }
    }
    var co;
    co = {};
    var na = {};
    Object.freeze(na);
    function Rl(c, p) {
      {
        var k = c.contextTypes;
        if (!k)
          return na;
        var O = {};
        for (var K in k)
          O[K] = p[K];
        {
          var oe = xn(c) || "Unknown";
          Ll(k, O, "context", oe);
        }
        return O;
      }
    }
    function Dl(c, p, k, O) {
      {
        if (typeof c.getChildContext != "function") {
          {
            var K = xn(p) || "Unknown";
            co[K] || (co[K] = !0, r("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", K, K));
          }
          return k;
        }
        var oe = c.getChildContext();
        for (var pe in oe)
          if (!(pe in O))
            throw new Error((xn(p) || "Unknown") + '.getChildContext(): key "' + pe + '" is not defined in childContextTypes.');
        {
          var Re = xn(p) || "Unknown";
          Ll(O, oe, "child context", Re);
        }
        return or({}, k, oe);
      }
    }
    var Br;
    Br = {};
    var js = null, ra = null;
    function aa(c) {
      c.context._currentValue = c.parentValue;
    }
    function Ol(c) {
      c.context._currentValue = c.value;
    }
    function br(c, p) {
      if (c !== p) {
        aa(c);
        var k = c.parent, O = p.parent;
        if (k === null) {
          if (O !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (O === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          br(k, O);
        }
        Ol(p);
      }
    }
    function fo(c) {
      aa(c);
      var p = c.parent;
      p !== null && fo(p);
    }
    function ho(c) {
      var p = c.parent;
      p !== null && ho(p), Ol(c);
    }
    function si(c, p) {
      aa(c);
      var k = c.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === p.depth ? br(k, p) : si(k, p);
    }
    function Ml(c, p) {
      var k = p.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      c.depth === k.depth ? br(c, k) : Ml(c, k), Ol(p);
    }
    function ui(c) {
      var p = ra, k = c;
      p !== k && (p === null ? ho(k) : k === null ? fo(p) : p.depth === k.depth ? br(p, k) : p.depth > k.depth ? si(p, k) : Ml(p, k), ra = k);
    }
    function Us(c, p) {
      var k;
      k = c._currentValue, c._currentValue = p, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== Br && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = Br;
      var O = ra, K = {
        parent: O,
        depth: O === null ? 0 : O.depth + 1,
        context: c,
        parentValue: k,
        value: p
      };
      return ra = K, K;
    }
    function Ks(c) {
      var p = ra;
      if (p === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      p.context !== c && r("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = p.parentValue;
        k === Yc ? p.context._currentValue = p.context._defaultValue : p.context._currentValue = k, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== Br && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = Br;
      }
      return ra = p.parent;
    }
    function po() {
      return ra;
    }
    function ci(c) {
      var p = c._currentValue;
      return p;
    }
    function _l(c) {
      return c._reactInternals;
    }
    function Gc(c, p) {
      c._reactInternals = p;
    }
    var Ra = {}, mo = {}, Nl, go, yo, di, vo, Da, fi, xo, Oa;
    {
      Nl = /* @__PURE__ */ new Set(), go = /* @__PURE__ */ new Set(), yo = /* @__PURE__ */ new Set(), fi = /* @__PURE__ */ new Set(), di = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), Oa = /* @__PURE__ */ new Set();
      var bo = /* @__PURE__ */ new Set();
      Da = function(c, p) {
        if (!(c === null || typeof c == "function")) {
          var k = p + "_" + c;
          bo.has(k) || (bo.add(k), r("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", p, c));
        }
      }, vo = function(c, p) {
        if (p === void 0) {
          var k = xn(c) || "Component";
          di.has(k) || (di.add(k), r("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function So(c, p) {
      {
        var k = c.constructor, O = k && xn(k) || "ReactClass", K = O + "." + p;
        if (Ra[K])
          return;
        r(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, p, p, O), Ra[K] = !0;
      }
    }
    var Eo = {
      isMounted: function(c) {
        return !1;
      },
      enqueueSetState: function(c, p, k) {
        var O = _l(c);
        O.queue === null ? So(c, "setState") : (O.queue.push(p), k != null && Da(k, "setState"));
      },
      enqueueReplaceState: function(c, p, k) {
        var O = _l(c);
        O.replace = !0, O.queue = [p], k != null && Da(k, "setState");
      },
      enqueueForceUpdate: function(c, p) {
        var k = _l(c);
        k.queue === null ? So(c, "forceUpdate") : p != null && Da(p, "setState");
      }
    };
    function Ys(c, p, k, O, K) {
      var oe = k(K, O);
      vo(p, oe);
      var pe = oe == null ? O : or({}, O, oe);
      return pe;
    }
    function Xs(c, p, k) {
      var O = na, K = c.contextType;
      if ("contextType" in c) {
        var oe = (
          // Allow null for conditional declaration
          K === null || K !== void 0 && K.$$typeof === io && K._context === void 0
        );
        if (!oe && !Oa.has(c)) {
          Oa.add(c);
          var pe = "";
          K === void 0 ? pe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof K != "object" ? pe = " However, it is set to a " + typeof K + "." : K.$$typeof === ao ? pe = " Did you accidentally pass the Context.Provider instead?" : K._context !== void 0 ? pe = " Did you accidentally pass the Context.Consumer instead?" : pe = " However, it is set to an object with keys {" + Object.keys(K).join(", ") + "}.", r("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", xn(c) || "Component", pe);
        }
      }
      typeof K == "object" && K !== null ? O = ci(K) : O = k;
      var Re = new c(p, O);
      {
        if (typeof c.getDerivedStateFromProps == "function" && (Re.state === null || Re.state === void 0)) {
          var l = xn(c) || "Component";
          Nl.has(l) || (Nl.add(l), r("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Re.state === null ? "null" : "undefined", l));
        }
        if (typeof c.getDerivedStateFromProps == "function" || typeof Re.getSnapshotBeforeUpdate == "function") {
          var f = null, S = null, A = null;
          if (typeof Re.componentWillMount == "function" && Re.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Re.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Re.componentWillReceiveProps == "function" && Re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? S = "componentWillReceiveProps" : typeof Re.UNSAFE_componentWillReceiveProps == "function" && (S = "UNSAFE_componentWillReceiveProps"), typeof Re.componentWillUpdate == "function" && Re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? A = "componentWillUpdate" : typeof Re.UNSAFE_componentWillUpdate == "function" && (A = "UNSAFE_componentWillUpdate"), f !== null || S !== null || A !== null) {
            var z = xn(c) || "Component", J = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            yo.has(z) || (yo.add(z), r(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, z, J, f !== null ? `
  ` + f : "", S !== null ? `
  ` + S : "", A !== null ? `
  ` + A : ""));
          }
        }
      }
      return Re;
    }
    function qs(c, p, k) {
      {
        var O = xn(p) || "Component", K = c.render;
        K || (p.prototype && typeof p.prototype.render == "function" ? r("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", O) : r("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", O)), c.getInitialState && !c.getInitialState.isReactClassApproved && !c.state && r("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", O), c.getDefaultProps && !c.getDefaultProps.isReactClassApproved && r("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", O), c.propTypes && r("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", O), c.contextType && r("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", O), c.contextTypes && r("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", O), p.contextType && p.contextTypes && !xo.has(p) && (xo.add(p), r("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", O)), typeof c.componentShouldUpdate == "function" && r("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", O), p.prototype && p.prototype.isPureReactComponent && typeof c.shouldComponentUpdate < "u" && r("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", xn(p) || "A pure component"), typeof c.componentDidUnmount == "function" && r("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", O), typeof c.componentDidReceiveProps == "function" && r("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", O), typeof c.componentWillRecieveProps == "function" && r("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", O), typeof c.UNSAFE_componentWillRecieveProps == "function" && r("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", O);
        var oe = c.props !== k;
        c.props !== void 0 && oe && r("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", O, O), c.defaultProps && r("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", O, O), typeof c.getSnapshotBeforeUpdate == "function" && typeof c.componentDidUpdate != "function" && !go.has(p) && (go.add(p), r("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", xn(p))), typeof c.getDerivedStateFromProps == "function" && r("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", O), typeof c.getDerivedStateFromError == "function" && r("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", O), typeof p.getSnapshotBeforeUpdate == "function" && r("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", O);
        var pe = c.state;
        pe && (typeof pe != "object" || W(pe)) && r("%s.state: must be set to an object or null", O), typeof c.getChildContext == "function" && typeof p.childContextTypes != "object" && r("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", O);
      }
    }
    function Zc(c, p) {
      var k = p.state;
      if (typeof p.componentWillMount == "function") {
        if (p.componentWillMount.__suppressDeprecationWarning !== !0) {
          var O = xn(c) || "Unknown";
          mo[O] || (i(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            O
          ), mo[O] = !0);
        }
        p.componentWillMount();
      }
      typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount(), k !== p.state && (r("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xn(c) || "Component"), Eo.enqueueReplaceState(p, p.state, null));
    }
    function Qc(c, p, k, O) {
      if (c.queue !== null && c.queue.length > 0) {
        var K = c.queue, oe = c.replace;
        if (c.queue = null, c.replace = !1, oe && K.length === 1)
          p.state = K[0];
        else {
          for (var pe = oe ? K[0] : p.state, Re = !0, l = oe ? 1 : 0; l < K.length; l++) {
            var f = K[l], S = typeof f == "function" ? f.call(p, pe, k, O) : f;
            S != null && (Re ? (Re = !1, pe = or({}, pe, S)) : or(pe, S));
          }
          p.state = pe;
        }
      } else
        c.queue = null;
    }
    function Gs(c, p, k, O) {
      qs(c, p, k);
      var K = c.state !== void 0 ? c.state : null;
      c.updater = Eo, c.props = k, c.state = K;
      var oe = {
        queue: [],
        replace: !1
      };
      Gc(c, oe);
      var pe = p.contextType;
      if (typeof pe == "object" && pe !== null ? c.context = ci(pe) : c.context = O, c.state === k) {
        var Re = xn(p) || "Component";
        fi.has(Re) || (fi.add(Re), r("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Re));
      }
      var l = p.getDerivedStateFromProps;
      typeof l == "function" && (c.state = Ys(c, p, l, K, k)), typeof p.getDerivedStateFromProps != "function" && typeof c.getSnapshotBeforeUpdate != "function" && (typeof c.UNSAFE_componentWillMount == "function" || typeof c.componentWillMount == "function") && (Zc(p, c), Qc(oe, c, k, O));
    }
    var Jc = {
      id: 1,
      overflow: ""
    };
    function ed(c) {
      var p = c.overflow, k = c.id, O = k & ~td(k);
      return O.toString(32) + p;
    }
    function ko(c, p, k) {
      var O = c.id, K = c.overflow, oe = wo(O) - 1, pe = O & ~(1 << oe), Re = k + 1, l = wo(p) + oe;
      if (l > 30) {
        var f = oe - oe % 5, S = (1 << f) - 1, A = (pe & S).toString(32), z = pe >> f, J = oe - f, de = wo(p) + J, Pe = Re << J, We = Pe | z, tt = A + K;
        return {
          id: 1 << de | We,
          overflow: tt
        };
      } else {
        var st = Re << oe, Tt = st | pe, hn = K;
        return {
          id: 1 << l | Tt,
          overflow: hn
        };
      }
    }
    function wo(c) {
      return 32 - Fl(c);
    }
    function td(c) {
      return 1 << wo(c) - 1;
    }
    var Fl = Math.clz32 ? Math.clz32 : rd, To = Math.log, nd = Math.LN2;
    function rd(c) {
      var p = c >>> 0;
      return p === 0 ? 32 : 31 - (To(p) / nd | 0) | 0;
    }
    function ad(c, p) {
      return c === p && (c !== 0 || 1 / c === 1 / p) || c !== c && p !== p;
    }
    var id = typeof Object.is == "function" ? Object.is : ad, Lr = null, zl = null, Co = null, Ht = null, ia = !1, oa = !1, Jt = 0, lr = null, la = 0, Ao = 25, Bn = !1, Rr;
    function sa() {
      if (Lr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Bn && r("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Lr;
    }
    function Sr(c, p) {
      if (p === null)
        return r("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Rr), !1;
      c.length !== p.length && r(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Rr, "[" + c.join(", ") + "]", "[" + p.join(", ") + "]");
      for (var k = 0; k < p.length && k < c.length; k++)
        if (!id(c[k], p[k]))
          return !1;
      return !0;
    }
    function ua() {
      if (la > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Dr() {
      return Ht === null ? Co === null ? (ia = !1, Co = Ht = ua()) : (ia = !0, Ht = Co) : Ht.next === null ? (ia = !1, Ht = Ht.next = ua()) : (ia = !0, Ht = Ht.next), Ht;
    }
    function od(c, p) {
      Lr = p, zl = c, Bn = !1, Jt = 0;
    }
    function Zs(c, p, k, O) {
      for (; oa; )
        oa = !1, Jt = 0, la += 1, Ht = null, k = c(p, O);
      return Bl(), k;
    }
    function Po() {
      var c = Jt !== 0;
      return c;
    }
    function Bl() {
      Bn = !1, Lr = null, zl = null, oa = !1, Co = null, la = 0, lr = null, Ht = null;
    }
    function ld(c) {
      return Bn && r("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ci(c);
    }
    function Qs(c) {
      return Rr = "useContext", sa(), ci(c);
    }
    function hi(c, p) {
      return typeof p == "function" ? p(c) : p;
    }
    function sd(c) {
      return Rr = "useState", Js(
        hi,
        // useReducer has a special case to support lazy useState initializers
        c
      );
    }
    function Js(c, p, k) {
      if (c !== hi && (Rr = "useReducer"), Lr = sa(), Ht = Dr(), ia) {
        var O = Ht.queue, K = O.dispatch;
        if (lr !== null) {
          var oe = lr.get(O);
          if (oe !== void 0) {
            lr.delete(O);
            var pe = Ht.memoizedState, Re = oe;
            do {
              var l = Re.action;
              Bn = !0, pe = c(pe, l), Bn = !1, Re = Re.next;
            } while (Re !== null);
            return Ht.memoizedState = pe, [pe, K];
          }
        }
        return [Ht.memoizedState, K];
      } else {
        Bn = !0;
        var f;
        c === hi ? f = typeof p == "function" ? p() : p : f = k !== void 0 ? k(p) : p, Bn = !1, Ht.memoizedState = f;
        var S = Ht.queue = {
          last: null,
          dispatch: null
        }, A = S.dispatch = tu.bind(null, Lr, S);
        return [Ht.memoizedState, A];
      }
    }
    function Lo(c, p) {
      Lr = sa(), Ht = Dr();
      var k = p === void 0 ? null : p;
      if (Ht !== null) {
        var O = Ht.memoizedState;
        if (O !== null && k !== null) {
          var K = O[1];
          if (Sr(k, K))
            return O[0];
        }
      }
      Bn = !0;
      var oe = c();
      return Bn = !1, Ht.memoizedState = [oe, k], oe;
    }
    function ud(c) {
      Lr = sa(), Ht = Dr();
      var p = Ht.memoizedState;
      if (p === null) {
        var k = {
          current: c
        };
        return Object.seal(k), Ht.memoizedState = k, k;
      } else
        return p;
    }
    function eu(c, p) {
      Rr = "useLayoutEffect", r("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function tu(c, p, k) {
      if (la >= Ao)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (c === Lr) {
        oa = !0;
        var O = {
          action: k,
          next: null
        };
        lr === null && (lr = /* @__PURE__ */ new Map());
        var K = lr.get(p);
        if (K === void 0)
          lr.set(p, O);
        else {
          for (var oe = K; oe.next !== null; )
            oe = oe.next;
          oe.next = O;
        }
      }
    }
    function cd(c, p) {
      return Lo(function() {
        return c;
      }, p);
    }
    function dd(c, p, k) {
      return sa(), p(c._source);
    }
    function fd(c, p, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function hd(c) {
      return sa(), c;
    }
    function pd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function md() {
      return sa(), [!1, pd];
    }
    function gd() {
      var c = zl, p = ed(c.treeContext), k = $l;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var O = Jt++;
      return An(k, p, O);
    }
    function Ro() {
    }
    var nu = {
      readContext: ld,
      useContext: Qs,
      useMemo: Lo,
      useReducer: Js,
      useRef: ud,
      useState: sd,
      useInsertionEffect: Ro,
      useLayoutEffect: eu,
      useCallback: cd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Ro,
      // Effects are not run in the server environment.
      useEffect: Ro,
      // Debugging effect
      useDebugValue: Ro,
      useDeferredValue: hd,
      useTransition: md,
      useId: gd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: dd,
      useSyncExternalStore: fd
    }, $l = null;
    function pi(c) {
      $l = c;
    }
    function ru(c) {
      try {
        var p = "", k = c;
        do {
          switch (k.tag) {
            case 0:
              p += ai(k.type, null, null);
              break;
            case 1:
              p += Ws(k.type, null, null);
              break;
            case 2:
              p += uo(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return p;
      } catch (O) {
        return `
Error generating stack: ` + O.message + `
` + O.stack;
      }
    }
    var mi = n.ReactCurrentDispatcher, Do = n.ReactDebugCurrentFrame, Il = 0, $r = 1, Oo = 2, Mo = 3, ca = 4, au = 0, Hl = 1, da = 2, yd = 12800;
    function iu(c) {
      return console.error(c), null;
    }
    function Er() {
    }
    function vd(c, p, k, O, K, oe, pe, Re, l) {
      var f = [], S = /* @__PURE__ */ new Set(), A = {
        destination: null,
        responseState: p,
        progressiveChunkSize: O === void 0 ? yd : O,
        status: au,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: S,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: K === void 0 ? iu : K,
        onAllReady: oe === void 0 ? Er : oe,
        onShellReady: pe === void 0 ? Er : pe,
        onShellError: Re === void 0 ? Er : Re,
        onFatalError: l === void 0 ? Er : l
      }, z = _o(
        A,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      z.parentFlushed = !0;
      var J = Wl(A, c, null, z, S, na, js, Jc);
      return f.push(J), A;
    }
    function xd(c, p) {
      var k = c.pingedTasks;
      k.push(p), k.length === 1 && d(function() {
        return Si(c);
      });
    }
    function gi(c, p) {
      return {
        id: Cn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: p,
        errorDigest: null
      };
    }
    function Wl(c, p, k, O, K, oe, pe, Re) {
      c.allPendingTasks++, k === null ? c.pendingRootTasks++ : k.pendingTasks++;
      var l = {
        node: p,
        ping: function() {
          return xd(c, l);
        },
        blockedBoundary: k,
        blockedSegment: O,
        abortSet: K,
        legacyContext: oe,
        context: pe,
        treeContext: Re
      };
      return l.componentStack = null, K.add(l), l;
    }
    function _o(c, p, k, O, K, oe) {
      return {
        status: Il,
        id: -1,
        // lazily assigned later
        index: p,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: O,
        boundary: k,
        lastPushedText: K,
        textEmbedded: oe
      };
    }
    var Or = null;
    function yi() {
      return Or === null || Or.componentStack === null ? "" : ru(Or.componentStack);
    }
    function Ir(c, p) {
      c.componentStack = {
        tag: 0,
        parent: c.componentStack,
        type: p
      };
    }
    function kr(c, p) {
      c.componentStack = {
        tag: 1,
        parent: c.componentStack,
        type: p
      };
    }
    function Vl(c, p) {
      c.componentStack = {
        tag: 2,
        parent: c.componentStack,
        type: p
      };
    }
    function sr(c) {
      c.componentStack === null ? r("Unexpectedly popped too many stack frames. This is a bug in React.") : c.componentStack = c.componentStack.parent;
    }
    var Ma = null;
    function jl(c, p) {
      {
        var k;
        typeof p == "string" ? k = p : p && typeof p.message == "string" ? k = p.message : k = String(p);
        var O = Ma || yi();
        Ma = null, c.errorMessage = k, c.errorComponentStack = O;
      }
    }
    function ur(c, p) {
      var k = c.onError(p);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Hr(c, p) {
      var k = c.onShellError;
      k(p);
      var O = c.onFatalError;
      O(p), c.destination !== null ? (c.status = da, _(c.destination, p)) : (c.status = Hl, c.fatalError = p);
    }
    function Ul(c, p, k) {
      Ir(p, "Suspense");
      var O = p.blockedBoundary, K = p.blockedSegment, oe = k.fallback, pe = k.children, Re = /* @__PURE__ */ new Set(), l = gi(c, Re), f = K.chunks.length, S = _o(
        c,
        f,
        l,
        K.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      K.children.push(S), K.lastPushedText = !1;
      var A = _o(
        c,
        0,
        null,
        K.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      A.parentFlushed = !0, p.blockedBoundary = l, p.blockedSegment = A;
      try {
        if (es(c, p, pe), Xn(A.chunks, c.responseState, A.lastPushedText, A.textEmbedded), A.status = $r, zo(l, A), l.pendingTasks === 0) {
          sr(p);
          return;
        }
      } catch (J) {
        A.status = ca, l.forceClientRender = !0, l.errorDigest = ur(c, J), jl(l, J);
      } finally {
        p.blockedBoundary = O, p.blockedSegment = K;
      }
      var z = Wl(c, oe, O, S, Re, p.legacyContext, p.context, p.treeContext);
      z.componentStack = p.componentStack, c.pingedTasks.push(z), sr(p);
    }
    function vi(c, p, k, O) {
      Ir(p, k);
      var K = p.blockedSegment, oe = Xa(K.chunks, k, O, c.responseState, K.formatContext);
      K.lastPushedText = !1;
      var pe = K.formatContext;
      K.formatContext = Qt(pe, k, O), es(c, p, oe), K.formatContext = pe, Ki(K.chunks, k), K.lastPushedText = !1, sr(p);
    }
    function No(c) {
      return c.prototype && c.prototype.isReactComponent;
    }
    function ou(c, p, k, O, K) {
      var oe = {};
      od(p, oe);
      var pe = k(O, K);
      return Zs(k, O, pe, K);
    }
    function lu(c, p, k, O, K) {
      var oe = k.render();
      k.props !== K && (bi || r("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xn(O) || "a component"), bi = !0);
      {
        var pe = O.childContextTypes;
        if (pe != null) {
          var Re = p.legacyContext, l = Dl(k, O, Re, pe);
          p.legacyContext = l, nr(c, p, oe), p.legacyContext = Re;
          return;
        }
      }
      nr(c, p, oe);
    }
    function bd(c, p, k, O) {
      Vl(p, k);
      var K = Rl(k, p.legacyContext), oe = Xs(k, O, K);
      Gs(oe, k, O, K), lu(c, p, oe, k, O), sr(p);
    }
    var Kl = {}, xi = {}, su = {}, Yl = {}, bi = !1, Xl = !1, ql = !1, Gl = !1;
    function uu(c, p, k, O) {
      var K;
      if (K = Rl(k, p.legacyContext), kr(p, k), k.prototype && typeof k.prototype.render == "function") {
        var oe = xn(k) || "Unknown";
        Kl[oe] || (r("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", oe, oe), Kl[oe] = !0);
      }
      var pe = ou(c, p, k, O, K), Re = Po();
      if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0) {
        var l = xn(k) || "Unknown";
        xi[l] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), xi[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0
      ) {
        {
          var f = xn(k) || "Unknown";
          xi[f] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), xi[f] = !0);
        }
        Gs(pe, k, O, K), lu(c, p, pe, k, O);
      } else if (cu(k), Re) {
        var S = p.treeContext, A = 1, z = 0;
        p.treeContext = ko(S, A, z);
        try {
          nr(c, p, pe);
        } finally {
          p.treeContext = S;
        }
      } else
        nr(c, p, pe);
      sr(p);
    }
    function cu(c) {
      {
        if (c && c.childContextTypes && r("%s(...): childContextTypes cannot be defined on a function component.", c.displayName || c.name || "Component"), typeof c.getDerivedStateFromProps == "function") {
          var p = xn(c) || "Unknown";
          Yl[p] || (r("%s: Function components do not support getDerivedStateFromProps.", p), Yl[p] = !0);
        }
        if (typeof c.contextType == "object" && c.contextType !== null) {
          var k = xn(c) || "Unknown";
          su[k] || (r("%s: Function components do not support contextType.", k), su[k] = !0);
        }
      }
    }
    function Zl(c, p) {
      if (c && c.defaultProps) {
        var k = or({}, p), O = c.defaultProps;
        for (var K in O)
          k[K] === void 0 && (k[K] = O[K]);
        return k;
      }
      return p;
    }
    function Sd(c, p, k, O, K) {
      kr(p, k.render);
      var oe = ou(c, p, k.render, O, K), pe = Po();
      if (pe) {
        var Re = p.treeContext, l = 1, f = 0;
        p.treeContext = ko(Re, l, f);
        try {
          nr(c, p, oe);
        } finally {
          p.treeContext = Re;
        }
      } else
        nr(c, p, oe);
      sr(p);
    }
    function Ed(c, p, k, O, K) {
      var oe = k.type, pe = Zl(oe, O);
      Ql(c, p, oe, pe, K);
    }
    function du(c, p, k, O) {
      k._context === void 0 ? k !== k.Consumer && (Gl || (Gl = !0, r("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var K = O.children;
      typeof K != "function" && r("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var oe = ci(k), pe = K(oe);
      nr(c, p, pe);
    }
    function kd(c, p, k, O) {
      var K = k._context, oe = O.value, pe = O.children, Re;
      Re = p.context, p.context = Us(K, oe), nr(c, p, pe), p.context = Ks(K), Re !== p.context && r("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function wd(c, p, k, O, K) {
      Ir(p, "Lazy");
      var oe = k._payload, pe = k._init, Re = pe(oe), l = Zl(Re, O);
      Ql(c, p, Re, l, K), sr(p);
    }
    function Ql(c, p, k, O, K) {
      if (typeof k == "function")
        if (No(k)) {
          bd(c, p, k, O);
          return;
        } else {
          uu(c, p, k, O);
          return;
        }
      if (typeof k == "string") {
        vi(c, p, k, O);
        return;
      }
      switch (k) {
        case lo:
        case vl:
        case Fs:
        case gl:
        case tr: {
          nr(c, p, O.children);
          return;
        }
        case ti: {
          Ir(p, "SuspenseList"), nr(c, p, O.children), sr(p);
          return;
        }
        case yl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ei: {
          Ul(c, p, O);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case oo: {
            Sd(c, p, k, O, K);
            return;
          }
          case ni: {
            Ed(c, p, k, O, K);
            return;
          }
          case ao: {
            kd(c, p, k, O);
            return;
          }
          case io: {
            du(c, p, k, O);
            return;
          }
          case Ca: {
            wd(c, p, k, O);
            return;
          }
        }
      var oe = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + oe));
    }
    function Td(c, p) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      c[Symbol.toStringTag] === "Generator" && (Xl || r("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Xl = !0), c.entries === p && (ql || r("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ql = !0);
    }
    function nr(c, p, k) {
      try {
        return Jl(c, p, k);
      } catch (O) {
        throw typeof O == "object" && O !== null && typeof O.then == "function" || (Ma = Ma !== null ? Ma : yi()), O;
      }
    }
    function Jl(c, p, k) {
      if (p.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Kc: {
            var O = k, K = O.type, oe = O.props, pe = O.ref;
            Ql(c, p, K, oe, pe);
            return;
          }
          case Ns:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ca: {
            var Re = k, l = Re._payload, f = Re._init, S;
            try {
              S = f(l);
            } catch (st) {
              throw typeof st == "object" && st !== null && typeof st.then == "function" && Ir(p, "Lazy"), st;
            }
            nr(c, p, S);
            return;
          }
        }
        if (W(k)) {
          fu(c, p, k);
          return;
        }
        var A = qc(k);
        if (A) {
          Td(k, A);
          var z = A.call(k);
          if (z) {
            var J = z.next();
            if (!J.done) {
              var de = [];
              do
                de.push(J.value), J = z.next();
              while (!J.done);
              fu(c, p, de);
              return;
            }
            return;
          }
        }
        var Pe = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (Pe === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : Pe) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var We = p.blockedSegment;
        We.lastPushedText = Zn(p.blockedSegment.chunks, k, c.responseState, We.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var tt = p.blockedSegment;
        tt.lastPushedText = Zn(p.blockedSegment.chunks, "" + k, c.responseState, tt.lastPushedText);
        return;
      }
      typeof k == "function" && r("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function fu(c, p, k) {
      for (var O = k.length, K = 0; K < O; K++) {
        var oe = p.treeContext;
        p.treeContext = ko(oe, O, K);
        try {
          es(c, p, k[K]);
        } finally {
          p.treeContext = oe;
        }
      }
    }
    function rr(c, p, k) {
      var O = p.blockedSegment, K = O.chunks.length, oe = _o(
        c,
        K,
        null,
        O.formatContext,
        // Adopt the parent segment's leading text embed
        O.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      O.children.push(oe), O.lastPushedText = !1;
      var pe = Wl(c, p.node, p.blockedBoundary, oe, p.abortSet, p.legacyContext, p.context, p.treeContext);
      p.componentStack !== null && (pe.componentStack = p.componentStack.parent);
      var Re = pe.ping;
      k.then(Re, Re);
    }
    function es(c, p, k) {
      var O = p.blockedSegment.formatContext, K = p.legacyContext, oe = p.context, pe = null;
      pe = p.componentStack;
      try {
        return nr(c, p, k);
      } catch (Re) {
        if (Bl(), typeof Re == "object" && Re !== null && typeof Re.then == "function") {
          rr(c, p, Re), p.blockedSegment.formatContext = O, p.legacyContext = K, p.context = oe, ui(oe), p.componentStack = pe;
          return;
        } else
          throw p.blockedSegment.formatContext = O, p.legacyContext = K, p.context = oe, ui(oe), p.componentStack = pe, Re;
      }
    }
    function hu(c, p, k, O) {
      var K = ur(c, O);
      if (p === null ? Hr(c, O) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = !0, p.errorDigest = K, jl(p, O), p.parentFlushed && c.clientRenderedBoundaries.push(p))), c.allPendingTasks--, c.allPendingTasks === 0) {
        var oe = c.onAllReady;
        oe();
      }
    }
    function Cd(c) {
      var p = this, k = c.blockedBoundary, O = c.blockedSegment;
      O.status = Mo, pu(p, k, O);
    }
    function Fo(c, p, k) {
      var O = c.blockedBoundary, K = c.blockedSegment;
      if (K.status = Mo, O === null)
        p.allPendingTasks--, p.status !== da && (p.status = da, p.destination !== null && E(p.destination));
      else {
        if (O.pendingTasks--, !O.forceClientRender) {
          O.forceClientRender = !0;
          var oe = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          O.errorDigest = p.onError(oe);
          {
            var pe = "The server did not finish this Suspense boundary: ";
            oe && typeof oe.message == "string" ? oe = pe + oe.message : oe = pe + String(oe);
            var Re = Or;
            Or = c;
            try {
              jl(O, oe);
            } finally {
              Or = Re;
            }
          }
          O.parentFlushed && p.clientRenderedBoundaries.push(O);
        }
        if (O.fallbackAbortableTasks.forEach(function(f) {
          return Fo(f, p, k);
        }), O.fallbackAbortableTasks.clear(), p.allPendingTasks--, p.allPendingTasks === 0) {
          var l = p.onAllReady;
          l();
        }
      }
    }
    function zo(c, p) {
      if (p.chunks.length === 0 && p.children.length === 1 && p.children[0].boundary === null) {
        var k = p.children[0];
        k.id = p.id, k.parentFlushed = !0, k.status === $r && zo(c, k);
      } else {
        var O = c.completedSegments;
        O.push(p);
      }
    }
    function pu(c, p, k) {
      if (p === null) {
        if (k.parentFlushed) {
          if (c.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          c.completedRootSegment = k;
        }
        if (c.pendingRootTasks--, c.pendingRootTasks === 0) {
          c.onShellError = Er;
          var O = c.onShellReady;
          O();
        }
      } else if (p.pendingTasks--, !p.forceClientRender) {
        if (p.pendingTasks === 0)
          k.parentFlushed && k.status === $r && zo(p, k), p.parentFlushed && c.completedBoundaries.push(p), p.fallbackAbortableTasks.forEach(Cd, c), p.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === $r) {
          zo(p, k);
          var K = p.completedSegments;
          K.length === 1 && p.parentFlushed && c.partialBoundaries.push(p);
        }
      }
      if (c.allPendingTasks--, c.allPendingTasks === 0) {
        var oe = c.onAllReady;
        oe();
      }
    }
    function mu(c, p) {
      var k = p.blockedSegment;
      if (k.status === Il) {
        ui(p.context);
        var O = null;
        O = Or, Or = p;
        try {
          nr(c, p, p.node), Xn(k.chunks, c.responseState, k.lastPushedText, k.textEmbedded), p.abortSet.delete(p), k.status = $r, pu(c, p.blockedBoundary, k);
        } catch (oe) {
          if (Bl(), typeof oe == "object" && oe !== null && typeof oe.then == "function") {
            var K = p.ping;
            oe.then(K, K);
          } else
            p.abortSet.delete(p), k.status = ca, hu(c, p.blockedBoundary, k, oe);
        } finally {
          Or = O;
        }
      }
    }
    function Si(c) {
      if (c.status !== da) {
        var p = po(), k = mi.current;
        mi.current = nu;
        var O;
        O = Do.getCurrentStack, Do.getCurrentStack = yi;
        var K = $l;
        pi(c.responseState);
        try {
          var oe = c.pingedTasks, pe;
          for (pe = 0; pe < oe.length; pe++) {
            var Re = oe[pe];
            mu(c, Re);
          }
          oe.splice(0, pe), c.destination !== null && $o(c, c.destination);
        } catch (l) {
          ur(c, l), Hr(c, l);
        } finally {
          pi(K), mi.current = k, Do.getCurrentStack = O, k === nu && ui(p);
        }
      }
    }
    function Ei(c, p, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Il: {
          var O = k.id = c.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, ya(p, c.responseState, O);
        }
        case $r: {
          k.status = Oo;
          for (var K = !0, oe = k.chunks, pe = 0, Re = k.children, l = 0; l < Re.length; l++) {
            for (var f = Re[l]; pe < f.index; pe++)
              y(p, oe[pe]);
            K = Bo(c, p, f);
          }
          for (; pe < oe.length - 1; pe++)
            y(p, oe[pe]);
          return pe < oe.length && (K = v(p, oe[pe])), K;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Bo(c, p, k) {
      var O = k.boundary;
      if (O === null)
        return Ei(c, p, k);
      if (O.parentFlushed = !0, O.forceClientRender)
        return jn(p, c.responseState, O.errorDigest, O.errorMessage, O.errorComponentStack), Ei(c, p, k), dl(p, c.responseState);
      if (O.pendingTasks > 0) {
        O.rootSegmentID = c.nextSegmentId++, O.completedSegments.length > 0 && c.partialBoundaries.push(O);
        var K = O.id = un(c.responseState);
        return ba(p, c.responseState, K), Ei(c, p, k), Sa(p, c.responseState);
      } else {
        if (O.byteSize > c.progressiveChunkSize)
          return O.rootSegmentID = c.nextSegmentId++, c.completedBoundaries.push(O), ba(p, c.responseState, O.id), Ei(c, p, k), Sa(p, c.responseState);
        Xi(p, c.responseState);
        var oe = O.completedSegments;
        if (oe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var pe = oe[0];
        return Bo(c, p, pe), qi(p, c.responseState);
      }
    }
    function gu(c, p, k) {
      return Ms(p, c.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function ki(c, p, k) {
      return Pt(p, c.responseState, k.formatContext, k.id), Bo(c, p, k), an(p, k.formatContext);
    }
    function wi(c, p, k) {
      for (var O = k.completedSegments, K = 0; K < O.length; K++) {
        var oe = O[K];
        ts(c, p, k, oe);
      }
      return O.length = 0, fl(p, c.responseState, k.id, k.rootSegmentID);
    }
    function Ad(c, p, k) {
      for (var O = k.completedSegments, K = 0; K < O.length; K++) {
        var oe = O[K];
        if (!ts(c, p, k, oe))
          return K++, O.splice(0, K), !1;
      }
      return O.splice(0, K), !0;
    }
    function ts(c, p, k, O) {
      if (O.status === Oo)
        return !0;
      var K = O.id;
      if (K === -1) {
        var oe = O.id = k.rootSegmentID;
        if (oe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ki(c, p, O);
      } else
        return ki(c, p, O), Bc(p, c.responseState, K);
    }
    function $o(c, p) {
      m();
      try {
        var k = c.completedRootSegment;
        k !== null && c.pendingRootTasks === 0 && (Bo(c, p, k), c.completedRootSegment = null, sl(p, c.responseState));
        var O = c.clientRenderedBoundaries, K;
        for (K = 0; K < O.length; K++) {
          var oe = O[K];
          gu(c, p, oe);
        }
        O.splice(0, K);
        var pe = c.completedBoundaries;
        for (K = 0; K < pe.length; K++) {
          var Re = pe[K];
          wi(c, p, Re);
        }
        pe.splice(0, K), w(p), m(p);
        var l = c.partialBoundaries;
        for (K = 0; K < l.length; K++) {
          var f = l[K];
          if (!Ad(c, p, f)) {
            c.destination = null, K++, l.splice(0, K);
            return;
          }
        }
        l.splice(0, K);
        var S = c.completedBoundaries;
        for (K = 0; K < S.length; K++) {
          var A = S[K];
          wi(c, p, A);
        }
        S.splice(0, K);
      } finally {
        w(p), c.allPendingTasks === 0 && c.pingedTasks.length === 0 && c.clientRenderedBoundaries.length === 0 && c.completedBoundaries.length === 0 && (c.abortableTasks.size !== 0 && r("There was still abortable task at the root when we closed. This is a bug in React."), E(p));
      }
    }
    function Pd(c) {
      d(function() {
        return Si(c);
      });
    }
    function yu(c, p) {
      if (c.status === Hl) {
        c.status = da, _(p, c.fatalError);
        return;
      }
      if (c.status !== da && c.destination === null) {
        c.destination = p;
        try {
          $o(c, p);
        } catch (k) {
          ur(c, k), Hr(c, k);
        }
      }
    }
    function Io(c, p) {
      try {
        var k = c.abortableTasks;
        k.forEach(function(O) {
          return Fo(O, c, p);
        }), k.clear(), c.destination !== null && $o(c, c.destination);
      } catch (O) {
        ur(c, O), Hr(c, O);
      }
    }
    function Ld(c, p) {
      return new Promise(function(k, O) {
        var K, oe, pe = new Promise(function(z, J) {
          oe = z, K = J;
        });
        function Re() {
          var z = new ReadableStream(
            {
              type: "bytes",
              pull: function(J) {
                yu(f, J);
              },
              cancel: function(J) {
                Io(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          z.allReady = pe, k(z);
        }
        function l(z) {
          pe.catch(function() {
          }), O(z);
        }
        var f = vd(c, Kt(p ? p.identifierPrefix : void 0, p ? p.nonce : void 0, p ? p.bootstrapScriptContent : void 0, p ? p.bootstrapScripts : void 0, p ? p.bootstrapModules : void 0), nn(p ? p.namespaceURI : void 0), p ? p.progressiveChunkSize : void 0, p ? p.onError : void 0, oe, Re, l, K);
        if (p && p.signal) {
          var S = p.signal, A = function() {
            Io(f, S.reason), S.removeEventListener("abort", A);
          };
          S.addEventListener("abort", A);
        }
        Pd(f);
      });
    }
    _u.renderToReadableStream = Ld, _u.version = t;
  }()), _u;
}
var Hi, Df;
process.env.NODE_ENV === "production" ? (Hi = RE(), Df = DE()) : (Hi = OE(), Df = ME());
ja.version = Hi.version;
ja.renderToString = Hi.renderToString;
ja.renderToStaticMarkup = Hi.renderToStaticMarkup;
ja.renderToNodeStream = Hi.renderToNodeStream;
ja.renderToStaticNodeStream = Hi.renderToStaticNodeStream;
ja.renderToReadableStream = Df.renderToReadableStream;
const _E = ({ width: e, height: t, runtime: n }) => {
  var Se, ye;
  const { config: i } = ce.useContext(Ct), { sankey: r } = i, o = i == null ? void 0 : i.data[0], [d, u] = ce.useState(0), s = ce.useRef([]), [h, m] = ce.useState(""), y = (ee) => {
    m(ee);
  }, v = () => {
    m("");
  }, [w, E] = ce.useState(!1);
  ce.useEffect(() => {
    window.innerWidth < 768 && window.innerHeight > window.innerWidth && E(!0);
  }, [window.innerWidth]);
  const R = () => {
    E(!1);
  };
  ce.useEffect(() => {
    var Ee;
    let ee = 0;
    (Ee = s == null ? void 0 : s.current) == null || Ee.map((He) => {
      const we = He == null ? void 0 : He.getBoundingClientRect().width;
      we > ee && (ee = we);
    }), u(ee);
  }, [s, r, window.innerWidth]);
  const C = Array.from(new Set((Se = o == null ? void 0 : o.links) == null ? void 0 : Se.flatMap((ee) => [ee.source, ee.target]))), g = {
    nodes: C.map((ee) => ({ id: ee })),
    links: (ye = o == null ? void 0 : o.links) == null ? void 0 : ye.map((ee) => ({
      source: C.findIndex((Ee) => Ee === ee.source),
      target: C.findIndex((Ee) => Ee === ee.target),
      value: ee.value
    }))
  };
  let _ = 5;
  const P = 50, M = CE().nodeWidth(r.nodeSize.nodeWidth).nodePadding(r.nodePadding).iterations(r.iterations).nodeAlign(SE).extent([
    [r.margin.margin_x, Number(r.margin.margin_y)],
    [e - _ - d, i.heights.vertical - P]
  ]), { nodes: N, links: T } = M(g), U = (ee) => {
    var Ae;
    let Ee = 30, He = 0, we = "node-value--storynode", fe = !0;
    return (Ae = o == null ? void 0 : o.storyNodeText) != null && Ae.every((ne) => ne.StoryNode !== ee) && (fe = !1, He = 10, Ee = 8, we = "node-value"), { textPositionHorizontal: Ee, textPositionVertical: He, classStyle: we, storyNodes: fe };
  }, V = (ee) => {
    const Ee = g.nodes.find((fe) => fe.id === ee), He = [], we = [];
    return Ee && (T.forEach((fe) => {
      const Ae = fe.target, ne = fe.source;
      Ae.id === ee && He.push(ne.id);
    }), He.forEach((fe) => {
      T.forEach((Ae) => {
        const ne = Ae.target, $e = Ae.source;
        ne.id === h && $e.id === fe && we.push(Ae);
      });
    })), { sourceNodes: He, activeLinks: we };
  }, G = `${((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).value}`, ue = `${((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).summary}`, Z = ((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).column1Label, $ = ((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).column2Label, H = ((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).column1, j = ((o == null ? void 0 : o.tooltips.find((ee) => ee.node === h)) || {}).column2, F = ({ columnData: ee }) => /* @__PURE__ */ a.createElement("ul", null, ee == null ? void 0 : ee.map((Ee, He) => /* @__PURE__ */ a.createElement("li", { key: He }, Ee.label, ": ", Ee.value, " (", Ee.additional_info, "%)"))), X = ja.renderToString(/* @__PURE__ */ a.createElement(F, { columnData: H })), Q = ja.renderToString(/* @__PURE__ */ a.createElement(F, { columnData: j })), ae = `<div class="sankey-chart__tooltip">
                    <span class="sankey-chart__tooltip--tooltip-header">${h}</span>
                    <span class="sankey-chart__tooltip--tooltip-header">${G}</span>
                    <div class="divider"></div>
                    <span><strong>Summary: </strong>${ue}</span>
                    <div class="divider"></div>
                      <div class="sankey-chart__tooltip--info-section">
                        <div>
                          <span><strong>${Z}<strong></span>
                          ${X}
                        </div>
                        <div>
                          <span><strong>${$}<strong></span>
                          ${Q}
                        </div>
                      </div>
                    </div>`, te = g.nodes.map((ee, Ee) => {
    var Ke, Ge;
    let { textPositionHorizontal: He, textPositionVertical: we, classStyle: fe, storyNodes: Ae } = U(ee.id), { sourceNodes: ne } = V(h), $e = r.opacity.nodeOpacityDefault, Le = r.nodeColor.default;
    return h !== ee.id && h !== "" && !ne.includes(ee.id) && (Le = r.nodeColor.inactive, $e = r.opacity.nodeOpacityInactive), /* @__PURE__ */ a.createElement(nt, { className: "", key: Ee }, /* @__PURE__ */ a.createElement(
      "rect",
      {
        height: ee.y1 - ee.y0 + 2,
        width: M.nodeWidth(),
        x: ee.x0,
        y: ee.y0 - 1,
        fill: Le,
        fillOpacity: $e,
        rx: r.rxValue,
        "data-tooltip-html": o.tooltips && i.enableTooltips ? ae : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        onClick: () => y(ee.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Ae ? /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
      vt,
      {
        x: ee.x0 + He,
        textAnchor: g.nodes.length - 1 === Ee ? "end" : "start",
        verticalAnchor: "end",
        y: (ee.y1 + ee.y0) / 2 - 30,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((Ke = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ke.find((et) => et.StoryNode === ee.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ a.createElement(vt, { verticalAnchor: "end", className: fe, x: ee.x0 + He, y: (ee.y1 + ee.y0 + 25) / 2, fill: r.storyNodeFontColor || r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof ee.value == "number" ? ee.value.toLocaleString() : ee.value), /* @__PURE__ */ a.createElement(
      vt,
      {
        x: ee.x0 + He,
        y: (ee.y1 + ee.y0) / 2 + 50,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: g.nodes.length === Ee ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Ge = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ge.find((et) => et.StoryNode === ee.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("text", { x: ee.x0 + He, y: (ee.y1 + ee.y0) / 2 + we, dominantBaseline: "text-before-edge", fill: r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ a.createElement("tspan", { id: ee.id, className: "node-id" }, ee.id)), /* @__PURE__ */ a.createElement(
      "text",
      {
        x: ee.x0 + He,
        y: (ee.y1 + ee.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ a.createElement("tspan", { className: fe }, r.nodeValueStyle.textBefore + (typeof ee.value == "number" ? ee.value.toLocaleString() : ee.value) + r.nodeValueStyle.textAfter)
    )));
  }), re = T.map((ee, Ee) => {
    const we = LE()(ee);
    let fe = r.opacity.LinkOpacityDefault, Ae = r.linkColor.default, { activeLinks: ne } = V(h);
    return !ne.includes(ee) && h !== "" && (Ae = r.linkColor.inactive, fe = r.opacity.LinkOpacityInactive), /* @__PURE__ */ a.createElement("path", { key: Ee, d: we, stroke: Ae, fill: "none", strokeOpacity: fe, strokeWidth: ee.width + 2 });
  }), ie = g.nodes.reduce((ee, Ee) => Math.max(ee, Ee.depth), -1), ve = g.nodes.filter((ee) => ee.depth === ie).map((ee, Ee) => {
    var Ke, Ge;
    let { textPositionHorizontal: He, textPositionVertical: we, classStyle: fe, storyNodes: Ae } = U(ee.id), { sourceNodes: ne } = V(h), $e = r.opacity.nodeOpacityDefault, Le = r.nodeColor.default;
    return h !== ee.id && h !== "" && !ne.includes(ee.id) && (Le = r.nodeColor.inactive, $e = r.opacity.nodeOpacityInactive), /* @__PURE__ */ a.createElement(nt, { className: "", key: Ee, innerRef: (et) => s.current[Ee] = et }, /* @__PURE__ */ a.createElement(
      "rect",
      {
        height: ee.y1 - ee.y0 + 2,
        width: M.nodeWidth(),
        x: ee.x0,
        y: ee.y0 - 1,
        fill: Le,
        fillOpacity: $e,
        rx: r.rxValue,
        "data-tooltip-html": o.tooltips && i.enableTooltips ? ae : null,
        "data-tooltip-id": "tooltip",
        onClick: () => y(ee.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Ae ? /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
      vt,
      {
        x: ee.x0 + He,
        textAnchor: g.nodes.length - 1 === Ee ? "end" : "start",
        verticalAnchor: "end",
        y: (ee.y1 + ee.y0) / 2 - 30,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((Ke = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ke.find((et) => et.StoryNode === ee.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ a.createElement(vt, { verticalAnchor: "end", className: fe, x: ee.x0 + He, y: (ee.y1 + ee.y0 + 25) / 2, fill: r.storyNodeFontColor || r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof ee.value == "number" ? ee.value.toLocaleString() : ee.value), /* @__PURE__ */ a.createElement(
      vt,
      {
        x: ee.x0 + He,
        y: (ee.y1 + ee.y0) / 2 + 50,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: g.nodes.length === Ee ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Ge = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ge.find((et) => et.StoryNode === ee.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("text", { x: ee.x0 + He, y: (ee.y1 + ee.y0) / 2 + we, dominantBaseline: "text-before-edge", fill: r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ a.createElement("tspan", { id: ee.id, className: "node-id" }, ee.id)), /* @__PURE__ */ a.createElement(
      "text",
      {
        x: ee.x0 + He,
        y: (ee.y1 + ee.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ a.createElement("tspan", { className: fe }, r.nodeValueStyle.textBefore + (typeof ee.value == "number" ? ee.value.toLocaleString() : ee.value) + r.nodeValueStyle.textAfter)
    )));
  });
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ a.createElement("svg", { className: "sankey-chart__diagram", width: e, height: Number(i.heights.vertical), style: { overflow: "visible" } }, /* @__PURE__ */ a.createElement(nt, { className: "links" }, re), /* @__PURE__ */ a.createElement(nt, { className: "nodes" }, te), /* @__PURE__ */ a.createElement(nt, { className: "finalNodes", style: { display: "none" } }, ve)), /* @__PURE__ */ a.createElement(ly, { id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`, afterHide: () => v(), events: ["click"], place: "bottom", style: { backgroundColor: "rgba(238, 238, 238, 1)", color: "black", boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)" } }), w && /* @__PURE__ */ a.createElement("div", { className: "popup" }, /* @__PURE__ */ a.createElement("div", { className: "popup-content" }, /* @__PURE__ */ a.createElement("button", { className: "visually-hidden", onClick: R }, "Select for accessible version."), /* @__PURE__ */ a.createElement("p", null, /* @__PURE__ */ a.createElement("strong", null, "Please change the orientation of your screen or increase the size of your browser to view the diagram better."))))));
};
var NE = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const ir = NE;
function FE(e) {
  var t = e.labelOffset, n = e.labelProps, i = e.orientation, r = e.range, o = e.tickLabelFontSize, d = e.tickLength, u = i === ir.left || i === ir.top ? -1 : 1, s, h, m;
  if (i === ir.top || i === ir.bottom) {
    var y = i === ir.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    s = (Number(r[0]) + Number(r[r.length - 1])) / 2, h = u * (d + t + o + y);
  } else
    s = u * ((Number(r[0]) + Number(r[r.length - 1])) / 2), h = -(d + t), m = "rotate(" + u * 90 + ")";
  return {
    x: s,
    y: h,
    transform: m
  };
}
function xs() {
  return xs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, xs.apply(this, arguments);
}
function zE(e) {
  var t = e.hideTicks, n = e.horizontal, i = e.orientation, r = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, u = e.tickStroke, s = u === void 0 ? "#222" : u, h = e.tickTransform, m = e.ticks, y = e.strokeWidth, v = e.tickLineProps;
  return m.map(function(w) {
    var E, R = w.value, C = w.index, g = w.from, _ = w.to, P = w.formattedValue, M = (E = d[C]) != null ? E : {}, N = Math.max(10, typeof M.fontSize == "number" && M.fontSize || 0), T = _.y + (n && i !== ir.top ? N : 0);
    return /* @__PURE__ */ a.createElement(nt, {
      key: "visx-tick-" + R + "-" + C,
      className: On("visx-axis-tick", r),
      transform: h
    }, !t && /* @__PURE__ */ a.createElement(on, xs({
      from: g,
      to: _,
      stroke: s,
      strokeWidth: y,
      strokeLinecap: "square"
    }, v)), o ? o(xs({}, M, {
      x: _.x,
      y: T,
      formattedValue: P
    })) : /* @__PURE__ */ a.createElement(vt, xs({
      x: _.x,
      y: T
    }, M), P));
  });
}
function mc() {
  return mc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, mc.apply(this, arguments);
}
var lm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function BE(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, i = e.axisToPoint, r = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, u = e.label, s = u === void 0 ? "" : u, h = e.labelClassName, m = e.labelOffset, y = m === void 0 ? 14 : m, v = e.labelProps, w = v === void 0 ? lm : v, E = e.orientation, R = E === void 0 ? ir.bottom : E, C = e.scale, g = e.stroke, _ = g === void 0 ? "#222" : g, P = e.strokeDasharray, M = e.strokeWidth, N = M === void 0 ? 1 : M, T = e.tickClassName, U = e.tickComponent, V = e.tickLineProps, G = e.tickLabelProps, ue = e.tickLength, Z = ue === void 0 ? 8 : ue, $ = e.tickStroke, H = $ === void 0 ? "#222" : $, j = e.tickTransform, F = e.ticks, X = e.ticksComponent, Q = X === void 0 ? zE : X, ae = mc({}, lm, typeof G == "object" ? G : null), te = F.map(function(ie) {
    var ge = ie.value, ve = ie.index;
    return typeof G == "function" ? G(ge, ve, F) : ae;
  }), re = Math.max.apply(Math, [10].concat(te.map(function(ie) {
    return typeof ie.fontSize == "number" ? ie.fontSize : 0;
  })));
  return /* @__PURE__ */ a.createElement(a.Fragment, null, Q({
    hideTicks: o,
    horizontal: d,
    orientation: R,
    scale: C,
    tickClassName: T,
    tickComponent: U,
    tickLabelProps: te,
    tickStroke: H,
    tickTransform: j,
    ticks: F,
    strokeWidth: N,
    tickLineProps: V
  }), !r && /* @__PURE__ */ a.createElement(on, {
    className: On("visx-axis-line", n),
    from: t,
    to: i,
    stroke: _,
    strokeWidth: N,
    strokeDasharray: P
  }), s && /* @__PURE__ */ a.createElement(vt, mc({
    className: On("visx-axis-label", h)
  }, FE({
    labelOffset: y,
    labelProps: w,
    orientation: R,
    range: C.range(),
    tickLabelFontSize: re,
    tickLength: Z
  }), w), s));
}
function $E(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var i = n.bandwidth();
    return t === "center" && (i /= 2), n.round() && (i = Math.round(i)), function(r) {
      var o = n(r);
      return typeof o == "number" ? o + i : o;
    };
  }
  return e;
}
function IE(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : Lv;
}
function Nu(e, t) {
  var n = e.x, i = e.y;
  return new rl(t ? {
    x: n,
    y: i
  } : {
    x: i,
    y: n
  });
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var Gd = 0;
function HE(e) {
  return e === void 0 && (e = Gd), typeof e == "number" ? {
    start: e,
    end: e
  } : Of({
    start: Gd,
    end: Gd
  }, e);
}
var WE = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Mf() {
  return Mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Mf.apply(this, arguments);
}
function VE(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Oc(e) {
  var t = e.children, n = t === void 0 ? BE : t, i = e.axisClassName, r = e.hideAxisLine, o = r === void 0 ? !1 : r, d = e.hideTicks, u = d === void 0 ? !1 : d, s = e.hideZero, h = s === void 0 ? !1 : s, m = e.innerRef, y = e.left, v = y === void 0 ? 0 : y, w = e.numTicks, E = w === void 0 ? 10 : w, R = e.orientation, C = R === void 0 ? ir.bottom : R, g = e.rangePadding, _ = g === void 0 ? 0 : g, P = e.scale, M = e.tickFormat, N = e.tickLength, T = N === void 0 ? 8 : N, U = e.tickValues, V = e.top, G = V === void 0 ? 0 : V, ue = VE(e, WE), Z = M ?? IE(P), $ = C === ir.left, H = C === ir.top, j = H || C === ir.bottom, F = $E(P), X = $ || H ? -1 : 1, Q = P.range(), ae = HE(_), te = Nu({
    x: Number(Q[0]) + 0.5 - ae.start,
    y: 0
  }, j), re = Nu({
    x: Number(Q[Q.length - 1]) + 0.5 + ae.end,
    y: 0
  }, j), ie = (U ?? Pv(P, E)).filter(function(ve) {
    return !h || ve !== 0 && ve !== "0";
  }).map(function(ve, Se) {
    return {
      value: ve,
      index: Se
    };
  }), ge = ie.map(function(ve) {
    var Se = ve.value, ye = ve.index, ee = Av(F(Se));
    return {
      value: Se,
      index: ye,
      from: Nu({
        x: ee,
        y: 0
      }, j),
      to: Nu({
        x: ee,
        y: T * X
      }, j),
      formattedValue: Z(Se, ye, ie)
    };
  });
  return /* @__PURE__ */ a.createElement(nt, {
    className: On("visx-axis", i),
    innerRef: m,
    top: G,
    left: v
  }, n(Mf({}, ue, {
    axisFromPoint: te,
    axisToPoint: re,
    hideAxisLine: o,
    hideTicks: u,
    hideZero: h,
    horizontal: j,
    numTicks: E,
    orientation: C,
    rangePadding: _,
    scale: P,
    tickFormat: Z,
    tickLength: T,
    tickPosition: F,
    tickSign: X,
    ticks: ge
  })));
}
var jE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function gc() {
  return gc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, gc.apply(this, arguments);
}
function UE(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var KE = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function YE(e) {
  var t = e.axisClassName, n = e.labelOffset, i = n === void 0 ? 36 : n, r = e.tickLength, o = r === void 0 ? 8 : r, d = e.tickLabelProps, u = UE(e, jE), s = typeof d == "function" ? d : gc({}, KE, d);
  return /* @__PURE__ */ a.createElement(Oc, gc({
    axisClassName: On("visx-axis-left", t),
    labelOffset: i,
    orientation: ir.left,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var XE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function yc() {
  return yc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, yc.apply(this, arguments);
}
function qE(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var GE = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function ZE(e) {
  var t = e.axisClassName, n = e.labelOffset, i = n === void 0 ? 36 : n, r = e.tickLength, o = r === void 0 ? 8 : r, d = e.tickLabelProps, u = qE(e, XE), s = typeof d == "function" ? d : yc({}, GE, d);
  return /* @__PURE__ */ a.createElement(Oc, yc({
    axisClassName: On("visx-axis-right", t),
    labelOffset: i,
    orientation: ir.right,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var QE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function JE(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var ek = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function tk(e) {
  var t = e.axisClassName, n = e.labelOffset, i = n === void 0 ? 8 : n, r = e.tickLength, o = r === void 0 ? 8 : r, d = e.tickLabelProps, u = JE(e, QE), s = typeof d == "function" ? d : vc({}, ek, d);
  return /* @__PURE__ */ a.createElement(Oc, vc({
    axisClassName: On("visx-axis-top", t),
    labelOffset: i,
    orientation: ir.top,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var nk = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function rk(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var ak = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Wu(e) {
  var t = e.axisClassName, n = e.labelOffset, i = n === void 0 ? 8 : n, r = e.tickLength, o = r === void 0 ? 8 : r, d = e.tickLabelProps, u = rk(e, nk), s = typeof d == "function" ? d : xc({}, ak, d);
  return /* @__PURE__ */ a.createElement(Oc, xc({
    axisClassName: On("visx-axis-bottom", t),
    labelOffset: i,
    orientation: ir.bottom,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
const bs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: y0,
  curveBasisClosed: v0,
  curveBasisOpen: x0,
  curveBundle: b0,
  curveCardinal: S0,
  curveCardinalClosed: E0,
  curveCardinalOpen: k0,
  curveCatmullRom: w0,
  curveCatmullRomClosed: T0,
  curveCatmullRomOpen: C0,
  curveLinear: Cc,
  curveLinearClosed: cf,
  curveMonotoneX: Hu,
  curveMonotoneY: A0,
  curveNatural: P0,
  curveStep: L0,
  curveStepAfter: D0,
  curveStepBefore: R0
}, Symbol.toStringTag, { value: "Module" })), ik = (e) => {
  var T, U;
  const { xScale: t, yScale: n, yMax: i, xMax: r, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: u, children: s } = e;
  let { transformedData: h, config: m, handleLineType: y, parseDate: v, formatDate: w, formatNumber: E, seriesHighlight: R, colorScale: C, rawData: g, brushConfig: _ } = ce.useContext(Ct);
  const P = (T = m.brush) != null && T.active && ((U = _.data) != null && U.length) ? _.data : h;
  if (!P)
    return;
  const M = (V) => (Pn(m.xAxis) ? t(v(V[m.xAxis.dataKey], !1)) : t(V[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), N = (V, G, ue = void 0) => n(V[ue.dataKey]);
  return P && /* @__PURE__ */ a.createElement("svg", null, /* @__PURE__ */ a.createElement(Cr, { component: "AreaChart" }, /* @__PURE__ */ a.createElement(nt, { className: "area-chart", key: "area-wrapper", left: Number(m.yAxis.size) }, (m.runtime.areaSeriesKeys || m.series).map((V, G) => {
    let ue = P.map((j) => ({
      [m.xAxis.dataKey]: j[m.xAxis.dataKey],
      [V.dataKey]: j[V.dataKey]
    })), Z = bs[V.lineType], $ = m.legend.behavior === "highlight" && R.length > 0 && R.indexOf(V.dataKey) === -1, H = m.legend.behavior === "highlight" || R.length === 0 || R.indexOf(V.dataKey) !== -1;
    return /* @__PURE__ */ a.createElement(a.Fragment, { key: G }, /* @__PURE__ */ a.createElement(
      qr,
      {
        data: ue,
        x: (j) => M(j),
        y: (j) => N(j, G, V),
        stroke: H ? C ? C(m.runtime.seriesLabels ? m.runtime.seriesLabels[V.dataKey] : V.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: Z,
        strokeDasharray: V.type ? y(V.type) : 0
      }
    ), /* @__PURE__ */ a.createElement(
      rS,
      {
        key: "area-chart",
        fill: H ? C ? C(m.runtime.seriesLabels ? m.runtime.seriesLabels[V.dataKey] : V.dataKey) : "#000" : "transparent",
        fillOpacity: $ ? 0.25 : 0.5,
        data: ue,
        x: (j) => M(j),
        y: (j) => N(j, G, V),
        yScale: n,
        curve: Z,
        strokeDasharray: V.type ? y(V.type) : 0
      }
    ));
  }), /* @__PURE__ */ a.createElement(gr, { width: Number(r), height: Number(i), fill: "transparent", fillOpacity: 0.05, onMouseMove: (V) => o(V, g), onMouseLeave: d }))));
}, ok = ce.memo(ik), bc = {
  Linear: "curveLinear",
  Cardinal: "curveCardinal",
  Natural: "curveNatural",
  "Monotone X": "curveMonotoneX",
  Step: "curveStep"
}, lk = ({ xScale: e, yScale: t, yMax: n, xMax: i, handleTooltipMouseOver: r, handleTooltipMouseOff: o, isDebug: d }) => {
  var R, C;
  let { transformedData: u, config: s, seriesHighlight: h, colorScale: m, rawData: y } = ce.useContext(Ct);
  const v = (R = s.brush) != null && R.active && ((C = s.brush.data) != null && C.length) ? s.brush.data : u;
  if (!v)
    return;
  const w = (g) => {
    if (s.xAxis.type === "categorical")
      return e(g);
    if (Pn(s.xAxis)) {
      let _ = new Date(g);
      return e(_);
    }
  }, E = 2;
  return v && /* @__PURE__ */ a.createElement("svg", { height: Number(n) }, /* @__PURE__ */ a.createElement(Cr, { component: "AreaChartStacked" }, /* @__PURE__ */ a.createElement(nt, { className: "area-chart", key: "area-wrapper", left: Number(s.yAxis.size) + E / 2, height: Number(n), style: { overflow: "hidden" } }, /* @__PURE__ */ a.createElement(
    uS,
    {
      data: v,
      keys: s.runtime.areaSeriesKeys.map((g) => g.dataKey) || s.series.map((g) => g.dataKey),
      x0: (g) => w(g.data[s.xAxis.dataKey]),
      y0: (g) => Number(t(g[0])),
      y1: (g) => Number(t(g[1])),
      curve: bs[bc[s.stackedAreaChartLineType]]
    },
    ({ stacks: g, path: _ }) => g.map((P, M) => {
      let N = s.legend.behavior === "highlight" && h.length > 0 && h.indexOf(P.key) === -1, T = s.legend.behavior === "highlight" || h.length === 0 || h.indexOf(P.key) !== -1;
      return (
        // prettier-ignore
        /* @__PURE__ */ a.createElement(
          "path",
          {
            key: P.key,
            d: _(P) || "",
            strokeWidth: 2,
            stroke: T ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent",
            fillOpacity: N ? 0.2 : 1,
            fill: T ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent"
          }
        )
      );
    })
  ), /* @__PURE__ */ a.createElement(gr, { width: Number(i), height: Number(n), fill: "transparent", onMouseMove: (g) => r(g, y), onMouseLeave: o }))));
}, sk = ce.memo(lk), Rs = () => {
  const { config: e, colorPalettes: t, tableData: n, updateConfig: i, parseDate: r, formatDate: o, setSeriesHighlight: d, seriesHighlight: u } = ce.useContext(Ct), { orientation: s } = e, [h, m] = ce.useState(null), y = s === "horizontal", v = 1, w = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, E = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, R = e.yAxis.labelPlacement === "Below Bar", C = e.yAxis.displayNumbersOnBar, g = e.orientation === "horizontal" ? "yAxis" : "xAxis", _ = e.barStyle === "rounded", P = e.visualizationSubType === "stacked", M = e.tipRounding, N = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", T = e.runtime.seriesKeys.length, U = { small: 16, medium: 18, large: 20 }, V = Object.keys(e.runtime.seriesLabels).length > 1, ue = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (u != null && u.length) ? u : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return ce.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && i({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, i]), ce.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && i({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), ce.useEffect(() => {
    e.visualizationSubType === "horizontal" && i({
      ...e,
      orientation: "horizontal"
    });
  }, []), ce.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && i({ ...e, isLollipopChart: !0 }), (_ || e.barStyle === "flat") && i({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: y,
    barBorderWidth: v,
    lollipopBarWidth: w,
    lollipopShapeSize: E,
    isLabelBelowBar: R,
    displayNumbersOnBar: C,
    shouldSuppress: (ie) => {
      var ge;
      return (ge = e.preliminaryData) == null ? void 0 : ge.some((ve) => {
        const Se = ve.column ? ve.column === ie.key : !0, ye = String(ie.value) === String(ve.value) && ve.value !== "";
        return Se && ye && ve.symbol && ve.type === "suppression";
      });
    },
    section: g,
    isRounded: _,
    isStacked: P,
    tipRounding: M,
    radius: N,
    stackCount: T,
    barStackedSeriesKeys: ue,
    fontSize: U,
    hasMultipleSeries: V,
    applyRadius: (ie) => {
      if (ie == null || !_)
        return {};
      let ge = {};
      return (P && ie + 1 === T || !P) && (ge = y ? { borderRadius: `0 ${N}  ${N}  0` } : { borderRadius: `${N} ${N} 0 0` }), !P && ie === -1 && (ge = y ? { borderRadius: `${N} 0  0 ${N} ` } : { borderRadius: ` 0  0 ${N} ${N}` }), M === "full" && P && ie === 0 && T > 1 && (ge = y ? { borderRadius: `${N} 0 0 ${N}` } : { borderRadius: `0 0 ${N} ${N}` }), M === "full" && (P && ie === 0 && T === 1 || !P) && (ge = { borderRadius: N }), ge;
    },
    updateBars: (ie) => {
      if (e.visualizationType !== "Bar" && !y)
        return ie;
      const ge = [...ie];
      let ve;
      const Se = {
        stacked: e.barHeight,
        lollipop: w
      };
      P ? ve = Se.stacked : ve = Se[e.isLollipopChart ? "lollipop" : "stacked"] * T;
      const ye = R ? U[e.fontSize] * 1.2 : 0;
      let ee = Number(e.barSpace), Ee = ge.length * (ve + ye + ee);
      return y && (e.heights.horizontal = Ee), ge.map((He, we) => {
        let fe = 0;
        return He.index !== 0 && (fe = (ve + ee + ye) * we), { ...He, y: fe, height: ve };
      });
    },
    assignColorsToValues: (ie, ge, ve) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return ve;
      const Se = e.customColors ?? t[e.palette], ye = n.map((we) => we[e.legend.colorCode]);
      let ee = /* @__PURE__ */ new Map(), Ee = [];
      for (let we = 0; we < ye.length; we++)
        ee.has(ye[we]) || ee.set(ye[we], Se[ee.size % Se.length]), Ee.push(ee.get(ye[we]));
      for (; Ee.length < ie; )
        Ee = Ee.concat(Ee);
      return Ee[ge];
    },
    getHighlightedBarColorByValue: (ie) => {
      const ge = e == null ? void 0 : e.highlightedBarValues.find((ve) => {
        if (ve.value)
          return e.xAxis.type === "date" ? o(r(ve.value)) === ie : ve.value === ie;
      });
      return ge != null && ge.color ? ge.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (ie) => {
      const ge = e == null ? void 0 : e.highlightedBarValues.filter((ve) => {
        if (ve.value)
          return e.xAxis.type === "date" ? o(r(ve.value)) === ie : ve.value === ie;
      })[0];
      return ge != null && ge.color ? ge : !1;
    },
    getAdditionalColumn: (ie, ge) => {
      if (!ge)
        return "";
      const ve = e.columns, Se = [];
      let ye = "";
      const ee = n.find((Ee) => Ee[e.xAxis.dataKey] === ge) || {};
      return Object.keys(ve).forEach((Ee) => {
        if (ie && e.columns[Ee].series && e.columns[Ee].series !== ie)
          return;
        const He = {
          addColPrefix: e.columns[Ee].prefix,
          addColSuffix: e.columns[Ee].suffix,
          addColRoundTo: e.columns[Ee].roundToPlace ? e.columns[Ee].roundToPlace : "",
          addColCommas: e.columns[Ee].commas
        }, we = Sm(ee[e.columns[Ee].name], "left", !0, e, He);
        e.columns[Ee].tooltips && Se.push([e.columns[Ee].label, we]);
      }), Se.forEach((Ee) => {
        ye += `${Ee[0]} : ${Ee[1]} <br/>`;
      }), ye;
    },
    hoveredBar: h,
    setHoveredBar: m,
    onMouseOverBar: (ie, ge) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && ge && d([ge]), m(ie);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && d([]);
    },
    composeSuppressionBars: ({ bar: ie }) => {
      const ge = e.general.showSuppressedSymbol ? 3 : 0, ve = ge || 3, Se = "Asterisk", ye = (we) => String(we).includes(Se) ? -5 : -ve * 3, ee = (we) => String(we).includes(Se) ? "middle" : "end", Ee = (we, fe) => {
        switch (we) {
          case Se:
            return fe * 1.2;
          case "Double " + Se:
            return fe;
          default:
            return fe / 1.5;
        }
      };
      function He() {
        return e.preliminaryData.some((fe) => {
          const Ae = !fe.column || fe.column === ie.key;
          return String(fe.value) === String(ie.value) && fe.value !== "" && fe.type === "suppression" && Ae;
        });
      }
      return {
        suppressedBarHeight: ge,
        getIconSize: Ee,
        getIconPadding: ye,
        getVerticalAnchor: ee,
        isSuppressed: He()
      };
    }
  };
}, Ds = ce.createContext(null), mh = ({ xScale: e, barWidth: t = 0, totalBarsInGroup: n = 1, yMax: i, handleTooltipMouseOff: r, handleTooltipMouseOver: o, handleTooltipClick: d, tooltipData: u, showTooltip: s, hideTooltip: h }) => {
  const { parseDate: m, config: y } = ce.useContext(Ct), { runtime: v, regions: w, visualizationType: E, orientation: R, xAxis: C } = y, g = e.domain(), _ = (N) => {
    let T;
    if (!(N != null && N.fromType) || N.fromType === "Fixed") {
      const U = new Date(N.from), V = m(ns(y.xAxis.dateParseFormat, U)).getTime();
      T = e(V), E === "Bar" && C.type === "date-time" && (T = T - t * n / 2);
    }
    if (N.fromType === "Previous Days") {
      const U = Number(N.from) || 0;
      g.map((Z) => ns(y.xAxis.dateParseFormat, new Date(Z)));
      const V = N.toType === "Last Date" ? new Date(g[g.length - 1]).getTime() : new Date(N.to), G = y.xAxis.type === "categorical" ? ns(y.xAxis.dateParseFormat, V) : ns(y.xAxis.dateParseFormat, V), ue = new Date(G);
      if (T = new Date(ue.setDate(ue.getDate() - Number(U))), C.type === "date") {
        T = new Date(ns(C.dateParseFormat, T)).getTime();
        let Z = g[0], $ = Math.abs(T - Z);
        for (let H = 1; H < g.length; H++) {
          const j = Math.abs(T - g[H]);
          j < $ && ($ = j, Z = g[H]);
        }
        T = Z;
      }
      if (C.type === "categorical") {
        let Z = g[0], $ = Math.abs(new Date(T).getTime() - new Date(Z).getTime());
        for (let H = 1; H < g.length; H++) {
          const j = Math.abs(new Date(T).getTime() - new Date(g[H]).getTime());
          j < $ && ($ = j, Z = g[H]);
        }
        T = Z;
      }
      T = e(T);
    }
    if (C.type === "categorical" && N.fromType !== "Previous Days" && (T = e(N.from)), E === "Line" || E === "Area Chart") {
      let U = Number(y.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), T = T + U;
    }
    return E === "Bar" && y.xAxis.type === "date-time" && N.fromType === "Previous Days" && (T = T - t * n / 2), T;
  }, P = (N) => {
    let T;
    if (C.type === "categorical" && (T = e(N.to)), Pn(C) && ((!(N != null && N.toType) || N.toType === "Fixed") && (T = e(m(N.to).getTime())), (E === "Bar" || y.visualizationType === "Combo") && (T = N.toType !== "Last Date" ? e(m(N.to).getTime()) + t * n : T)), N.toType === "Last Date") {
      const U = g[g.length - 1];
      T = Number(e(U) + ((E === "Bar" || E === "Combo") && y.xAxis.type === "date" ? t * n : 0));
    }
    if (E === "Line" || E === "Area Chart") {
      let U = Number(y.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), T = T + U;
    }
    return E === "Bar" && y.xAxis.type === "date-time" && N.toType !== "Last Date" && (T = T - t * n / 2), (E === "Bar" || E === "Combo") && C.type === "categorical" && (T = T + (E === "Bar" || E === "Combo" ? t * n : 0)), T;
  }, M = (N, T) => N - T;
  if (w && R === "vertical")
    return w.map((N) => {
      const T = _(N), U = P(N), V = M(U, T);
      if (!T || !U)
        return null;
      const G = () => /* @__PURE__ */ a.createElement(
        "path",
        {
          stroke: "#333",
          d: `M${T} -5
                L${T} 5
                M${T} 0
                L${U} 0
                M${U} -5
                L${U} 5`
        }
      ), ue = () => /* @__PURE__ */ a.createElement("rect", { x: T, y: 0, width: V, height: i, fill: N.background, opacity: 0.3 });
      return /* @__PURE__ */ a.createElement(nt, { height: 100, fill: "red", className: "regions regions-group--line zzz", key: N.label, onMouseMove: o, onMouseLeave: r, handleTooltipClick: d, tooltipData: JSON.stringify(u), showTooltip: s }, /* @__PURE__ */ a.createElement(G, null), /* @__PURE__ */ a.createElement(ue, null), /* @__PURE__ */ a.createElement(vt, { x: T + V / 2, y: 5, fill: N.color, verticalAnchor: "start", textAnchor: "middle" }, N.label));
    });
};
function Mc(e) {
  var ie, ge;
  const { config: t, index: n, id: i, className: r, background: o, borderColor: d, borderWidth: u, width: s, height: h, x: m, y, onMouseOver: v, onMouseLeave: w, onClick: E, tooltipHtml: R, tooltipId: C, styleOverrides: g, seriesHighlight: _ } = e, P = Math.max(0, s), M = Math.max(0, h), N = t.orientation === "horizontal", T = t.barStyle === "rounded", U = t.visualizationSubType === "stacked", V = t.tipRounding, G = t.visualizationType === "Combo" && ((ge = (ie = t.runtime) == null ? void 0 : ie.barSeriesKeys) == null ? void 0 : ge.length), ue = t.runtime.seriesKeys.length, Z = t.visualizationType === "Bar" && t.legend.axisAlign && (_ != null && _.length) ? _ == null ? void 0 : _.length : 0, $ = G || Z || ue;
  let H = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (H > P / 2 || H > M / 2) && (H = Math.min(P / 2, M / 2));
  const j = () => `M${m},${y + M}
      L${m},${y + H}
      Q${m},${y} ${m + H},${y}
      L${m + P - H},${y}
      Q${m + P},${y} ${m + P},${y + H}
      L${m + P},${y + M}
      L${m},${y + M}`, F = () => `M${m},${y + M}
      L${m},${y}
      L${m + P - H},${y}
      Q${m + P},${y} ${m + P},${y + H}
      L${m + P},${y + M - H}
      Q${m + P},${y + M} ${m + P - H},${y + M}
      L${m},${y + M}`, X = () => `M${m + H},${y + M}
      Q${m},${y + M} ${m},${y + M - H}
      L${m},${y}
      L${m + P},${y}
      L${m + P},${y + M - H}
      Q${m + P},${y + M} ${m + P - H},${y + M}
      L${m + H},${y + M}`, Q = () => `M${m + H},${y + M}
      Q${m},${y + M} ${m},${y + M - H}
      L${m},${y + H}
      Q${m},${y} ${m + H},${y}
      L${m + P},${y}
      L${m + P},${y + M}
      L${m + H},${y + M}`, ae = () => `M${m + H},${y + M}
      Q${m},${y + M} ${m},${y + M - H}
      L${m},${y + H}
      Q${m},${y} ${m + H},${y}
      L${m + P - H},${y}
      Q${m + P},${y} ${m + P},${y + H}
      L${m + P},${y + M - H}
      Q${m + P},${y + M} ${m + P - H},${y + M}
      L${m + H},${y + M}`, te = () => `M${m},${y}
      L${m + P},${y}
      L${m + P},${y + M}
      L${m},${y + M}
      L${m},${y}`;
  let re;
  return n == null || !T ? re = te() : (re = te(), (U && n + 1 === $ || !U) && (re = N ? F() : j()), !U && n === -1 && (re = N ? Q() : X()), V === "full" && U && n === 0 && $ > 1 && (re = N ? Q() : X()), V === "full" && (U && n === 0 && $ === 1 || !U) && (re = ae())), /* @__PURE__ */ a.createElement(
    "path",
    {
      id: i,
      className: r,
      d: re,
      fill: o,
      stroke: d,
      strokeWidth: u,
      onMouseOver: v,
      onMouseLeave: w,
      onClick: E,
      "data-tooltip-html": R,
      "data-tooltip-id": C,
      style: {
        transition: "all 0.2s linear",
        ...g
      }
    }
  );
}
const uk = () => {
  var ue, Z;
  const [e, t] = ce.useState(0), { xScale: n, yScale: i, seriesScale: r, xMax: o, yMax: d } = ce.useContext(Ds), { transformedData: u, colorScale: s, seriesHighlight: h, config: m, formatNumber: y, formatDate: v, parseDate: w, setSharedFilter: E } = ce.useContext(Ct), { isHorizontal: R, barBorderWidth: C, applyRadius: g, hoveredBar: _, getAdditionalColumn: P, onMouseLeaveBar: M, onMouseOverBar: N, barStackedSeriesKeys: T } = Rs(), { orientation: U } = m, V = (ue = m.brush) != null && ue.active && ((Z = m.brush.data) != null && Z.length) ? m.brush.data : u, G = m.runtime.xAxis.type === "date-time" || m.runtime.xAxis.type === "date";
  return m.visualizationSubType === "stacked" && !R && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(pS, { data: V, keys: T, x: ($) => $[m.runtime.xAxis.dataKey], xScale: n, yScale: i, color: s }, ($) => $.reverse().map(
    (H) => H.bars.map((j) => {
      let F = m.legend.behavior === "highlight" && h.length > 0 && h.indexOf(j.key) === -1, X = m.legend.behavior === "highlight" || h.length === 0 || h.indexOf(j.key) !== -1, Q = G ? r.range()[1] - r.range()[0] : o / H.bars.length;
      m.runtime.xAxis.type !== "date" && (Q = m.barThickness * Q);
      const ae = j.bar.data[m.runtime.xAxis.dataKey], te = G ? v(w(ae)) : ae, re = y(j.bar ? j.bar.data[j.key] : 0, "left");
      if (!re)
        return;
      const ie = n(G ? w(ae) : ae) - (G && m.xAxis.sortDates ? barThicknessAdjusted / 2 : 0), ge = m.runtime.xAxis.label ? `${m.runtime.xAxis.label}: ${te}` : te, ve = P(_), Se = `${m.runtime.seriesLabels[j.key]}: ${re}`, ye = `<ul>
                  <li class="tooltip-heading"">${ge}</li>
                  <li class="tooltip-body ">${Se}</li>
                  <li class="tooltip-body ">${ve}</li>
                    </li></ul>`;
      return t(Q), /* @__PURE__ */ a.createElement(nt, { key: `${H.index}--${j.index}--${U}` }, /* @__PURE__ */ a.createElement(nt, { key: `bar-stack-${H.index}-${j.index}`, id: `barStack${H.index}-${j.index}`, className: "stack vertical" }, /* @__PURE__ */ a.createElement(vt, { display: m.labels && X ? "block" : "none", opacity: F ? 0.5 : 1, x: ie + e / 2, y: j.y - 5, fill: "#000", textAnchor: "middle" }, re), Mc({
        config: m,
        seriesHighlight: h,
        index: H.index,
        background: s(m.runtime.seriesLabels[j.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${m.barHasBorder === "true" ? C : 0}px`,
        width: Q,
        height: j.height,
        x: ie,
        y: j.y,
        onMouseOver: () => N(te, j.key),
        onMouseLeave: M,
        tooltipHtml: ye,
        tooltipId: `cdc-open-viz-tooltip-${m.runtime.uniqueId}`,
        onClick: (ee) => {
          ee.preventDefault(), E && (j[m.xAxis.dataKey] = te, E(m.uid, j));
        },
        styleOverrides: {
          animationDelay: `${H.index * 0.5}s`,
          transformOrigin: `${Q / 2}px ${j.y + j.height}px`,
          opacity: F ? 0.2 : 1,
          display: X ? "block" : "none"
        }
      })));
    })
  )), /* @__PURE__ */ a.createElement(mh, { xScale: n, yMax: d, barWidth: e, totalBarsInGroup: 1 }));
}, ck = () => {
  const { yMax: e, yScale: t, xScale: n } = ce.useContext(Ds), {
    animatedChart: i,
    colorScale: r,
    config: o,
    formatDate: d,
    formatNumber: u,
    getTextWidth: s,
    parseDate: h,
    seriesHighlight: m,
    setSharedFilter: y,
    transformedData: v
  } = ce.useContext(Ct), { barBorderWidth: w, displayNumbersOnBar: E, fontSize: R, getAdditionalColumn: C, hoveredBar: g, isHorizontal: _, isLabelBelowBar: P, onMouseLeaveBar: M, onMouseOverBar: N, updateBars: T, barStackedSeriesKeys: U } = Rs(), { orientation: V, visualizationSubType: G } = o;
  return o.visualizationSubType === "stacked" && _ && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(yS, { data: v, keys: U, height: e, y: (ue) => ue[o.runtime.yAxis.dataKey], xScale: n, yScale: t, color: r, offset: "none" }, (ue) => ue.map(
    (Z) => T(Z.bars).map(($, H) => {
      const j = o.legend.behavior === "highlight" && m.length > 0 && m.indexOf($.key) === -1, F = o.legend.behavior === "highlight" || m.length === 0 || m.indexOf($.key) !== -1;
      o.barHeight = Number(o.barHeight);
      const X = Zo("#000", r(o.runtime.seriesLabels[$.key])), Q = u(v[$.index][$.key], "left"), ae = o.runtime.yAxis.type === "date" ? d(h(v[$.index][o.runtime.originalXAxis.dataKey])) : v[$.index][o.runtime.originalXAxis.dataKey], te = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${ae}` : ae, re = s(Q, `normal ${R[o.fontSize]}px sans-serif`), ie = C(g), ge = `${o.runtime.seriesLabels[$.key]}: ${Q}`, ve = `<ul>
                  <li class="tooltip-heading"">${te}</li>
                  <li class="tooltip-body ">${ge}</li>
                  <li class="tooltip-body ">${ie}</li>
                    </li></ul>`;
      return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(nt, { key: H, id: `barStack${Z.index}-${$.index}`, className: "stack horizontal" }, Mc({
        config: o,
        seriesHighlight: m,
        index: Z.index,
        className: `animated-chart group ${i ? "animated" : ""}`,
        background: r(o.runtime.seriesLabels[$.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${o.barHasBorder === "true" ? w : 0}px`,
        width: $.width,
        height: $.height,
        x: $.x,
        y: $.y,
        onMouseOver: () => N(ae, $.key),
        onMouseLeave: M,
        tooltipHtml: ve,
        tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
        onClick: (Se) => {
          Se.preventDefault(), y && ($[o.xAxis.dataKey] = Q, y(o.uid, $));
        },
        styleOverrides: {
          animationDelay: `${Z.index * 0.5}s`,
          transformOrigin: `${$.x}px 0`,
          opacity: j ? 0.2 : 1,
          display: F ? "block" : "none"
        }
      }), V === "horizontal" && G === "stacked" && P && Z.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ a.createElement(
        vt,
        {
          x: `${$.x + (o.isLollipopChart ? 15 : 5)}`,
          y: $.y + $.height * 1.2,
          fill: "#000000",
          textAnchor: "start",
          verticalAnchor: "start"
        },
        ae
      ), E && re < $.width && /* @__PURE__ */ a.createElement(
        vt,
        {
          display: F ? "block" : "none",
          x: $.x + Z.bars[$.index].width / 2,
          y: $.y + $.height / 2,
          fill: X,
          textAnchor: "middle",
          verticalAnchor: "middle"
        },
        Q
      )));
    })
  )));
}, sy = ({ isSuppressed: e, showMissingDataLabel: t, defaultBarWidth: n, suppressedBarWidth: i, defaultBarHeight: r, suppressedBarHeight: o, showZeroValueDataLabel: d, textFitstobar: u }) => {
  let s = n, h = r;
  const m = t ? 3 : 0;
  return e && (h = o, s = i), t && (s = i, h = m), d && (h = d ? 3 : 0, s = i), (t || d || e) && !u && (h = 0), { barWidth: s, barHeight: h };
}, dk = ({ bar: e, yScale: t, isSuppressed: n, scaleVal: i, showMissingDataLabel: r, isNumber: o, suppressedBarHeight: d, showZeroValueDataLabel: u }) => {
  const s = t(i) - d, h = t(i) - 3, m = t(i) - 3;
  let v = e.value >= 0 && o(e.value) ? e.y : t(0);
  return n && (v = s), r && (v = h), u && (v = m), v;
}, _c = (e, t, n) => !!(e === "Line" && t.length < 3 && n), fk = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: i, seriesScale: r } = ce.useContext(Ds), [o, d] = ce.useState(0), [u, s] = ce.useState(0), { assignColorsToValues: h, barBorderWidth: m, getAdditionalColumn: y, getHighlightedBarByValue: v, getHighlightedBarColorByValue: w, lollipopBarWidth: E, lollipopShapeSize: R, onMouseLeaveBar: C, onMouseOverBar: g, section: _, composeSuppressionBars: P, fontSize: M } = Rs(), { colorScale: N, config: T, dashboardConfig: U, tableData: V, formatDate: G, formatNumber: ue, getXAxisData: Z, getYAxisData: $, isNumber: H, parseDate: j, seriesHighlight: F, setSharedFilter: X, transformedData: Q, brushConfig: ae, getTextWidth: te } = ce.useContext(Ct), { HighLightedBarUtils: re } = Lc(T);
  let ie = Q;
  return T.preliminaryData.some((ve) => ve.value && ve.type === "suppression") && (ie = V), ae.data.length && (ie = ae.data), T.visualizationSubType !== "stacked" && (T.visualizationType === "Bar" || T.visualizationType === "Combo" || _c(T.visualizationType, ie, T.allowLineToBarGraph)) && T.orientation === "vertical" && /* @__PURE__ */ a.createElement(nt, null, /* @__PURE__ */ a.createElement(
    Rg,
    {
      data: ie,
      keys: T.runtime.barSeriesKeys || T.runtime.seriesKeys,
      height: i,
      x0: (ve) => {
        const Se = ve[T.runtime.originalXAxis.dataKey];
        return Pn(T.runtime.xAxis) ? j(Se) : Se;
      },
      x0Scale: e,
      x1Scale: r,
      yScale: t,
      color: () => ""
    },
    (ve) => ve.map((Se, ye) => /* @__PURE__ */ a.createElement(nt, { className: `bar-group-${Se.index}-${Se.x0}--${ye} ${T.orientation}`, key: `bar-group-${Se.index}-${Se.x0}--${ye}`, id: `bar-group-${Se.index}-${Se.x0}--${ye}`, left: Se.x0 }, Se.bars.map((ee, Ee) => {
      const { suppressedBarHeight: He, getIconSize: we, getIconPadding: fe, getVerticalAnchor: Ae, isSuppressed: ne } = P({ bar: ee }), $e = T.useLogScale ? 0.1 : 0, Le = T.general.showMissingDataLabel && !H(ee.value), Ke = T.general.showZeroValueDataLabel && ee.value && Number(ee.value) === 0;
      let Ge = T.highlightedBarValues.map((pt) => pt.value).filter((pt) => pt !== void 0);
      Ge = T.xAxis.type === "date" ? re.formatDates(Ge) : Ge;
      const et = T.legend.behavior === "highlight" && F.length > 0 && F.indexOf(ee.key) === -1, Ze = T.legend.behavior === "highlight" || F.length === 0 || F.indexOf(ee.key) !== -1;
      let Et = r.range()[1] - r.range()[0];
      const qe = Math.abs(t(ee.value) - t($e));
      let Be = T.isLollipopChart ? E : r.bandwidth(), Ie = ee.x + (T.isLollipopChart ? (Et / Se.bars.length - E) / 2 : 0) - (T.xAxis.type === "date-time" ? Et / 2 : 0);
      d(Be), s(Se.bars.length);
      const Fe = ue(/[a-zA-Z]/.test(String(ee.value)) ? "" : ee.value, "left"), lt = T.runtime[_].type === "date" ? G(j(ie[Se.index][T.runtime.originalXAxis.dataKey])) : ie[Se.index][T.runtime.originalXAxis.dataKey], Ue = dk({ bar: ee, yScale: t, isSuppressed: ne, scaleVal: $e, showMissingDataLabel: Le, isNumber: H, suppressedBarHeight: He, showZeroValueDataLabel: Ke }), ct = ee.value < 0 ? -1 : Ee, ht = y(ee.key, ie[Se.index][T.runtime.originalXAxis.dataKey]);
      let gt = T.runtime.xAxis.label ? `${T.runtime.xAxis.label}: ${lt}` : lt;
      const Dt = `${T.runtime.seriesLabels[ee.key]}: ${Fe}`, qt = `<ul>
                  <li class="tooltip-heading">${gt}</li>
                  <li class="tooltip-body ">${Dt}</li>
                  ${ht ? '<li class="tooltip-body ">' + ht + "</li>" : ""}
                    </li></ul>`;
      let Vt = "#000000";
      Vt = re.checkFontColor(Fe, Ge, Vt);
      let kt = T.runtime.seriesLabels && T.runtime.seriesLabels[ee.key] ? N(T.runtime.seriesLabels[ee.key]) : N(ee.key);
      kt = h(ve.length, Se.index, kt);
      const zt = T.isLollipopChart && T.lollipopColorStyle === "regular", ln = T.isLollipopChart && T.lollipopColorStyle === "two-tone", en = Ge == null ? void 0 : Ge.includes(lt), cn = w(lt), ze = v(lt), Nt = en ? cn : T.barHasBorder === "true" ? "#000" : "transparent", Gt = en ? ze.borderWidth : T.isLollipopChart ? 0 : T.barHasBorder === "true" ? m : 0, Bt = ne || Number(Fe) === 0 ? "" : Fe, yn = Le ? "N/A" : "", Lt = Ke ? "0" : "";
      let bn = Be / 2;
      const mn = te(yn, `normal ${bn}px sans-serif`) < Be && Be > 10, { barHeight: dn } = sy({ isSuppressed: ne, showMissingDataLabel: Le, defaultBarHeight: qe, suppressedBarHeight: He, showZeroValueDataLabel: Ke, textFitstobar: mn }), jt = ne ? "none" : "block", wn = (pt, Tn) => {
        var Sn;
        let tn = pt, $t = Tn || "#f2f2f2";
        if (U && ((Sn = U.dashboard.sharedFilters) == null ? void 0 : Sn.length) !== 0) {
          const { sharedFilters: En } = U.dashboard;
          return tn = En ? En.map((Dn) => Dn.setBy === T.uid ? Dn.resetLabel === Dn.active || Dn.active === Q[Se.index][T.xAxis.dataKey] ? N(T.runtime.seriesLabels[ee.key]) : $t : N(T.runtime.seriesLabels[ee.key]))[0] : N(T.runtime.seriesLabels[ee.key]), zt && (tn = pt), ln && (tn = Ss(pt).brighten(1)), en && (tn = "transparent"), tn;
        }
        return ln && (tn = Ss(pt).brighten(1)), en && (tn = "transparent"), tn;
      };
      let Ft = !0;
      return T.preliminaryData.forEach((pt) => {
        pt.value && String(pt.value) === String(ee.value) && pt.type === "suppression" && (Ft = !1);
      }), /* @__PURE__ */ a.createElement(nt, { key: `${Se.index}--${Ee}` }, /* @__PURE__ */ a.createElement(nt, { key: `bar-sub-group-${Se.index}-${Se.x0}-${Ue}--${Ee}` }, Mc({
        config: T,
        index: ct,
        id: `barGroup${Se.index}`,
        background: wn(N(T.runtime.seriesLabels[ee.key])),
        borderColor: Nt,
        borderStyle: "solid",
        borderWidth: `${Gt}px`,
        width: Be,
        height: dn,
        x: Ie,
        y: Ue,
        onMouseOver: () => g(lt, ee.key),
        onMouseLeave: C,
        tooltipHtml: qt,
        tooltipId: `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
        onClick: (pt) => {
          pt.preventDefault(), X && (ee[T.xAxis.dataKey] = lt, X(T.uid, ee));
        },
        styleOverrides: {
          transformOrigin: `0 ${Ue + dn}px`,
          opacity: et ? 0.2 : 1,
          display: Ze ? "block" : "none",
          cursor: U ? "pointer" : "default"
        }
      }), T.preliminaryData.map((pt, Tn) => {
        const tn = !pt.column || pt.column === ee.key;
        if (!(!(String(pt.value) === String(ee.value) && pt.value !== "" && tn) || Be < 10 || !T.general.showSuppressedSymbol))
          return /* @__PURE__ */ a.createElement(
            vt,
            {
              key: Tn,
              dy: fe(pt.symbol),
              display: Ze ? "block" : "none",
              opacity: et ? 0.5 : 1,
              x: Ie + Be / 2,
              y: Ue,
              verticalAnchor: Ae(pt.symbol),
              fill: Vt,
              textAnchor: "middle",
              fontSize: `${we(pt.symbol, Be)}px`
            },
            pt.iconCode
          );
      }), /* @__PURE__ */ a.createElement(
        vt,
        {
          display: T.labels && Ze ? "block" : "none",
          opacity: et ? 0.5 : 1,
          x: Ie + Be / 2,
          y: Ue - 5,
          fill: Vt,
          textAnchor: "middle"
        },
        Bt
      ), Ft && /* @__PURE__ */ a.createElement(
        vt,
        {
          display: mn && Ze ? "block" : "none",
          opacity: et ? 0.5 : 1,
          x: Ie + Be / 2,
          y: Ue - 5,
          fontSize: bn,
          fill: Vt,
          textAnchor: "middle"
        },
        yn
      ), Ft && /* @__PURE__ */ a.createElement(
        vt,
        {
          display: mn && Ze ? "block" : "none",
          opacity: et ? 0.5 : 1,
          x: Ie + Be / 2,
          y: Ue - 5,
          fill: Vt,
          textAnchor: "middle",
          fontSize: bn
        },
        Lt
      ), T.isLollipopChart && T.lollipopShape === "circle" && /* @__PURE__ */ a.createElement(
        "circle",
        {
          display: jt,
          cx: Ie + R / 3.5,
          cy: ee.y,
          r: R / 2,
          fill: kt,
          key: `circle--${ee.index}`,
          "data-tooltip-html": qt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), T.isLollipopChart && T.lollipopShape === "square" && /* @__PURE__ */ a.createElement(
        "rect",
        {
          display: jt,
          x: Ie - E / 2,
          y: Ue,
          width: R,
          height: R,
          fill: kt,
          key: `circle--${ee.index}`,
          "data-tooltip-html": qt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ a.createElement("animate", { attributeName: "height", values: `0, ${R}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(T.confidenceKeys).length > 0 ? ie.map((ve) => {
    let Se, ye, ee, Ee, He = 5;
    return Se = e(Z(ve)) + (T.xAxis.type !== "date" || T.xAxis.type !== "date-time" ? r.range()[1] / 2 : 0), ee = t($(ve, T.confidenceKeys.lower)), Ee = t($(ve, T.confidenceKeys.upper)), /* @__PURE__ */ a.createElement(
      "path",
      {
        key: `confidence-interval-v-${ye}-${ve[T.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${Se - He} ${ee}
                    L${Se + He} ${ee}
                    M${Se} ${ee}
                    L${Se} ${Ee}
                    M${Se - He} ${Ee}
                    L${Se + He} ${Ee}`
      }
    );
  }) : "", /* @__PURE__ */ a.createElement(mh, { xScale: e, yMax: i, barWidth: o, totalBarsInGroup: u }));
}, hk = () => {
  var te;
  const { xScale: e, yScale: t, yMax: n, seriesScale: i } = ce.useContext(Ds), { transformedData: r, tableData: o, colorScale: d, seriesHighlight: u, config: s, formatNumber: h, formatDate: m, parseDate: y, setSharedFilter: v, isNumber: w, getTextWidth: E, getYAxisData: R, getXAxisData: C } = ce.useContext(Ct), {
    isHorizontal: g,
    barBorderWidth: _,
    updateBars: P,
    assignColorsToValues: M,
    section: N,
    fontSize: T,
    isLabelBelowBar: U,
    displayNumbersOnBar: V,
    lollipopBarWidth: G,
    lollipopShapeSize: ue,
    getHighlightedBarColorByValue: Z,
    getHighlightedBarByValue: $,
    getAdditionalColumn: H,
    hoveredBar: j,
    onMouseLeaveBar: F,
    onMouseOverBar: X,
    composeSuppressionBars: Q
  } = Rs(), { HighLightedBarUtils: ae } = Lc(s);
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ a.createElement(nt, null, /* @__PURE__ */ a.createElement(
    Rg,
    {
      data: (te = s.preliminaryData) != null && te.some((re) => re.value && re.type === "suppression") ? o : r,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: n,
      x0: (re) => re[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: i,
      yScale: e,
      color: () => ""
    },
    (re) => P(re).map((ie, ge) => /* @__PURE__ */ a.createElement(nt, { className: `bar-group-${ie.index}-${ie.x0}--${ge} ${s.orientation}`, key: `bar-group-${ie.index}-${ie.x0}--${ge}`, id: `bar-group-${ie.index}-${ie.x0}--${ge}`, top: ie.y }, ie.bars.map((ve, Se) => {
      var Ft;
      const ye = s.useLogScale ? 0.1 : 0, { suppressedBarHeight: ee, getIconSize: Ee, getVerticalAnchor: He, isSuppressed: we } = Q({ bar: ve });
      let fe = s.highlightedBarValues.map((pt) => pt.value).filter((pt) => pt !== void 0);
      fe = s.xAxis.type === "date" ? ae.formatDates(fe) : fe;
      let Ae = s.legend.behavior === "highlight" && u.length > 0 && u.indexOf(ve.key) === -1, ne = s.legend.behavior === "highlight" || u.length === 0 || u.indexOf(ve.key) !== -1, $e = s.barHeight, Le = parseInt(s.isLollipopChart ? G : $e);
      isNaN(Le) && (Le = 25);
      let Ke = ve.value >= 0 && w(ve.value) ? ve.y : t(ye);
      const Ge = Math.abs(e(ve.value) - e(ye)), et = ve.value >= 0 && w(ve.value), Ze = s.general.showMissingDataLabel && !ve.value, Et = s.general.showZeroValueDataLabel && ve.value && Number(ve.value) === 0, { barWidth: qe } = sy({ isSuppressed: we, defaultBarWidth: Ge, suppressedBarWidth: ee, showMissingDataLabel: Ze, showZeroValueDataLabel: Et }), Be = ve.value < 0 ? Math.abs(e(ve.value)) : e(ye), Ie = h(ve.value, "left"), Fe = s.runtime[N].type === "date" ? m(y(r[ie.index][s.runtime.originalXAxis.dataKey])) : r[ie.index][s.runtime.originalXAxis.dataKey], lt = et ? "above" : "below", Ue = we || Number(Ie) === 0 ? "" : Ie;
      let ct = E(Fe, `normal ${T[s.fontSize]}px sans-serif`), ht = Number(ct) < Ge - 5, gt = ht ? "end" : "start", Dt = "start", qt = ht ? -5 : 5, Vt = 10;
      lt === "below" && (gt = ht ? "start" : "end", qt = ht ? 5 : -5, s.isLollipopChart && (Dt = "end", Vt = -10));
      const kt = ve.value < 0 ? -1 : Se;
      let zt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Fe}` : Fe;
      const ln = H(j), en = `${s.runtime.seriesLabels[ve.key]}: ${Ie}`, cn = `<ul>
                  <li class="tooltip-heading"">${zt}</li>
                  <li class="tooltip-body ">${en}</li>
                  <li class="tooltip-body ">${ln}</li>
                    </li></ul>`;
      let ze = "#000000";
      ze = ae.checkFontColor(Ie, fe, ze);
      let Nt = s.runtime.seriesLabels && s.runtime.seriesLabels[ve.key] ? d(s.runtime.seriesLabels[ve.key]) : d(ve.key);
      Nt = M(re.length, ie.index, Nt);
      const Gt = s.isLollipopChart && s.lollipopColorStyle === "regular", Bt = s.isLollipopChart && s.lollipopColorStyle === "two-tone", yn = fe == null ? void 0 : fe.includes(Fe), Lt = Z(Fe), bn = $(Fe), Mn = yn ? Lt : s.barHasBorder === "true" ? "#000" : "transparent", mn = yn ? bn.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? _ : 0, dn = we ? "none" : "block";
      Nt && ze && ht && (ze = Zo("#000", Nt));
      const jt = () => Gt ? Nt : Bt ? Ss(Nt).brighten(1) : yn ? "transparent" : Nt, wn = (pt) => pt === "Asterisk" ? "3px" : pt === "Double Asterisks" ? "4px" : "12px";
      return /* @__PURE__ */ a.createElement(nt, { key: `${ie.index}--${Se}` }, /* @__PURE__ */ a.createElement(nt, { key: `bar-sub-group-${ie.index}-${ie.x0}-${Ke}--${Se}` }, Mc({
        config: s,
        index: kt,
        id: `barGroup${ie.index}`,
        background: jt(),
        borderColor: Mn,
        borderStyle: "solid",
        borderWidth: `${mn}px`,
        width: qe,
        height: Le,
        x: Be,
        y: $e * ve.index,
        onMouseOver: () => X(Fe, ve.key),
        onMouseLeave: F,
        tooltipHtml: cn,
        tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
        onClick: (pt) => {
          pt.preventDefault(), v && (ve[s.xAxis.dataKey] = Ie, v(s.uid, ve));
        },
        styleOverrides: {
          transformOrigin: `0 ${Ke + $e}px`,
          opacity: Ae ? 0.2 : 1,
          display: ne ? "block" : "none"
        }
      }), (Ft = s.preliminaryData) == null ? void 0 : Ft.map((pt, Tn) => {
        const tn = !pt.column || pt.column === ve.key;
        if (!(!(String(pt.value) === String(o[ie.index][ve.key]) && pt.value !== "" && tn) || $e < 10 || !s.general.showSuppressedSymbol))
          return /* @__PURE__ */ a.createElement(
            vt,
            {
              key: Tn,
              fontSize: Ee(pt.symbol, $e),
              angle: 90,
              display: ne ? "block" : "none",
              opacity: Ae ? 0.5 : 1,
              x: Be,
              y: s.barHeight / 2 + s.barHeight * ve.index,
              fill: "#000",
              dx: wn(pt.symbol),
              verticalAnchor: He(pt.symbol),
              textAnchor: "middle"
            },
            pt.iconCode
          );
      }), /* @__PURE__ */ a.createElement(
        vt,
        {
          display: ne ? "block" : "none",
          x: ve.y,
          opacity: Ae ? 0.5 : 1,
          y: s.barHeight / 2 + s.barHeight * ve.index,
          fill: ze,
          dx: 10,
          verticalAnchor: "middle",
          textAnchor: "start"
        },
        Ze ? "N/A" : ""
      ), /* @__PURE__ */ a.createElement(
        vt,
        {
          display: ne ? "block" : "none",
          x: ve.y,
          opacity: Ae ? 0.5 : 1,
          y: s.barHeight / 2 + s.barHeight * ve.index,
          fill: ze,
          dx: 15,
          verticalAnchor: "middle",
          textAnchor: "start"
        },
        Et ? "0" : ""
      ), !s.isLollipopChart && V && /* @__PURE__ */ a.createElement(
        vt,
        {
          display: ne ? "block" : "none",
          x: ve.y,
          y: s.barHeight / 2 + s.barHeight * ve.index,
          fill: ze,
          dx: qt,
          verticalAnchor: "middle",
          textAnchor: gt
        },
        Ue
      ), s.isLollipopChart && V && /* @__PURE__ */ a.createElement(
        vt,
        {
          display: ne ? "block" : "none",
          x: ve.y,
          y: 0,
          fill: "#000000",
          dx: Vt,
          textAnchor: Dt,
          verticalAnchor: "middle",
          fontWeight: "normal"
        },
        Ue
      ), U && !s.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { x: s.yAxis.hideAxis ? 0 : 5, y: ie.height, dy: 4, verticalAnchor: "start", textAnchor: "start" }, s.runtime.yAxis.type === "date" ? m(y(r[ie.index][s.runtime.originalXAxis.dataKey])) : g ? r[ie.index][s.runtime.originalXAxis.dataKey] : h(r[ie.index][s.runtime.originalXAxis.dataKey])), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ a.createElement(
        "circle",
        {
          display: dn,
          cx: ve.y,
          cy: $e * ve.index + G / 2,
          r: ue / 2,
          fill: Nt,
          key: `circle--${ve.index}`,
          "data-tooltip-html": cn,
          "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ a.createElement(
        "rect",
        {
          display: dn,
          x: ve.y > 10 ? ve.y - ue / 2 : 0,
          y: 0 - G / 2,
          width: ue,
          height: ue,
          fill: Nt,
          key: `circle--${ve.index}`,
          "data-tooltip-html": cn,
          "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ a.createElement("animate", { attributeName: "height", values: `0, ${ue}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(s.confidenceKeys).length > 0 ? r.map((re) => {
    let ie, ge, ve, Se = 5;
    return ie = t(C(re)) - 0.75 * s.barHeight, ge = e(R(re, s.confidenceKeys.upper)), ve = e(R(re, s.confidenceKeys.lower)), /* @__PURE__ */ a.createElement(
      "path",
      {
        key: `confidence-interval-h-${ie}-${re[s.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${ve} ${ie - Se}
                    L${ve} ${ie + Se}
                    M${ve} ${ie}
                    L${ge} ${ie}
                    M${ge} ${ie - Se}
                    L${ge} ${ie + Se} `
      }
    );
  }) : "");
}, Fu = {
  Vertical: fk,
  Horizontal: hk,
  StackedVertical: uk,
  StackedHorizontal: ck
}, pk = ({ xScale: e, yScale: t, seriesScale: n, xMax: i, yMax: r, handleTooltipMouseOver: o, handleTooltipMouseOff: d, handleTooltipClick: u }) => {
  const { transformedData: s, config: h } = ce.useContext(Ct), m = {
    xScale: e,
    yScale: t,
    xMax: i,
    yMax: r,
    seriesScale: n
  };
  return /* @__PURE__ */ a.createElement(Cr, { component: "BarChart" }, /* @__PURE__ */ a.createElement(Ds.Provider, { value: m }, /* @__PURE__ */ a.createElement(nt, { left: parseFloat(h.runtime.yAxis.size) }, /* @__PURE__ */ a.createElement(Fu.StackedVertical, null), /* @__PURE__ */ a.createElement(Fu.StackedHorizontal, null), /* @__PURE__ */ a.createElement(Fu.Vertical, null), /* @__PURE__ */ a.createElement(Fu.Horizontal, null), /* @__PURE__ */ a.createElement(gr, { key: "bars", display: h.tooltips.singleSeries ? "none" : "block", width: Number(i), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (y) => o(y, s), onMouseOut: d, onClick: (y) => u(y, s) }))));
};
function za() {
  return za = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, za.apply(this, arguments);
}
function Di(e) {
  var t = e.x1, n = e.x2, i = e.y1, r = e.y2;
  return {
    x1: i,
    x2: r,
    y1: t,
    y2: n
  };
}
function uy(e) {
  var t = e.left, n = t === void 0 ? 0 : t, i = e.top, r = i === void 0 ? 0 : i, o = e.className, d = e.max, u = e.min, s = e.firstQuartile, h = e.thirdQuartile, m = e.median, y = e.boxWidth, v = y === void 0 ? 10 : y, w = e.fill, E = e.fillOpacity, R = e.stroke, C = e.strokeWidth, g = e.rx, _ = g === void 0 ? 2 : g, P = e.ry, M = P === void 0 ? 2 : P, N = e.valueScale, T = e.outliers, U = T === void 0 ? [] : T, V = e.horizontal, G = e.medianProps, ue = G === void 0 ? {} : G, Z = e.maxProps, $ = Z === void 0 ? {} : Z, H = e.minProps, j = H === void 0 ? {} : H, F = e.boxProps, X = F === void 0 ? {} : F, Q = e.outlierProps, ae = Q === void 0 ? {} : Q, te = e.container, re = te === void 0 ? !1 : te, ie = e.containerProps, ge = ie === void 0 ? {} : ie, ve = e.children, Se = V ? r : n, ye = Se + (v || 0) / 2, ee = N.range(), Ee = N(u ?? 0), He = N(s ?? 0), we = N(m ?? 0), fe = N(h ?? 0), Ae = N(d ?? 0), ne = {
    valueRange: ee,
    center: ye,
    offset: Se,
    boxWidth: v,
    max: {
      x1: ye - (v || 0) / 4,
      x2: ye + (v || 0) / 4,
      y1: Ae,
      y2: Ae
    },
    maxToThird: {
      x1: ye,
      x2: ye,
      y1: Ae,
      y2: fe
    },
    median: {
      x1: Se,
      x2: Se + (v || 0),
      y1: we,
      y2: we
    },
    minToFirst: {
      x1: ye,
      x2: ye,
      y1: He,
      y2: Ee
    },
    min: {
      x1: ye - (v || 0) / 4,
      x2: ye + (v || 0) / 4,
      y1: Ee,
      y2: Ee
    },
    box: {
      x1: Se,
      x2: v || 0,
      y1: fe,
      y2: Math.abs(fe - He)
    },
    container: {
      x1: Se,
      x2: v || 0,
      y1: Math.min.apply(Math, ee),
      y2: Math.abs(ee[0] - ee[1])
    }
  };
  return V && (ne.max = Di(ne.max), ne.maxToThird = Di(ne.maxToThird), ne.box.y1 = He, ne.box = Di(ne.box), ne.median = Di(ne.median), ne.minToFirst = Di(ne.minToFirst), ne.min = Di(ne.min), ne.container = Di(ne.container), ne.container.y1 = Math.min.apply(Math, ee)), ve ? /* @__PURE__ */ a.createElement(a.Fragment, null, ve(ne)) : /* @__PURE__ */ a.createElement(nt, {
    className: On("visx-boxplot", o)
  }, U.map(function($e, Le) {
    var Ke = V ? N($e) : ye, Ge = V ? ye : N($e);
    return /* @__PURE__ */ a.createElement("circle", za({
      key: "visx-boxplot-outlier-" + Le,
      className: "visx-boxplot-outlier",
      cx: Ke,
      cy: Ge,
      r: 4,
      stroke: R,
      strokeWidth: C,
      fill: w,
      fillOpacity: E
    }, ae));
  }), /* @__PURE__ */ a.createElement("line", za({
    className: "visx-boxplot-max",
    x1: ne.max.x1,
    y1: ne.max.y1,
    x2: ne.max.x2,
    y2: ne.max.y2,
    stroke: R,
    strokeWidth: C
  }, $)), /* @__PURE__ */ a.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: ne.maxToThird.x1,
    y1: ne.maxToThird.y1,
    x2: ne.maxToThird.x2,
    y2: ne.maxToThird.y2,
    stroke: R,
    strokeWidth: C
  }), /* @__PURE__ */ a.createElement("rect", za({
    className: "visx-boxplot-box",
    x: ne.box.x1,
    y: ne.box.y1,
    width: ne.box.x2,
    height: ne.box.y2,
    stroke: R,
    strokeWidth: C,
    fill: w,
    fillOpacity: E,
    rx: _,
    ry: M
  }, X)), /* @__PURE__ */ a.createElement("line", za({
    className: "visx-boxplot-median",
    x1: ne.median.x1,
    y1: ne.median.y1,
    x2: ne.median.x2,
    y2: ne.median.y2,
    stroke: R,
    strokeWidth: C
  }, ue)), /* @__PURE__ */ a.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: ne.minToFirst.x1,
    y1: ne.minToFirst.y1,
    x2: ne.minToFirst.x2,
    y2: ne.minToFirst.y2,
    stroke: R,
    strokeWidth: C
  }), /* @__PURE__ */ a.createElement("line", za({
    className: "visx-boxplot-min",
    x1: ne.min.x1,
    y1: ne.min.y1,
    x2: ne.min.x2,
    y2: ne.min.y2,
    stroke: R,
    strokeWidth: C
  }, j)), re && /* @__PURE__ */ a.createElement("rect", za({
    x: ne.container.x1,
    y: ne.container.y1,
    width: ne.container.x2,
    height: ne.container.y2,
    fillOpacity: "0"
  }, ge)));
}
uy.propTypes = {
  max: he.number,
  min: he.number,
  firstQuartile: he.number,
  thirdQuartile: he.number,
  median: he.number,
  boxWidth: he.number,
  fill: he.string,
  fillOpacity: he.oneOfType([he.number, he.string]),
  stroke: he.string,
  strokeWidth: he.oneOfType([he.number, he.string]),
  rx: he.number,
  ry: he.number,
  outliers: he.arrayOf(he.number),
  container: he.bool,
  children: he.func
};
const mk = ({ xScale: e, yScale: t }) => {
  const { config: n, setConfig: i } = ce.useContext(Ct), { boxplot: r } = n;
  ce.useEffect(() => {
    n.legend.hide === !1 && i({
      ...n,
      legend: {
        ...n.legend,
        hide: !0
      }
    });
  }, []);
  const o = `cdc-open-viz-tooltip-${n.runtime.uniqueId}`, d = (C) => `
      <strong>${C.columnCategory}</strong></br>
      ${r.labels.q1}: ${C.columnFirstQuartile}<br/>
      ${r.labels.q3}: ${C.columnThirdQuartile}<br/>
      ${r.labels.iqr}: ${C.columnIqr}<br/>
      ${r.labels.median}: ${C.columnMedian}
    `, u = (C) => Number(C.columnMax), s = (C) => Number(C.columnMin), h = (C) => Number(C.columnMedian), m = (C) => Number(C.columnThirdQuartile), y = (C) => Number(C.columnFirstQuartile), v = 0.5, w = e.bandwidth(), E = Math.min(40, w), R = dr[n == null ? void 0 : n.palette][0] ? dr[n == null ? void 0 : n.palette][0] : "#000";
  return /* @__PURE__ */ a.createElement(Cr, { component: "BoxPlot" }, /* @__PURE__ */ a.createElement(nt, { className: "boxplot", key: "boxplot-group" }, r.plots.map((C, g) => {
    const _ = w - E, P = 4;
    return /* @__PURE__ */ a.createElement(nt, { key: `boxplotplot-${g}` }, r.plotNonOutlierValues && C.nonOutlierValues.map((M, N) => /* @__PURE__ */ a.createElement("circle", { cx: e(C.columnCategory) + Number(n.yAxis.size) + w / 2, cy: t(M), r: P, fill: "#ccc", style: { opacity: 1, fillOpacity: 1, stroke: "black" }, key: `boxplot-${g}--circle-${N}` })), /* @__PURE__ */ a.createElement(
      uy,
      {
        "data-left": e(C.columnCategory) + n.yAxis.size + _ / 2 + 0.5,
        key: `box-plot-${g}`,
        min: s(C),
        max: u(C),
        left: Number(e(C.columnCategory)) + Number(n.yAxis.size) + _ / 2 + 0.5,
        firstQuartile: y(C),
        thirdQuartile: m(C),
        median: h(C),
        boxWidth: E,
        fill: R,
        fillOpacity: v,
        stroke: "black",
        valueScale: t,
        outliers: r.plotOutlierValues ? C.columnOutliers : [],
        outlierProps: {
          style: {
            fill: `${R}`,
            opacity: 1
          }
        },
        medianProps: {
          style: {
            stroke: "black"
          }
        },
        boxProps: {
          style: {
            stroke: "black",
            strokeWidth: r.borders === "true" ? 1 : 0
          }
        },
        maxProps: {
          style: {
            stroke: "black"
          }
        },
        container: !0,
        containerProps: {
          "data-tooltip-html": d(C),
          "data-tooltip-id": o,
          tabIndex: -1
        }
      }
    ));
  })));
}, gk = ({ xScale: e, yScale: t, getXAxisData: n, getYAxisData: i }) => {
  const { colorScale: r, transformedData: o, config: d, formatNumber: u, seriesHighlight: s, colorPalettes: h } = ce.useContext(Ct), m = 4.5, y = Object.keys(d.runtime.seriesLabels).length > 1, v = Object.entries(d.columns).filter(([E, R]) => R.tooltips).map(([E, R]) => [R.label || R.name, R.name]), w = (E, R) => `<div>
    ${d.legend.showLegendValuesTooltip && d.runtime.seriesLabels && y ? `${d.runtime.seriesLabels[R] || ""}<br/>` : ""}
    ${d.xAxis.label}: ${u(E[d.xAxis.dataKey], "bottom")} <br/>
    ${d.yAxis.label}: ${u(E[R], "left")}<br/>
   ${v.map(([C, g]) => `${C} : ${u(E[g], "left")}<br/>`).join("")}
</div>`;
  return /* @__PURE__ */ a.createElement(nt, { className: "scatter-plot", left: d.yAxis.size }, o.map((E, R) => d.runtime.seriesKeys.map((C, g) => {
    const _ = d.legend.behavior === "highlight" && s.length > 0 && s.indexOf(C) === -1, P = d.legend.behavior === "highlight" || s.length === 0 || s.indexOf(C) !== -1, M = d.palette ? h[d.palette][g] : "#000";
    let N = {
      filter: "unset",
      opacity: 1,
      stroke: P ? "black" : ""
    };
    return /* @__PURE__ */ a.createElement(
      "circle",
      {
        key: `${R}-${g}`,
        r: m,
        cx: e(E[d.xAxis.dataKey]),
        cy: t(E[C]),
        fill: P ? M : "transparent",
        fillOpacity: _ ? 0.25 : 1,
        style: N,
        "data-tooltip-html": w(E, C),
        "data-tooltip-id": `cdc-open-viz-tooltip-${d.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function yk({ height: e, xScale: t }) {
  const { transformedData: n, config: i, formatNumber: r, twoColorPalette: o, getTextWidth: d, updateConfig: u, parseDate: s, formatDate: h, currentViewport: m } = ce.useContext(Ct), { barStyle: y, tipRounding: v, roundingStyle: w, twoColor: E } = i, R = ce.useRef([]), [C, g] = ce.useState(window.innerWidth), _ = w === "standard" ? "8px" : w === "shallow" ? "5px" : w === "finger" ? "15px" : "0px", P = { small: 16, medium: 18, large: 20 };
  i.barStyle;
  const M = Number(i.xAxis.target), N = i.series[0].dataKey, T = Number(t.domain()[1]), V = n.some((te) => te[N] < 0) || M > 0 || t.domain()[0] < 0, G = i.barHasBorder === "true" ? 1 : 0, ue = i.lollipopSize === "large" ? 7 : i.lollipopSize === "medium" ? 6 : 5, Z = i.lollipopSize === "large" ? 14 : i.lollipopSize === "medium" ? 12 : 10, $ = Math.max(t(0), Math.min(t(M), t(T))), H = (te) => {
    if (te == null || y !== "rounded")
      return;
    let re = {};
    return te === "left" && (re = { borderRadius: `${_} 0 0 ${_}` }), te === "right" && (re = { borderRadius: `0 ${_} ${_} 0` }), v === "full" && (re = { borderRadius: _ }), re;
  }, j = {
    calculate: function() {
      const re = n[0][N] < M ? "left" : "right", ie = `${i.xAxis.targetLabel} ${r(i.xAxis.target || 0, "left")}`, ge = d(ie, `bold ${P[i.fontSize]}px sans-serif`);
      let ve = i.isLollipopChart ? ue / 2 : Number(i.barHeight) / 2, Se = 0, ye = 0, ee = !1;
      re === "right" && (Se = -10, ee = ge - Se < $, ye = $ - ge), re === "left" && (Se = 10, ee = t(T) - $ > ge + Se, ye = $), this.text = ie, this.y = ve, this.x = ye, this.padding = Se, this.showLabel = i.xAxis.showTargetLabel ? ee : !1;
    }
  };
  j.calculate();
  const F = ce.useRef(null), X = dh(F, {});
  ce.useEffect(() => {
    const te = () => {
      var re;
      g(window.innerWidth), (re = R.current) == null || re.forEach((ie) => {
        !ie || !ie.style || (ie.style.transition = "none", ie.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", te), () => {
      window.removeEventListener("resize", te);
    };
  }, []);
  const [Q, ae] = ce.useState(!1);
  return ce.useEffect(() => {
    X != null && X.isIntersecting && setTimeout(() => {
      ae(!0);
    }, 100);
  }, [X == null ? void 0 : X.isIntersecting, i.animate]), ce.useEffect(() => {
    var te;
    (te = R.current) == null || te.forEach((re, ie) => {
      if (!(!re || !re.style)) {
        if (i.animate) {
          const ge = M / T * 100;
          re.style.opacity = "0", re.style.transform = `translate(${ge / 1.07}%) scale(0, 1)`, setTimeout(() => {
            re.style.opacity = "1", re.style.transform = "translate(0) scale(1)", re.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          re.style.transition = "none", re.style.opacity = "0";
        i.animate || (re.style.transition = "none", re.style.opacity = "1");
      }
    });
  }, [i.animate, i, Q]), /* @__PURE__ */ a.createElement(Cr, { component: "Deviation Bar" }, /* @__PURE__ */ a.createElement(nt, { left: Number(i.xAxis.size) }, n.map((te, re) => {
    const ie = Number(te[N]), ge = i.isLollipopChart ? ue : Number(i.barHeight), ve = Number(i.barSpace), Se = Math.abs(t(ie) - $), ye = t(ie), ee = ie > M ? $ : ye, Ee = ie < M ? "left" : "right";
    let He = 0;
    He = re !== 0 ? (ve + ge + G) * re : He;
    const we = (ve + ge + G) * n.length;
    i.heights.horizontal = we;
    const Ae = d(r(ie, "left"), `normal ${P[i.fontSize]}px sans-serif`) < Se - 6, ne = ye, $e = He + ge / 2, Le = ye, Ke = He + ge / 2, Ge = ye, et = He - ge / 2, Ze = H(Ee), [Et, qe] = o[E.palette], Be = { left: Et, right: qe }, Ie = Zo("#000", Be[Ee]);
    let Fe = vk(i.isLollipopChart, Ae, Z, Ie);
    const lt = r(ie, "left"), Ue = i.runtime.yAxis.type === "date" ? h(s(n[re][i.runtime.originalXAxis.dataKey])) : n[re][i.runtime.originalXAxis.dataKey];
    let ct = i.runtime.yAxis.label ? `${i.runtime.yAxis.label}: ${Ue}` : Ue, ht = i.runtime.xAxis.label ? `${i.runtime.xAxis.label}: ${lt}` : lt;
    const gt = `<div>
          ${ct}<br />
          ${ht}
            </div>`;
    return /* @__PURE__ */ a.createElement(nt, { key: `deviation-bar-${i.orientation}-${N}-${re}` }, /* @__PURE__ */ a.createElement(
      "foreignObject",
      {
        ref: (Dt) => {
          R.current[re] = Dt;
        },
        x: ee,
        y: He,
        width: Se,
        height: ge,
        "data-tooltip-html": gt,
        "data-tooltip-id": `cdc-open-viz-tooltip-${i.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ a.createElement("div", { style: { width: Se, height: ge, border: `${G}px solid #333`, backgroundColor: Be[Ee], ...Ze } })
    ), i.yAxis.displayNumbersOnBar && /* @__PURE__ */ a.createElement(vt, { verticalAnchor: "middle", x: ne, y: $e, ...Fe[Ee] }, r(te[N], "left")), i.isLollipopChart && i.lollipopShape === "circle" && /* @__PURE__ */ a.createElement("circle", { cx: Le, cy: Ke, r: Z / 2, fill: Be[Ee], style: { filter: "unset", opacity: 1 } }), i.isLollipopChart && i.lollipopShape === "square" && /* @__PURE__ */ a.createElement("rect", { x: Ge, y: et, width: Z, height: Z, fill: Be[Ee], style: { opacity: 1, filter: "unset" } }));
  }), j.showLabel && /* @__PURE__ */ a.createElement(vt, { fontWeight: "bold", dx: j.padding, verticalAnchor: "middle", x: j.x, y: j.y }, j.text), V && /* @__PURE__ */ a.createElement(on, { from: { x: $, y: 0 }, to: { x: $, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ a.createElement("foreignObject", { y: e / 2, ref: F }));
}
function vk(e, t, n, i) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? i : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? i : "#000000"
    }
  };
}
const xk = ({ xScale: e, yScale: t, height: n, width: i, handleTooltipMouseOver: r, handleTooltipMouseOff: o }) => {
  var E;
  const { transformedData: d, rawData: u, config: s, seriesHighlight: h } = ce.useContext(Ct), { xAxis: m, yAxis: y, legend: v, runtime: w } = s;
  return d && /* @__PURE__ */ a.createElement(Cr, { component: "ForecastingChart" }, /* @__PURE__ */ a.createElement(nt, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(y.size) }, (E = w.forecastingSeriesKeys) == null ? void 0 : E.map((R, C) => !R || !R.stages ? !1 : R.stages.map((g, _) => {
    var U;
    const { behavior: P } = v, M = u.filter((V) => V[R.stageColumn] === g.key);
    let N = P === "highlight" && h.length > 0 && h.indexOf(g.key) === -1, T = P === "highlight" || h.length === 0 || h.indexOf(g.key) !== -1;
    return /* @__PURE__ */ a.createElement(nt, { className: `forecasting-areas-combo-${C}`, key: `forecasting-areas--stage-${g.key.replaceAll(" ", "-")}-${C}` }, (U = R.confidenceIntervals) == null ? void 0 : U.map((V, G) => {
      const ue = Ku[g.color] || dr[g.color] || !1, Z = () => T && ue[2] ? ue[2] : "transparent", $ = () => T && ue[1] ? ue[1] : "transparent";
      if (!(V.high === "" || V.low === ""))
        return /* @__PURE__ */ a.createElement(nt, { key: `forecasting-areas--stage-${g.key.replaceAll(" ", "-")}--group-${_}-${G}` }, /* @__PURE__ */ a.createElement(
          eS,
          {
            curve: Hu,
            data: M,
            fill: Z(),
            opacity: N ? 0.1 : 0.5,
            x: (H) => e(Date.parse(H[m.dataKey])),
            y0: (H) => t(H[V.low]),
            y1: (H) => t(H[V.high])
          }
        ), G === 0 && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(qr, { data: M, x: (H) => Number(e(Date.parse(H[m.dataKey]))), y: (H) => Number(t(H[V.high])), curve: Hu, stroke: $(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ a.createElement(qr, { data: M, x: (H) => Number(e(Date.parse(H[m.dataKey]))), y: (H) => Number(t(H[V.low])), curve: Hu, stroke: $(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ a.createElement(nt, { key: "tooltip-hover-section" }, /* @__PURE__ */ a.createElement(gr, { key: "bars", width: Number(i), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (R) => r(R, d), onMouseOut: o }))));
};
function Vu(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
function Nc(e, t) {
  const n = e.series.every(({ type: v }) => v === "Bar"), i = e.series.every(({ type: v }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(v)), r = (v) => (w) => v.reduce((E, R) => isNaN(Number(w[R])) ? E : E + Number(w[R]), 0), o = () => {
    let v = Math.max(...t.map((w) => Math.max(...e.runtime.seriesKeys.map((E) => Vu(w[E]) ? Number(s(w[E])) : 0))));
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const w = t.map(r(e.runtime.seriesKeys)).filter((E) => !isNaN(E));
      v = Math.max(...w);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const w = t.map(r(e.runtime.seriesKeys));
      v = Math.max(...w);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (v = Math.max(...t.map((w) => Vu(w[e.series.dataKey]) ? Number(s(w[e.series.dataKey])) : 0))), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const w = t.map(r(e.runtime.barSeriesKeys)), E = Math.max(...t.map((C) => Math.max(...e.runtime.lineSeriesKeys.map((g) => Number(s(C[g])))))), R = Math.max(...w);
      v = Math.max(R, E);
    }
    return v;
  }, d = () => {
    const v = Math.min(...t.map((w) => Math.min(...e.runtime.seriesKeys.map((E) => Vu(w[E]) ? Number(s(w[E])) : 1 / 0))));
    return String(v);
  }, u = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((v) => t.some((w) => w[v] >= 0)) : !1, s = (v) => v === null || v === "" ? "" : typeof v == "string" ? v.replace(/[,$]/g, "") : v, h = Number(o()), m = Number(d()), y = u();
  return { minValue: m, maxValue: h, existPositiveValue: y, isAllLine: i };
}
function gh({ config: e, yMax: t = 0, data: n = [], updateConfig: i }) {
  var v, w, E, R;
  const r = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((C) => C.axis === "Right").map((C) => C.dataKey);
  let { minValue: d } = Nc(e, n);
  const u = (C) => {
    if (!C)
      return [0];
    let g = [];
    return C.map((_, P) => g = [...g, ...n.map((M) => Number(M[_]))]), g;
  };
  let s = Math.max.apply(null, u(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const h = ((w = (v = e.runtime) == null ? void 0 : v.barSeriesKeys) == null ? void 0 : w.length) > 0, m = ((R = (E = e.runtime) == null ? void 0 : E.lineSeriesKeys) == null ? void 0 : R.length) > 0;
  return (h || m) && d > 0 && (d = 0), { yScaleRight: Kn({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: r };
}
const bk = (e) => {
  const { preliminaryData: t, data: n, stroke: i, strokeWidth: r, handleLineType: o, lineType: d, seriesKey: u } = e, s = t.filter((v) => v.seriesKey && v.column && v.value && v.type && v.style && v.type === "effect"), h = (v) => s.find((w) => w.seriesKey === u && v[w.column] === w.value && w.type === "effect" && w.style !== "Open Circles");
  let m = [];
  const y = (v) => ({
    stroke: i,
    strokeWidth: r,
    strokeDasharray: v
  });
  return n.forEach((v, w) => {
    let E = h(v), R = y(o(E ? E.style : d));
    m.push(R), E && w > 0 && (m[w - 1] = y(o(E.style)));
  }), m;
}, Sk = (e, t, n) => {
  const i = e == null ? void 0 : e.filter((o) => o.style === "Open Circles" && o.type === "effect").map((o) => ({ column: o.column, value: o.value, seriesKey: o.seriesKey })), r = [];
  return t.forEach((o) => {
    i.forEach((d) => {
      o[d.column] === d.value && d.seriesKey === n && r.push(o);
    });
  }), r;
}, Sc = (e) => !isNaN(parseFloat(e)) && isFinite(e), Ek = (e, t, n) => {
  const i = {
    data: [],
    style: ""
  };
  if (!e.length)
    return i;
  const r = e[0], o = (u) => {
    if (u.type !== "effect")
      return u.type == "suppression" && u.value === r[t] && (!u.column || u.column === t);
  }, d = n.find(o);
  if (d && d.style) {
    const u = { ...r, [t]: 0 };
    i.data.push(u), i.style = d.style;
    let s = 1;
    for (; s < e.length && !Sc(e[s][t]); )
      s++;
    s < e.length && i.data.push(e[s]);
  } else
    i.data.push(r);
  return i;
}, kk = (e, t, n) => {
  const i = {
    data: [],
    style: ""
  };
  let r = -1;
  return n == null || n.forEach((o) => {
    if (o.type !== "effect" && e[e.length - 1][t] === o.value && o.style && (!o.column || o.column === t) && o.type == "suppression") {
      const d = e.length - 1, u = { ...e[d], [t]: 0 };
      i.data.push(u);
      let s = d - 1;
      for (; s >= 0 && !Sc(e[s][t]); )
        s--;
      s >= 0 && r !== s && (i.data.push(e[s]), r = s), i.style = o.style;
    }
  }), i;
};
function wk(e, t, n, i) {
  const r = {
    data: [],
    style: ""
  }, o = (d) => d > 0 && d < e.length - 1;
  return i == null || i.forEach((d) => {
    if (d.type === "effect")
      return;
    const u = d.value;
    e.reduce((h, m, y) => (m[t] === u && o(y) && (!d.column || d.column === t) && h.push(y), h), []).forEach((h) => {
      r.style = d.style, Sc(e[h - 1][t]) && r.data.push(e[h - 1]);
      const m = e.slice(h + 1).findIndex((y) => y[t] !== u && Sc(y[t]));
      m !== -1 && r.data.push(e[h + 1 + m]);
    });
  }), r.data = Ni.uniqWith(r.data, (d, u) => d[n] === u[n] && d[t] === u[t]), r;
}
const Tk = (e, t, n, i) => {
  const r = Ek(e, t, n), o = kk(e, t, n), d = wk(e, t, i, n);
  return [r, d, o].filter((u) => u.data.length > 0 && u.style !== "");
}, Zd = (e) => {
  var M, N, T, U, V, G, ue, Z;
  const { config: t, d: n, tableData: i, displayArea: r, seriesKey: o, tooltipData: d, xScale: u, yScale: s, colorScale: h, parseDate: m, yScaleRight: y, data: v, circleData: w, dataIndex: E, mode: R } = e, { lineDatapointStyle: C } = t, g = (M = t == null ? void 0 : t.series.filter(($) => $.dataKey === o)) == null ? void 0 : M[0], _ = ($, H, j, F, X) => {
    const Q = j.runtime.seriesLabels || [];
    let ae;
    return $ ? ae = H(Q[F] || X) : ae = "transparent", j.lineDatapointColor === "Lighter than Line" && ae !== "transparent" && ae && (ae = Ss(ae).brighten(1)), ae;
  }, P = ($) => (t.xAxis.type === "categorical" ? u($) : u(m($))) + (u.bandwidth ? u.bandwidth() / 2 : 0);
  if (R === "ALWAYS_SHOW_POINTS") {
    if (C === "hidden")
      return /* @__PURE__ */ a.createElement(a.Fragment, null);
    if (C === "always show")
      return (w == null ? void 0 : w.some((H) => H[t.xAxis.dataKey] === n[t.xAxis.dataKey] && H[o] === n[o])) ? /* @__PURE__ */ a.createElement(a.Fragment, null) : /* @__PURE__ */ a.createElement(
        "circle",
        {
          cx: P(n[t.xAxis.dataKey]),
          cy: g.axis === "Right" ? y(n[g.dataKey]) : s(n[g.dataKey]),
          r: 4.5,
          opacity: n[o] ? 1 : 0,
          fillOpacity: 1,
          fill: _(r, h, t, o, o),
          style: { filter: "unset", opacity: 1 }
        }
      );
  }
  if (R === "HOVER_POINTS" && C === "hover") {
    if (!d || !o || !d.data)
      return;
    let $ = (T = (N = d == null ? void 0 : d.data) == null ? void 0 : N[0]) == null ? void 0 : T[1];
    if (!$)
      return;
    let H, j = d.data.filter((Q) => Q[0] === o), F = (U = j == null ? void 0 : j[0]) == null ? void 0 : U[0], X = (V = j == null ? void 0 : j[0]) == null ? void 0 : V[2];
    return F ? (d == null || d.data.indexOf(F), H = (G = i == null ? void 0 : i.find((Q) => Q[t == null ? void 0 : t.xAxis.dataKey] === $)) == null ? void 0 : G[o], d == null ? void 0 : d.data.map((Q, ae) => (t.runtime.seriesLabelsAll.indexOf($), isNaN(H) ? /* @__PURE__ */ a.createElement(a.Fragment, null) : (w == null ? void 0 : w.some((re) => re[t.xAxis.dataKey] === $)) ? /* @__PURE__ */ a.createElement(a.Fragment, null) : /* @__PURE__ */ a.createElement(
      "circle",
      {
        cx: P($),
        cy: X === "right" ? y(H) : s(H),
        r: 4.5,
        opacity: 1,
        fillOpacity: 1,
        fill: _(r, h, t, F, o),
        style: { filter: "unset", opacity: 1 },
        key: `line-chart-circle--${JSON.stringify(Q)}--${ae}`
      }
    )))) : void 0;
  }
  return R === "ISOLATED_POINTS" && R && ((H, j) => {
    const F = v[H], X = H > 0 ? v[H - 1] : null, Q = H < v.length - 1 ? v[H + 1] : null;
    let ae = !1;
    return H === 0 && Q && !Q[j] && (ae = !0), H === v.length - 1 && X && !X[j] && (ae = !0), H > 0 && H < v.length - 1 && F && F[j] && (!X || !X[j]) && (!Q || !Q[j]) && (ae = !0), ae;
  })(E, o) ? /* @__PURE__ */ a.createElement("circle", { cx: P(n[(ue = t.xAxis) == null ? void 0 : ue.dataKey]), cy: g.axis === "Right" ? y(n[g.dataKey]) : s(n[g == null ? void 0 : g.dataKey]), r: 5.3, strokeWidth: 2, stroke: h(t.runtime.seriesLabels[o]), fill: h((Z = t.runtime) == null ? void 0 : Z.seriesLabels[o]) }) : null;
}, sm = (e) => {
  var H;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipClick: i,
    handleTooltipMouseOff: r,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: u,
    xScale: s,
    yMax: h,
    yScale: m
  } = e, { colorScale: y, config: v, formatNumber: w, handleLineType: E, isNumber: R, parseDate: C, seriesHighlight: g, tableData: _, transformedData: P, updateConfig: M, brushConfig: N, clean: T } = ce.useContext(Ct), { yScaleRight: U } = gh({ config: v, yMax: h, data: P, updateConfig: M });
  if (!o)
    return;
  const { lineDatapointStyle: V, showLineSeriesLabels: G, legend: ue } = v;
  let Z = P, $ = _;
  return N.data.length > 0 && ((H = v.brush) != null && H.active) && (Z = T(N.data), $ = T(N.data)), /* @__PURE__ */ a.createElement(Cr, { component: "LineChart" }, /* @__PURE__ */ a.createElement(nt, { left: Number(v.runtime.yAxis.size) }, " ", (v.runtime.lineSeriesKeys || v.runtime.seriesKeys).map((j, F) => {
    var Se;
    let X = v.series.filter((ye) => ye.dataKey === j)[0].type;
    const Q = v.series.filter((ye) => ye.dataKey === j), ae = Q[0].axis ? Q[0].axis : "left";
    let te = ue.behavior === "highlight" || g.length === 0 || g.indexOf(j) !== -1;
    const re = Sk(v == null ? void 0 : v.preliminaryData, $, j);
    let ie = bk({ preliminaryData: v.preliminaryData, data: $, stroke: y(v.runtime.seriesLabels[j]), strokeWidth: Q[0].weight || 2, handleLineType: E, lineType: X, seriesKey: j });
    const ge = Tk(_, j, v.preliminaryData, v.xAxis.dataKey);
    let ve = (ye) => s(t(ye)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
    return /* @__PURE__ */ a.createElement(
      nt,
      {
        key: `series-${j}`,
        opacity: ue.behavior === "highlight" && g.length > 0 && g.indexOf(j) === -1 ? 0.5 : 1,
        display: ue.behavior === "highlight" || g.length === 0 && !ue.dynamicLegend || g.indexOf(j) !== -1 ? "block" : "none"
      },
      Z.map((ye, ee) => {
        const Ee = v.series.find(({ dataKey: ne }) => ne === j), { axis: He } = Ee, we = Object.keys(v.runtime.seriesLabels).length > 1, fe = He === "Right" ? "rightLabel" : "label";
        let Ae = v.runtime.yAxis[fe];
        return we || (Ae = v.isLegendValue ? v.runtime.seriesLabels[j] : Ae), ye[j] !== void 0 && ye[j] !== "" && ye[j] !== null && R(ye[j]) && /* @__PURE__ */ a.createElement(nt, { key: `series-${j}-point-${ee}`, className: "checkwidth" }, /* @__PURE__ */ a.createElement(gr, { key: "bars", width: Number(u), height: Number(h), fill: "transparent", fillOpacity: 0.05, onMouseMove: (ne) => o(ne, _), onMouseOut: r, onClick: (ne) => i(ne, Z) }), /* @__PURE__ */ a.createElement(vt, { display: v.labels ? "block" : "none", x: ve(ye), y: ae === "Right" ? U(n(ye, j)) : m(n(ye, j)), fill: "#000", textAnchor: "middle" }, w(ye[j], "left")), (V === "hidden" || V === "always show") && /* @__PURE__ */ a.createElement(
          Zd,
          {
            mode: "ALWAYS_SHOW_POINTS",
            dataIndex: ee,
            circleData: re,
            tableData: _,
            data: Z,
            d: ye,
            config: v,
            seriesKey: j,
            displayArea: te,
            tooltipData: d,
            xScale: s,
            yScale: m,
            colorScale: y,
            parseDate: C,
            yScaleRight: U,
            seriesAxis: ae,
            key: `line-circle--${ee}`
          }
        ), /* @__PURE__ */ a.createElement(
          Zd,
          {
            mode: "ISOLATED_POINTS",
            dataIndex: ee,
            tableData: _,
            circleData: re,
            data: Z,
            d: ye,
            config: v,
            seriesKey: j,
            displayArea: te,
            tooltipData: d,
            xScale: s,
            yScale: m,
            colorScale: y,
            parseDate: C,
            yScaleRight: U,
            seriesAxis: ae,
            key: `isolated-circle-${ee}`
          }
        ));
      }),
      /* @__PURE__ */ a.createElement(a.Fragment, null, V === "hover" && /* @__PURE__ */ a.createElement(
        Zd,
        {
          tableData: _,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: re,
          data: Z,
          config: v,
          seriesKey: j,
          displayArea: te,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: y,
          parseDate: C,
          yScaleRight: U,
          seriesAxis: ae
        }
      )),
      (Se = v == null ? void 0 : v.preliminaryData) != null && Se.some((ye) => ye.value && ye.type) ? /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
        Mg,
        {
          curve: bs[Q[0].lineType],
          segments: Z.map((ye) => [ye]),
          segmentation: "x",
          x: (ye) => ve(ye),
          y: (ye) => ae === "Right" ? U(n(ye, j)) : m(Number(n(ye, j))),
          styles: ie,
          defined: (ye, ee) => ye[j] !== "" && ye[j] !== null && ye[j] !== void 0
        }
      ), ge.map((ye, ee) => /* @__PURE__ */ a.createElement(
        qr,
        {
          key: ee,
          data: ye.data,
          x: (Ee) => ve(Ee),
          y: (Ee) => ae === "Right" ? U(n(Ee, j)) : m(Number(n(Ee, j))),
          stroke: y(v.runtime.seriesLabels[j]),
          strokeWidth: Q[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: E(ye.style),
          defined: (Ee, He) => Ee[j] !== "" && Ee[j] !== null && Ee[j] !== void 0
        }
      ))) : /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
        qr,
        {
          curve: bs[Q[0].lineType],
          data: v.xAxis.type === "date-time" ? Z.sort((ye, ee) => {
            let Ee = t(ye), He = t(ee);
            return Ee < He ? -1 : He < Ee ? 1 : 0;
          }) : Z,
          x: (ye) => ve(ye),
          y: (ye) => ae === "Right" ? U(n(ye, j)) : m(Number(n(ye, j))),
          stroke: y(v.runtime.seriesLabels[j]),
          strokeWidth: Q[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: X ? E(X) : 0,
          defined: (ye, ee) => ye[j] !== "" && ye[j] !== null && ye[j] !== void 0
        }
      )),
      re.map((ye, ee) => /* @__PURE__ */ a.createElement(
        "circle",
        {
          key: ee,
          cx: ve(ye),
          cy: ae === "Right" ? U(n(ye, j)) : m(Number(n(ye, j))),
          r: 6,
          strokeWidth: Q[0].weight || 2,
          stroke: y ? y(v.runtime.seriesLabels[j]) : "#000",
          fill: "#fff"
        }
      )),
      v.animate && /* @__PURE__ */ a.createElement(
        qr,
        {
          className: "animation",
          curve: bs[Q[0].lineType],
          data: Z,
          x: (ye) => ve(ye),
          y: (ye) => ae === "Right" ? U(n(ye, j)) : m(Number(n(ye, j))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: X ? E(X) : 0,
          defined: (ye, ee) => ye[j] !== "" && ye[j] !== null && ye[j] !== void 0
        }
      ),
      G && (v.runtime.lineSeriesKeys || v.runtime.seriesKeys).map((ye) => {
        let ee;
        for (let Ee = Z.length - 1; Ee >= 0; Ee--)
          if (Z[Ee][ye]) {
            ee = Z[Ee];
            break;
          }
        return ee ? /* @__PURE__ */ a.createElement("text", { x: ve(ee) + 5, y: m(n(ee, ye)), alignmentBaseline: "middle", fill: v.colorMatchLineSeriesLabels && y ? y(v.runtime.seriesLabels[ye] || ye) : "black" }, v.runtime.seriesLabels[ye] || ye) : /* @__PURE__ */ a.createElement(a.Fragment, null);
      })
    );
  }), v.legend.dynamicLegend && g.length === 0 && /* @__PURE__ */ a.createElement(vt, { x: u / 2, y: h / 2, fill: "black", textAnchor: "middle", color: "black" }, v.legend.dynamicLegendChartMessage)));
}, Ck = (e) => {
  const { rawData: t, updateConfig: n } = ce.useContext(Ct), { xScale: i, yScale: r, config: o, height: d, width: u, handleTooltipMouseOff: s, handleTooltipMouseOver: h } = e, { forestPlot: m } = o, y = o.xAxis.tickWidthMax + 10, [v, w] = ce.useState(!1);
  ce.useEffect(() => {
    try {
      const M = ["estimateField", "lower", "upper", "estimateRadius"], N = o, T = 10;
      for (let U = 0; U < T; U++)
        M.forEach((V) => {
          var G;
          o.forestPlot[V] && o.forestPlot[V] !== ((G = N.columns[o.forestPlot[`additionalColumn${U}`]]) == null ? void 0 : G.name) && (delete N.columns[`additionalColumn${U}`], N.columns[o.forestPlot[V]] = {}, N.columns[o.forestPlot[V]].dataKey = N.forestPlot[V], N.columns[o.forestPlot[V]].name = N.forestPlot[V], N.columns[o.forestPlot[V]].dataTable = !0, N.columns[o.forestPlot[V]].tooltips = !0, N.columns[o.forestPlot[V]].label = N.forestPlot[V]);
        });
      o.forestPlot.radius.scalingColumn && (N.columns[o.forestPlot.radius.scalingColumn] = {}, N.columns[o.forestPlot.radius.scalingColumn].dataKey = N.forestPlot.radius.scalingColumn, N.columns[o.forestPlot.radius.scalingColumn].name = N.forestPlot.radius.scalingColumn, N.columns[o.forestPlot.radius.scalingColumn].label = N.forestPlot.radius.scalingColumn, N.columns[o.forestPlot.radius.scalingColumn].dataTable = !0, N.columns[o.forestPlot.radius.scalingColumn].tooltips = !0), N.table.showVertical && (N.table.indexLabel = o.xAxis.dataKey), n(N);
    } catch (M) {
      console.log(M.message);
    }
  }, []), ce.useEffect(() => {
    !v && o.forestPlot.type === "Logarithmic" && (n({
      ...o,
      dataFormat: {
        ...o.dataFormat,
        roundTo: 2
      }
    }), w(!0));
  }, [o.forestPlot.type]);
  const E = o.data.find((M) => M[o.xAxis.dataKey] === o.forestPlot.pooledResult.column), R = E ? [
    { x: i(E[o.forestPlot.lower]), y: d - Number(o.forestPlot.rowHeight) },
    { x: i(E[o.forestPlot.estimateField]), y: d - m.pooledResult.diamondHeight - Number(o.forestPlot.rowHeight) },
    { x: i(E[o.forestPlot.upper]), y: d - Number(o.forestPlot.rowHeight) },
    { x: i(E[o.forestPlot.estimateField]), y: d + m.pooledResult.diamondHeight - Number(o.forestPlot.rowHeight) },
    { x: i(E[o.forestPlot.lower]), y: d - Number(o.forestPlot.rowHeight) }
  ] : [], C = o.forestPlot.rowHeight, g = [
    { x: 0, y: C },
    { x: u, y: C }
  ], _ = [
    { x: 0, y: d },
    { x: u, y: d }
  ], P = Object.entries(o.columns).map((M) => M[1]).filter((M) => M.forestPlot === !0);
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(nt, { width: u }, m.title && /* @__PURE__ */ a.createElement(vt, { className: "forest-plot--title", x: m.type === "Linear" ? i(0) : i(1), y: 0, textAnchor: "middle", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, m.title), m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ a.createElement(on, { from: { x: i(0), y: 0 + C }, to: { x: i(0), y: d }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ a.createElement(on, { from: { x: i(1), y: 0 + C }, to: { x: i(1), y: d }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), t.map((M, N) => {
    const T = Kn({
      domain: t.map(($) => $[m.radius.scalingColumn]),
      range: [m.radius.min, m.radius.max]
    }), U = m.radius.scalingColumn !== "" ? T(t[N][m.radius.scalingColumn]) : 4, V = m.colors.shape ? m.colors.shape : "black", G = m.colors.line ? m.colors.line : "black", ue = 4;
    return M[o.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ a.createElement(qr, { data: R, x: ($) => $.x, y: ($) => $.y - Ci(o.fontSize) / 2, stroke: "black", strokeWidth: 2, fill: "black", curve: cf }) : /* @__PURE__ */ a.createElement(nt, null, /* @__PURE__ */ a.createElement(
      "path",
      {
        stroke: G,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${i(M[m.lower])} ${r(N) - Number(ue)}
                    L${i(M[m.lower])} ${r(N) + Number(ue)}
                `
      }
    ), /* @__PURE__ */ a.createElement(
      "path",
      {
        stroke: G,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${i(M[m.upper])} ${r(N) - Number(ue)}
                    L${i(M[m.upper])} ${r(N) + Number(ue)}
                `
      }
    ), /* @__PURE__ */ a.createElement("line", { stroke: G, className: `line-${M[o.yAxis.dataKey]}`, key: N, x1: i(M[m.lower]), x2: i(M[m.upper]), y1: r(N), y2: r(N) }), m.shape === "circle" && /* @__PURE__ */ a.createElement(Iy, { className: "forest-plot--circle", cx: i(Number(M[m.estimateField])), cy: r(N), r: m.radius.scalingColumn !== "" ? T(t[N][m.radius.scalingColumn]) : 4, fill: V, style: { opacity: 1, filter: "unset" } }), m.shape === "square" && /* @__PURE__ */ a.createElement("rect", { className: "forest-plot--square", x: i(Number(M[m.estimateField])), y: r(N) - U / 2, width: U, height: U, fill: V, style: { opacity: 1, filter: "unset" } }), m.shape === "text" && /* @__PURE__ */ a.createElement(vt, { className: "forest-plot--text", x: i(Number(M[m.estimateField])), y: r(N), textAnchor: "middle", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: V }, M[m.estimateField]));
  }), R && m.regression.showDiamond && /* @__PURE__ */ a.createElement(qr, { data: R, x: (M) => M.x, y: (M) => M.y, stroke: "black", strokeWidth: 2, fill: m.regression.baseLineColor, curve: cf }), m.regression.description && /* @__PURE__ */ a.createElement(vt, { x: 0 - Number(o.xAxis.size), width: u, y: d - o.forestPlot.rowHeight - Number(m.rowHeight) / 3, verticalAnchor: "start", textAnchor: "start", style: { fontWeight: "bold", fontSize: 12 } }, m.regression.description), /* @__PURE__ */ a.createElement(gr, { key: "forest-plot-tooltip-area", className: "forest-plot-tooltip-area", width: u, height: d, fill: "transparent", fillOpacity: 0.5, onMouseMove: (M) => h(M, t), onMouseOut: s })), /* @__PURE__ */ a.createElement(on, { from: g[0], to: g[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__top-line" }), /* @__PURE__ */ a.createElement(on, { from: _[0], to: _[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__bottom-line" }), P.map((M) => t.map((N, T) => /* @__PURE__ */ a.createElement(vt, { className: `${N[M.name]}`, x: M.forestPlotAlignRight ? u : M.forestPlotStartingPoint, y: r(T), textAnchor: M.forestPlotAlignRight ? "end" : "start", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: "black" }, N[M.name]))), !m.hideDateCategoryCol && t.map((M, N) => /* @__PURE__ */ a.createElement(vt, { className: `${M[o.xAxis.dataKey]}`, x: 0, y: r(N), textAnchor: "start", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: "black" }, M[o.xAxis.dataKey])), !m.hideDateCategoryCol && o.xAxis.dataKey && /* @__PURE__ */ a.createElement(vt, { className: o.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, o.xAxis.dataKey), P.map((M) => /* @__PURE__ */ a.createElement(vt, { className: `${M.label}`, x: M.forestPlotAlignRight ? u : M.forestPlotStartingPoint, y: 0, textAnchor: M.forestPlotAlignRight ? "end" : "start", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, M.label)), m.leftLabel && /* @__PURE__ */ a.createElement(vt, { className: "forest-plot__left-label", x: m.type === "Linear" ? i(0) - 25 : i(1) - 25, y: d + y, textAnchor: "end", verticalAnchor: "start" }, m.leftLabel), m.rightLabel && /* @__PURE__ */ a.createElement(vt, { className: "forest-plot__right-label", x: m.type === "Linear" ? i(0) + 25 : i(1) + 25, y: d + y, textAnchor: "start", verticalAnchor: "start" }, m.rightLabel));
}, Ak = ({ width: e, height: t, originalWidth: n }) => {
  var P, M, N;
  const { config: i, colorScale: r, transformedData: o, formatNumber: d, seriesHighlight: u, getTextWidth: s } = ce.useContext(Ct);
  if (!i || ((P = i == null ? void 0 : i.series) == null ? void 0 : P.length) < 2)
    return;
  const h = i.barHasBorder === "true" ? 1 : 0, m = e / 2, y = { small: 16, medium: 18, large: 20 }, v = 1.02, w = {
    parentKey: (M = i.dataDescription) == null ? void 0 : M.seriesKey,
    dataKey: i.series[0].dataKey,
    dataKeyLabel: i.runtime.seriesLabels[i.series[0].dataKey] || i.series[0].dataKey,
    color: r(i.runtime.seriesLabels[i.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((T) => T[i.series[0].dataKey])
    ),
    labelColor: ""
  }, E = {
    parentKey: (N = i.dataDescription) == null ? void 0 : N.seriesKey,
    dataKey: i.series[1].dataKey,
    dataKeyLabel: i.runtime.seriesLabels[i.series[1].dataKey] || i.series[1].dataKey,
    color: r(i.runtime.seriesLabels[i.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((T) => T[i.series[1].dataKey])
    ),
    labelColor: ""
  }, R = Kn({
    domain: [0, Math.max(w.max * v, E.max * 1.1)],
    range: [0, m]
  });
  w.labelColor = w.color ? Zo("#000", w.color) : "#000", E.labelColor = E.color ? Zo("#000", E.color) : "#000";
  const C = i.yAxis.label ? `${i.yAxis.label}: ` : "", g = (T) => {
    var U;
    return `<p>
				${(U = i.dataDescription) == null ? void 0 : U.seriesKey}: ${w.dataKeyLabel}<br/>
				${i.xAxis.dataKey}: ${T[i.xAxis.dataKey]}<br/>
				${C}${d(T[w.dataKey], "left")}
			</p>`;
  }, _ = (T) => {
    var U;
    return `<p>
				${(U = i.dataDescription) == null ? void 0 : U.seriesKey}: ${E.dataKeyLabel}<br/>
				${i.xAxis.dataKey}: ${T[i.xAxis.dataKey]}<br/>
				${C}${d(T[E.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ a.createElement("svg", { id: "cdc-visualization__paired-bar-chart", width: n, height: t, viewBox: `0 0 ${e + Number(i.runtime.yAxis.size)} ${t}`, role: "img", tabIndex: 0 }, /* @__PURE__ */ a.createElement("title", null, `Paired bar chart graphic with the title ${i.title ? i.title : "No Title Found"}`), /* @__PURE__ */ a.createElement(nt, { top: 0, left: Number(i.xAxis.size) }, o.filter((T) => i.series[0].dataKey === w.dataKey).map((T, U) => {
    var X, Q;
    let V = i.legend.behavior === "highlight" && u.length > 0 && u.indexOf(i.series[0].dataKey) === -1, G = i.legend.behavior === "highlight" || u.length === 0 || u.indexOf(i.series[0].dataKey) !== -1, ue = R(T[i.series[0].dataKey]), Z = Number(i.barHeight) ? Number(i.barHeight) : 25, $ = 0;
    $ = U !== 0 ? (Number(i.barSpace) + Z + h) * U : $;
    const H = (Number(i.barSpace) + Z + h) * o.length;
    i.heights.horizontal = H;
    const F = s(d(T[w.dataKey], "left"), `normal ${y[i.fontSize]}px sans-serif`) < ue - 5;
    return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(nt, { key: `group-${w.dataKey}-${T[i.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ a.createElement(
      gr,
      {
        id: `bar-${w.dataKey}-${T[(X = i.dataDescription) == null ? void 0 : X.xKey]}`,
        className: "bar group-1",
        key: `bar-${w.dataKey}-${T[(Q = i.dataDescription) == null ? void 0 : Q.xKey]}`,
        x: m - ue,
        y: $,
        width: R(T[i.series[0].dataKey]),
        height: Z,
        fill: w.color,
        "data-tooltip-html": g(T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${i.runtime.uniqueId}`,
        stroke: "#333",
        strokeWidth: h,
        opacity: V ? 0.5 : 1,
        display: G ? "block" : "none",
        tabIndex: -1
      }
    ), i.yAxis.displayNumbersOnBar && G && /* @__PURE__ */ a.createElement(vt, { textAnchor: F ? "start" : "end", dx: F ? 5 : -5, verticalAnchor: "middle", x: m - ue, y: $ + i.barHeight / 2, fill: F ? w.labelColor : "#000" }, d(T[w.dataKey], "left"))));
  }), o.filter((T) => i.series[1].dataKey === E.dataKey).map((T, U) => {
    var X, Q, ae;
    let V = R(T[i.series[1].dataKey]), G = i.legend.behavior === "highlight" && u.length > 0 && u.indexOf(i.series[1].dataKey) === -1, ue = i.legend.behavior === "highlight" || u.length === 0 || u.indexOf(i.series[1].dataKey) !== -1, Z = i.barHeight ? Number(i.barHeight) : 25, $ = 0;
    $ = U !== 0 ? (Number(i.barSpace) + Z + h) * U : $;
    const H = (Number(i.barSpace) + Z + h) * o.length;
    i.heights.horizontal = H;
    const F = s(d(T[E.dataKey], "left"), `normal ${y[i.fontSize]}px sans-serif`) < V - 5;
    return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("style", null, `
                      .bar-${E.dataKey}-${T[i.xAxis.dataKey]} {
                          transform-origin: ${m}px ${$}px
                      }
							      `), /* @__PURE__ */ a.createElement(nt, { key: `group-${E.dataKey}-${T[(X = i.dataDescription) == null ? void 0 : X.xKey]}`, className: "horizontal" }, /* @__PURE__ */ a.createElement(
      gr,
      {
        id: `bar-${E.dataKey}-${T[(Q = i.dataDescription) == null ? void 0 : Q.xKey]}`,
        className: "bar group-2",
        key: `bar-${E.dataKey}-${T[(ae = i.dataDescription) == null ? void 0 : ae.xKey]}`,
        x: m,
        y: $,
        width: R(T[i.series[1].dataKey]),
        height: Z,
        fill: E.color,
        "data-tooltip-html": _(T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${i.runtime.uniqueId}`,
        strokeWidth: h,
        stroke: "#333",
        opacity: G ? 0.5 : 1,
        display: ue ? "block" : "none",
        tabIndex: -1
      }
    ), i.yAxis.displayNumbersOnBar && ue && /* @__PURE__ */ a.createElement(vt, { textAnchor: F ? "end" : "start", dx: F ? -5 : 5, verticalAnchor: "middle", x: m + V, y: $ + i.barHeight / 2, fill: F ? E.labelColor : "#000" }, d(T[E.dataKey], "left"))));
  }))));
}, cy = ({ config: e, minValue: t, maxValue: n, existPositiveValue: i, data: r, isAllLine: o, tableData: d }) => {
  let u = 0, s = 0, h = 0, m = 0;
  if (!r)
    return { min: u, max: s };
  const y = () => _c(e.visualizationType, r, e.allowLineToBarGraph), { visualizationType: v, series: w } = e, { max: E, min: R } = e.runtime.yAxis, C = i ? E >= n : E >= 0, g = e.useLogScale ? R >= 0 : R <= 0 && t >= 0 || R <= t && t < 0;
  u = R && g ? R : t, s = E && C ? E : Number.MIN_VALUE;
  const { lower: _, upper: P } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (_ && P && e.visualizationType === "Bar") {
    const M = u < 0 ? 1.1 : 0;
    s = Math.max(n, Math.max(...r.flatMap((N) => [N[P], N[_]])) * 1.15), u = Math.min(t, Math.min(...r.flatMap((N) => [N[P], N[_]])) * 1.15) * M;
  }
  if (e.series.filter((M) => (M == null ? void 0 : M.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: M }
    } = e;
    if ((M == null ? void 0 : M.length) > 0) {
      let N = [];
      M.forEach((G) => {
        var ue;
        (ue = G.confidenceIntervals) == null || ue.map((Z) => {
          N.push(Z.high), N.push(Z.low);
        });
      });
      const T = r.map((G) => N.map((ue) => G[ue])), U = Math.max.apply(
        null,
        T.map((G) => G[0])
      ), V = Math.min.apply(
        null,
        T.map((G) => G[1])
      );
      U > s && (s = U), V < u && (u = V);
    }
  }
  if (v === "Combo")
    try {
      if (!r)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let M = w.filter((U) => U.axis === "Left"), N = w.filter((U) => U.axis === "Right");
      const T = (U, V, G, ue = "left") => {
        let Z = 0;
        return (V.map((H) => H.dataKey) || []).forEach((H) => {
          let j = V.find((Q) => Q.dataKey === H), F = U.map((Q) => Q[H]), X = Math.max.apply(null, F);
          e.visualizationSubType === "stacked" && ue === "left" && j.type === "Bar" && (Z += X), X > G && (G = X), G < Z && (G = Z);
        }), G;
      };
      h = T(r, M, h, "left"), m = T(r, N, m, "right"), h < E && (h = E);
    } catch (M) {
      console.error(M.message);
    }
  if ((v === "Bar" || y() || v === "Combo" && !o) && u > 0 && (u = 0), (e.visualizationType === "Bar" || y() || e.visualizationType === "Combo" && !o) && u < 0 && (u = u * 1.1), e.visualizationType === "Combo" && o && ((R == null || R === "") && u > 0 && (u = 0), R)) {
    const M = e.useLogScale ? R >= 0 && R < t : R < t;
    u = R && M ? R : t;
  }
  if (e.visualizationType === "Deviation Bar" && u > 0) {
    const M = Number(R) < Math.min(t, Number(e.xAxis.target));
    u = R && M ? R : 0;
  }
  if (e.visualizationType === "Line" && !y()) {
    const M = e.useLogScale ? R >= 0 && R < t : R < t, N = d == null ? void 0 : d.some((T, U) => {
      var V;
      return (V = e.preliminaryData) == null ? void 0 : V.some((G) => {
        var H;
        if (G.type !== "suppression" || !G.style)
          return !1;
        const ue = Ni.pick(T, (H = e.runtime) == null ? void 0 : H.seriesKeys), Z = Ni.values(ue).includes(G.value);
        return (G.column ? T[G.column] === G.value : Z) && (U === 0 || U === d.length - 1);
      });
    });
    u = R && M ? R : N ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = i ? n : 0), e.runtime.yAxis.paddingPercent) {
    let M = (s - u) * e.runtime.yAxis.paddingPercent;
    u -= M, s += M;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const M = r.map((T) => T[e.series[0].dataKey]), N = Math.max(...M).toString().length;
    switch (!0) {
      case (N > 8 && N <= 12):
        s = s * 1.3;
        break;
      case (N > 4 && N <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (u < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, u *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), { min: u, max: s, leftMax: h, rightMax: m };
}, jr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Pk = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: i, min: r, max: o, config: d, data: u } = e;
  const { rawData: s, dimensions: h } = ce.useContext(Ct), [m, y] = h, v = d.runtime.barSeriesKeys || d.runtime.seriesKeys, w = d.runtime.xAxis.type, E = d.orientation === "horizontal", R = (G) => G[d.runtime.originalXAxis.dataKey], C = u.map((G) => R(G)), { visualizationType: g } = d;
  let _ = null, P = null, M = null, N = null, T = null, U = null, V = null;
  if (E && (_ = Rk({ min: r * 1.03, ...e }), _.type = d.useLogScale ? jr.LOG : jr.LINEAR, P = Ok(w, t), P.rangeRound([0, i]), T = um(v, [0, i])), E || (V = um(C, [0, n], 0.5), _ = Qd(t, [0, n], 1 - d.barThickness), P = Dk(e), T = Qd(v, [0, _.bandwidth()], 0)), d.xAxis.type === "date-time") {
    let G = Math.min(...t), ue = Math.max(...t);
    G -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ue - G), ue += (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ue - G), _ = wv({
      domain: [G, ue],
      range: [0, n]
    }), _.type = jr.TIME;
    let Z = Number.MAX_VALUE;
    for (let $ = 0; $ < t.length - 1; $++) {
      let H = _(t[$ + 1]) - _(t[$]);
      H < Z && (Z = H);
    }
    T = Qd(v, [0, (d.barThickness || 1) * Z], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const G = d.isLollipopChart ? 1.05 : 1.03;
    P = nf({
      domain: t,
      range: [0, i]
    }), _ = Kn({
      domain: [r * G, Math.max(Number(d.xAxis.target), o)],
      range: [0, n],
      round: !0,
      nice: !0
    }), _.type = jr.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot" && d.xAxis.type === "continuous" && (_ = Kn({
    domain: [0, Math.max.apply(null, _.domain())],
    range: [0, n]
  }), _.type = jr.LINEAR), g === "Box Plot") {
    const G = [];
    if (d.boxplot.plots.map((H) => H.columnOutliers.map((j) => G.push(j))) && !d.boxplot.hideOutliers) {
      let H = Math.min(...G), j = Math.max(...G);
      H < r && (r = H), j > o && (o = j);
    }
    let Z = Math.min(...d.boxplot.plots.map((H) => H.columnLowerBounds)), $ = Math.max(...d.boxplot.plots.map((H) => H.columnUpperBounds));
    Z < r && (r = Z), $ > o && (o = $), P = Kn({
      range: [i, 0],
      round: !0,
      domain: [r, o]
    }), _ = nf({
      range: [0, n],
      round: !0,
      domain: d.boxplot.categories,
      padding: 0.4
    }), _.type = jr.BAND;
  }
  if (g === "Paired Bar") {
    let ue = Math.max.apply(
      Math,
      u.map(($) => {
        var H;
        return $[(H = d.series[0]) == null ? void 0 : H.dataKey];
      })
    ), Z = Math.max.apply(
      Math,
      u.map(($) => {
        var H;
        return $[(H = d.series[1]) == null ? void 0 : H.dataKey];
      })
    );
    N = Kn({
      domain: [0, Math.max(ue, Z) * 1.02],
      range: [n / 2, 0]
    }), M = Kn({
      domain: N.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (g === "Forest Plot") {
    const G = () => d.forestPlot.regression.showDiamond || d.forestPlot.regression.description ? [0 + d.forestPlot.rowHeight * 2, i - d.forestPlot.rowHeight] : [0 + d.forestPlot.rowHeight * 2, i];
    P = Kn({
      domain: [0, s.length],
      range: G()
    });
    const ue = 5, Z = Number(d.forestPlot.leftWidthOffset) / 100 * n, $ = Number(d.forestPlot.rightWidthOffset) / 100 * n, H = Number(d.forestPlot.rightWidthOffsetMobile) / 100 * n, j = Number(d.forestPlot.leftWidthOffsetMobile) / 100 * n;
    if (m > 480) {
      if (d.forestPlot.type === "Linear" && (_ = Kn({
        domain: [Math.min(...u.map((F) => parseFloat(F[d.forestPlot.lower]))) - ue, Math.max(...u.map((F) => parseFloat(F[d.forestPlot.upper]))) + ue],
        range: [Z, h[0] - $]
      }), _.type = jr.LINEAR), d.forestPlot.type === "Logarithmic") {
        let F = Math.max(...u.map((Q) => parseFloat(Q[d.forestPlot.upper]))), X = Math.min(...u.map((Q) => parseFloat(Q[d.forestPlot.lower])));
        _ = Xu({
          domain: [X, F],
          range: [Z, n - $],
          nice: !0
        }), _.type = jr.LOG;
      }
    } else if (d.forestPlot.type === "Linear" && (_ = Kn({
      domain: [Math.min(...u.map((F) => parseFloat(F[d.forestPlot.lower]))) - ue, Math.max(...u.map((F) => parseFloat(F[d.forestPlot.upper]))) + ue],
      range: [j, n - H],
      type: jr.LINEAR
    })), d.forestPlot.type === "Logarithmic") {
      let F = Math.max(...u.map((Q) => parseFloat(Q[d.forestPlot.upper]))), X = Math.min(...u.map((Q) => parseFloat(Q[d.forestPlot.lower])));
      _ = Xu({
        domain: [X, F],
        range: [Z, n - $],
        nice: !0,
        base: F > 1 ? 10 : 2,
        round: !1,
        type: jr.LOG
      });
    }
  }
  return { xScale: _, yScale: P, seriesScale: T, g1xScale: N, g2xScale: M, xScaleNoPadding: U, xScaleBrush: V };
}, Lk = (e, t, n) => {
  const i = t.domain();
  if (t.type === "time") {
    const r = e[e.length - 1], o = e[0], d = (r - o) / (n - 1), u = [];
    for (let s = r; s >= o; s -= d)
      u.push(s);
    return u[u.length - 1] !== o && u.push(o), u.reverse(), u;
  }
  if (i.length > 2) {
    const r = n || 1, o = [];
    for (let d = i.length; d > 0; d -= r) {
      const u = Math.max(Math.round(d) - 1, 0);
      o.push(i[u]);
    }
    return o.reverse(), o;
  }
}, Rk = ({ min: e, max: t, xMax: n, config: i }) => (e = i.useLogScale && e >= 0 && e < 1 ? e + 0.1 : e, (i.useLogScale ? Xu : Kn)({
  domain: [e, t],
  range: [0, n],
  nice: i.useLogScale,
  zero: i.useLogScale
})), Dk = ({ min: e, max: t, yMax: n, config: i, leftMax: r }) => {
  e = i.useLogScale && e >= 0 && e < 1 ? e + 0.1 : e;
  const o = i.useLogScale ? Xu : Kn;
  return i.visualizationType === "Combo" && (t = r), o({
    domain: [e, t],
    range: [n, 0],
    nice: i.useLogScale,
    zero: i.useLogScale
  });
}, Ok = (e, t) => e === "date" ? Kn({
  domain: [Math.min(...t), Math.max(...t)]
}) : Yo({ domain: t, padding: 0.5 }), um = (e, t, n = 0) => Yo({
  domain: e,
  range: t,
  padding: n
}), Qd = (e, t, n = 0) => nf({
  domain: e,
  range: t,
  padding: n
});
function Mk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Os = () => {
  const { config: e } = ce.useContext(Ct), { visualizationType: t, series: n, orientation: i, visualizationSubType: r } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = ["theme-blue", "theme-purple", "theme-brown", "theme-teal", "theme-pink", "theme-orange", "theme-slate", "theme-indigo", "theme-cyan", "theme-green", "theme-amber"], u = () => !["Forest Plot", "Sankey"].includes(t), s = () => !["Spark Line"].includes(t), h = () => !["Spark Line"].includes(t), m = () => !["Area Chart", "Box Plot", "Pie", "Scatter Plot", "Forest Plot", "Spark Line", "Sankey"].includes(t), y = () => !["Area Chart", "Scatter Plot", "Box Plot", "Forest Plot", "Spark Line", "Sankey"].includes(t), v = () => {
    switch (t) {
      case "Box Plot":
        return !1;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, w = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), E = () => e.visualizationType === "Bar" && e.visualizationSubType === "stacked" ? !1 : !!["Bar", "Combo"].includes(e.visualizationType), R = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, C = () => {
    if ((t === "Bar" || "Combo") && r === "regular")
      return !0;
  }, g = () => ["Line", "Bar", "Area Chart", "Combo"].includes(t) && i === "vertical", _ = () => ["Box Plot", "Scatter Plot", "Pie"].includes(t) ? !1 : n == null ? void 0 : n.some((Ke) => Ke.type === "Bar" || Ke.type === "Paired Bar" || Ke.type === "Deviation Bar"), P = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, M = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: y,
    visHasAnchors: R,
    visHasBarBorders: _,
    visHasDataCutoff: P,
    visHasLabelOnData: m,
    visHasDataSuppression: C,
    visHasLegend: v,
    visHasLegendAxisAlign: () => t === "Bar" && r === "stacked" && e.legend.behavior === "isolate",
    visHasBrushChart: g,
    visHasNumbersOnBars: w,
    visHasaAdditionalLabelsOnBars: E,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : i === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxis: u,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: h,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => (e == null || e.series.some((Le) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(Le == null ? void 0 : Le.type)), t === "Line" || t === "Bar" && r === "regular" || t === "Combo"),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: s,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: M,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Le = ["Forest Plot"];
      return !(i === "horizontal" || Le.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t)
  };
};
var yh = {};
const _k = /* @__PURE__ */ jf(FS), Nk = /* @__PURE__ */ jf(US);
var vh = {};
vh.__esModule = !0;
vh.default = Fk;
var zu = ce;
function Fk(e) {
  var t = (0, zu.useState)(e), n = t[0], i = t[1], r = (0, zu.useRef)(null), o = (0, zu.useCallback)(function(d, u) {
    r.current = u || null, i(d);
  }, [i]);
  return (0, zu.useLayoutEffect)(function() {
    r.current && (r.current(n), r.current = null);
  }, [n]), [n, o];
}
var xh = {}, bh = {};
bh.__esModule = !0;
bh.default = zk;
function zk(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
var Sh = {};
Sh.__esModule = !0;
Sh.default = Ik;
function Bk(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n)
    return (n = n.call(e)).next.bind(n);
  if (Array.isArray(e) || (n = $k(e)) || t && e && typeof e.length == "number") {
    n && (e = n);
    var i = 0;
    return function() {
      return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function $k(e, t) {
  if (e) {
    if (typeof e == "string")
      return cm(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return cm(e, t);
  }
}
function cm(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, i = new Array(t); n < t; n++)
    i[n] = e[n];
  return i;
}
function Ik(e, t) {
  for (var n = e, i = 1 / 0, r = Bk(t), o; !(o = r()).done; ) {
    var d = o.value, u = Math.sqrt(Math.pow(d.x - e.x, 2) + Math.pow(d.y - e.y, 2));
    u < i && (i = u, n = {
      x: d.x,
      y: d.y
    });
  }
  return n;
}
xh.__esModule = !0;
xh.default = Wk;
var dm = dy(bh), Hk = dy(Sh);
function dy(e) {
  return e && e.__esModule ? e : { default: e };
}
function Wk(e, t, n) {
  var i, r, o, d;
  return n === void 0 && (n = {}), t.length > 0 ? (0, Hk.default)(e, t) : {
    x: (0, dm.default)(e.x, (i = n.xMin) != null ? i : -1 / 0, (r = n.xMax) != null ? r : 1 / 0),
    y: (0, dm.default)(e.y, (o = n.yMin) != null ? o : -1 / 0, (d = n.yMax) != null ? d : 1 / 0)
  };
}
var Eh = {};
Eh.__esModule = !0;
Eh.default = Uk;
var Vk = ce;
function jk(e, t, n) {
  if (n === void 0 && (n = 1), !e)
    return [];
  for (var i = [], r = e.getTotalLength(), o = 0; o <= r; o += n) {
    var d = e.getPointAtLength(o), u = d.matrixTransform(t);
    i.push(u);
  }
  return i;
}
function Uk(e) {
  var t = (0, Vk.useMemo)(function() {
    if (!e)
      return [];
    var n = e.getCTM() || new DOMMatrix();
    return jk(e, n);
  }, [e == null ? void 0 : e.getTotalLength()]);
  return t;
}
yh.__esModule = !0;
yh.default = Xk;
var Oi = ce, Uo = _k, fm = Nk, Kk = kh(vh), hm = kh(xh), Yk = kh(Eh);
function kh(e) {
  return e && e.__esModule ? e : { default: e };
}
function Yr() {
  return Yr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Yr.apply(this, arguments);
}
function Xk(e) {
  var t = e === void 0 ? {} : e, n = t.resetOnStart, i = n === void 0 ? !1 : n, r = t.snapToPointer, o = r === void 0 ? !0 : r, d = t.onDragEnd, u = t.onDragMove, s = t.onDragStart, h = t.x, m = t.y, y = t.dx, v = t.dy, w = t.isDragging, E = t.restrict, R = E === void 0 ? {} : E, C = t.restrictToPath, g = (0, Oi.useRef)({
    x: h,
    y: m,
    dx: y,
    dy: v
  }), _ = (0, Kk.default)({
    x: h,
    y: m,
    dx: y ?? 0,
    dy: v ?? 0,
    isDragging: !1
  }), P = _[0], M = _[1], N = (0, Oi.useState)(new Uo.Point({
    x: 0,
    y: 0
  })), T = N[0], U = N[1];
  (0, Oi.useEffect)(function() {
    (g.current.x !== h || g.current.y !== m || g.current.dx !== y || g.current.dy !== v) && (g.current = {
      x: h,
      y: m,
      dx: y,
      dy: v
    }, M(function($) {
      return Yr({}, $, {
        x: h,
        y: m,
        dx: y ?? 0,
        dy: v ?? 0
      });
    }));
  }), (0, Oi.useEffect)(function() {
    w !== void 0 && P.isDragging !== w && M(function($) {
      return Yr({}, $, {
        isDragging: w
      });
    });
  }, [P.isDragging, w, M]);
  var V = (0, Yk.default)(C), G = (0, Oi.useCallback)(function($) {
    $.persist(), M(function(H) {
      var j = H.x, F = j === void 0 ? 0 : j, X = H.y, Q = X === void 0 ? 0 : X, ae = H.dx, te = H.dy, re = new Uo.Point({
        x: (F || 0) + ae,
        y: (Q || 0) + te
      }), ie = (0, fm.localPoint)($) || new Uo.Point({
        x: 0,
        y: 0
      }), ge = o ? ie : re, ve = (0, hm.default)(ge, V, R);
      return U((0, Uo.subtractPoints)(re, ie)), {
        isDragging: !0,
        dx: i ? 0 : H.dx,
        dy: i ? 0 : H.dy,
        x: i ? ve.x : ve.x - H.dx,
        y: i ? ve.y : ve.y - H.dy
      };
    }, s && function(H) {
      s(Yr({}, H, {
        event: $
      }));
    });
  }, [s, i, R, V, M, o]), ue = (0, Oi.useCallback)(function($) {
    $.persist(), M(function(H) {
      if (!H.isDragging)
        return H;
      var j = H.x, F = j === void 0 ? 0 : j, X = H.y, Q = X === void 0 ? 0 : X, ae = (0, fm.localPoint)($) || new Uo.Point({
        x: 0,
        y: 0
      }), te = o ? ae : (0, Uo.sumPoints)(ae, T), re = (0, hm.default)(te, V, R);
      return Yr({}, H, {
        dx: re.x - F,
        dy: re.y - Q
      });
    }, u && function(H) {
      H.isDragging && u(Yr({}, H, {
        event: $
      }));
    });
  }, [M, u, o, T, V, R]), Z = (0, Oi.useCallback)(function($) {
    $.persist(), M(function(H) {
      return Yr({}, H, {
        isDragging: !1
      });
    }, d && function(H) {
      d(Yr({}, H, {
        event: $
      }));
    });
  }, [d, M]);
  return Yr({}, P, {
    dragEnd: Z,
    dragMove: ue,
    dragStart: G
  });
}
var Fc = fy, ls = wh(bm), Jd = wh(ce), qk = wh(yh);
function wh(e) {
  return e && e.__esModule ? e : { default: e };
}
function fy(e) {
  var t = e.captureDragArea, n = t === void 0 ? !0 : t, i = e.snapToPointer, r = i === void 0 ? !0 : i, o = e.children, d = e.dx, u = e.dy, s = e.height, h = e.onDragEnd, m = e.onDragMove, y = e.onDragStart, v = e.resetOnStart, w = e.width, E = e.x, R = e.y, C = e.isDragging, g = e.restrict, _ = e.restrictToPath, P = (0, qk.default)({
    resetOnStart: v,
    snapToPointer: r,
    onDragEnd: h,
    onDragMove: m,
    onDragStart: y,
    x: E,
    y: R,
    dx: d,
    dy: u,
    isDragging: C,
    restrict: g,
    restrictToPath: _
  });
  return /* @__PURE__ */ Jd.default.createElement(Jd.default.Fragment, null, P.isDragging && n && /* @__PURE__ */ Jd.default.createElement("rect", {
    width: w,
    height: s,
    onPointerDown: P.dragStart,
    onPointerMove: P.dragMove,
    onPointerUp: P.dragEnd,
    fill: "transparent"
  }), o(P));
}
fy.propTypes = {
  children: ls.default.func.isRequired,
  width: ls.default.number.isRequired,
  height: ls.default.number.isRequired,
  captureDragArea: ls.default.bool,
  isDragging: ls.default.bool
};
function Ec(e, t) {
  if ("invert" in e && typeof e.invert < "u")
    return e.invert(t).valueOf();
  var n = e.range(), i = n[0], r = n[1], o = 0, d = "step" in e && typeof e.step < "u" ? e.step() : 1, u = d * (r - i) / Math.abs(r - i);
  if (u > 0)
    for (; t > i + u * (o + 1); )
      o += 1;
  else
    for (; t < i + u * (o + 1); )
      o += 1;
  return o;
}
function pm(e, t, n, i) {
  var r, o = Ec(e, t + (t < n ? -i : i)), d = Ec(e, n + (n < t ? -i : i)), u = Math.min(o, d), s = Math.max(o, d);
  if ("invert" in e && typeof e.invert < "u")
    r = {
      start: u,
      end: s
    };
  else {
    for (var h = [], m = e.domain(), y = u; y <= s; y += 1)
      h.push(m[y]);
    r = {
      values: h
    };
  }
  return r;
}
function Th(e) {
  if (typeof window < "u" && window.TouchEvent && e instanceof TouchEvent)
    return {
      pageX: e.touches[0].pageX,
      pageY: e.touches[0].pageY
    };
  var t = e;
  return {
    pageX: t.pageX,
    pageY: t.pageY
  };
}
function wr() {
  return wr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, wr.apply(this, arguments);
}
function Gk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, _f(e, t);
}
function _f(e, t) {
  return _f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, _f(e, t);
}
var hy = /* @__PURE__ */ function(e) {
  Gk(t, e);
  function t() {
    for (var i, r = arguments.length, o = new Array(r), d = 0; d < r; d++)
      o[d] = arguments[d];
    return i = e.call.apply(e, [this].concat(o)) || this, i.handleDragStart = function(u) {
      var s = i.props, h = s.onBrushHandleChange, m = s.type, y = s.onBrushStart;
      h && h(m, Th(u.event)), y && y(u);
    }, i.handleDragMove = function(u) {
      var s = i.props, h = s.updateBrush, m = s.type, y = s.isControlled;
      !u.isDragging || y || h(function(v) {
        var w = v.start, E = v.end, R = 0, C = Math.max(w.x, E.x), g = Math.min(w.x, E.x), _ = Math.max(w.y, E.y), P = Math.min(w.y, E.y);
        switch (m) {
          case "right":
            return R = C + u.dx, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                x0: Math.max(Math.min(R, w.x), v.bounds.x0),
                x1: Math.min(Math.max(R, w.x), v.bounds.x1)
              })
            });
          case "left":
            return R = g + u.dx, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                x0: Math.min(R, E.x),
                x1: Math.max(R, E.x)
              })
            });
          case "bottom":
            return R = _ + u.dy, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                y0: Math.min(R, w.y),
                y1: Math.max(R, w.y)
              })
            });
          case "top":
            return R = P + u.dy, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                y0: Math.min(R, E.y),
                y1: Math.max(R, E.y)
              })
            });
          default:
            return v;
        }
      });
    }, i.handleDragEnd = function() {
      var u = i.props, s = u.updateBrush, h = u.onBrushEnd, m = u.onBrushHandleChange, y = u.isControlled;
      y || s(function(v) {
        var w = v.start, E = v.end, R = v.extent;
        w.x = Math.min(R.x0, R.x1), w.y = Math.min(R.y0, R.y0), E.x = Math.max(R.x0, R.x1), E.y = Math.max(R.y0, R.y1);
        var C = wr({}, v, {
          start: w,
          end: E,
          activeHandle: null,
          isBrushing: !1,
          extent: {
            x0: Math.min(w.x, E.x),
            x1: Math.max(w.x, E.x),
            y0: Math.min(w.y, E.y),
            y1: Math.max(w.y, E.y)
          }
        });
        return h && h(C), C;
      }), m && m();
    }, i;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this, o = this.props, d = o.stageWidth, u = o.stageHeight, s = o.brush, h = o.type, m = o.handle, y = o.isControlled, v = o.isDragInProgress, w = o.renderBrushHandle, E = m.x, R = m.y, C = m.width, g = m.height, _ = h === "right" || h === "left" ? "ew-resize" : "ns-resize";
    return /* @__PURE__ */ a.createElement(Fc, {
      width: d,
      height: u,
      onDragStart: this.handleDragStart,
      onDragMove: this.handleDragMove,
      onDragEnd: this.handleDragEnd,
      resetOnStart: !0,
      isDragging: y ? v : void 0
    }, function(P) {
      var M = P.dragStart, N = P.dragEnd, T = P.dragMove, U = P.isDragging;
      return /* @__PURE__ */ a.createElement("g", null, U && /* @__PURE__ */ a.createElement("rect", {
        fill: "transparent",
        width: d,
        height: u,
        style: {
          cursor: _
        },
        onPointerMove: T,
        onPointerUp: y ? void 0 : N,
        onPointerLeave: y ? void 0 : N
      }), !w && /* @__PURE__ */ a.createElement("rect", {
        x: E,
        y: R,
        width: C,
        height: g,
        fill: "transparent",
        className: "visx-brush-handle-" + h,
        onPointerDown: M,
        onPointerMove: T,
        onPointerUp: y ? void 0 : N,
        style: {
          cursor: _,
          pointerEvents: s.activeHandle || s.isBrushing ? "none" : "all"
        }
      }), w && /* @__PURE__ */ a.createElement("g", {
        onPointerDown: M,
        onPointerMove: T,
        onPointerUp: y ? void 0 : N
      }, w(wr({}, r.props.handle, {
        height: u,
        className: "visx-brush-handle-" + h,
        isBrushActive: s.extent.x0 !== -1 && s.extent.x1 !== -1
      }))));
    });
  }, t;
}(a.Component);
hy.propTypes = {
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  handle: he.shape({
    x: he.number.isRequired,
    y: he.number.isRequired,
    width: he.number.isRequired,
    height: he.number.isRequired
  }).isRequired,
  isControlled: he.bool,
  isDragInProgress: he.bool,
  onBrushHandleChange: he.func,
  renderBrushHandle: he.func
};
function mr() {
  return mr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, mr.apply(this, arguments);
}
function Zk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Nf(e, t);
}
function Nf(e, t) {
  return Nf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, Nf(e, t);
}
var Ch = /* @__PURE__ */ function(e) {
  Zk(t, e);
  function t() {
    for (var i, r = arguments.length, o = new Array(r), d = 0; d < r; d++)
      o[d] = arguments[d];
    return i = e.call.apply(e, [this].concat(o)) || this, i.cornerDragMove = function(u) {
      var s = i.props, h = s.updateBrush, m = s.type;
      u.isDragging && h(function(y) {
        var v = y.start, w = y.end, E = Math.max(v.x, w.x), R = Math.min(v.x, w.x), C = Math.max(v.y, w.y), g = Math.min(v.y, w.y), _ = 0, P = 0;
        switch (m) {
          case "topRight":
            return _ = E + u.dx, P = g + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(_, v.x), y.bounds.x0),
                x1: Math.min(Math.max(_, v.x), y.bounds.x1),
                y0: Math.max(Math.min(P, w.y), y.bounds.y0),
                y1: Math.min(Math.max(P, w.y), y.bounds.y1)
              })
            });
          case "topLeft":
            return _ = R + u.dx, P = g + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(_, w.x), y.bounds.x0),
                x1: Math.min(Math.max(_, w.x), y.bounds.x1),
                y0: Math.max(Math.min(P, w.y), y.bounds.y0),
                y1: Math.min(Math.max(P, w.y), y.bounds.y1)
              })
            });
          case "bottomLeft":
            return _ = R + u.dx, P = C + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(_, w.x), y.bounds.x0),
                x1: Math.min(Math.max(_, w.x), y.bounds.x1),
                y0: Math.max(Math.min(P, v.y), y.bounds.y0),
                y1: Math.min(Math.max(P, v.y), y.bounds.y1)
              })
            });
          case "bottomRight":
            return _ = E + u.dx, P = C + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(_, v.x), y.bounds.x0),
                x1: Math.min(Math.max(_, v.x), y.bounds.x1),
                y0: Math.max(Math.min(P, v.y), y.bounds.y0),
                y1: Math.min(Math.max(P, v.y), y.bounds.y1)
              })
            });
          default:
            return y;
        }
      });
    }, i.cornerDragEnd = function() {
      var u = i.props, s = u.updateBrush, h = u.onBrushEnd;
      s(function(m) {
        var y = m.start, v = m.end, w = m.extent;
        y.x = Math.min(w.x0, w.x1), y.y = Math.min(w.y0, w.y0), v.x = Math.max(w.x0, w.x1), v.y = Math.max(w.y0, w.y1);
        var E = mr({}, m, {
          start: y,
          end: v,
          activeHandle: null,
          domain: {
            x0: Math.min(y.x, v.x),
            x1: Math.max(y.x, v.x),
            y0: Math.min(y.y, v.y),
            y1: Math.max(y.y, v.y)
          }
        });
        return h && h(E), E;
      });
    }, i;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this.props, o = r.type, d = r.brush, u = r.stageWidth, s = r.stageHeight, h = r.style, m = r.corner, y = (h == null ? void 0 : h.cursor) || (o === "topLeft" || o === "bottomRight" ? "nwse-resize" : "nesw-resize"), v = d.activeHandle || d.isBrushing ? "none" : "all";
    return /* @__PURE__ */ a.createElement(Fc, {
      width: u,
      height: s,
      onDragMove: this.cornerDragMove,
      onDragEnd: this.cornerDragEnd,
      resetOnStart: !0
    }, function(w) {
      var E = w.dragMove, R = w.dragEnd, C = w.dragStart, g = w.isDragging;
      return /* @__PURE__ */ a.createElement("g", null, g && /* @__PURE__ */ a.createElement("rect", {
        fill: "transparent",
        width: u,
        height: s,
        style: {
          cursor: y
        },
        onPointerMove: E,
        onPointerUp: R
      }), /* @__PURE__ */ a.createElement("rect", mr({
        fill: "transparent",
        onPointerDown: C,
        onPointerMove: E,
        onPointerUp: R,
        className: "visx-brush-corner-" + o,
        style: mr({
          cursor: y,
          pointerEvents: v
        }, h)
      }, m)));
    });
  }, t;
}(a.Component);
Ch.propTypes = {
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onBrushEnd: he.func,
  corner: he.shape({
    x: he.number.isRequired,
    y: he.number.isRequired,
    width: he.number.isRequired,
    height: he.number.isRequired
  }).isRequired
};
Ch.defaultProps = {
  style: {}
};
function Ba() {
  return Ba = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Ba.apply(this, arguments);
}
function Qk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ff(e, t);
}
function Ff(e, t) {
  return Ff = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, Ff(e, t);
}
var Jk = {
  cursor: "move"
}, Ah = /* @__PURE__ */ function(e) {
  Qk(t, e);
  function t() {
    for (var i, r = arguments.length, o = new Array(r), d = 0; d < r; d++)
      o[d] = arguments[d];
    return i = e.call.apply(e, [this].concat(o)) || this, i.selectionDragStart = function(u) {
      var s = i.props, h = s.onMoveSelectionChange, m = s.onBrushStart;
      h && h("move", Th(u.event)), m && m(u);
    }, i.selectionDragMove = function(u) {
      var s = i.props, h = s.updateBrush, m = s.isControlled;
      m || h(function(y) {
        var v = y.start, w = v.x, E = v.y, R = y.end, C = R.x, g = R.y, _ = u.dx > 0 ? Math.min(u.dx, y.bounds.x1 - C) : Math.max(u.dx, y.bounds.x0 - w), P = u.dy > 0 ? Math.min(u.dy, y.bounds.y1 - g) : Math.max(u.dy, y.bounds.y0 - E);
        return Ba({}, y, {
          isBrushing: !0,
          extent: Ba({}, y.extent, {
            x0: w + _,
            x1: C + _,
            y0: E + P,
            y1: g + P
          })
        });
      });
    }, i.selectionDragEnd = function() {
      var u = i.props, s = u.updateBrush, h = u.onBrushEnd, m = u.onMoveSelectionChange, y = u.isControlled;
      y || s(function(v) {
        var w = Ba({}, v, {
          isBrushing: !1,
          start: Ba({}, v.start, {
            x: Math.min(v.extent.x0, v.extent.x1),
            y: Math.min(v.extent.y0, v.extent.y1)
          }),
          end: Ba({}, v.end, {
            x: Math.max(v.extent.x0, v.extent.x1),
            y: Math.max(v.extent.y0, v.extent.y1)
          })
        });
        return h && h(w), w;
      }), m && m();
    }, i;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this.props, o = r.width, d = r.height, u = r.stageWidth, s = r.stageHeight, h = r.brush, m = r.disableDraggingSelection, y = r.onMouseLeave, v = r.onMouseMove, w = r.onMouseUp, E = r.onClick, R = r.selectedBoxStyle, C = r.isControlled, g = r.isDragInProgress;
    return /* @__PURE__ */ a.createElement(Fc, {
      width: o,
      height: d,
      resetOnStart: !0,
      onDragStart: this.selectionDragStart,
      onDragMove: this.selectionDragMove,
      onDragEnd: this.selectionDragEnd,
      isDragging: C ? g : void 0
    }, function(_) {
      var P = _.isDragging, M = _.dragStart, N = _.dragEnd, T = _.dragMove;
      return /* @__PURE__ */ a.createElement("g", null, P && /* @__PURE__ */ a.createElement("rect", {
        width: u,
        height: s,
        fill: "transparent",
        onPointerUp: C ? void 0 : N,
        onPointerMove: T,
        onPointerLeave: C ? void 0 : N,
        style: Jk
      }), /* @__PURE__ */ a.createElement("rect", Ba({
        x: Math.min(h.extent.x0, h.extent.x1),
        y: Math.min(h.extent.y0, h.extent.y1),
        width: o,
        height: d,
        className: "visx-brush-selection",
        onPointerDown: m ? void 0 : M,
        onPointerLeave: function(V) {
          y && y(V);
        },
        onPointerMove: function(V) {
          T(V), v && v(V);
        },
        onPointerUp: function(V) {
          C || N(V), w && w(V);
        },
        onClick: function(V) {
          E && E(V);
        },
        style: {
          pointerEvents: h.isBrushing || h.activeHandle ? "none" : "all",
          cursor: m ? void 0 : "move"
        }
      }, R)));
    });
  }, t;
}(a.Component);
Ah.propTypes = {
  width: he.number.isRequired,
  height: he.number.isRequired,
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onMoveSelectionChange: he.func,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  disableDraggingSelection: he.bool.isRequired,
  onMouseLeave: he.func,
  onMouseMove: he.func,
  onMouseUp: he.func,
  onClick: he.func,
  isControlled: he.bool,
  isDragInProgress: he.bool
};
Ah.defaultProps = {
  onMouseLeave: null,
  onMouseUp: null,
  onMouseMove: null,
  onClick: null
};
function zf() {
  return zf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, zf.apply(this, arguments);
}
function Bf(e) {
  return /* @__PURE__ */ a.createElement(gr, zf({
    className: "visx-brush-overlay",
    fill: "transparent",
    x: 0,
    y: 0
  }, e));
}
Bf.propTypes = {
  width: he.number.isRequired,
  height: he.number.isRequired,
  onClick: he.func,
  onDoubleClick: he.func,
  onPointerDown: he.func,
  onPointerLeave: he.func,
  onPointerMove: he.func,
  onPointerUp: he.func
};
function ar() {
  return ar = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, ar.apply(this, arguments);
}
function ew(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, $f(e, t);
}
function $f(e, t) {
  return $f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, $f(e, t);
}
var Ph = /* @__PURE__ */ function(e) {
  ew(t, e);
  function t(i) {
    var r;
    r = e.call(this, i) || this, r.mouseUpTime = 0, r.mouseDownTime = 0, r.getIdleState = function() {
      var u = r.props, s = u.width, h = u.height;
      return {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        },
        extent: {
          x0: -1,
          x1: -1,
          y0: -1,
          y1: -1
        },
        bounds: {
          x0: 0,
          x1: s,
          y0: 0,
          y1: h
        },
        isBrushing: !1,
        brushPageOffset: void 0,
        activeHandle: null,
        brushingType: void 0
      };
    }, r.handleWindowPointerUp = function() {
      var u = r.props, s = u.useWindowMoveEvents, h = u.onBrushEnd, m = u.resetOnEnd, y = r.state.brushingType;
      s && y && r.updateBrush(function(v) {
        var w = v.start, E = v.end, R = v.extent;
        w.x = Math.min(R.x0, R.x1), w.y = Math.min(R.y0, R.y0), E.x = Math.max(R.x0, R.x1), E.y = Math.max(R.y0, R.y1);
        var C = ar({}, v, {
          activeHandle: null,
          isBrushing: !1,
          brushingType: void 0
        });
        return h && h(C), m && (C = ar({}, C, r.getIdleState())), C;
      });
    }, r.handleWindowPointerMove = function(u) {
      var s = r.props.useWindowMoveEvents, h = r.state, m = h.brushingType, y = h.isBrushing, v = h.brushPageOffset, w = h.start;
      if (!(!s || !y)) {
        var E = u.pageX - ((v == null ? void 0 : v.pageX) || 0), R = u.pageY - ((v == null ? void 0 : v.pageY) || 0);
        ["left", "right", "top", "bottom"].includes(m ?? "") && r.updateBrush(function(C) {
          var g = C.start, _ = g.x, P = g.y, M = C.end, N = M.x, T = M.y;
          return ar({}, C, {
            isBrushing: !0,
            extent: ar({}, C.extent, r.getExtent({
              x: m === "left" ? Math.min(Math.max(_ + E, C.bounds.x0), C.bounds.x1) : _,
              y: m === "top" ? Math.min(Math.max(P + R, C.bounds.y0), C.bounds.y1) : P
            }, {
              x: m === "right" ? Math.min(Math.max(N + E, C.bounds.x0), C.bounds.x1) : N,
              y: m === "bottom" ? Math.min(Math.max(T + R, C.bounds.y0), C.bounds.y1) : T
            }))
          });
        }), m === "move" && r.updateBrush(function(C) {
          var g = C.start, _ = g.x, P = g.y, M = C.end, N = M.x, T = M.y, U = E > 0 ? Math.min(E, C.bounds.x1 - N) : Math.max(E, C.bounds.x0 - _), V = R > 0 ? Math.min(R, C.bounds.y1 - T) : Math.max(R, C.bounds.y0 - P);
          return ar({}, C, {
            isBrushing: !0,
            extent: ar({}, C.extent, {
              x0: _ + U,
              y0: P + V,
              x1: N + U,
              y1: T + V
            })
          });
        }), m === "select" && r.updateBrush(function(C) {
          var g = C.start, _ = g.x, P = g.y, M = {
            x: Math.min(Math.max(_ + E, C.bounds.x0), C.bounds.x1),
            y: Math.min(Math.max(P + R, C.bounds.y0), C.bounds.y1)
          }, N = r.getExtent(w, M), T = ar({}, C, {
            end: M,
            extent: N
          });
          return T;
        });
      }
    }, r.getExtent = function(u, s) {
      var h = r.props, m = h.brushDirection, y = h.width, v = h.height, w = m === "vertical" ? 0 : Math.min(u.x || 0, s.x || 0), E = m === "vertical" ? y : Math.max(u.x || 0, s.x || 0), R = m === "horizontal" ? 0 : Math.min(u.y || 0, s.y || 0), C = m === "horizontal" ? v : Math.max(u.y || 0, s.y || 0);
      return {
        x0: w,
        x1: E,
        y0: R,
        y1: C
      };
    }, r.handleDragStart = function(u) {
      var s = r.props, h = s.onBrushStart, m = s.left, y = s.top, v = s.inheritedMargin, w = s.useWindowMoveEvents, E = v != null && v.left ? v.left : 0, R = v != null && v.top ? v.top : 0, C = {
        x: (u.x || 0) + u.dx - m - E,
        y: (u.y || 0) + u.dy - y - R
      }, g = ar({}, C);
      h && h(C), r.updateBrush(function(_) {
        return ar({}, _, {
          start: C,
          end: g,
          extent: {
            x0: -1,
            x1: -1,
            y0: -1,
            y1: -1
          },
          isBrushing: !0,
          brushingType: "select",
          brushPageOffset: w ? Th(u.event) : void 0
        });
      });
    }, r.handleBrushStart = function(u) {
      var s = r.props, h = s.onBrushStart, m = s.left, y = s.top, v = s.inheritedMargin;
      if (h) {
        var w = v != null && v.left ? v.left : 0, E = v != null && v.top ? v.top : 0, R = {
          x: (u.x || 0) + u.dx - m - w,
          y: (u.y || 0) + u.dy - y - E
        };
        h(R);
      }
    }, r.handleDragMove = function(u) {
      var s = r.props, h = s.left, m = s.top, y = s.inheritedMargin, v = s.useWindowMoveEvents;
      if (!(!u.isDragging || v)) {
        var w = (y == null ? void 0 : y.left) || 0, E = (y == null ? void 0 : y.top) || 0, R = {
          x: (u.x || 0) + u.dx - h - w,
          y: (u.y || 0) + u.dy - m - E
        };
        r.updateBrush(function(C) {
          var g = C.start, _ = r.getExtent(g, R);
          return ar({}, C, {
            end: R,
            extent: _
          });
        });
      }
    }, r.handleDragEnd = function() {
      var u = r.props, s = u.onBrushEnd, h = u.resetOnEnd, m = u.useWindowMoveEvents;
      m || r.updateBrush(function(y) {
        var v = y.extent, w = ar({}, y, {
          start: {
            x: v.x0,
            y: v.y0
          },
          end: {
            x: v.x1,
            y: v.y1
          },
          isBrushing: !1,
          brushingType: void 0,
          activeHandle: null
        });
        return s && s(w), h && (w = ar({}, w, r.getIdleState())), w;
      });
    }, r.getBrushWidth = function() {
      var u = r.state.extent, s = u.x0, h = u.x1;
      return Math.max(Math.max(s, h) - Math.min(s, h), 0);
    }, r.getBrushHeight = function() {
      var u = r.state.extent, s = u.y1, h = u.y0;
      return Math.max(Math.max(h, s) - Math.min(h, s), 0);
    }, r.handles = function() {
      var u = r.props.handleSize, s = r.state.extent, h = s.x0, m = s.x1, y = s.y0, v = s.y1, w = u / 2, E = r.getBrushWidth(), R = r.getBrushHeight();
      return {
        top: {
          x: h - w,
          y: y - w,
          height: u,
          width: E + u
        },
        bottom: {
          x: h - w,
          y: v - w,
          height: u,
          width: E + u
        },
        right: {
          x: m - w,
          y: y - w,
          height: R + u,
          width: u
        },
        left: {
          x: h - w,
          y: y - w,
          height: R + u,
          width: u
        }
      };
    }, r.corners = function() {
      var u = r.props.handleSize, s = r.state.extent, h = s.x0, m = s.x1, y = s.y0, v = s.y1, w = u / 2, E = u, R = u;
      return {
        topLeft: {
          x: Math.min(h, m) - w,
          y: Math.min(y, v) - w,
          width: E,
          height: R
        },
        topRight: {
          x: Math.max(h, m) - w,
          y: Math.min(y, v) - w,
          width: E,
          height: R
        },
        bottomLeft: {
          x: Math.min(h, m) - w,
          y: Math.max(y, v) - w,
          width: E,
          height: R
        },
        bottomRight: {
          x: Math.max(h, m) - w,
          y: Math.max(y, v) - w,
          width: E,
          height: R
        }
      };
    }, r.updateBrush = function(u) {
      var s = r.props.onChange;
      r.setState(u, function() {
        s && s(r.state);
      });
    }, r.reset = function() {
      return r.updateBrush(function() {
        return r.getIdleState();
      });
    }, r.handleBrushingTypeChange = function(u, s) {
      r.updateBrush(function(h) {
        var m = ar({}, h, {
          brushingType: u,
          isBrushing: u !== void 0
        });
        return (s || u === void 0) && (m.brushPageOffset = s), m;
      });
    };
    var o = i.initialBrushPosition, d = o ? r.getExtent(o.start, o.end) : {
      x0: -1,
      x1: -1,
      y0: -1,
      y1: -1
    };
    return r.state = {
      start: {
        x: Math.max(0, d.x0),
        y: Math.max(0, d.y0)
      },
      end: {
        x: Math.max(0, d.x1),
        y: Math.max(0, d.y1)
      },
      extent: d,
      bounds: {
        x0: 0,
        x1: r.props.width,
        y0: 0,
        y1: r.props.height
      },
      isBrushing: !1,
      brushingType: void 0,
      activeHandle: null
    }, r;
  }
  var n = t.prototype;
  return n.componentDidUpdate = function(r) {
    var o = this;
    (this.props.width !== r.width || this.props.height !== r.height) && this.setState(function(d) {
      var u = d.start, s = d.end, h = d.extent;
      if (!(h.x0 === -1 && h.x1 === -1 && h.y0 === -1 && h.y1 === -1)) {
        var m = o.props.width / r.width, y = o.props.height / r.height;
        u = {
          x: m * h.x0,
          y: y * h.y0
        }, s = {
          x: m * h.x1,
          y: y * h.y1
        }, h = o.getExtent(u, s);
      }
      return {
        start: u,
        end: s,
        extent: h,
        bounds: {
          x0: 0,
          x1: o.props.width,
          y0: 0,
          y1: o.props.height
        }
      };
    });
  }, n.componentDidMount = function() {
    this.props.useWindowMoveEvents && (window.addEventListener("mouseup", this.handleWindowPointerUp), window.addEventListener("mousemove", this.handleWindowPointerMove));
  }, n.componentWillUnmount = function() {
    this.props.useWindowMoveEvents && (window.removeEventListener("mouseup", this.handleWindowPointerUp), window.removeEventListener("mousemove", this.handleWindowPointerMove));
  }, n.render = function() {
    var r = this, o = this.state, d = o.start, u = o.end, s = this.props, h = s.top, m = s.left, y = s.width, v = s.height, w = s.onMouseLeave, E = s.onMouseUp, R = s.onMouseMove, C = s.onBrushEnd, g = s.onClick, _ = s.resizeTriggerAreas, P = s.selectedBoxStyle, M = s.disableDraggingSelection, N = s.disableDraggingOverlay, T = s.clickSensitivity, U = s.useWindowMoveEvents, V = s.renderBrushHandle, G = this.state.brushingType, ue = this.handles(), Z = this.corners(), $ = this.getBrushWidth(), H = this.getBrushHeight(), j = new Set(_);
    return /* @__PURE__ */ a.createElement(nt, {
      className: "visx-brush",
      top: h,
      left: m
    }, N ? /* @__PURE__ */ a.createElement(Bf, {
      width: y,
      height: v,
      onClick: function(X) {
        var Q = r.mouseUpTime - r.mouseDownTime;
        g && Q < T && g(X);
      },
      style: {
        cursor: "default"
      }
    }) : /* @__PURE__ */ a.createElement(Fc, {
      width: y,
      height: v,
      resetOnStart: !0,
      onDragStart: this.handleDragStart,
      onDragMove: this.handleDragMove,
      onDragEnd: this.handleDragEnd,
      isDragging: U ? G === "select" : void 0
    }, function(F) {
      var X = F.dragStart, Q = F.isDragging, ae = F.dragMove, te = F.dragEnd;
      return /* @__PURE__ */ a.createElement(Bf, {
        width: y,
        height: v,
        onDoubleClick: function() {
          return r.reset();
        },
        onClick: function(ie) {
          var ge = r.mouseUpTime - r.mouseDownTime;
          g && ge < T && g(ie);
        },
        onPointerDown: function(ie) {
          r.mouseDownTime = Date.now(), X(ie);
        },
        onPointerLeave: function(ie) {
          w && w(ie);
        },
        onPointerMove: function(ie) {
          !Q && R && R(ie), Q && ae(ie);
        },
        onPointerUp: function(ie) {
          r.mouseUpTime = Date.now(), E && E(ie), te(ie);
        },
        style: {
          cursor: "crosshair"
        }
      });
    }), d && u && /* @__PURE__ */ a.createElement(Ah, {
      updateBrush: this.updateBrush,
      width: $,
      height: H,
      stageWidth: y,
      stageHeight: v,
      brush: this.state,
      disableDraggingSelection: M,
      onBrushEnd: C,
      onBrushStart: this.handleBrushStart,
      onMouseLeave: w,
      onMouseMove: R,
      onMouseUp: E,
      onMoveSelectionChange: this.handleBrushingTypeChange,
      onClick: g,
      selectedBoxStyle: P,
      isControlled: U,
      isDragInProgress: U ? G === "move" : void 0
    }), d && u && Object.keys(ue).filter(function(F) {
      return j.has(F);
    }).map(function(F) {
      var X = ue[F];
      return X && /* @__PURE__ */ a.createElement(hy, {
        key: "handle-" + F,
        type: F,
        handle: X,
        stageWidth: y,
        stageHeight: v,
        updateBrush: r.updateBrush,
        brush: r.state,
        onBrushStart: r.handleBrushStart,
        onBrushEnd: C,
        isControlled: U,
        isDragInProgress: U ? G === F : void 0,
        onBrushHandleChange: r.handleBrushingTypeChange,
        renderBrushHandle: V
      });
    }), d && u && Object.keys(Z).filter(function(F) {
      return j.has(F);
    }).map(function(F) {
      var X = Z[F];
      return X && /* @__PURE__ */ a.createElement(Ch, {
        key: "corner-" + F,
        type: F,
        brush: r.state,
        updateBrush: r.updateBrush,
        stageWidth: y,
        stageHeight: v,
        corner: X,
        onBrushEnd: C
      });
    }));
  }, t;
}(a.Component);
Ph.propTypes = {
  brushDirection: he.oneOf(["horizontal", "vertical", "both"]),
  width: he.number.isRequired,
  height: he.number.isRequired,
  left: he.number.isRequired,
  top: he.number.isRequired,
  onChange: he.func,
  handleSize: he.number,
  resizeTriggerAreas: he.array,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  onMouseLeave: he.func,
  onMouseUp: he.func,
  onMouseMove: he.func,
  onClick: he.func,
  clickSensitivity: he.number,
  disableDraggingSelection: he.bool,
  disableDraggingOverlay: he.bool,
  resetOnEnd: he.bool,
  useWindowMoveEvents: he.bool,
  renderBrushHandle: he.func
};
Ph.defaultProps = {
  brushDirection: "both",
  inheritedMargin: {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  onChange: null,
  handleSize: 4,
  resizeTriggerAreas: ["left", "right"],
  onBrushStart: null,
  onBrushEnd: null,
  onMouseLeave: null,
  onMouseUp: null,
  onMouseMove: null,
  onClick: null,
  disableDraggingSelection: !1,
  disableDraggingOverlay: !1,
  clickSensitivity: 200,
  resetOnEnd: !1,
  initialBrushPosition: null,
  useWindowMoveEvents: !1,
  renderBrushHandles: null
};
function tw(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, If(e, t);
}
function If(e, t) {
  return If = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, If(e, t);
}
var mm = 2, gm = "steelblue", Lh = /* @__PURE__ */ function(e) {
  tw(t, e);
  function t() {
    for (var i, r = arguments.length, o = new Array(r), d = 0; d < r; d++)
      o[d] = arguments[d];
    return i = e.call.apply(e, [this].concat(o)) || this, i.handleChange = function(u) {
      var s = i.props.onChange;
      if (s) {
        var h = u.extent.x0;
        if (typeof h > "u" || h < 0) {
          s(null);
          return;
        }
        var m = i.convertRangeToDomain(u);
        s(m);
      }
    }, i.handleBrushStart = function(u) {
      var s = i.props.onBrushStart;
      if (s) {
        var h = u.x, m = u.y, y = i.props, v = y.xScale, w = y.yScale, E = Ec(v, h), R = Ec(w, m);
        s({
          x: "invert" in v && typeof v.invert < "u" ? E : v.domain()[E],
          y: "invert" in w && typeof w.invert < "u" ? R : w.domain()[R]
        });
      }
    }, i.handleBrushEnd = function(u) {
      var s = i.props.onBrushEnd;
      if (s) {
        var h = u.extent.x0;
        if (typeof h > "u" || h < 0) {
          s(null);
          return;
        }
        var m = i.convertRangeToDomain(u);
        s(m);
      }
    }, i;
  }
  var n = t.prototype;
  return n.convertRangeToDomain = function(r) {
    var o = this.props, d = o.xScale, u = o.yScale, s = r.extent, h = s.x0, m = s.x1, y = s.y0, v = s.y1, w = pm(d, h || 0, m || 0, mm), E = pm(u, y || 0, v || 0, mm), R = {
      x0: w.start || 0,
      x1: w.end || 0,
      xValues: w.values,
      y0: E.start || 0,
      y1: E.end || 0,
      yValues: E.values
    };
    return R;
  }, n.render = function() {
    var r = this.props, o = r.xScale, d = r.yScale, u = r.height, s = r.width, h = r.margin, m = r.brushDirection, y = r.initialBrushPosition, v = r.innerRef, w = r.resizeTriggerAreas, E = r.brushRegion, R = r.yAxisOrientation, C = r.xAxisOrientation, g = r.selectedBoxStyle, _ = r.disableDraggingSelection, P = r.disableDraggingOverlay, M = r.resetOnEnd, N = r.onMouseLeave, T = r.onMouseMove, U = r.onClick, V = r.handleSize, G = r.useWindowMoveEvents, ue = r.renderBrushHandle;
    if (!o || !d)
      return null;
    var Z, $, H, j, F = h != null && h.left ? h.left : 0, X = h != null && h.top ? h.top : 0, Q = h != null && h.right ? h.right : 0, ae = h != null && h.bottom ? h.bottom : 0;
    return E === "chart" ? (H = 0, j = 0, Z = s, $ = u) : E === "yAxis" ? (j = 0, $ = u, R === "right" ? (H = s, Z = Q) : (H = -F, Z = F)) : (H = 0, Z = s, C === "bottom" ? (j = u, $ = ae) : (j = -X, $ = X)), /* @__PURE__ */ a.createElement(Ph, {
      width: Z,
      height: $,
      left: H,
      top: j,
      brushDirection: m,
      disableDraggingSelection: _,
      disableDraggingOverlay: P,
      handleSize: V,
      inheritedMargin: h,
      initialBrushPosition: y,
      ref: v,
      resetOnEnd: M,
      resizeTriggerAreas: w,
      selectedBoxStyle: g,
      onBrushEnd: this.handleBrushEnd,
      onBrushStart: this.handleBrushStart,
      onChange: this.handleChange,
      onClick: U,
      onMouseLeave: N,
      onMouseMove: T,
      useWindowMoveEvents: G,
      renderBrushHandle: ue
    });
  }, t;
}(ce.Component);
Lh.propTypes = {
  height: he.number,
  width: he.number,
  onChange: he.func,
  onBrushEnd: he.func,
  brushDirection: he.oneOf(["vertical", "horizontal", "both"]),
  resizeTriggerAreas: he.array,
  brushRegion: he.oneOf(["xAxis", "yAxis", "chart"]),
  yAxisOrientation: he.oneOf(["left", "right"]),
  xAxisOrientation: he.oneOf(["top", "bottom"]),
  disableDraggingSelection: he.bool,
  disableDraggingOverlay: he.bool,
  resetOnEnd: he.bool,
  handleSize: he.number,
  useWindowMoveEvents: he.bool,
  renderBrushHandle: he.func
};
Lh.defaultProps = {
  xScale: null,
  yScale: null,
  onChange: null,
  height: 0,
  width: 0,
  selectedBoxStyle: {
    fill: gm,
    fillOpacity: 0.2,
    stroke: gm,
    strokeWidth: 1,
    strokeOpacity: 0.8
  },
  margin: {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  handleSize: 4,
  brushDirection: "horizontal",
  initialBrushPosition: null,
  resizeTriggerAreas: ["left", "right"],
  brushRegion: "chart",
  yAxisOrientation: "right",
  xAxisOrientation: "bottom",
  onBrushStart: null,
  onBrushEnd: null,
  disableDraggingSelection: !1,
  resetOnEnd: !1,
  onMouseMove: null,
  onMouseLeave: null,
  onClick: null,
  useWindowMoveEvents: !1,
  renderBrushHandles: null
};
const nw = Lh, rw = (e) => {
  var U, V, G, ue;
  const { tableData: t, config: n, parseDate: i, formatDate: r, setBrushConfig: o, getTextWidth: d, dashboardConfig: u } = ce.useContext(Ct), s = ((U = u == null ? void 0 : u.dashboard) == null ? void 0 : U.sharedFilters) ?? [], h = (s == null ? void 0 : s.length) > 0, { fontSize: m } = Rs(), [y, v] = ce.useState(!1), [w, E] = ce.useState(0), R = ce.useRef(null), C = 15, [g, _] = ce.useState({
    startPosition: 0,
    endPosition: 0,
    startValue: "",
    endValue: "",
    xMax: e.xMax
  }), P = {
    start: { x: 0 },
    end: { x: e.xMax }
  }, M = {
    fill: "#474747",
    stroke: "blue",
    fillOpacity: 0.8,
    strokeOpacity: 0,
    rx: C
  }, N = (Z) => {
    var ae, te;
    v(!1);
    const $ = (ae = Z == null ? void 0 : Z.xValues) == null ? void 0 : ae.filter((re) => re !== void 0);
    if (($ == null ? void 0 : $.length) === 0)
      return;
    const H = (te = n.xAxis) == null ? void 0 : te.dataKey, j = t.filter((re) => $.includes(re[H])), F = $.slice().reverse().find((re) => re !== void 0), X = $.find((re) => re !== void 0), Q = (re) => Pn(n.runtime.xAxis) ? r(i(re)) : re;
    _((re) => {
      var ie, ge;
      return {
        ...re,
        startPosition: (ie = R.current) == null ? void 0 : ie.state.start.x,
        endPosition: (ge = R.current) == null ? void 0 : ge.state.end.x,
        endValue: Q(F),
        startValue: Q(X),
        xMax: e.xMax
      };
    }), o((re) => {
      var ie;
      return {
        ...re,
        isBrushing: (ie = R.current) == null ? void 0 : ie.state.isBrushing,
        data: j
      };
    });
  };
  ce.useEffect(() => {
    var Z;
    (Z = n.brush) != null && Z.active || (E(($) => $ + 1), o({
      data: [],
      isActive: !1,
      isBrushing: !1
    }));
  }, [(V = n.brush) == null ? void 0 : V.active]), ce.useEffect(() => {
    var H, j, F;
    const Z = (H = n.filters) == null ? void 0 : H.some((X) => X.active), $ = (j = n.exclusions) == null ? void 0 : j.active;
    return (Z || $ || h) && ((F = n.brush) != null && F.active) && (E((X) => X + 1), o((X) => ({
      ...X,
      data: t
    }))), () => o((X) => ({
      ...X,
      data: []
    }));
  }, [n.filters, n.exclusions, (G = n.brush) == null ? void 0 : G.active, h]);
  const T = () => {
    const Z = Number(n.xAxis.tickRotation) > 0 ? Number(n.xAxis.tickRotation) : 0;
    let $ = 0;
    const H = 30;
    return n.xAxis.label || (!n.isResponsiveTicks && Z && ($ = Number(Z + n.xAxis.tickWidthMax) / 1.6), !n.isResponsiveTicks && !Z && ($ = Number(n.xAxis.labelOffset) - H), n.isResponsiveTicks && n.dynamicMarginTop && ($ = Number(n.xAxis.labelOffset + n.xAxis.tickWidthMax / 1.6)), n.isResponsiveTicks && !n.dynamicMarginTop && ($ = Number(n.xAxis.labelOffset - H))), n.xAxis.label && (!n.isResponsiveTicks && Z && ($ = Number(n.xAxis.tickWidthMax + Z) + H), !n.isResponsiveTicks && !Z && ($ = n.xAxis.labelOffset + H), n.isResponsiveTicks && !Z && ($ = Number(n.dynamicMarginTop ? n.dynamicMarginTop : n.xAxis.labelOffset) + H * 2)), $;
  };
  if (["Line", "Bar", "Area Chart", "Combo"].includes(n.visualizationType))
    return /* @__PURE__ */ a.createElement(Cr, { component: "Brush Chart" }, /* @__PURE__ */ a.createElement(
      nt,
      {
        onMouseMove: () => {
          g.startPosition === 0 && (g.endPosition === 0 || g.endPosition === e.xMax) && v(!0);
        },
        onMouseLeave: () => v(!1),
        display: (ue = n.brush) != null && ue.active ? "block" : "none",
        top: Number(e.yMax) + T(),
        left: Number(n.runtime.yAxis.size),
        pointerEvents: "fill"
      },
      /* @__PURE__ */ a.createElement("rect", { fill: "#949494", width: e.xMax, height: n.brush.height, rx: C }),
      /* @__PURE__ */ a.createElement(
        nw,
        {
          key: w,
          disableDraggingOverlay: !0,
          renderBrushHandle: (Z) => {
            var $;
            return /* @__PURE__ */ a.createElement(
              aw,
              {
                left: Number(n.runtime.yAxis.size),
                showTooltip: y,
                getTextWidth: d,
                pixelDistance: g.endPosition - g.startPosition,
                textProps: g,
                fontSize: m[n.fontSize],
                ...Z,
                isBrushing: ($ = R.current) == null ? void 0 : $.state.isBrushing
              }
            );
          },
          innerRef: R,
          useWindowMoveEvents: !0,
          selectedBoxStyle: M,
          xScale: e.xScaleBrush,
          yScale: e.yScale,
          width: e.xMax,
          resizeTriggerAreas: ["left", "right"],
          height: n.brush.height,
          handleSize: 8,
          brushDirection: "horizontal",
          initialBrushPosition: P,
          onChange: N
        }
      )
    ));
}, aw = (e) => {
  const { x: t, isBrushActive: n, isBrushing: i, className: r, textProps: o, fontSize: d, showTooltip: u, left: s, getTextWidth: h } = e, m = 8;
  if (!n)
    return null;
  const y = r.includes("left"), v = y ? "scale(-1, 1)" : "translate(0,0)", w = y ? "end" : "start", E = y ? " Drag edges to focus on a specific segment " : "", R = h(E, `normal ${d / 1.1}px sans-serif`);
  return /* @__PURE__ */ a.createElement(a.Fragment, null, u && /* @__PURE__ */ a.createElement(vt, { x: (Number(o.xMax) - R) / 2, dy: -12, pointerEvents: "visiblePainted", fontSize: d / 1.1 }, E), /* @__PURE__ */ a.createElement(nt, { left: t + m / 2, top: -2 }, /* @__PURE__ */ a.createElement(vt, { pointerEvents: "visiblePainted", dominantBaseline: "hanging", x: y ? 55 : -50, y: 25, verticalAnchor: "start", textAnchor: w, fontSize: d / 1.4 }, y ? o.startValue : o.endValue), /* @__PURE__ */ a.createElement("path", { cursor: "ew-resize", d: "M0.5,10A6,6 0 0 1 6.5,16V14A6,6 0 0 1 0.5,20ZM2.5,18V12M4.5,18V12", fill: "#297EF1", strokeWidth: "1", transform: v })));
}, Ur = (e) => {
  var tn, $t, Sn, En, Dn, Ln;
  const { transformedData: t, tableData: n, dimensions: i, config: r, parseDate: o, formatDate: d, currentViewport: u, formatNumber: s, handleChartAriaLabels: h, updateConfig: m, handleLineType: y, getTextWidth: v, brushConfig: w } = ce.useContext(Ct), { visualizationType: E, visualizationSubType: R, orientation: C, xAxis: g, yAxis: _, runtime: P, debugSvg: M } = r, N = () => _c(r.visualizationType, t, r.allowLineToBarGraph);
  let [T] = i;
  r && r.legend && !r.legend.hide && ((tn = r.legend) == null ? void 0 : tn.position) !== "bottom" && ["lg", "md"].includes(u) && (T = T * 0.73);
  const { horizontal: U } = r.heights, V = C === "horizontal" || r.visualizationType === "Forest Plot", G = !0, ue = isNaN(parseInt(P.xAxis.labelOffset)) ? 0 : parseInt(P.xAxis.labelOffset), Z = isNaN(parseInt(P.yAxis.labelOffset)) ? 0 : parseInt(P.yAxis.labelOffset), $ = isNaN(parseInt(P.xAxis.size)) ? 0 : parseInt(P.xAxis.size);
  let H = r.aspectRatio ? T * r.aspectRatio : r.visualizationType === "Forest Plot" ? r.heights.vertical : r.heights[C];
  const j = T - P.yAxis.size - (E === "Combo" ? r.yAxis.rightAxisSize : 0);
  let F = H - (C === "horizontal" ? 0 : $);
  H += C === "horizontal" ? $ : 0, r.visualizationType === "Forest Plot" && (H = H + r.data.length * r.forestPlot.rowHeight, F = F + r.data.length * r.forestPlot.rowHeight, T = i[0]), ($t = r.brush) != null && $t.active && (H = H + ((Sn = r.brush) == null ? void 0 : Sn.height));
  const { minValue: X, maxValue: Q, existPositiveValue: ae, isAllLine: te } = Nc(r, t), { visSupportsReactTooltip: re } = Os(), { hasTopAxis: ie } = Mk(r), [ge, ve] = ce.useState(!1), [Se, ye] = ce.useState({ x: 0, y: 0 }), ee = ce.useRef(), Ee = ce.useRef(), He = dh(ee, {
    freezeOnceVisible: !1
  }), we = (Me) => Pn(r.runtime.xAxis) ? o(Me[r.runtime.originalXAxis.dataKey]).getTime() : Me[r.runtime.originalXAxis.dataKey], fe = (Me, dt) => Me[dt], Ae = (En = r.brush) != null && En.active && ((Dn = w.data) != null && Dn.length) ? w.data.map((Me) => we(Me)) : t.map((Me) => we(Me)), ne = r.orientation === "horizontal" || r.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", $e = { data: t, tableData: n, config: r, minValue: X, maxValue: Q, isAllLine: te, existPositiveValue: ae, xAxisDataMapped: Ae, xMax: j, yMax: F }, { min: Le, max: Ke, leftMax: Ge, rightMax: et } = cy($e), { yScaleRight: Ze, hasRightAxis: Et } = gh({ config: r, yMax: F, data: t, updateConfig: m }), { xScale: qe, yScale: Be, seriesScale: Ie, g1xScale: Fe, g2xScale: lt, xScaleNoPadding: Ue, xScaleBrush: ct } = Pk({ ...$e, min: Le, max: Ke, leftMax: Ge, rightMax: et, dimensions: i }), [ht, gt] = ce.useState(null);
  ce.useEffect(() => {
    var Me;
    gt((Me = Ee == null ? void 0 : Ee.current) == null ? void 0 : Me.getBoundingClientRect());
  }, [Ee, r.legend]);
  const Dt = (Me, dt) => {
    if (r.useLogScale && Me === 0.1 && (Me = 0), !(r.data && !r.data[dt] && E === "Forest Plot"))
      return r.visualizationType === "Forest Plot" ? r.data[dt][r.xAxis.dataKey] : Pn(P.yAxis) ? d(o(Me)) : C === "vertical" && Ke - Le < 3 ? s(Me, "left", G, !1, !1, "1") : C === "vertical" ? s(Me, "left", G) : Me;
  }, qt = (Me) => (r.useLogScale && Me === 0.1 && (Me = 0), Pn(P.xAxis) && r.visualizationType !== "Forest Plot" ? d(Me) : C === "horizontal" && r.visualizationType !== "Forest Plot" ? s(Me, "left", G) : r.xAxis.type === "continuous" && r.visualizationType !== "Forest Plot" ? s(Me, "bottom", G) : r.visualizationType === "Forest Plot" ? s(Me, "left", r.dataFormat.abbreviated, r.runtime.xAxis.prefix, r.runtime.xAxis.suffix, Number(r.dataFormat.roundTo)) : Me), Vt = (Me) => {
    let { numTicks: dt } = P[Me];
    P[Me].viewportNumTicks && P[Me].viewportNumTicks[u] && (dt = P[Me].viewportNumTicks[u]);
    let it;
    return Me === "yAxis" && (it = V && !dt ? t.length : V && dt ? dt : !V && !dt ? void 0 : !V && dt && dt, it === void 0 && !r.dataFormat.roundTo && (Number(Ke) <= 3 ? it = 2 : it = 4), Number(it) > Number(Ke) && (it = Number(Le) < 0 ? Math.round(Ke) * 2 : Math.round(Ke))), Me === "xAxis" && (it = V && !dt ? void 0 : V && dt ? dt : !V && !dt ? void 0 : !V && dt && dt, V && it === void 0 && !r.dataFormat.roundTo && (Ke <= 3 ? it = 2 : it = 4), r.visualizationType === "Forest Plot" && (it = r.yAxis.numTicks !== "" ? r.yAxis.numTicks : 4)), it;
  }, { tooltipData: kt, showTooltip: zt, hideTooltip: ln, tooltipOpen: en, tooltipLeft: cn, tooltipTop: ze } = _g(), {
    handleTooltipMouseOver: Nt,
    handleTooltipClick: Gt,
    handleTooltipMouseOff: Bt,
    tooltipStyles: yn,
    TooltipListItem: Lt,
    getXValueFromCoordinateDate: bn,
    getXValueFromCoordinate: Mn
  } = $g({
    xScale: qe,
    yScale: Be,
    showTooltip: zt,
    hideTooltip: ln
  });
  ce.useEffect(() => {
    document.querySelector(".isEditor") && ve((dt) => !0);
  }), ce.useEffect(() => {
    (He == null ? void 0 : He.isIntersecting) === !0 && r.animate && setTimeout(() => {
      ve((Me) => !0);
    }, 500);
  }, [He == null ? void 0 : He.isIntersecting, r.animate]);
  const mn = () => {
    const { visualizationType: Me } = r;
    return Me === "Combo" && P.forecastingSeriesKeys > 0 || Me === "Area Chart" || Me === "Line" || Me === "Bar";
  }, dn = Number(C === "horizontal" ? r.xAxis.size : r.yAxis.size), jt = { small: 16, medium: 18, large: 20 }, wn = () => r.visualizationType === "Forest Plot" ? r.data.length : Vt("yAxis"), Ft = () => {
    let Me = r.xAxis.manualStep;
    return r.xAxis.viewportStepCount && r.xAxis.viewportStepCount[u] && (Me = r.xAxis.viewportStepCount[u]), Me;
  }, pt = (Me) => {
    const dt = Me.currentTarget.getBoundingClientRect(), it = Me.clientX - dt.left, W = Me.clientY - dt.top;
    ye({
      x: it,
      y: W
    });
  }, Tn = () => {
    let Me = 40;
    return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Wu, { top: F, left: Number(P.yAxis.size), label: P.xAxis.label, tickFormat: Pn(P.xAxis) ? d : s, scale: Fe, stroke: "#333", tickStroke: "#333", numTicks: P.xAxis.numTicks || void 0 }, (dt) => /* @__PURE__ */ a.createElement(nt, { className: "bottom-axis" }, dt.ticks.map((it, W) => {
      const _e = it.index !== 0 ? r.yAxis.tickRotation : 0, Xe = it.index !== 0 && r.yAxis.tickRotation && r.yAxis.tickRotation > 0 ? "end" : "middle", ot = v(it.value, `normal ${jt[r.fontSize]}px sans-serif`) * Math.sin(_e * (Math.PI / 180)) + 25;
      return ot > Me && (Me = ot), /* @__PURE__ */ a.createElement(nt, { key: `vx-tick-${it.value}-${W}`, className: "vx-axis-tick" }, !P.yAxis.hideTicks && /* @__PURE__ */ a.createElement(on, { from: it.from, to: it.to, stroke: "#333" }), !P.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { x: it.to.x, y: it.to.y, angle: -_e, verticalAnchor: "start", textAnchor: Xe }, s(it.value, "left")));
    }), !P.yAxis.hideAxis && /* @__PURE__ */ a.createElement(on, { from: dt.axisFromPoint, to: dt.axisToPoint, stroke: "#333" }))), /* @__PURE__ */ a.createElement(
      Wu,
      {
        top: F,
        left: Number(P.yAxis.size),
        label: P.xAxis.label,
        tickFormat: Pn(P.xAxis) ? d : P.xAxis.dataKey !== "Year" ? s : (dt) => dt,
        scale: lt,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: P.xAxis.numTicks || void 0
      },
      (dt) => /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(nt, { className: "bottom-axis" }, dt.ticks.map((it, W) => {
        const _e = it.index !== 0 ? r.yAxis.tickRotation : 0, Xe = it.index !== 0 && r.yAxis.tickRotation && r.yAxis.tickRotation > 0 ? "end" : "middle", ot = v(it.value, `normal ${jt[r.fontSize]}px sans-serif`) * Math.sin(_e * (Math.PI / 180)) + 25;
        return ot > Me && (Me = ot), /* @__PURE__ */ a.createElement(nt, { key: `vx-tick-${it.value}-${W}`, className: "vx-axis-tick" }, !P.yAxis.hideTicks && /* @__PURE__ */ a.createElement(on, { from: it.from, to: it.to, stroke: "#333" }), !P.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { x: it.to.x, y: it.to.y, angle: -_e, verticalAnchor: "start", textAnchor: Xe }, s(it.value, "left")));
      }), !P.yAxis.hideAxis && /* @__PURE__ */ a.createElement(on, { from: dt.axisFromPoint, to: dt.axisToPoint, stroke: "#333" })), /* @__PURE__ */ a.createElement(nt, null, /* @__PURE__ */ a.createElement(vt, { x: j / 2, y: Me + 20 + ue, stroke: "#333", textAnchor: "middle", verticalAnchor: "start" }, P.xAxis.label)), Ee.current ? Ee.current.setAttribute("height", Number(H) + Number(Me) + (P.xAxis.label ? 50 : 0) + "px") : "")
    ));
  };
  return isNaN(T) ? /* @__PURE__ */ a.createElement(a.Fragment, null) : /* @__PURE__ */ a.createElement(Cr, { component: "LinearChart" }, /* @__PURE__ */ a.createElement("div", { style: { width: `${T}px`, overflow: "visible" }, className: "tooltip-boundary" }, /* @__PURE__ */ a.createElement(
    "svg",
    {
      onMouseMove: pt,
      width: "100%",
      height: H,
      className: `linear ${r.animate ? "animated" : ""} ${ge && r.animate ? "animate" : ""} ${M && "debug"}`,
      role: "img",
      "aria-label": h(r),
      ref: Ee,
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ a.createElement(gr, { width: T, height: H, fill: "transparent" }),
    " ",
    !["Spark Line", "Forest Plot"].includes(E) && /* @__PURE__ */ a.createElement(YE, { scale: Be, tickLength: r.useLogScale ? 6 : 8, left: Number(P.yAxis.size) - r.yAxis.axisPadding, label: P.yAxis.label || P.yAxis.label, stroke: "#333", tickFormat: (Me, dt) => Dt(Me, dt), numTicks: wn() }, (Me) => {
      const dt = r.orientation === "horizontal" ? (Me.axisToPoint.y - Me.axisFromPoint.y) / 2 : (Me.axisFromPoint.y - Me.axisToPoint.y) / 2, it = F / Me.ticks.length / 2 - F / Me.ticks.length * (1 - r.barThickness) + 5;
      return /* @__PURE__ */ a.createElement(nt, { className: "left-axis" }, Me.ticks.map((W, _e) => {
        const Xe = Me.ticks[0].to.y, Ve = 15, ot = String(W.value).startsWith("1") || W.value === 0.1 ? "block" : "none", rt = ot === "block" ? 7 : 0, xt = { x: W.to.x - rt, y: W.to.y };
        return /* @__PURE__ */ a.createElement(nt, { key: `vx-tick-${W.value}-${_e}`, className: "vx-axis-tick" }, !P.yAxis.hideTicks && /* @__PURE__ */ a.createElement(on, { key: `${W.value}--hide-hideTicks`, from: W.from, to: r.useLogScale ? xt : W.to, stroke: r.yAxis.tickColor, display: C === "horizontal" ? "none" : "block" }), P.yAxis.gridLines ? /* @__PURE__ */ a.createElement(on, { key: `${W.value}--hide-hideGridLines`, display: (r.useLogScale && ot).toString(), from: { x: W.from.x + j, y: W.from.y }, to: W.from, stroke: "rgba(0,0,0,0.3)" }) : "", C === "horizontal" && R !== "stacked" && r.yAxis.labelPlacement === "On Date/Category Axis" && !r.yAxis.hideLabel && /* @__PURE__ */ a.createElement(
          vt,
          {
            transform: `translate(${W.to.x - 5}, ${r.isLollipopChart ? W.to.y - Xe : W.to.y - Xe + (Number(r.barHeight * r.series.length) - Ve) / 2}) rotate(-${r.runtime.horizontal && r.runtime.yAxis.tickRotation || 0})`,
            verticalAnchor: "start",
            textAnchor: "end"
          },
          W.formattedValue
        ), C === "horizontal" && R === "stacked" && r.yAxis.labelPlacement === "On Date/Category Axis" && !r.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { transform: `translate(${W.to.x - 5}, ${W.to.y - Xe + (Number(r.barHeight) - Ve) / 2}) rotate(-${P.horizontal ? P.yAxis.tickRotation : 0})`, verticalAnchor: "start", textAnchor: "end" }, W.formattedValue), C === "horizontal" && E === "Paired Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { transform: `translate(${W.to.x - 5}, ${W.to.y - Xe + Number(r.barHeight) / 2}) rotate(-${P.horizontal ? P.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, W.formattedValue), C === "horizontal" && E === "Deviation Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ a.createElement(vt, { transform: `translate(${W.to.x - 5}, ${r.isLollipopChart ? W.to.y - Xe + 2 : W.to.y - Xe + Number(r.barHeight) / 2}) rotate(-${P.horizontal ? P.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, W.formattedValue), C === "vertical" && E !== "Paired Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ a.createElement(
          vt,
          {
            display: r.useLogScale ? ot : "block",
            dx: r.useLogScale ? -6 : 0,
            x: r.runtime.horizontal ? W.from.x + 2 : W.to.x,
            y: W.to.y + (r.runtime.horizontal ? it : 0),
            angle: -Number(r.yAxis.tickRotation) || 0,
            verticalAnchor: r.runtime.horizontal ? "start" : "middle",
            textAnchor: r.runtime.horizontal ? "start" : "end",
            fill: r.yAxis.tickLabelColor
          },
          W.formattedValue
        ));
      }), !r.yAxis.hideAxis && /* @__PURE__ */ a.createElement(on, { from: Me.axisFromPoint, to: P.horizontal ? { x: 0, y: r.visualizationType === "Forest Plot" ? H : Number(U) } : Me.axisToPoint, stroke: "#000" }), Be.domain()[0] < 0 && /* @__PURE__ */ a.createElement(on, { from: { x: Me.axisFromPoint.x, y: Be(0) }, to: { x: j, y: Be(0) }, stroke: "#333" }), E === "Bar" && C === "horizontal" && qe.domain()[0] < 0 && /* @__PURE__ */ a.createElement(on, { from: { x: qe(0), y: 0 }, to: { x: qe(0), y: F }, stroke: "#333", strokeWidth: 2 }), /* @__PURE__ */ a.createElement(vt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${-1 * P.yAxis.size + Z}, ${dt}) rotate(-90)`, fontWeight: "bold", fill: r.yAxis.labelColor }, Me.label));
    }),
    Et && /* @__PURE__ */ a.createElement(ZE, { scale: Ze, left: Number(T - r.yAxis.rightAxisSize), label: r.yAxis.rightLabel, tickFormat: (Me) => s(Me, "right"), numTicks: P.yAxis.rightNumTicks || void 0, labelOffset: 45 }, (Me) => {
      const dt = r.orientation === "horizontal" ? (Me.axisToPoint.y - Me.axisFromPoint.y) / 2 : (Me.axisFromPoint.y - Me.axisToPoint.y) / 2, it = F / Me.ticks.length / 2 - F / Me.ticks.length * (1 - r.barThickness) + 5;
      return /* @__PURE__ */ a.createElement(nt, { className: "right-axis" }, Me.ticks.map((W, _e) => /* @__PURE__ */ a.createElement(nt, { key: `vx-tick-${W.value}-${_e}`, className: "vx-axis-tick" }, !P.yAxis.rightHideTicks && /* @__PURE__ */ a.createElement(on, { from: W.from, to: W.to, display: P.horizontal ? "none" : "block", stroke: r.yAxis.rightAxisTickColor }), P.yAxis.rightGridLines ? /* @__PURE__ */ a.createElement(on, { from: { x: W.from.x + j, y: W.from.y }, to: W.from, stroke: "rgba(0,0,0,0.3)" }) : "", !r.yAxis.rightHideLabel && /* @__PURE__ */ a.createElement(vt, { x: W.to.x, y: W.to.y + (P.horizontal ? it : 0), verticalAnchor: P.horizontal ? "start" : "middle", textAnchor: "start", fill: r.yAxis.rightAxisTickLabelColor }, W.formattedValue))), !r.yAxis.rightHideAxis && /* @__PURE__ */ a.createElement(on, { from: Me.axisFromPoint, to: Me.axisToPoint, stroke: "#333" }), /* @__PURE__ */ a.createElement(vt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${r.yAxis.rightLabelOffsetSize ? r.yAxis.rightLabelOffsetSize : 0}, ${dt}) rotate(-90)`, fontWeight: "bold", fill: r.yAxis.rightAxisLabelColor }, Me.label));
    }),
    ie && r.topAxis.hasLine && /* @__PURE__ */ a.createElement(
      tk,
      {
        stroke: "#333",
        left: Number(P.yAxis.size),
        scale: qe,
        hideTicks: !0,
        hideZero: !0,
        tickLabelProps: () => ({
          fill: "transparent"
        })
      }
    ),
    E !== "Paired Bar" && E !== "Spark Line" && /* @__PURE__ */ a.createElement(
      Wu,
      {
        top: P.horizontal && r.visualizationType !== "Forest Plot" ? Number(U) + Number(r.xAxis.axisPadding) : r.visualizationType === "Forest Plot" ? F + Number(r.xAxis.axisPadding) : F,
        left: r.visualizationType !== "Forest Plot" ? Number(P.yAxis.size) : 0,
        label: r[ne].label,
        tickFormat: qt,
        scale: qe,
        stroke: "#333",
        numTicks: Vt("xAxis"),
        tickStroke: "#333",
        tickValues: r.xAxis.manual ? Lk(Ae, qe, r.xAxis.type === "date-time" ? Vt("xAxis") : Ft()) : void 0
      },
      (Me) => {
        const dt = r.visualizationType !== "Forest Plot" ? (Me.axisToPoint.x - Me.axisFromPoint.x) / 2 : i[0] / 2, it = (mt) => /\s/.test(mt), W = Me.ticks.some((mt) => it(mt.value)), _e = 8, Xe = Math.max(...Me.ticks.map((mt) => v(mt.formattedValue, `normal ${jt[r.fontSize]}px sans-serif`))), Ve = W ? 180 : 100, ot = Me.ticks.map((mt) => v(mt.formattedValue, `normal ${jt[r.fontSize]}px sans-serif`)), rt = ot.reduce((mt, Rt) => mt + Rt, Ve), xt = (j - rt) / (Me.ticks.length - 1);
        let Mt = [0];
        for (let mt = 1; mt < ot.length; mt++)
          Mt[mt] = Mt[mt - 1] + ot[mt - 1] + xt;
        let Qe = !1;
        ot.forEach((mt, Rt) => {
          if (Mt[Rt] + ot[Rt] > Mt[Rt + 1]) {
            Qe = !0;
            return;
          }
        });
        const Kt = Qe && r.isResponsiveTicks ? Xe + _e + 20 : 0;
        Number(r.xAxis.tickRotation) > 0 && Number(r.xAxis.tickRotation), r.dynamicMarginTop = Kt, r.xAxis.tickWidthMax = Xe;
        let It = 40;
        const _t = /* @__PURE__ */ a.createElement(nt, { className: "bottom-axis", width: i[0] }, Me.ticks.map((mt, Rt, wt) => {
          const Yt = String(mt.value).startsWith("1") || mt.value === 0.1 ? "block" : "none", Xt = Yt === "block" ? 16 : _e, sn = { x: mt.to.x, y: Xt }, fn = v(mt.formattedValue, `normal ${jt[r.fontSize]}px sans-serif`), nn = 100 / wt.length;
          r.yAxis.tickRotation = r.isResponsiveTicks && r.orientation === "horizontal" ? 0 : r.yAxis.tickRotation, r.xAxis.tickRotation = r.isResponsiveTicks && r.orientation === "vertical" ? 0 : r.xAxis.tickRotation;
          const Qt = r.isResponsiveTicks && Qe ? -Number(r.xAxis.maxTickRotation) || -90 : -Number(r.runtime.xAxis.tickRotation), Cn = fn * Math.sin(Qt * -1 * (Math.PI / 180)) + 25;
          return Cn > It && (It = Cn), /* @__PURE__ */ a.createElement(nt, { key: `vx-tick-${mt.value}-${Rt}`, className: "vx-axis-tick" }, !r.xAxis.hideTicks && /* @__PURE__ */ a.createElement(on, { from: mt.from, to: C === "horizontal" && r.useLogScale ? sn : mt.to, stroke: r.xAxis.tickColor, strokeWidth: Yt === "block" && r.useLogScale ? 1.3 : 1 }), !r.xAxis.hideLabel && /* @__PURE__ */ a.createElement(
            vt,
            {
              dy: r.orientation === "horizontal" && r.useLogScale ? 8 : 0,
              display: r.orientation === "horizontal" && r.useLogScale ? Yt : "block",
              x: mt.to.x,
              y: mt.to.y,
              angle: Qt,
              verticalAnchor: Qt < -50 ? "middle" : "start",
              textAnchor: Qt ? "end" : "middle",
              width: Qe && !r.isResponsiveTicks && !Number(r[ne].tickRotation) ? nn : void 0,
              fill: r.xAxis.tickLabelColor
            },
            mt.formattedValue
          ));
        }), !r.xAxis.hideAxis && /* @__PURE__ */ a.createElement(on, { from: Me.axisFromPoint, to: Me.axisToPoint, stroke: "#333" }), /* @__PURE__ */ a.createElement(vt, { x: dt, y: It + 20 + ue, textAnchor: "middle", verticalAnchor: "start", fontWeight: "bold", fill: r.xAxis.labelColor }, Me.label));
        return Ee.current && Ee.current.setAttribute("height", Number(H) + Number(It) + (P.xAxis.label ? 50 : 0) + "px"), _t;
      }
    ),
    E === "Paired Bar" && Tn(),
    E === "Deviation Bar" && ((Ln = r.series) == null ? void 0 : Ln.length) === 1 && /* @__PURE__ */ a.createElement(yk, { animatedChart: ge, xScale: qe, yScale: Be, width: j, height: F }),
    E === "Paired Bar" && /* @__PURE__ */ a.createElement(Ak, { originalWidth: T, width: j, height: F }),
    E === "Scatter Plot" && /* @__PURE__ */ a.createElement(
      gk,
      {
        xScale: qe,
        yScale: Be,
        getXAxisData: we,
        getYAxisData: fe,
        xMax: j,
        yMax: F,
        handleTooltipMouseOver: Nt,
        handleTooltipMouseOff: Bt,
        handleTooltipClick: Gt,
        tooltipData: kt,
        showTooltip: zt
      }
    ),
    E === "Box Plot" && /* @__PURE__ */ a.createElement(mk, { xScale: qe, yScale: Be }),
    (E === "Area Chart" && r.visualizationSubType === "regular" || E === "Combo") && /* @__PURE__ */ a.createElement(ok, { xScale: qe, yScale: Be, yMax: F, xMax: j, chartRef: Ee, width: j, height: F, handleTooltipMouseOver: Nt, handleTooltipMouseOff: Bt, tooltipData: kt, showTooltip: zt }),
    (E === "Area Chart" && r.visualizationSubType === "stacked" || E === "Combo") && /* @__PURE__ */ a.createElement(sk, { xScale: qe, yScale: Be, yMax: F, xMax: j, chartRef: Ee, width: j, height: F, handleTooltipMouseOver: Nt, handleTooltipMouseOff: Bt, tooltipData: kt, showTooltip: zt }),
    (E === "Bar" || E === "Combo" || N()) && /* @__PURE__ */ a.createElement(
      pk,
      {
        xScale: qe,
        yScale: Be,
        seriesScale: Ie,
        xMax: j,
        yMax: F,
        getXAxisData: we,
        getYAxisData: fe,
        animatedChart: ge,
        visible: ge,
        handleTooltipMouseOver: Nt,
        handleTooltipMouseOff: Bt,
        handleTooltipClick: Gt,
        tooltipData: kt,
        showTooltip: zt,
        chartRef: Ee
      }
    ),
    (E === "Line" && !N() || E === "Combo") && /* @__PURE__ */ a.createElement(
      sm,
      {
        xScale: qe,
        yScale: Be,
        getXAxisData: we,
        getYAxisData: fe,
        xMax: j,
        yMax: F,
        seriesStyle: r.series,
        handleTooltipMouseOver: Nt,
        handleTooltipMouseOff: Bt,
        handleTooltipClick: Gt,
        tooltipData: kt,
        showTooltip: zt,
        chartRef: Ee
      }
    ),
    (E === "Forecasting" || E === "Combo") && /* @__PURE__ */ a.createElement(
      xk,
      {
        showTooltip: zt,
        tooltipData: kt,
        xScale: qe,
        yScale: Be,
        width: j,
        le: !0,
        height: F,
        xScaleNoPadding: Ue,
        chartRef: Ee,
        getXValueFromCoordinate: Mn,
        handleTooltipMouseOver: Nt,
        handleTooltipMouseOff: Bt,
        isBrush: !1
      }
    ),
    r.yAxis.anchors && r.yAxis.anchors.map((Me) => /* @__PURE__ */ a.createElement(on, { strokeDasharray: y(Me.lineStyle), stroke: "rgba(0,0,0,1)", className: "customAnchor", from: { x: 0 + r.yAxis.size, y: Be(Me.value) }, to: { x: j, y: Be(Me.value) }, display: P.horizontal ? "none" : "block" })),
    E === "Forest Plot" && /* @__PURE__ */ a.createElement(
      Ck,
      {
        xScale: qe,
        yScale: Be,
        seriesScale: Ie,
        width: T,
        height: H,
        getXAxisData: we,
        getYAxisData: fe,
        animatedChart: ge,
        visible: ge,
        handleTooltipMouseOver: Nt,
        handleTooltipMouseOff: Bt,
        handleTooltipClick: Gt,
        tooltipData: kt,
        showTooltip: zt,
        chartRef: Ee,
        config: r
      }
    ),
    ["Line", "Bar", "Combo", "Area Chart"].includes(r.visualizationType) && !V && /* @__PURE__ */ a.createElement(rw, { xScaleBrush: ct, yScale: Be, xMax: j, yMax: F }),
    !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(E) && !N() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(sm, { xScale: qe, yScale: Be, getXAxisData: we, getYAxisData: fe, xMax: j, yMax: F, seriesStyle: r.series })),
    r.yAxis.anchors && r.yAxis.anchors.map((Me, dt) => {
      let it = Be(Me.value);
      if (!Me.value)
        return;
      const W = C === "horizontal" && E === "Bar" ? r.barHeight / 4 : 0;
      if (it)
        return (
          // prettier-ignore
          /* @__PURE__ */ a.createElement(
            on,
            {
              key: `yAxis-${Me.value}--${dt}`,
              strokeDasharray: y(Me.lineStyle),
              stroke: Me.color ? Me.color : "rgba(0,0,0,1)",
              className: "anchor-y",
              from: { x: 0 + dn, y: it - W },
              to: { x: T - r.yAxis.rightAxisSize, y: it - W }
            }
          )
        );
    }),
    r.xAxis.anchors && r.xAxis.anchors.map((Me, dt) => {
      let it = g;
      C === "horizontal" && (it = _);
      let W = Pn(it) ? qe(o(Me.value, !1)) : qe(Me.value);
      if (W)
        return (
          // prettier-ignore
          /* @__PURE__ */ a.createElement(
            on,
            {
              key: `xAxis-${Me.value}--${dt}`,
              strokeDasharray: y(Me.lineStyle),
              stroke: Me.color ? Me.color : "rgba(0,0,0,1)",
              fill: Me.color ? Me.color : "rgba(0,0,0,1)",
              className: "anchor-x",
              from: { x: Number(W) + Number(dn), y: 0 },
              to: { x: Number(W) + Number(dn), y: F }
            }
          )
        );
    }),
    (r.visualizationType !== "Bar" || !N()) && r.visualizationType !== "Combo" && /* @__PURE__ */ a.createElement(mh, { xScale: qe, handleTooltipClick: Gt, handleTooltipMouseOff: Bt, handleTooltipMouseOver: Nt, showTooltip: zt, hideTooltip: ln, tooltipData: kt, yMax: F, width: T }),
    mn && zt && kt && r.visual.verticalHoverLine && /* @__PURE__ */ a.createElement(nt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ a.createElement(on, { from: { x: kt.dataXPosition - 10, y: 0 }, to: { x: kt.dataXPosition - 10, y: F }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" })),
    mn && zt && kt && r.visual.horizontalHoverLine && /* @__PURE__ */ a.createElement(nt, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: r.yAxis.size ? r.yAxis.size : 0 }, /* @__PURE__ */ a.createElement(on, { from: { x: 0, y: kt.dataYPosition }, to: { x: j, y: kt.dataYPosition }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    r.filters && r.filters.values.length === 0 && t.length === 0 && /* @__PURE__ */ a.createElement(vt, { x: Number(r.yAxis.size) + Number(j / 2), y: H / 2 - r.xAxis.padding / 2, textAnchor: "middle" }, r.chartMessage.noData),
    (r.visualizationType === "Bar" || N()) && r.tooltips.singleSeries && r.visual.horizontalHoverLine && /* @__PURE__ */ a.createElement(nt, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: r.yAxis.size ? r.yAxis.size : 0 }, /* @__PURE__ */ a.createElement(on, { from: { x: 0, y: Se.y }, to: { x: j, y: Se.y }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    (r.visualizationType === "Bar" || N()) && r.tooltips.singleSeries && r.visual.verticalHoverLine && /* @__PURE__ */ a.createElement(nt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ a.createElement(on, { from: { x: Se.x, y: 0 }, to: { x: Se.x, y: F }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" }))
  ), kt && Object.entries(kt.data).length > 0 && en && zt && kt.dataYPosition && kt.dataXPosition && !r.tooltips.singleSeries && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ a.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ a.createElement(Bg, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: cn, top: ze }, /* @__PURE__ */ a.createElement("ul", null, typeof kt == "object" && Object.entries(kt.data).map((Me, dt) => /* @__PURE__ */ a.createElement(Lt, { item: Me, key: dt }))))), re() && /* @__PURE__ */ a.createElement(ly, { id: `cdc-open-viz-tooltip-${P.uniqueId}`, variant: "light", arrowColor: "rgba(0,0,0,0)", className: "tooltip", style: { background: `rgba(255,255,255, ${r.tooltips.opacity / 100})`, color: "black" } }), /* @__PURE__ */ a.createElement("div", { className: "animation-trigger", ref: ee })));
};
var iw = ["id", "markerWidth", "markerHeight", "markerUnits", "children"];
function Hf() {
  return Hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Hf.apply(this, arguments);
}
function ow(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function py(e) {
  var t = e.id, n = e.markerWidth, i = n === void 0 ? 3 : n, r = e.markerHeight, o = r === void 0 ? 3 : r, d = e.markerUnits, u = d === void 0 ? "userSpaceOnUse" : d, s = e.children, h = ow(e, iw);
  return /* @__PURE__ */ a.createElement("defs", null, /* @__PURE__ */ a.createElement("marker", Hf({
    id: t,
    markerWidth: i,
    markerHeight: o,
    markerUnits: u
  }, h), s));
}
py.propTypes = {
  id: he.string.isRequired,
  size: he.number,
  markerWidth: he.oneOfType([he.string, he.number]),
  markerHeight: he.oneOfType([he.string, he.number]),
  markerUnits: he.string,
  refX: he.oneOfType([he.string, he.number]),
  refY: he.oneOfType([he.string, he.number]),
  strokeWidth: he.number,
  children: he.node.isRequired
};
var lw = ["id", "size", "strokeWidth"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function sw(e, t) {
  if (e == null)
    return {};
  var n = {}, i = Object.keys(e), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function uw(e) {
  var t = e.id, n = e.size, i = n === void 0 ? 9 : n, r = e.strokeWidth, o = r === void 0 ? 1 : r, d = sw(e, lw), u = i + o * 2, s = i, h = u / 2, m = "0 0, " + i + " " + i / 2 + ", 0 " + i;
  return /* @__PURE__ */ a.createElement(py, Wf({
    id: t,
    markerWidth: u,
    markerHeight: u,
    refX: s,
    refY: h,
    orient: "auto",
    markerUnits: "strokeWidth",
    fill: "none",
    strokeWidth: o
  }, d), /* @__PURE__ */ a.createElement("g", {
    transform: "translate(" + o + ", " + o + ")"
  }, /* @__PURE__ */ a.createElement("polyline", {
    points: m
  })));
}
const cw = (e) => {
  var Z;
  const { width: t, height: n } = e, { transformedData: i, config: r, parseDate: o, formatDate: d, seriesHighlight: u, formatNumber: s, colorScale: h, handleChartAriaLabels: m } = ce.useContext(Ct);
  let y = Number(t);
  const { minValue: v, maxValue: w } = Nc(r, i), E = { top: 5, right: 10, bottom: 10, left: 10 }, R = Number(n), C = y - r.runtime.yAxis.size, g = R - E.top - 20, _ = ($) => r.runtime.xAxis.type === "date" ? o($[r.runtime.originalXAxis.dataKey]).getTime() : $[r.runtime.originalXAxis.dataKey], P = ($, H) => $[H];
  let M, N;
  const { max: T, min: U } = r.runtime.yAxis, V = Number(T) >= Number(w), G = Number(U) <= Number(v);
  if (i) {
    let $ = Number(U && G ? U : v), H = Number(T && V ? T : Number.MIN_VALUE);
    if (H === Number.MIN_VALUE && (H = w), r.runtime.yAxis.paddingPercent) {
      let F = (H - $) * r.runtime.yAxis.paddingPercent;
      $ -= F, H += F;
    }
    let j = i.map((F) => _(F));
    r.runtime.horizontal ? (M = Kn({
      domain: [$, H],
      range: [0, C]
    }), N = r.runtime.xAxis.type === "date" ? Kn({ domain: [Math.min(...j), Math.max(...j)] }) : Yo({ domain: j, padding: 0.5 }), Yo({
      domain: r.runtime.barSeriesKeys || r.runtime.seriesKeys,
      range: [0, g]
    }), N.rangeRound([0, g])) : ($ = $ < 0 ? $ * 1.11 : $, N = Kn({
      domain: [$, H],
      range: [g - E.bottom, E.top]
    }), M = Yo({
      domain: j,
      range: [E.left, y - E.right]
    }), Yo({
      domain: r.runtime.barSeriesKeys || r.runtime.seriesKeys,
      range: [0, C]
    }));
  }
  const ue = [M.domain()[0], M.domain()[M.domain().length - 1]];
  return /* @__PURE__ */ a.createElement(Cr, { component: "SparkLine" }, /* @__PURE__ */ a.createElement("svg", { role: "img", "aria-label": m(r), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ a.createElement("title", null, `Spark line graphic with the title ${r.title ? r.title : "No Title Found"}`), ((Z = r.runtime.lineSeriesKeys) == null ? void 0 : Z.length) > 0 ? r.runtime.lineSeriesKeys : r.runtime.seriesKeys.map(($, H) => /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    nt,
    {
      style: { width: y },
      className: "sparkline-group",
      key: `series-${$}`,
      opacity: r.legend.behavior === "highlight" && u.length > 0 && u.indexOf($) === -1 ? 0.5 : 1,
      display: r.legend.behavior === "highlight" || u.length === 0 || u.indexOf($) !== -1 ? "block" : "none"
    },
    i.map((j, F) => /* @__PURE__ */ a.createElement(nt, { key: `series-${$}-point-${F}` }, /* @__PURE__ */ a.createElement(vt, { display: r.labels ? "block" : "none", x: M(_(j)), y: N(P(j, $)), fill: h ? h(r.runtime.seriesLabels ? r.runtime.seriesLabels[$] : $) : "#000", textAnchor: "middle" }, s(j[$])))),
    /* @__PURE__ */ a.createElement(
      qr,
      {
        curve: Cc,
        data: i,
        x: (j) => M(_(j)),
        y: (j) => N(P(j, $)),
        stroke: h ? h(r.runtime.seriesLabels ? r.runtime.seriesLabels[$] : $) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${H})`
      }
    ),
    /* @__PURE__ */ a.createElement(uw, { id: `arrow--${H}`, refX: 2, size: 6, markerEnd: `url(#arrow--${H})`, strokeOpacity: 1, fillOpacity: 1, fill: h ? h(r.runtime.seriesLabels ? r.runtime.seriesLabels[$] : $) : "#000" })
  ), /* @__PURE__ */ a.createElement(
    Wu,
    {
      top: g + E.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: M,
      tickValues: ue,
      tickFormat: (j) => r.xAxis.type === "date" ? d(j) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
}, dw = ce.forwardRef((e, t) => {
  const {
    config: n,
    colorScale: i,
    seriesHighlight: r,
    highlight: o,
    tableData: d,
    highlightReset: u,
    transformedData: s,
    currentViewport: h
  } = ce.useContext(Ct);
  if (!n.legend)
    return null;
  const m = Yg(n, d, s, i);
  return !["Box Plot", "Pie"].includes(n.visualizationType) && /* @__PURE__ */ a.createElement(Kg, { ref: t, skipId: e.skipId || "legend", config: n, colorScale: i, seriesHighlight: r, highlight: o, highlightReset: u, currentViewport: h, formatLabels: m });
}), ef = {
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  fontSize: "medium",
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "false",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueDataLabel: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !0,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0
  },
  boxplot: {
    plots: [],
    borders: "true",
    firstQuartilePercentage: 25,
    thirdQuartilePercentage: 75,
    boxWidthPercentage: 40,
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    legend: {
      showHowToReadText: !1,
      howToReadText: ""
    },
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      total: "Total",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 65,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    seriesHighlight: []
  },
  brush: {
    height: 25,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, ju = (e) => /* @__PURE__ */ ce.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ ce.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), fw = ({ name: e }) => {
  var u, s, h, m, y;
  const { config: t, rawData: n, updateConfig: i } = ce.useContext(Ct);
  if (t.visualizationType !== "Forest Plot")
    return;
  const r = (v) => {
    v.orientation === "horizontal" && (v.labels = !1), v.table.show === void 0 && (v.table.show = !isDashboard), v.visualizationType === "Combo" && (v.orientation = "vertical");
  }, o = (v = !0) => {
    let w = {};
    return n.forEach((E) => {
      Object.keys(E).forEach((R) => w[R] = !0);
    }), v && Object.keys(w).forEach((E) => {
      (t.series && t.series.filter((R) => R.dataKey === E).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(E)) && delete w[E];
    }), Object.keys(w);
  }, d = (v, w, E, R) => {
    if (v === "boxplot" && w === "legend") {
      i({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.boxplot[w],
            [E]: R
          }
        }
      });
      return;
    }
    if (v === "boxplot" && w === "labels") {
      i({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.boxplot[w],
            [E]: R
          }
        }
      });
      return;
    }
    if (v === "forestPlot" && w) {
      let P = {
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.forestPlot[w],
            [E]: R
          }
        }
      };
      i(P);
      return;
    }
    if (v === "columns" && w !== "" && E !== "") {
      i({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t[v][w],
            [E]: R
          }
        }
      });
      return;
    }
    if (v === null && w === null) {
      let P = { ...t, [E]: R };
      r(P), i(P);
      return;
    }
    const C = Array.isArray(t[v]);
    let g = C ? [...t[v], R] : { ...t[v], [E]: R };
    w !== null && (C ? (g = [...t[v]], g[w] = { ...g[w], [E]: R }) : typeof R == "string" ? g[w] = R : g = { ...t[v], [w]: { ...t[v][w], [E]: R } });
    let _ = { ...t, [v]: g };
    r(_), i(_);
  };
  return /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ a.createElement(ju, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: d,
      options: o(!1),
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: v.target.value
          }
        }), v.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ a.createElement(Je, { type: "text", value: ((u = t.forestPlot) == null ? void 0 : u.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("h4", null, "Column Settings"), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: v.target.value
          }
        }), v.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: v.target.value
            }
          }
        }), v.target.value = "";
      }
    }
  ))), /* @__PURE__ */ a.createElement(ut, { value: ((h = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : h.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("h4", null, "Width Settings"), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement(Je, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ a.createElement(Je, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ a.createElement(Je, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("hr", null), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: v.target.value
            }
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ a.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(v.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ a.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (v) => {
        i({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(v.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, al = a.createContext({}), hw = (e) => {
  const { updateConfig: t, config: n, rawData: i } = ce.useContext(Ct), { getColumns: r, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], u = (s, h, m) => {
    let y = [...n.series];
    if (y[s][m] = h, m === "type" && h === "Bar" && (y[s].axis = "Left"), y[s].type === "Forecasting") {
      let v = Array.from(new Set(i.map((E) => E[y[s].dataKey]))), w = [];
      v.forEach((E) => {
        w.push({ key: E });
      }), y[s].stages = w, y[s].stageColumn = y[s].dataKey;
    }
    t({ ...n, series: y });
  };
  return /* @__PURE__ */ a.createElement(al.Provider, { value: { updateSeries: u, supportedRightAxisTypes: d, getColumns: r, selectComponent: o } }, e.children);
}, pw = (e) => {
  const { config: t, updateConfig: n } = ce.useContext(Ct), { series: i, index: r } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart"].some((m) => m.includes(i.type)) && (s = !0), s;
  })())
    return;
  const d = (s, h) => {
    let m = [...t.series];
    m[s].lineType = h, n({ ...t, series: m });
  };
  let u = [];
  return Object.keys(bc).map((s) => u.push(bc[s])), /* @__PURE__ */ a.createElement(
    Ha,
    {
      initial: "Select an option",
      value: i.lineType ? i.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(r, s.target.value);
      },
      options: u
    }
  );
}, mw = (e) => {
  const { config: t } = ce.useContext(Ct), { updateSeries: n } = ce.useContext(al), { index: i, series: r } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo"].includes(t.visualizationType))
    return /* @__PURE__ */ a.createElement(
      Ha,
      {
        initial: "Select an option",
        value: r.type,
        label: "Series Type",
        onChange: (d) => {
          n(i, d.target.value, "type");
        },
        options: o()
      }
    );
}, gw = (e) => {
  const { config: t, updateConfig: n, rawData: i } = ce.useContext(Ct), { updateSeries: r, getColumns: o } = ce.useContext(al), { index: d, series: u } = e;
  return /* @__PURE__ */ a.createElement(
    Ha,
    {
      initial: "Select an option",
      value: u.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let h = [], m = new Set(i == null ? void 0 : i.map((v) => v[s.target.value]));
        m = Array.from(m), m = m.filter((v) => v !== void 0), m.forEach((v) => h.push({ key: v }));
        const y = [...t.series];
        y[d] = { ...y[d], stages: h, stageColumn: s.target.value }, n({
          ...t,
          series: y
        });
      },
      options: o(!1)
    }
  );
}, yw = (e) => {
  const { config: t, rawData: n } = ce.useContext(Ct), { updateSeries: i } = ce.useContext(al), { index: r, series: o } = e;
  if (o.type !== "Forecasting" || !n || !o.stageColumn)
    return;
  let d = new Set(n.map((u) => u[o.stageColumn]));
  return d = Array.from(d), d = d.filter((u) => u !== void 0), /* @__PURE__ */ a.createElement(
    Ha,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (u) => {
        i(r, u.target.value, "stageItem");
      },
      options: d
    }
  );
}, vw = (e) => {
  const { config: t } = ce.useContext(Ct), { updateSeries: n, supportedRightAxisTypes: i } = ce.useContext(al), { index: r, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && i.includes(o.type))
    return /* @__PURE__ */ a.createElement(
      Ha,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          n(r, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, xw = (e) => {
  var o;
  const { config: t, updateConfig: n } = ce.useContext(Ct), { index: i, series: r } = e;
  if (r.type === "Forecasting" && r)
    return (o = r == null ? void 0 : r.stages) == null ? void 0 : o.map((d, u) => {
      var s, h, m, y;
      return /* @__PURE__ */ a.createElement(
        Ha,
        {
          key: `${d}--${u}`,
          initial: "Select an option",
          value: (h = (s = t.series) == null ? void 0 : s[i].stages) != null && h[u].color ? (y = (m = t.series) == null ? void 0 : m[i].stages) == null ? void 0 : y[u].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (v) => {
            const w = [...t.series], E = w[i].stages;
            E[u].color = v.target.value, w[i] = { ...w[i], stages: E }, n({
              ...t,
              series: w
            });
          },
          options: Object.keys(Ku)
        }
      );
    });
}, bw = (e) => {
  var d;
  const { config: t, updateConfig: n } = ce.useContext(Ct), { series: i, index: r } = e, { getColumns: o } = ce.useContext(al);
  if (i.type === "Forecasting")
    return /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ a.createElement("fieldset", null, /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, (d = i == null ? void 0 : i.confidenceIntervals) == null ? void 0 : d.map((u, s) => {
      const h = u.showInTooltip ? u.showInTooltip : !1, m = (y, v, w) => {
        y.preventDefault();
        let E = [...t.series];
        E[v].confidenceIntervals[w].showInTooltip = !h, n({
          ...t,
          series: E
        });
      };
      return /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Fn, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ a.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (y) => {
            y.preventDefault();
            const v = [...t.series[r].confidenceIntervals];
            v.splice(s, 1);
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: [...v] }, n({
              ...t,
              series: w
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("div", { className: "input-group" }, /* @__PURE__ */ a.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ a.createElement("div", { className: "cove-input__checkbox--small", onClick: (y) => m(y, r, s) }, /* @__PURE__ */ a.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, h && /* @__PURE__ */ a.createElement(Rm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ a.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: "showInTooltip", checked: h || !1, readOnly: !0 }))), /* @__PURE__ */ a.createElement(
        Ha,
        {
          initial: "Select an option",
          value: t.series[r].confidenceIntervals[s].low ? t.series[r].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (y) => {
            const v = [...t.series[r].confidenceIntervals];
            v[s].low = y.target.value;
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: v }, n({
              ...t,
              series: w
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ a.createElement(
        Ha,
        {
          initial: "Select an option",
          value: t.series[r].confidenceIntervals[s].high ? t.series[r].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (y) => {
            const v = [...t.series[r].confidenceIntervals];
            v[s].high = y.target.value;
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: v }, n({
              ...t,
              series: w
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ a.createElement(
      "button",
      {
        className: "btn full-width",
        onClick: (u) => {
          u.preventDefault();
          let s = null;
          t.series[r].confidenceIntervals ? s = [...t.series[r].confidenceIntervals] : s = [];
          const h = [...t.series];
          h[r] = { ...h[r], confidenceIntervals: [...s, { high: "", low: "" }] }, n({
            ...t,
            series: h
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Sw = (e) => {
  const { series: t, index: n } = e, { config: i, updateConfig: r } = ce.useContext(Ct);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (u, s, h, m) => {
    let y = [...i.series], v = { ...i.runtime.seriesLabels };
    y[u].weight = s && Math.max(Number(h), Math.min(Number(m), Number(s))), v[y[u].dataKey] = y[u].weight ? y[u].weight : y[u].dataKey;
    const w = {
      ...i,
      series: y,
      runtime: {
        ...i.runtime,
        seriesLabels: v
      }
    };
    r(w);
  };
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${n}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (u) => {
        d(n, u.target.value, u.target.min, u.target.max);
      }
    }
  ));
}, Ew = (e) => {
  const { series: t, index: n } = e, { config: i, updateConfig: r } = ce.useContext(Ct);
  if (!["Bar", "Line", "Area Chart", "Combo", "Deviation Bar", "Paired Bar", "Scatter Plot", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (u, s) => {
    let h = [...i.series], m = { ...i.runtime.seriesLabels };
    h[u].name = s, m[h[u].dataKey] = h[u].name ? h[u].name : h[u].dataKey;
    let y = {
      ...i,
      series: h,
      runtime: {
        ...i.runtime,
        seriesLabels: m
      }
    };
    r(y);
  };
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${n}`,
      value: t.name ? t.name : "",
      onChange: (u) => {
        d(n, u.target.value);
      }
    }
  ));
}, kw = (e) => {
  const { series: t, index: n } = e, { config: i, updateConfig: r } = ce.useContext(Ct);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(i.visualizationType))
    return;
  const o = (d) => {
    let u = [...i.series];
    u[d].tooltip && u[d].tooltip, u[d].tooltip = !u[d].tooltip, r({
      ...i,
      series: u
    });
  };
  return /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("div", { className: "input-group" }, /* @__PURE__ */ a.createElement("label", { htmlFor: `series-tooltip--${n}` }, "Show In Tooltip"), /* @__PURE__ */ a.createElement("div", { className: "cove-input__checkbox--small", onClick: (d) => o(n) }, /* @__PURE__ */ a.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ a.createElement(Rm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ a.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: `series-tooltip--${n}`, checked: t.tooltip ? t.tooltip : !1, readOnly: !0 }))));
}, ww = (e) => {
  const { config: t, updateConfig: n } = ce.useContext(Ct), { series: i, index: r } = e, o = (u) => {
    let s = [...t.series], h = -1;
    for (let m = 0; m < s.length; m++)
      if (s[m].dataKey === u) {
        h = m;
        break;
      }
    if (h !== -1) {
      s.splice(h, 1);
      let m = { ...t, series: s };
      s.length === 0 && delete m.series, n(m);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, d = (u, s, h) => {
    u.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ a.createElement("button", { className: "series-list__remove", onClick: (u) => d(u, i) }, "Remove");
}, my = (e) => {
  const { config: t } = ce.useContext(Ct), { series: n, getItemStyle: i, sortableItemStyles: r, chartsWithOptions: o, index: d } = e;
  return /* @__PURE__ */ a.createElement(by, { key: n.dataKey, draggableId: `draggableFilter-${n.dataKey}`, index: d }, (u, s) => /* @__PURE__ */ a.createElement("div", { key: d, className: s.isDragging ? "currently-dragging" : "", style: i(s.isDragging, u.draggableProps.style, r), ref: u.innerRef, ...u.draggableProps, ...u.dragHandleProps }, /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart" }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(Fn, { className: o.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow" }, /* @__PURE__ */ a.createElement(ft, { display: "move", size: 15, style: { cursor: "default" } }), n.dataKey, /* @__PURE__ */ a.createElement(Kr.Button.Remove, { series: n, index: d }))), o.includes(t.visualizationType) && /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(Kr.Input.Name, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Input.Weight, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Dropdown.SeriesType, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Dropdown.AxisPosition, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Dropdown.LineType, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Dropdown.ForecastingColor, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Dropdown.ConfidenceInterval, { series: n, index: d }), /* @__PURE__ */ a.createElement(Kr.Checkbox.DisplayInTooltip, { series: n, index: d }))))));
}, Tw = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: i, chartsWithOptions: r } = e;
  return t.map((o, d) => /* @__PURE__ */ a.createElement(my, { getItemStyle: n, sortableItemStyles: i, chartsWithOptions: r, series: o, index: d, key: `series-list-${d}` }));
}, Kr = {
  Wrapper: hw,
  Dropdown: {
    SeriesType: mw,
    AxisPosition: vw,
    ConfidenceInterval: bw,
    LineType: pw,
    ForecastingStage: gw,
    ForecastingColumn: yw,
    ForecastingColor: xw
  },
  Input: {
    Name: Ew,
    Weight: Sw
  },
  Checkbox: {
    DisplayInTooltip: kw
  },
  Button: {
    Remove: ww
  },
  Item: my,
  List: Tw
}, Cw = ce.memo(({ config: e, updateConfig: t }) => {
  let n = (s, h, m) => {
    let y = [];
    e.regions && (y = [...e.regions]), y[m][s] = h, t({ ...e, regions: y });
  }, i = (s, h, m, y, v) => n(m, y, v), r = (s) => {
    let h = [];
    e.regions && (h = [...e.regions]), h.splice(s, 1), t({ ...e, regions: h });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], u = ["Last Date", "Fixed"];
  return /* @__PURE__ */ a.createElement(a.Fragment, null, e.regions && e.regions.map(({ label: s, color: h, from: m, to: y, background: v, range: w = "Custom" }, E) => {
    var R;
    return /* @__PURE__ */ a.createElement("div", { className: "edit-block", key: `region-${E}` }, /* @__PURE__ */ a.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (C) => {
          C.preventDefault(), r(E);
        }
      },
      "Remove"
    ), /* @__PURE__ */ a.createElement(Je, { value: s, label: "Region Label", fieldName: "label", i: E, updateField: i }), /* @__PURE__ */ a.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ a.createElement(Je, { value: h, label: "Text Color", fieldName: "color", updateField: (C, g, _, P) => n(_, P, E) }), /* @__PURE__ */ a.createElement(Je, { value: v, label: "Background", fieldName: "background", updateField: (C, g, _, P) => n(_, P, E) })), /* @__PURE__ */ a.createElement(
      At,
      {
        value: e.regions[E].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (C) => {
          if (C.target.value !== "" && C.target.value !== "Select") {
            const g = [...e.regions];
            g[E].fromType = C.target.value, t({
              ...e,
              regions: g
            });
          }
          C.target.value = "";
        },
        options: d
      }
    ), (e.regions[E].fromType === "Fixed" || e.regions[E].fromType === "Previous Days" || !e.regions[E].fromType) && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
      Je,
      {
        value: m,
        label: e.regions[E].fromType === "Fixed" || !((R = e.regions[E]) != null && R.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (C, g, _, P) => n(_, P, E),
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ a.createElement(
      At,
      {
        value: e.regions[E].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (C) => {
          if (C.target.value !== "" && C.target.value !== "Select") {
            const g = [...e.regions];
            g[E].toType = C.target.value, t({
              ...e,
              regions: g
            });
          }
          C.target.value = "";
        },
        options: u
      }
    ), (e.regions[E].toType === "Fixed" || !e.regions[E].toType) && /* @__PURE__ */ a.createElement(Je, { value: y, label: "To Value", fieldName: "to", updateField: (C, g, _, P) => n(_, P, E) }));
  }), !e.regions && /* @__PURE__ */ a.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ a.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), Aw = ({ name: e }) => {
  const { visSupportsRegions: t } = Os(), { config: n, updateConfig: i } = ce.useContext(Ct);
  return t() ? /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, e)), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(Cw, { config: n, updateConfig: i }))) : null;
}, Rh = ce.createContext(null), Dh = () => {
  const e = ce.useContext(Rh);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Pw = (e) => {
  const { config: t } = ce.useContext(Ct), { updateField: n } = Dh(), { enabledChartTypes: i, visHasNumbersOnBars: r, visHasaAdditionalLabelsOnBars: o, visHasLabelOnData: d, visSupportsChartHeight: u, visSupportsSuperTitle: s, visSupportsFootnotes: h } = Os(), { visualizationType: m, visualizationSubType: y, barStyle: v } = t, w = () => (m === "Bar" || m === "Deviation Bar") && y !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ a.createElement(_n, null, " ", /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "General")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(At, { value: m, fieldName: "visualizationType", label: "Chart Type", updateField: n, options: i }), (m === "Bar" || m === "Combo" || m === "Area Chart") && /* @__PURE__ */ a.createElement(At, { value: y || "Regular", fieldName: "visualizationSubType", label: "Chart Subtype", updateField: n, options: ["regular", "stacked"] }), m === "Area Chart" && y === "stacked" && /* @__PURE__ */ a.createElement(At, { value: t.stackedAreaChartLineType || "Linear", fieldName: "stackedAreaChartLineType", label: "Stacked Area Chart Line Type", updateField: n, options: Object.keys(bc) }), m === "Bar" && /* @__PURE__ */ a.createElement(At, { value: t.orientation || "vertical", fieldName: "orientation", label: "Orientation", updateField: n, options: ["vertical", "horizontal"] }), m === "Deviation Bar" && /* @__PURE__ */ a.createElement(At, { label: "Orientation", options: ["horizontal"] }), (m === "Bar" || m === "Deviation Bar") && /* @__PURE__ */ a.createElement(
    At,
    {
      value: t.isLollipopChart ? "lollipop" : v || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: n,
      options: w(),
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (m === "Bar" || m === "Deviation Bar") && v === "rounded" && /* @__PURE__ */ a.createElement(At, { value: t.tipRounding || "top", fieldName: "tipRounding", label: "tip rounding", updateField: n, options: ["top", "full"] }), (m === "Bar" || m === "Deviation Bar") && v === "rounded" && /* @__PURE__ */ a.createElement(At, { value: t.roundingStyle || "standard", fieldName: "roundingStyle", label: "rounding style", updateField: n, options: ["standard", "shallow", "finger"] }), m === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ a.createElement(At, { value: t.yAxis.labelPlacement || "Below Bar", section: "yAxis", fieldName: "labelPlacement", label: "Label Placement", updateField: n, options: ["Below Bar", "On Date/Category Axis"] }), r() ? /* @__PURE__ */ a.createElement(ut, { value: t.yAxis.displayNumbersOnBar, section: "yAxis", fieldName: "displayNumbersOnBar", label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar", updateField: n }) : d() && /* @__PURE__ */ a.createElement(
    ut,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: n,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Selecting this option will not hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), o() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    ut,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, ' Selecting this option will display "N/A" on the Date/Category Axis as an indication of missing or undefined data values.'))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ a.createElement(
    ut,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, ' Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueDataLabel,
      section: "general",
      fieldName: "showZeroValueDataLabel",
      label: 'Display "Zero Value Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ a.createElement(
    ut,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Selecting this option will display "suppressed data symbol" on the Date/Category Axis where suppressed data values are indicated in the Data Series, unless a different symbol was chosen from the data series (e.g., suppression symbol) menu.'))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" symbol',
      updateField: n
    }
  )), m === "Pie" && /* @__PURE__ */ a.createElement(At, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }), m === "Line" && /* @__PURE__ */ a.createElement(
    ut,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: n,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: n,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ a.createElement(ut, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }), s() && /* @__PURE__ */ a.createElement(
    Je,
    {
      value: t.superTitle,
      updateField: n,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "textarea",
      value: t.introText,
      updateField: n,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: n,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), h() && /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: n,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  ), u() && t.orientation === "vertical" && /* @__PURE__ */ a.createElement(Je, { type: "number", value: t.heights.vertical, section: "heights", fieldName: "vertical", label: "Chart Height", updateField: n })));
}, Lw = (e) => {
  const { config: t } = ce.useContext(Ct), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: i } = Dh();
  return /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, e.name)), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "text",
      value: n.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: i,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: i,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "text",
      value: n.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: i,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: i,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      type: "text",
      value: n.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: i,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ a.createElement("br", null), /* @__PURE__ */ a.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ a.createElement(Je, { type: "text", value: n.labels.iqr, fieldName: "iqr", section: "boxplot", subsection: "labels", label: "Interquartile Range", updateField: i }), /* @__PURE__ */ a.createElement(Je, { type: "text", value: n.labels.total, fieldName: "total", section: "boxplot", subsection: "labels", label: "Total", updateField: i }), /* @__PURE__ */ a.createElement(Je, { type: "text", value: n.labels.mean, fieldName: "mean", section: "boxplot", subsection: "labels", label: "Mean", updateField: i }), /* @__PURE__ */ a.createElement(Je, { type: "text", value: n.labels.outliers, fieldName: "outliers", section: "boxplot", subsection: "labels", label: "Outliers", updateField: i }), /* @__PURE__ */ a.createElement(Je, { type: "text", value: n.labels.values, fieldName: "values", section: "boxplot", subsection: "labels", label: "Values", updateField: i })));
}, Rw = (e, t) => {
  let n = [], i = [], r = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const o = e.twoColor.isPaletteReversed;
    n = Object.keys(Uu).filter((d) => o ? d.endsWith("reverse") : !d.endsWith("reverse"));
  } else {
    const o = [], d = [];
    for (const u in dr) {
      const s = u.startsWith("sequential"), h = u.startsWith("qualitative"), m = u.endsWith("reverse");
      s && (!e.isPaletteReversed && !m || e.isPaletteReversed && m) && o.push(u), h && (!e.isPaletteReversed && !m || e.isPaletteReversed && m) && d.push(u);
    }
    i = o, r = d;
  }
  return ce.useEffect(() => {
    let o = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (o = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (o = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: o } });
  }, [e.twoColor.isPaletteReversed]), ce.useEffect(() => {
    let o = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (o = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (o = e.palette.slice(0, -7)), t({ ...e, palette: o });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: i, nonSequential: r };
}, Dw = (e) => {
  var U;
  const { config: t, updateConfig: n, colorPalettes: i, twoColorPalette: r } = ce.useContext(Ct), { visual: o } = t, { setLollipopShape: d, updateField: u } = Dh(), { visHasBarBorders: s, visCanAnimate: h, visSupportsNonSequentialPallete: m, headerColors: y, visSupportsTooltipOpacity: v, visSupportsTooltipLines: w, visSupportsBarSpace: E, visSupportsBarThickness: R, visHasDataCutoff: C, visSupportsSequentialPallete: g, visSupportsReverseColorPalette: _ } = Os(), { twoColorPalettes: P, sequential: M, nonSequential: N } = Rw(t, n), T = (V, G) => {
    if (console.log("value", G), V === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: G
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [V]: {
            ...t.sankey[V],
            default: G
          }
        }
      });
  };
  return /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Visual")), /* @__PURE__ */ a.createElement(zn, null, t.isLollipopChart && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("fieldset", { className: "header" }, /* @__PURE__ */ a.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ a.createElement(
    "div",
    {
      onChange: (V) => {
        d(V.target.value);
      }
    },
    /* @__PURE__ */ a.createElement("label", { className: "radio-label" }, /* @__PURE__ */ a.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ a.createElement("label", { className: "radio-label" }, /* @__PURE__ */ a.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ a.createElement(At, { value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone", fieldName: "lollipopColorStyle", label: "Lollipop Color Style", updateField: u, options: ["regular", "two-tone"] }), /* @__PURE__ */ a.createElement(At, { value: t.lollipopSize ? t.lollipopSize : "small", fieldName: "lollipopSize", label: "Lollipop Size", updateField: u, options: ["small", "medium", "large"] })), t.visualizationType === "Box Plot" && /* @__PURE__ */ a.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ a.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ a.createElement(At, { value: t.boxplot.borders, fieldName: "borders", section: "boxplot", label: "Box Plot Borders", updateField: u, options: ["true", "false"] }), /* @__PURE__ */ a.createElement(ut, { value: t.boxplot.plotOutlierValues, fieldName: "plotOutlierValues", section: "boxplot", label: "Plot Outliers", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: t.boxplot.plotNonOutlierValues, fieldName: "plotNonOutlierValues", section: "boxplot", label: "Plot non-outlier values", updateField: u })), /* @__PURE__ */ a.createElement(At, { value: t.fontSize, fieldName: "fontSize", label: "Font Size", updateField: u, options: ["small", "medium", "large"] }), s() && /* @__PURE__ */ a.createElement(At, { value: t.barHasBorder, fieldName: "barHasBorder", label: "Bar Borders", updateField: u, options: ["true", "false"] }), h() && /* @__PURE__ */ a.createElement(ut, { value: t.animate, fieldName: "animate", label: "Animate Visualization", updateField: u }), (((U = t.series) == null ? void 0 : U.some((V) => V.type === "Line" || V.type === "dashed-lg" || V.type === "dashed-sm" || V.type === "dashed-md")) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(At, { value: t.lineDatapointStyle, fieldName: "lineDatapointStyle", label: "Line Datapoint Style", updateField: u, options: ["hidden", "hover", "always show"] }), /* @__PURE__ */ a.createElement(At, { value: t.lineDatapointColor, fieldName: "lineDatapointColor", label: "Line Datapoint Color", updateField: u, options: ["Same as Line", "Lighter than Line"] })), /* @__PURE__ */ a.createElement("label", { className: "header" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ a.createElement("ul", { className: "color-palette" }, y.map((V) => /* @__PURE__ */ a.createElement(
    "button",
    {
      title: V,
      key: V,
      onClick: (G) => {
        G.preventDefault(), n({ ...t, theme: V });
      },
      className: t.theme === V ? "selected " + V : V
    }
  )))), (m() || m()) && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label" }, "Chart Color Palette")), _() && /* @__PURE__ */ a.createElement(Hh, { fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: u, value: t.isPaletteReversed }), g() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("span", null, "Sequential"), /* @__PURE__ */ a.createElement("ul", { className: "color-palette" }, M.map((V) => {
    const G = {
      backgroundColor: i[V][2]
    }, ue = {
      backgroundColor: i[V][3]
    }, Z = {
      backgroundColor: i[V][5]
    };
    return /* @__PURE__ */ a.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: ($) => {
          $.preventDefault(), n({ ...t, palette: V });
        },
        className: t.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ a.createElement("span", { style: G }),
      /* @__PURE__ */ a.createElement("span", { style: ue }),
      /* @__PURE__ */ a.createElement("span", { style: Z })
    );
  }))), m() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ a.createElement("ul", { className: "color-palette" }, N.map((V) => {
    const G = {
      backgroundColor: i[V][2]
    }, ue = {
      backgroundColor: i[V][4]
    }, Z = {
      backgroundColor: i[V][6]
    };
    return /* @__PURE__ */ a.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: ($) => {
          $.preventDefault(), n({ ...t, palette: V });
        },
        className: t.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ a.createElement("span", { style: G }),
      /* @__PURE__ */ a.createElement("span", { style: ue }),
      /* @__PURE__ */ a.createElement("span", { style: Z })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ a.createElement("input", { type: "color", value: t.sankey.nodeColor.default, id: "storyNodeColor", name: "storyNodeColor", onChange: (V) => T("nodeColor", V.target.value) }), /* @__PURE__ */ a.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ a.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ a.createElement("input", { type: "color", value: t.sankey.storyNodeFontColor || "red", id: "storyNodeFontColor", name: "storyNodeFontColor", onChange: (V) => T("storyNodeFontColor", V.target.value) }), /* @__PURE__ */ a.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ a.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ a.createElement("input", { type: "color", value: t.sankey.linkColor.default, id: "linkColor", name: "linkColor", onChange: (V) => T("linkColor", V.target.value) }), /* @__PURE__ */ a.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Hh, { section: "twoColor", fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: u, value: t.twoColor.isPaletteReversed }), /* @__PURE__ */ a.createElement("ul", { className: "color-palette" }, P.map((V) => {
    const G = {
      backgroundColor: r[V][0]
    }, ue = {
      backgroundColor: r[V][1]
    };
    return /* @__PURE__ */ a.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: (Z) => {
          Z.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: V } });
        },
        className: t.twoColor.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ a.createElement("span", { className: "two-color", style: G }),
      /* @__PURE__ */ a.createElement("span", { className: "two-color", style: ue })
    );
  }))), C() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: u,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), R() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ a.createElement(Je, { type: "number", value: t.barHeight || "25", fieldName: "barHeight", label: " Bar Thickness", updateField: u, min: 15 }), (t.visualizationType === "Bar" && t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ a.createElement(Je, { value: t.barThickness, type: "number", fieldName: "barThickness", label: "Bar Thickness", updateField: u }), E() && /* @__PURE__ */ a.createElement(Je, { type: "number", value: t.barSpace || "15", fieldName: "barSpace", label: "Bar Space", updateField: u, min: 0 }), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a.createElement(ut, { value: t.topAxis.hasLine, section: "topAxis", fieldName: "hasLine", label: "Add Top Axis Line", updateField: u }), t.visualizationType === "Spark Line" && /* @__PURE__ */ a.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ a.createElement(ut, { value: o == null ? void 0 : o.border, section: "visual", fieldName: "border", label: "Show Border", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: o == null ? void 0 : o.borderColorTheme, section: "visual", fieldName: "borderColorTheme", label: "Use Border Color Theme", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: o == null ? void 0 : o.accent, section: "visual", fieldName: "accent", label: "Use Accent Style", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: o == null ? void 0 : o.background, section: "visual", fieldName: "background", label: "Use Theme Background Color", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: o == null ? void 0 : o.hideBackgroundColor, section: "visual", fieldName: "hideBackgroundColor", label: "Hide Background Color", updateField: u })), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a.createElement(ut, { value: t.showLineSeriesLabels, fieldName: "showLineSeriesLabels", label: "Append Series Name to End of Line Charts", updateField: u }), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ a.createElement(ut, { value: t.colorMatchLineSeriesLabels, fieldName: "colorMatchLineSeriesLabels", label: "Match Series Color to Name at End of Line Charts", updateField: u }), w() && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(ut, { value: o.verticalHoverLine, fieldName: "verticalHoverLine", section: "visual", label: "Vertical Hover Line", updateField: u }), /* @__PURE__ */ a.createElement(ut, { value: o.horizontalHoverLine, fieldName: "horizontalHoverLine", section: "visual", label: "Horizontal Hover Line", updateField: u })), v() && /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (V) => n({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: V.target.value
        }
      })
    }
  )), t.visualizationType === "Bar" && /* @__PURE__ */ a.createElement(ut, { value: t.tooltips.singleSeries, fieldName: "singleSeries", section: "tooltips", label: "SHOW HOVER FOR SINGLE DATA SERIES", updateField: u }), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (V) => n({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: V.target.value
        }
      })
    }
  ))));
}, Ow = () => {
  var u, s, h;
  const { config: e, updateConfig: t } = ce.useContext(Ct), n = (u = e.data) == null ? void 0 : u[0], { updateField: i } = ce.useContext(Rh);
  if (e.visualizationType !== "Sankey")
    return;
  const r = (m, y, v) => {
    let w = [];
    n != null && n.storyNodeText && (w = [...n == null ? void 0 : n.storyNodeText]), w[v][m] = y, t({
      ...e,
      sankey: {
        ...e.sankey,
        data: {
          ...e.sankey.data,
          storyNodeText: w
        }
      }
    });
  }, o = () => {
    const m = n;
    m.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), t({
      ...e,
      sankey: {
        ...e.sankey,
        data: [{ ...m }]
      }
    });
  }, d = (m) => {
    const y = n;
    y.storyNodeText.splice(m, 1), t({ ...e, sankey: { ...e.sankey, data: { ...y } } });
  };
  return /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Sankey Settings")), /* @__PURE__ */ a.createElement(zn, null, (n == null ? void 0 : n.storyNodeText) && (n == null ? void 0 : n.storyNodeText.map(({ StoryNode: m, segmentTextBefore: y, segmentTextAfter: v }, w) => /* @__PURE__ */ a.createElement("div", { key: w, style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" } }, /* @__PURE__ */ a.createElement("label", null, "Story Node Text", /* @__PURE__ */ a.createElement("input", { type: "text", value: m, fieldName: "StoryNode", label: "StoryNode", onChange: (E) => r("StoryNode", E.target.value, w) })), /* @__PURE__ */ a.createElement("label", null, "Story Text Before", /* @__PURE__ */ a.createElement("input", { type: "text", value: y, fieldName: "segmentTextBefore", label: "Segment Text Before", onChange: (E) => r("segmentTextBefore", E.target.value, w) })), /* @__PURE__ */ a.createElement("label", null, "Story Text After", /* @__PURE__ */ a.createElement("input", { type: "text", value: v, fieldName: "segmentTextAfter", label: "Segment Text After", onChange: (E) => r("segmentTextAfter", E.target.value, w) })), /* @__PURE__ */ a.createElement(Vf, { onClick: (E) => d(w), className: "btn", style: { background: "tomato" } }, "Remove Story Node")))), `Total Story Nodes: ${(s = n == null ? void 0 : n.storyNodeText) == null ? void 0 : s.length}`, ((h = n == null ? void 0 : n.storyNodeText) == null ? void 0 : h.length) < 3 && /* @__PURE__ */ a.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (m) => {
        m.preventDefault(), o();
      }
    },
    "Add StoryNode"
  ), /* @__PURE__ */ a.createElement(ut, { value: e.enableTooltips, fieldName: "enableTooltips", label: "Enable Tooltips", updateField: i })));
}, Fa = {
  ForestPlot: fw,
  Series: Kr,
  Regions: Aw,
  General: Pw,
  BoxPlot: Lw,
  Visual: Dw,
  Sankey: Ow
};
const Mw = ({ config: e, updateConfig: t, data: n }) => {
  var C, g, _;
  const i = e.visualizationType === "Combo", r = ((C = e.runtime.lineSeriesKeys) == null ? void 0 : C.length) > 0, o = ((g = e.runtime.barSeriesKeys) == null ? void 0 : g.length) > 0, d = i && r, u = i && o, s = () => Ni.uniq(Ni.flatMap(n, Ni.keys)), h = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], m = {
    "Dashed Small": "- - -",
    "Dashed Medium": " ",
    "Dashed Large": " ",
    "Open Circles": ""
  }, y = (P) => {
    if (e.visualizationType === "Line" || i) {
      const M = Object.keys(m);
      return P === "suppression" ? M.slice(0, -1) : M;
    }
  }, v = () => {
    if (e.visualizationType === "Bar" || u)
      return Object.keys(Yh);
  };
  let w = (P) => {
    let M = [];
    e.preliminaryData && (M = [...e.preliminaryData]), M.splice(P, 1), t({ ...e, preliminaryData: M });
  }, E = () => {
    const P = e.visualizationType === "Line" ? "effect" : "suppression";
    let M = e.preliminaryData ? [...e.preliminaryData] : [];
    const N = {
      type: P,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: ""
    };
    M.push(N), t({ ...e, preliminaryData: M });
  }, R = (P, M, N) => {
    let T = [];
    e.preliminaryData && (T = [...e.preliminaryData]), T[N][P] = M, P === "symbol" && (T[N].iconCode = Yh[M]), P === "style" && (T[N].lineCode = m[M]), t({ ...e, preliminaryData: T });
  };
  return /* @__PURE__ */ a.createElement(a.Fragment, null, e.preliminaryData && ((_ = e.preliminaryData) == null ? void 0 : _.map(({ column: P, displayLegend: M, displayTable: N, displayTooltip: T, label: U, seriesKey: V, style: G, symbol: ue, type: Z, value: $ }, H) => {
    var j, F;
    return /* @__PURE__ */ a.createElement("div", { key: `preliminaryData-${H}`, className: "edit-block" }, /* @__PURE__ */ a.createElement("p", null, " ", Z === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ a.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (X) => {
          X.preventDefault(), w(H);
        }
      },
      "Remove"
    ), /* @__PURE__ */ a.createElement(At, { value: Z, initial: e.visualizationType == "Bar" ? "" : "Select", fieldName: "type", label: "Type", updateField: (X, Q, ae, te) => R(ae, te, H), options: h() }), Z === "suppression" ? /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
      At,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'If no Data Series" is selected, the symbol will be applied to "all" suppressed values indicated in the dataset.'))),
        value: P,
        initial: "Select",
        fieldName: "column",
        label: "Add Data Series",
        updateField: (X, Q, ae, te) => R(ae, te, H),
        options: (j = e.runtime) == null ? void 0 : j.seriesKeys
      }
    ), /* @__PURE__ */ a.createElement(Je, { value: $, fieldName: "value", label: "Suppressed Data  Value", updateField: (X, Q, ae, te) => R(ae, te, H) }), (d || e.visualizationType === "Line") && /* @__PURE__ */ a.createElement(
      At,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
        value: G,
        initial: "Select",
        fieldName: "style",
        label: "suppression line style",
        updateField: (X, Q, ae, te) => R(ae, te, H),
        options: y(Z)
      }
    ), (u || e.visualizationType === "Bar") && /* @__PURE__ */ a.createElement(
      At,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'The suggested method for presenting suppressed data is to use "double asterisks". If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
        value: ue,
        initial: "Select",
        fieldName: "symbol",
        label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
        updateField: (X, Q, ae, te) => R(ae, te, H),
        options: v()
      }
    ), /* @__PURE__ */ a.createElement(
      Je,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "This label will display in the tooltip and legend."))),
        value: U || "Suppressed",
        fieldName: "label",
        label: "Suppressed Data Label",
        placeholder: "",
        updateField: (X, Q, ae, te) => R(ae, te, H)
      }
    ), /* @__PURE__ */ a.createElement(
      ut,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enabling this tooltip will provide a clearer indication of 'suppressed' or 'zero data' values, whichever is applicable. Deselecting 'Display In Tooltip' indicates that you do not want to display 'suppressed' or 'zero data' values in tooltips when hovering over them."))),
        value: T,
        fieldName: "displayTooltip",
        label: "Display in tooltips",
        updateField: (X, Q, ae, te) => R(ae, te, H)
      }
    ), /* @__PURE__ */ a.createElement(
      ut,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
        value: M,
        fieldName: "displayLegend",
        label: "Display in legend",
        updateField: (X, Q, ae, te) => R(ae, te, H)
      }
    ), /* @__PURE__ */ a.createElement(
      ut,
      {
        tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
        value: N,
        fieldName: "displayTable",
        label: "Display in table",
        updateField: (X, Q, ae, te) => R(ae, te, H)
      }
    )) : /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(At, { value: V, initial: "Select", fieldName: "seriesKey", label: "ASSOCIATE TO SERIES", updateField: (X, Q, ae, te) => R(ae, te, H), options: e.runtime.lineSeriesKeys ?? ((F = e.runtime) == null ? void 0 : F.seriesKeys) }), /* @__PURE__ */ a.createElement(At, { value: P, initial: "Select", fieldName: "column", label: "COLUMN WITH CONFIGURATION VALUE", updateField: (X, Q, ae, te) => R(ae, te, H), options: s() }), /* @__PURE__ */ a.createElement(Je, { value: $, fieldName: "value", label: "VALUE TO TRIGGER", updateField: (X, Q, ae, te) => R(ae, te, H) }), /* @__PURE__ */ a.createElement(At, { value: G, initial: "Select", fieldName: "style", label: "Style", updateField: (X, Q, ae, te) => R(ae, te, H), options: y(Z) }), /* @__PURE__ */ a.createElement(Je, { value: U, fieldName: "label", label: "Label", placeholder: "", updateField: (X, Q, ae, te) => R(ae, te, H) })));
  })), /* @__PURE__ */ a.createElement("button", { type: "button", onClick: E, className: "btn full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, _w = () => {
  var nn, Qt, Cn, un, An, In, Yn, Zn, Xn, x, L, I, Y, Te, xe, De, je, at, yt;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: i,
    loading: r,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: u,
    unfilteredData: s,
    excludedData: h,
    isDashboard: m,
    setParentConfig: y,
    missingRequiredSections: v,
    isDebug: w,
    setFilteredData: E,
    lineOptions: R,
    rawData: C,
    highlight: g,
    highlightReset: _
  } = ce.useContext(Ct), { minValue: P, maxValue: M, existPositiveValue: N, isAllLine: T } = Nc(e, s), U = { data: i, config: e }, { leftMax: V, rightMax: G } = cy(U), {
    headerColors: ue,
    visSupportsTooltipLines: Z,
    visSupportsNonSequentialPallete: $,
    visSupportsSequentialPallete: H,
    visSupportsReverseColorPalette: j,
    visHasLabelOnData: F,
    visHasNumbersOnBars: X,
    visHasAnchors: Q,
    visHasBarBorders: ae,
    visHasDataCutoff: te,
    visHasSelectableLegendValues: re,
    visCanAnimate: ie,
    visHasLegend: ge,
    visHasLegendAxisAlign: ve,
    visHasBrushChart: Se,
    visSupportsDateCategoryAxis: ye,
    visSupportsValueAxisMin: ee,
    visSupportsValueAxisMax: Ee,
    visSupportsDateCategoryAxisLabel: He,
    visSupportsDateCategoryAxisLine: we,
    visSupportsDateCategoryAxisTicks: fe,
    visSupportsDateCategoryTickRotation: Ae,
    visSupportsDateCategoryNumTicks: ne,
    visSupportsDateCategoryAxisPadding: $e,
    visSupportsRegions: Le,
    visSupportsFilters: Ke,
    visSupportsPreliminaryData: Ge,
    visSupportsValueAxisGridLines: et,
    visSupportsValueAxisLine: Ze,
    visSupportsValueAxisTicks: Et,
    visSupportsValueAxisLabels: qe,
    visSupportsBarSpace: Be,
    visSupportsBarThickness: Ie,
    visSupportsFootnotes: Fe,
    visSupportsSuperTitle: lt,
    visSupportsDataCutoff: Ue,
    visSupportsChartHeight: ct,
    visSupportsLeftValueAxis: ht,
    visSupportsTooltipOpacity: gt,
    visSupportsRankByValue: Dt,
    visSupportsResponsiveTicks: qt,
    visSupportsDateCategoryHeight: Vt,
    visHasDataSuppression: kt
  } = Os();
  ce.useEffect(() => {
    let le = [];
    e.series && (le = e.series.map((se) => ({
      ...se,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: le
    });
  }, [e.visualizationType]), ce.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), ce.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: zt } = gh({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), ln = (le, se) => ({
    ...se
  }), en = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, cn = (le) => {
    le.orientation === "horizontal" && (le.labels = !1), le.table.show === void 0 && (le.table.show = !m), le.visualizationType === "Combo" && (le.orientation = "vertical"), Pn(le.xAxis) && !le.xAxis.padding && (le.xAxis.padding = 6), le.visualizationType === "Line" && (le.visualizationSubType = "regular", le.barStyle = "flat", le.isLollipopChart = !1);
  }, ze = (le, se, me, Oe) => {
    if (w && console.log("#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue", le, se, me, Oe), le === "boxplot" && se === "legend") {
      t({
        ...e,
        [le]: {
          ...e[le],
          [se]: {
            ...e.boxplot[se],
            [me]: Oe
          }
        }
      });
      return;
    }
    if (le === "boxplot" && se === "labels") {
      t({
        ...e,
        [le]: {
          ...e[le],
          [se]: {
            ...e.boxplot[se],
            [me]: Oe
          }
        }
      });
      return;
    }
    const bt = (Hn) => Hn === 0 ? !0 : !!Hn;
    if (le === "columns" && bt(se) && bt(me)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [se]: {
            ...e.columns[se],
            [me]: Oe
          }
        }
      });
      return;
    }
    if (le === null && se === null) {
      bt(me) || console.error("fieldName is required");
      let Hn = { ...e, [me]: Oe };
      cn(Hn), t(Hn);
      return;
    }
    const vn = Array.isArray(e[le]);
    let Rn = vn ? [...e[le], Oe] : { ...e[le], [me]: Oe };
    bt(se) && (vn ? (Rn = [...e[le]], Rn[se] = { ...Rn[se], [me]: Oe }) : typeof Oe == "string" ? Rn[se] = Oe : bt(me) && (Rn = { ...e[le], [se]: { ...e[le][se], [me]: Oe } }));
    let fr = { ...e, [le]: Rn };
    cn(fr), t(fr);
  }, [Nt, Gt] = ce.useState(!0), [Bt, yn] = ce.useState(!1);
  if (r)
    return null;
  ce.useEffect(() => {
    var le;
    (le = e.general) != null && le.boxplot && (e.general.boxplot.firstQuartilePercentage || t({
      ...e,
      boxplot: {
        ...e.boxplot,
        firstQuartilePercentage: 25
      }
    }));
  }, [e]);
  const Lt = (le) => {
    t({
      ...e,
      lollipopShape: le
    });
  }, bn = (le) => {
    let se = e.series ? [...e.series] : [], me = Array.from(new Set(i.map((bt) => bt[le]))), Oe = [];
    me.forEach((bt) => {
      Oe.push({ key: bt });
    }), e.visualizationType === "Forecasting" ? se.push({ dataKey: le, type: e.visualizationType, stages: Oe, stageColumn: le, axis: "Left", tooltip: !0 }) : se.push({ dataKey: le, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: se });
  }, Mn = (le) => {
    const se = e.series[0].dataKey, me = i.sort((bt, vn) => bt[se] - vn[se]), Oe = le === "asc" ? me : me.reverse();
    t({ ...e }, Oe);
  }, mn = (le) => {
    let se = [...e.exclusions.keys];
    se.push(le);
    let me = { ...e.exclusions, keys: se };
    t({ ...e, exclusions: me });
  }, dn = (le) => {
    let se = -1, me = [...e.exclusions.keys];
    for (let Oe = 0; Oe < me.length; Oe++)
      if (me[Oe] === le) {
        se = Oe;
        break;
      }
    if (se !== -1) {
      me.splice(se, 1);
      let Oe = { ...e.exclusions, keys: me }, bt = { ...e, exclusions: Oe };
      me.length === 0 && delete bt.exclusions.keys, t(bt);
    }
  }, jt = (le = !0) => {
    let se = {};
    if (s.forEach((me) => {
      Object.keys(me).forEach((Oe) => se[Oe] = !0);
    }), le) {
      const { lower: me, upper: Oe } = e.confidenceKeys || {};
      Object.keys(se).forEach((bt) => {
        (e.series && e.series.filter((vn) => vn.dataKey === bt).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(bt) && (me && Oe || me || Oe) && bt !== me && bt !== Oe) && delete se[bt];
      });
    }
    return Object.keys(se);
  }, wn = (le) => {
    if (!le)
      return [];
    const se = /* @__PURE__ */ new Set();
    for (let me = 0; me < le.length; me++)
      for (const [Oe] of Object.entries(le[me]))
        se.add(Oe);
    return Array.from(se);
  }, Ft = (le, se = !1) => {
    let me = [];
    return h.forEach((Oe) => {
      me.push(Oe[le]);
    }), se ? [...new Set(me)] : me;
  }, pt = () => {
    Gt(!Nt), t({
      ...e,
      showEditorPanel: !Nt
    });
  }, Tn = () => {
    let le = JSON.parse(JSON.stringify(e));
    return v() === !1 && delete le.newViz, delete le.runtime, le;
  };
  ce.useEffect(() => {
    if (y) {
      const le = Tn();
      y(le);
    }
  }, [e]), ce.useEffect(() => {
    const le = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], se = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: se
      },
      yAxis: {
        ...e.yAxis,
        anchors: le
      }
    });
  }, [e.orientation]), ce.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), ce.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), ce.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const tn = ce.useCallback(() => {
    const le = [...e.exclusions.keys];
    return /* @__PURE__ */ a.createElement("ul", { className: "series-list" }, le.map((se, me) => /* @__PURE__ */ a.createElement("li", { key: se }, /* @__PURE__ */ a.createElement("div", { className: "series-list__name", "data-title": se }, /* @__PURE__ */ a.createElement("div", { className: "series-list__name--text" }, se)), /* @__PURE__ */ a.createElement("button", { className: "series-list__remove", onClick: () => dn(se) }, ""))));
  }, [e]), $t = (le, se) => {
    let me = e.series, [Oe] = me.splice(le, 1);
    me.splice(se, 0, Oe), t({ ...e, series: me });
  };
  e.isLollipopChart && ((nn = e == null ? void 0 : e.series) == null ? void 0 : nn.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((Qt = e == null ? void 0 : e.series) == null ? void 0 : Qt.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Cn = e == null ? void 0 : e.series) == null ? void 0 : Cn.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((un = e == null ? void 0 : e.series) == null ? void 0 : un.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const Sn = e.orientation === "horizontal" ? "xAxis" : "yAxis", [En, Dn] = ce.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), Ln = () => {
    const le = e[Sn].max, se = e[Sn].rightMax;
    let me = "", Oe = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (le && parseFloat(le) < parseFloat(M) && N):
          me = "Max value must be more than " + M;
          break;
        case (le && parseFloat(le) < 0 && !N):
          me = "Value must be more than or equal to 0";
          break;
        default:
          me = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (le && parseFloat(le) < V):
          me = "Max value must be more than " + V;
          break;
        case (se && parseFloat(se) < G):
          Oe = "Max value must be more than " + G;
          break;
        case (le && parseFloat(le) < 0 && !N):
          me = "Value must be more than or equal to 0";
          break;
        default:
          me = "";
      }
    Dn((bt) => ({ ...bt, maxMsg: me, rightMaxMessage: Oe }));
  }, Me = () => {
    const le = parseFloat(e[Sn].min);
    let se = Number(P), me = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && le < 0):
        me = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && le > se):
        me = "Value should not exceed " + P;
        break;
      case (e.visualizationType === "Combo" && T && le > se):
        me = "Value should not exceed " + P;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !T) && se > 0 && le > 0):
        me = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && le >= Math.min(se, e.xAxis.target)):
        me = "Value must be less than " + Math.min(se, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && le && se < 0 && le > se):
        me = "Value should not exceed " + P;
        break;
      default:
        me = "";
    }
    Dn((Oe) => ({ ...Oe, minMsg: me }));
  };
  ce.useEffect(() => {
    Me(), Ln();
  }, [P, M, e]);
  const dt = ((An = e == null ? void 0 : e.dataKey) == null ? void 0 : An.includes("http://")) || ((In = e == null ? void 0 : e.dataKey) == null ? void 0 : In.includes("https://")), it = () => {
    var le, se;
    if (w !== void 0 && w && !((le = e == null ? void 0 : e.xAxis) != null && le.dataKey)) {
      let me = jt(!1);
      if (me.includes("Date"))
        return "Date";
      if (me.includes("Race"))
        return "Race";
      if (me.includes("Month"))
        return "Month";
    }
    return ((se = e == null ? void 0 : e.xAxis) == null ? void 0 : se.dataKey) || "";
  }, W = () => {
    if (w !== void 0 && w && jt(!1).length > 0) {
      let le = jt(!1).filter((se) => se !== it());
      if (le.length > 0)
        return le[0];
    }
    return "";
  };
  if (w && !e.xAxis.dataKey && (e.xAxis.dataKey = it()), w && ((Yn = e == null ? void 0 : e.series) == null ? void 0 : Yn.length) === 0) {
    let le = W();
    le !== "" && bn(le), w && console.log("### COVE DEBUG: Chart: Setting default datacol=", le);
  }
  const _e = ["Area Chart", "Combo", "Line", "Bar", "Forecasting", "Scatter Plot", "Paired Bar", "Deviation Bar"], Xe = [
    /* @__PURE__ */ a.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((Zn = e.data) == null ? void 0 : Zn[0]) || []).map((se) => {
      const me = e == null ? void 0 : e.series.some((Oe) => Oe.dataKey === se);
      if (se !== e.xAxis.dataKey && !me)
        return Xe.push(
          /* @__PURE__ */ a.createElement("option", { value: se, key: se }, se)
        );
    });
    let le = {};
    e.data.forEach((se) => {
      Object.keys(se).forEach((me) => {
        le[me] = le[me] || [];
        const Oe = typeof se[me] == "number" ? se[me].toString() : se[me];
        le[me].indexOf(Oe) === -1 && le[me].push(Oe);
      });
    });
  }
  if (!e.data && i) {
    if (!i[0])
      return;
    Object.keys(i[0]).map((se) => {
      const me = i.some((Oe) => Oe.dataKey === se);
      if (se !== e.xAxis.dataKey && !me)
        return Xe.push(
          /* @__PURE__ */ a.createElement("option", { value: se, key: se }, se)
        );
    });
    let le = {};
    i.forEach((se) => {
      Object.keys(se).forEach((me) => {
        le[me] = le[me] || [];
        const Oe = typeof se[me] == "number" ? se[me].toString() : se[me];
        le[me].indexOf(Oe) === -1 && le[me].push(Oe);
      });
    });
  }
  const Ve = (le) => {
    const se = Ni.cloneDeep(e.columns);
    delete se[le], t({
      ...e,
      columns: se
    });
  }, ot = async (le, se, me) => {
    switch (se) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [le]: {
              ...e.columns[le],
              [se]: me
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [le]: {
              ...e.columns[le],
              [se]: me
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: rt,
    highlightedSeriesValues: xt,
    handleUpdateHighlightedBar: Mt,
    handleAddNewHighlightedBar: Qe,
    handleRemoveHighlightedBar: Kt,
    handleUpdateHighlightedBarColor: It,
    handleHighlightedBarLegendLabel: _t,
    handleUpdateHighlightedBorderWidth: mt
  } = Lc(e, t), Rt = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, wt = () => {
    const le = i.map((se) => se[e.legend.colorCode]);
    return Rt ? le : jt(!1).filter((se) => se !== e.xAxis.dataKey);
  }, Yt = (le) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: le } });
  }, Xt = (le, se, me) => {
    var vn;
    const Oe = { ...e[le], [se]: me }, bt = { ...e, [le]: Oe };
    me === "highlight" && ((vn = e.legend.seriesHighlight) != null && vn.length) && (bt.legend.seriesHighlight.length = 0), t(bt);
  }, sn = (le, se, me) => {
    const Oe = { ...e.xAxis[le] };
    Oe[se] = me;
    const bt = { ...e, xAxis: { ...e.xAxis, [le]: Oe } };
    t(bt);
  }, fn = {
    addNewExclusion: mn,
    data: i,
    editColumn: ot,
    getColumns: jt,
    getDataValueOptions: wn,
    getDataValues: Ft,
    getItemStyle: ln,
    handleSeriesChange: $t,
    handleAddNewHighlightedBar: Qe,
    setCategoryAxis: it,
    sortSeries: Mn,
    updateField: ze,
    warningMsg: En,
    highlightedBarValues: rt,
    handleHighlightedBarLegendLabel: _t,
    handleUpdateHighlightedBar: Mt,
    handleRemoveHighlightedBar: Kt,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: xt,
    handleUpdateHighlightedBorderWidth: mt,
    handleUpdateHighlightedBarColor: It,
    setLollipopShape: Lt
  };
  return /* @__PURE__ */ a.createElement(Rh.Provider, { value: fn }, /* @__PURE__ */ a.createElement(Cr, { component: "EditorPanel" }, /* @__PURE__ */ a.createElement(tf.Sidebar, { displayPanel: Nt, isDashboard: m, title: "Configure Chart", onBackClick: pt }, /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ a.createElement(Fa.General, { name: "General" }), /* @__PURE__ */ a.createElement(Fa.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ a.createElement(Fa.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Data Series ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && /* @__PURE__ */ a.createElement(ju, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ a.createElement(zn, null, (!e.series || e.series.length === 0) && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ a.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    At,
    {
      fieldName: "visualizationType",
      label: "Add Data Series",
      initial: "Select",
      onChange: (le) => {
        le.target.value !== "" && le.target.value !== "Select" && bn(le.target.value), le.target.value = "";
      },
      options: jt()
    }
  ), e.series && e.series.length !== 0 && /* @__PURE__ */ a.createElement(Fa.Series.Wrapper, { getColumns: jt }, /* @__PURE__ */ a.createElement("fieldset", null, /* @__PURE__ */ a.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ a.createElement(Sy, { onDragEnd: ({ source: le, destination: se }) => $t(le.index, se.index) }, /* @__PURE__ */ a.createElement(Ey, { droppableId: "filter_order" }, (le) => /* @__PURE__ */ a.createElement("ul", { ...le.droppableProps, className: "series-list", ref: le.innerRef }, /* @__PURE__ */ a.createElement(Fa.Series.List, { series: e.series, getItemStyle: ln, sortableItemStyles: en, chartsWithOptions: _e }), le.placeholder))))), e.series && e.series.length <= 1 && e.visualizationType === "Bar" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ a.createElement(At, { value: e.confidenceKeys.upper || "", section: "confidenceKeys", fieldName: "upper", label: "Upper", updateField: ze, initial: "Select", options: jt() }), /* @__PURE__ */ a.createElement(At, { value: e.confidenceKeys.lower || "", section: "confidenceKeys", fieldName: "lower", label: "Lower", updateField: ze, initial: "Select", options: jt() })), Dt() && e.series && e.series.length === 1 && /* @__PURE__ */ a.createElement(At, { fieldName: "visualizationType", label: "Rank by Value", initial: "Select", onChange: (le) => Mn(le.target.value), options: ["asc", "desc"] }), Ge() && /* @__PURE__ */ a.createElement(Mw, { config: e, updateConfig: t, data: i }))), /* @__PURE__ */ a.createElement(Fa.BoxPlot, { name: "Measures" }), ht() && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ a.createElement(ju, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ a.createElement(zn, null, e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement(
    At,
    {
      value: e.yAxis.dataKey || "",
      section: "yAxis",
      fieldName: "dataKey",
      label: "Data Column",
      initial: "Select",
      required: !0,
      updateField: ze,
      options: jt(!1),
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Select the source data to be visually represented.")))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.label, section: "yAxis", fieldName: "label", label: "Label ", updateField: ze }), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ a.createElement(ut, { value: e.isLegendValue, fieldName: "isLegendValue", label: "Use Legend Value in Hover", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.numTicks, placeholder: "Auto", type: "number", section: "yAxis", fieldName: "numTicks", label: "Number of ticks", className: "number-narrow", updateField: ze }), /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.yAxis.size,
      type: "number",
      section: "yAxis",
      fieldName: "size",
      label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
    }
  ), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.labelOffset, section: "yAxis", fieldName: "labelOffset", label: "Label offset", type: "number", className: "number-narrow", updateField: ze }), e.orientation === "horizontal" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a.createElement(ut, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: ze }), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.tickRotation || 0, type: "number", min: 0, section: "yAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: ze }), e.isResponsiveTicks && e.orientation === "horizontal" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), et() && /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.gridLines, section: "yAxis", fieldName: "gridLines", label: "Show Gridlines", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.enablePadding, section: "yAxis", fieldName: "enablePadding", label: "Add Padding to Value Axis Scale", updateField: ze }), e.yAxis.enablePadding && /* @__PURE__ */ a.createElement(Je, { type: "number", section: "yAxis", fieldName: "scalePadding", label: "Padding Percentage", className: "number-narrow", updateField: ze, value: e.yAxis.scalePadding }), e.visualizationSubType === "regular" && e.visualizationType !== "Forest Plot" && /* @__PURE__ */ a.createElement(ut, { value: e.useLogScale, fieldName: "useLogScale", label: "use logarithmic scale", updateField: ze })), /* @__PURE__ */ a.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.dataFormat.commas,
      section: "dataFormat",
      fieldName: "commas",
      label: "Add commas",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
    }
  ), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.dataFormat.abbreviated,
      section: "dataFormat",
      fieldName: "abbreviated",
      label: "Abbreviate Axis Values",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  ), /* @__PURE__ */ a.createElement(Je, { value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0, type: "number", section: "dataFormat", fieldName: "roundTo", label: "Round to decimal point", className: "number-narrow", updateField: ze, min: 0 }), /* @__PURE__ */ a.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.prefix,
      section: "dataFormat",
      fieldName: "prefix",
      label: "Prefix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.suffix,
      section: "dataFormat",
      fieldName: "suffix",
      label: "Suffix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), e.orientation === "horizontal" ? (
    // horizontal - x is vertical y is horizontal
    /* @__PURE__ */ a.createElement(a.Fragment, null, Ze() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: ze }), qe() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: ze }), Et() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: ze }), Ee() && /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.max, section: "xAxis", fieldName: "max", label: "max value", type: "number", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.maxMsg), ee() && /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.min, section: "xAxis", fieldName: "min", type: "number", label: "min value", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.target, section: "xAxis", fieldName: "target", type: "number", label: "Deviation point", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.targetLabel || "Target", section: "xAxis", fieldName: "targetLabel", type: "text", label: "Deviation point Label", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.showTargetLabel, section: "xAxis", fieldName: "showTargetLabel", label: "Show Deviation point label", updateField: ze })))
  ) : e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.hideTicks, section: "yAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "max", type: "number", label: "left axis max value", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.maxMsg), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "min", type: "number", label: "left axis min value", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.minMsg)), Q() && e.orientation !== "horizontal" && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, (x = (Xn = e.yAxis) == null ? void 0 : Xn.anchors) == null ? void 0 : x.map((le, se) => /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${se}` }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Fn, { className: "accordion__button accordion__button" }, "Anchor ", se + 1, /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe.splice(se, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Value"), /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[se].value ? e.yAxis.anchors[se].value : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe[se].value = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Color"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[se].color ? e.yAxis.anchors[se].color : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe[se].color = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ a.createElement(
    "select",
    {
      value: e.yAxis.anchors[se].lineStyle || "",
      onChange: (me) => {
        const Oe = [...e.yAxis.anchors];
        Oe[se].lineStyle = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    },
    /* @__PURE__ */ a.createElement("option", null, "Select"),
    R.map((me) => /* @__PURE__ */ a.createElement("option", { key: me.key }, me.value))
  )))))), /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (le) => {
        le.preventDefault();
        const se = [...e.yAxis.anchors];
        se.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: se
          }
        });
      }
    },
    "Add Anchor"
  )), Q() && e.orientation === "horizontal" && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, (I = (L = e.xAxis) == null ? void 0 : L.anchors) == null ? void 0 : I.map((le, se) => /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart", key: `xaxis-anchors-${se}` }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Fn, { className: "accordion__button accordion__button" }, "Anchor ", se + 1, /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe.splice(se, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Value"), /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[se].value ? e.xAxis.anchors[se].value : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe[se].value = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Color"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[se].color ? e.xAxis.anchors[se].color : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe[se].color = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ a.createElement(
    "select",
    {
      value: e.xAxis.anchors[se].lineStyle || "",
      onChange: (me) => {
        const Oe = [...e.xAxis.anchors];
        Oe[se].lineStyle = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    },
    /* @__PURE__ */ a.createElement("option", null, "Select"),
    R.map((me) => /* @__PURE__ */ a.createElement("option", { key: me.key }, me.value))
  )))))), /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (le) => {
        le.preventDefault();
        const se = [...e.xAxis.anchors];
        se.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: se
          }
        });
      }
    },
    "Add Anchor"
  )))), zt && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Right Value Axis")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.rightLabel, section: "yAxis", fieldName: "rightLabel", label: "Label", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.rightNumTicks, placeholder: "Auto", type: "number", section: "yAxis", fieldName: "rightNumTicks", label: "Number of ticks", className: "number-narrow", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.rightAxisSize, type: "number", section: "yAxis", fieldName: "rightAxisSize", label: "Size (Width)", className: "number-narrow", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.rightLabelOffsetSize, type: "number", section: "yAxis", fieldName: "rightLabelOffsetSize", label: "Label Offset", className: "number-narrow", updateField: ze }), /* @__PURE__ */ a.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ a.createElement(ut, { value: e.dataFormat.rightCommas, section: "dataFormat", fieldName: "rightCommas", label: "Add commas", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.dataFormat.rightRoundTo, type: "number", section: "dataFormat", fieldName: "rightRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: ze, min: 0 }), /* @__PURE__ */ a.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.rightPrefix,
      section: "dataFormat",
      fieldName: "rightPrefix",
      label: "Prefix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.rightSuffix,
      section: "dataFormat",
      fieldName: "rightSuffix",
      label: "Suffix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.rightHideAxis, section: "yAxis", fieldName: "rightHideAxis", label: "Hide Axis", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.rightHideLabel, section: "yAxis", fieldName: "rightHideLabel", label: "Hide Tick Labels", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.rightHideTicks, section: "yAxis", fieldName: "rightHideTicks", label: "Hide Ticks", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "rightMax", type: "number", label: "right axis max value", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.rightMaxMessage), /* @__PURE__ */ a.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "rightMin", type: "number", label: "right axis min value", placeholder: "Auto", updateField: ze }), /* @__PURE__ */ a.createElement("span", { style: { color: "red", display: "block" } }, En.minMsg))), ye() && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ a.createElement(ju, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ a.createElement(zn, null, e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement(a.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ a.createElement(
    "select",
    {
      value: e.xAxis.type,
      onChange: (le) => t({
        ...e,
        xAxis: {
          ...e.xAxis,
          type: le.target.value
        }
      })
    },
    /* @__PURE__ */ a.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
    /* @__PURE__ */ a.createElement("option", { value: "date" }, "Date (Linear Scale)"),
    /* @__PURE__ */ a.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
    e.visualizationType === "Scatter Plot" && /* @__PURE__ */ a.createElement("option", { value: "continuous" }, "Continuous")
  )), /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.manual, section: "xAxis", fieldName: "manual", label: "Manual Ticks", updateField: ze }), $e() && /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.xAxis.padding,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "padding",
      label: "Padding (Percent)",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
    }
  )), /* @__PURE__ */ a.createElement(
    At,
    {
      value: e.xAxis.dataKey || it() || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Data Key",
      initial: "Select",
      required: !0,
      updateField: ze,
      options: jt(!1),
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  )), e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement(
    At,
    {
      value: e.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Segment Labels",
      initial: "Select",
      required: !0,
      updateField: ze,
      options: jt(!1),
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.label, section: "xAxis", fieldName: "label", label: "Label", updateField: ze }), e.xAxis.type === "continuous" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.bottomPrefix,
      section: "dataFormat",
      fieldName: "bottomPrefix",
      label: "Prefix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.dataFormat.bottomSuffix,
      section: "dataFormat",
      fieldName: "bottomSuffix",
      label: "Suffix",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  ), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.dataFormat.bottomAbbreviated,
      section: "dataFormat",
      fieldName: "bottomAbbreviated",
      label: "Abbreviate Axis Values",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  )), Pn(e.xAxis) && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ a.createElement("a", { href: "https://github.com/d3/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ a.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed. "))),
      value: e.xAxis.dateParseFormat,
      section: "xAxis",
      fieldName: "dateParseFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "Date Parse Format",
      updateField: ze
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, " Adjusts the date display format on the axis for clear, visual date representation."))),
      value: e.xAxis.dateDisplayFormat,
      section: "xAxis",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "AXIS DATE DISPLAY FORMAT",
      updateField: ze
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.table.dateDisplayFormat,
      section: "table",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "DATA TABLE DATE DISPLAY FORMAT",
      updateField: ze
    }
  ), /* @__PURE__ */ a.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.tooltips.dateDisplayFormat,
      section: "tooltips",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "HOVER DATE DISPLAY FORMAT",
      updateField: ze
    }
  )), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: e.xAxis.type === "date" ? "Limit by start and/or end dates" : "Exclude one or more values",
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis. "))),
      updateField: ze
    }
  ), Se && /* @__PURE__ */ a.createElement(
    ut,
    {
      value: (Y = e.brush) == null ? void 0 : Y.active,
      section: "brush",
      fieldName: "active",
      label: "Brush Slider ",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset. ")))
    }
  ), e.exclusions.active && /* @__PURE__ */ a.createElement(a.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ a.createElement(a.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("fieldset", null, /* @__PURE__ */ a.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ a.createElement(tn, null)), /* @__PURE__ */ a.createElement(
    At,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (le) => {
        le.target.value !== "" && le.target.value !== "Select" && mn(le.target.value), le.target.value = "";
      },
      options: Ft(e.xAxis.dataKey, !0)
    }
  )), e.xAxis.type === "date" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateStart", label: "Start Date", updateField: ze, value: e.exclusions.dateStart || "" }), /* @__PURE__ */ a.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateEnd", label: "End Date", updateField: ze, value: e.exclusions.dateEnd || "" }))), ne() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.xAxis.manualStep,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "manualStep",
      label: "Step count",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
    }
  ), /* @__PURE__ */ a.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("button", { onClick: () => yn(!Bt), className: "edit-label" }, "Step Count: viewport overrides ", /* @__PURE__ */ a.createElement("span", { style: { transform: `rotate(${Bt ? "90deg" : "0deg"})` } }, ">"))), Bt && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, Object.keys(Oh).map((le) => /* @__PURE__ */ a.createElement(
    Je,
    {
      key: `viewport-step-count-input-${le}`,
      value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[le] : void 0,
      placeholder: "Auto",
      type: "number",
      label: le,
      className: "number-narrow",
      updateField: (se, me, Oe, bt) => sn("viewportStepCount", le, bt)
    }
  ))))), ne() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.xAxis.numTicks,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "numTicks",
      label: "Number of ticks",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
    }
  ), /* @__PURE__ */ a.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("button", { onClick: () => yn(!Bt), className: "edit-label" }, "Number of ticks: viewport overrides ", /* @__PURE__ */ a.createElement("span", { style: { transform: `rotate(${Bt ? "90deg" : "0deg"})` } }, ">"))), Bt && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, Object.keys(Oh).map((le) => /* @__PURE__ */ a.createElement(
    Je,
    {
      key: `viewport-num-ticks-input-${le}`,
      value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[le] : void 0,
      placeholder: "Auto",
      type: "number",
      label: le,
      className: "number-narrow",
      updateField: (se, me, Oe, bt) => sn("viewportNumTicks", le, bt)
    }
  ))))), Vt() && /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.size, type: "number", min: 0, section: "xAxis", fieldName: "size", label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)", className: "number-narrow", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.labelOffset, section: "xAxis", fieldName: "labelOffset", label: "Label offset", type: "number", className: "number-narrow", updateField: ze }), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(ut, { value: e.dataFormat.bottomCommas, section: "dataFormat", fieldName: "bottomCommas", label: "Add commas", updateField: ze }), /* @__PURE__ */ a.createElement(Je, { value: e.dataFormat.bottomRoundTo, type: "number", section: "dataFormat", fieldName: "bottomRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: ze, min: 0 })), qt() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a.createElement(ut, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: ze }), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Ae() && /* @__PURE__ */ a.createElement(Je, { value: e.xAxis.tickRotation, type: "number", min: 0, section: "xAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: ze }), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), e.orientation === "horizontal" ? /* @__PURE__ */ a.createElement(a.Fragment, null, we() && /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: ze }), He() && /* @__PURE__ */ a.createElement(ut, { value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: ze })) : /* @__PURE__ */ a.createElement(a.Fragment, null, we() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: ze }), He() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: ze }), fe() && /* @__PURE__ */ a.createElement(ut, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: ze })), ((Te = e.series) == null ? void 0 : Te.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && rt.map((le, se) => /* @__PURE__ */ a.createElement("fieldset", null, /* @__PURE__ */ a.createElement("div", { className: "edit-block", key: `highlighted-bar-${se}` }, /* @__PURE__ */ a.createElement("button", { className: "remove-column", onClick: (me) => Kt(me, se) }, "Remove"), /* @__PURE__ */ a.createElement("p", null, "Highlighted Bar ", se + 1), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ a.createElement("select", { value: e.highlightedBarValues[se].value, onChange: (me) => Mt(me, se) }, /* @__PURE__ */ a.createElement("option", { value: "" }, "- Select Value -"), xt && [...new Set(xt)].sort().map((me) => /* @__PURE__ */ a.createElement("option", { key: `special-class-value-option-${se}-${me}` }, me)))), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ a.createElement("input", { type: "text", value: e.highlightedBarValues[se].color ? e.highlightedBarValues[se].color : "", onChange: (me) => It(me, se) })), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ a.createElement("input", { max: "5", min: "0", type: "number", value: e.highlightedBarValues[se].borderWidth ? e.highlightedBarValues[se].borderWidth : "", onChange: (me) => mt(me, se) })), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ a.createElement("input", { type: "text", value: e.highlightedBarValues[se].legendLabel ? e.highlightedBarValues[se].legendLabel : "", onChange: (me) => _t(me, se) }))))), /* @__PURE__ */ a.createElement("button", { className: "btn full-width", onClick: (le) => Qe(le) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: "Exclude one or more values",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
    }
  ), e.exclusions.active && /* @__PURE__ */ a.createElement(a.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement("fieldset", null, /* @__PURE__ */ a.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ a.createElement(tn, null)), /* @__PURE__ */ a.createElement(
    At,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (le) => {
        le.target.value !== "" && le.target.value !== "Select" && mn(le.target.value), le.target.value = "";
      },
      options: Ft(e.xAxis.dataKey, !0)
    }
  ))), Q() && e.orientation !== "horizontal" && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, (De = (xe = e.xAxis) == null ? void 0 : xe.anchors) == null ? void 0 : De.map((le, se) => /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${se}` }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Fn, { className: "accordion__button accordion__button" }, "Anchor ", se + 1, /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe.splice(se, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Value"), /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[se].value ? e.xAxis.anchors[se].value : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe[se].value = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Color"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[se].color ? e.xAxis.anchors[se].color : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.xAxis.anchors];
        Oe[se].color = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ a.createElement(
    "select",
    {
      value: e.xAxis.anchors[se].lineStyle || "",
      onChange: (me) => {
        const Oe = [...e.xAxis.anchors];
        Oe[se].lineStyle = me.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Oe
          }
        });
      }
    },
    /* @__PURE__ */ a.createElement("option", null, "Select"),
    R.map((me) => /* @__PURE__ */ a.createElement("option", { key: me.key }, me.value))
  )))))), /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (le) => {
        le.preventDefault();
        const se = [...e.xAxis.anchors];
        se.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: se
          }
        });
      }
    },
    "Add Anchor"
  )), Q() && e.orientation === "horizontal" && /* @__PURE__ */ a.createElement("div", { className: "edit-block" }, /* @__PURE__ */ a.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ a.createElement(_i, { allowZeroExpanded: !0 }, (at = (je = e.yAxis) == null ? void 0 : je.anchors) == null ? void 0 : at.map((le, se) => /* @__PURE__ */ a.createElement(_n, { className: "series-item series-item--chart", key: `accordion-yaxis-anchors-${se}` }, /* @__PURE__ */ a.createElement(Nn, { className: "series-item__title" }, /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Fn, { className: "accordion__button accordion__button" }, "Anchor ", se + 1, /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe.splice(se, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Value"), /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[se].value ? e.yAxis.anchors[se].value : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe[se].value = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", null, "Anchor Color"), /* @__PURE__ */ a.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[se].color ? e.yAxis.anchors[se].color : "",
      onChange: (me) => {
        me.preventDefault();
        const Oe = [...e.yAxis.anchors];
        Oe[se].color = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    }
  )), /* @__PURE__ */ a.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ a.createElement(
    "select",
    {
      value: e.yAxis.anchors[se].lineStyle || "",
      onChange: (me) => {
        const Oe = [...e.yAxis.anchors];
        Oe[se].lineStyle = me.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Oe
          }
        });
      }
    },
    /* @__PURE__ */ a.createElement("option", null, "Select"),
    R.map((me) => /* @__PURE__ */ a.createElement("option", { key: me.key }, me.value))
  )))))), /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (le) => {
        le.preventDefault();
        const se = [...e.yAxis.anchors];
        se.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: se
          }
        });
      }
    },
    "Add Anchor"
  )))), /* @__PURE__ */ a.createElement(Fa.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Columns")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(Vy, { config: e, updateField: ze, deleteColumn: Ve }), " ")), ge() && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Legend")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(ut, { value: e.legend.reverseLabelOrder, section: "legend", fieldName: "reverseLabelOrder", label: "Reverse Labels", updateField: ze }), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: !!e.legend.hide,
      section: "legend",
      fieldName: "hide",
      label: "Hide Legend",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
    }
  ), /* @__PURE__ */ a.createElement(
    ut,
    {
      value: e.legend.hideSuppressedLabels,
      section: "legend",
      fieldName: "hideSuppressedLabels",
      label: "Hide Suppressed Labels",
      updateField: ze,
      tooltip: /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
    }
  ), e.visualizationType === "Line" && /* @__PURE__ */ a.createElement(ut, { value: e.legend.lineMode, section: "legend", fieldName: "lineMode", label: "Show Lined Style Legend", updateField: ze }), e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1 && /* @__PURE__ */ a.createElement(At, { value: e.legend.colorCode, section: "legend", fieldName: "colorCode", label: "Color code by category", initial: "Select", updateField: ze, options: wn(i) }), /* @__PURE__ */ a.createElement(At, { value: e.legend.behavior, section: "legend", fieldName: "behavior", label: "Legend Behavior (When clicked)", updateField: (...[le, , se, me]) => Xt(le, se, me), options: ["highlight", "isolate"] }), ve() && /* @__PURE__ */ a.createElement(ut, { value: e.legend.axisAlign, fieldName: "axisAlign", section: "legend", label: "Align to Axis on Isolate", updateField: ze }), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ a.createElement(ut, { value: e.legend.highlightOnHover, section: "legend", fieldName: "highlightOnHover", label: "HIGHLIGHT DATA SERIES ON HOVER", updateField: ze }), re && e.legend.behavior === "isolate" && !Rt && /* @__PURE__ */ a.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ a.createElement("label", null, /* @__PURE__ */ a.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ a.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ a.createElement(be.Target, null, /* @__PURE__ */ a.createElement(ft, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ a.createElement(be.Content, null, /* @__PURE__ */ a.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((le, se) => /* @__PURE__ */ a.createElement("fieldset", { className: "edit-block", key: `${le}-${se}` }, /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (me) => {
        me.preventDefault();
        const Oe = [...e.legend.seriesHighlight];
        Oe.splice(se, 1), ze("legend", null, "seriesHighlight", Oe), Oe.length || _();
      }
    },
    "Remove"
  ), /* @__PURE__ */ a.createElement(
    At,
    {
      value: e.legend.seriesHighlight[se],
      fieldName: "seriesHighlight",
      label: "Isolate Value",
      onChange: (me) => {
        const Oe = [...e.legend.seriesHighlight];
        Oe.includes(me.target.value) || (Oe[se] = me.target.value, Yt([...Oe]));
      },
      options: wt()
    }
  ))), /* @__PURE__ */ a.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (le) => {
        le.preventDefault();
        const se = wt(), me = [...e.legend.seriesHighlight];
        if (me.length < se.length) {
          const [bt] = se.filter((vn) => !me.includes(vn));
          me.push(bt), Yt([...me]);
        }
      }
    },
    "Add Isolate Value"
  )), /* @__PURE__ */ a.createElement(Je, { value: e.legend.label, section: "legend", fieldName: "label", label: "Title", updateField: ze }), /* @__PURE__ */ a.createElement(At, { value: (yt = e.legend) == null ? void 0 : yt.position, section: "legend", fieldName: "position", label: "Position", updateField: ze, options: ["right", "left", "bottom"] }), e.legend.position === "bottom" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(ut, { value: e.legend.singleRow, section: "legend", fieldName: "singleRow", label: "Single Row Legend", updateField: ze }), /* @__PURE__ */ a.createElement(ut, { value: e.legend.verticalSorted, section: "legend", fieldName: "verticalSorted", label: "Vertical sorted Legend", updateField: ze })), /* @__PURE__ */ a.createElement(Je, { type: "textarea", value: e.legend.description, updateField: ze, section: "legend", fieldName: "description", label: "Legend Description" }))), Ke() && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Filters")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(jy, { config: e, updateField: ze, rawData: C }))), /* @__PURE__ */ a.createElement(Fa.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ a.createElement(_n, null, /* @__PURE__ */ a.createElement(Nn, null, /* @__PURE__ */ a.createElement(Fn, null, "Data Table")), /* @__PURE__ */ a.createElement(zn, null, /* @__PURE__ */ a.createElement(Uy, { config: e, columns: Object.keys(i[0] || {}), updateField: ze, isDashboard: m, isLoadedFromUrl: dt }), " "))), e.type !== "Spark Line" && /* @__PURE__ */ a.createElement(ky, { loadConfig: t, state: e, convertStateToConfig: Tn }))));
}, ym = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, Nw = (e) => {
  e.sort((h, m) => h - m);
  const t = Math.floor(e.length / 2), n = e.length % 2 === 0, i = n ? e.slice(0, t) : e.slice(0, t + 1), r = n ? e.slice(t) : e.slice(t + 1), o = Math.floor(i.length / 2), d = n ? (i[o - 1] + i[o]) / 2 : i[o], u = Math.floor(r.length / 2), s = n ? (r[u - 1] + r[u]) / 2 : r[u];
  return { q1: d, q3: s };
}, Fw = (e, t) => e.toString().localeCompare(t.toString(), "en", { numeric: !0 }), zw = (e, t) => t.toString().localeCompare(e.toString(), "en", { numeric: !0 }), fa = (e, t) => {
  let n = [];
  return t.forEach((i) => {
    let r = !0;
    e.filter((o) => o.type !== "url").forEach((o) => {
      i[o.columnName] != o.active && (r = !1);
    }), r && n.push(i);
  }), n;
}, Bw = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], vm = (e = "#000000", t = !1) => {
  let n = Ss(e), i = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, i, n.darken(0.3).hex()];
};
const xm = (e) => {
  const t = /(?:\.([^.]+))$/, n = /[?&]wt=(csv|json)(?:&|$)/, i = new URL(e, window.location.origin), r = i.pathname, o = i.search, d = t.exec(r);
  if (d && d[1])
    return d[1];
  const u = n.exec(o);
  return u && u[1] ? u[1] : "";
};
function mT({ configUrl: e, config: t, isEditor: n = !1, isDebug: i = !1, isDashboard: r = !1, setConfig: o, setEditing: d, hostname: u, link: s, setSharedFilter: h, setSharedFilterValue: m, dashboardConfig: y }) {
  var pt, Tn, tn, $t, Sn, En, Dn, Ln, Me, dt, it;
  const v = new Gy(), [w, E] = ce.useState(!0), [R, C] = ce.useState(null), [g, _] = ce.useState({}), [P, M] = ce.useState(g.data || []), [N, T] = ce.useState(void 0), [U, V] = ce.useState(void 0), [G, ue] = ce.useState(t && ((Tn = (pt = t == null ? void 0 : t.legend) == null ? void 0 : pt.seriesHighlight) != null && Tn.length) ? [...(tn = t == null ? void 0 : t.legend) == null ? void 0 : tn.seriesHighlight] : []), [Z, $] = ce.useState("lg"), [H, j] = ce.useState([]), [F, X] = ce.useState(), [Q, ae] = ce.useState(), [te, re] = ce.useState(!1), [ie, ge] = ce.useState([]), [ve] = ce.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Se, ye] = ce.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  });
  ce.useRef(/* @__PURE__ */ new Map()), ce.useRef();
  const ee = ce.useRef(null);
  i && console.log("Chart config, isEditor", g, n);
  let { legend: Ee, title: He, description: we, visualizationType: fe } = g;
  n && (!He || He === "") && (He = "Chart Title"), g.table && (!(($t = g.table) != null && $t.label) || ((Sn = g.table) == null ? void 0 : Sn.label) === "") && (g.table.label = "Data Table");
  const { barBorderClass: Ae, lineDatapointClass: ne, contentClasses: $e, sparkLineStyles: Le } = Ky(g), Ke = ce.useId(), Ge = (En = g.legend) != null && En.hide ? g != null && g.title ? `dataTableSection__${g.title.replace(/\s/g, "")}` : "dataTableSection" : Ke, et = () => _c(g.visualizationType, fa, g.allowLineToBarGraph), Ze = async () => {
    var W;
    if (g.dataUrl) {
      const _e = new URL(g.runtimeDataUrl || g.dataUrl, window.location.origin);
      let Xe = Object.fromEntries(new URLSearchParams(_e.search)), Ve = !1;
      if ((W = g.filters) == null || W.forEach((xt) => {
        xt.type === "url" && Xe[xt.queryParameter] !== decodeURIComponent(xt.active) && (Xe[xt.queryParameter] = xt.active, Ve = !0);
      }), (!g.formattedData || g.formattedData.urlFiltered) && !Ve)
        return;
      let ot = `${_e.origin}${_e.pathname}${Object.keys(Xe).map((xt, Mt) => {
        let Qe = Mt === 0 ? "?" : "&";
        return Qe += xt + "=", Qe += Xe[xt], Qe;
      }).join("")}`, rt = [];
      try {
        const xt = xm(_e.href);
        xt === "csv" || Mh(ot) ? rt = await fetch(ot).then((Mt) => Mt.text()).then((Mt) => Fh.parse(Mt, {
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0
        }).data) : xt === "json" || _h(ot) ? rt = await fetch(ot).then((Mt) => Mt.json()) : rt = [];
      } catch {
        console.error(`Cannot parse URL: ${ot}`), rt = [];
      }
      g.dataDescription && (rt = v.autoStandardize(rt), rt = v.developerStandardize(rt, g.dataDescription)), Object.assign(rt, { urlFiltered: !0 }), qe({ ...g, runtimeDataUrl: ot, data: rt, formattedData: rt }), rt && (M(rt), T(rt), V(fa(g.filters, rt)));
    }
  }, Et = async () => {
    let W = t || await (await fetch(e)).json(), _e = W.data || [];
    const Xe = W.filters ? W.filters.filter((rt) => rt.type === "url").length > 0 : !1;
    if (W.dataUrl && !Xe)
      try {
        const rt = xm(W.dataUrl);
        (rt === "csv" || Mh(W.dataUrl)) && (_e = await fetch(W.dataUrl + `?v=${qh()}`).then((xt) => xt.text()).then((xt) => (xt = xt.replace(/(".*?")|,/g, (...Qe) => Qe[1] || "|"), xt = xt.replace(/["]+/g, ""), Fh.parse(xt, {
          //quotes: "true",  // dont need these
          //quoteChar: "'",  // has no effect that I can tell
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0,
          delimiter: "|"
          // we are using pipe symbol as delimiter so setting this explicitly for Papa.parse
        }).data))), (rt === "json" || _h(W.dataUrl)) && (_e = await fetch(W.dataUrl + `?v=${qh()}`).then((xt) => xt.json()));
      } catch {
        console.error(`COVE: Cannot parse URL: ${W.dataUrl}`), _e = [];
      }
    W.dataDescription && (_e = v.autoStandardize(_e), _e = v.developerStandardize(_e, W.dataDescription)), _e && (M(_e), T(_e)), W !== void 0 && W.table !== void 0 && (!W.table || !W.table.showVertical) && (W.table = W.table || {}, W.table.showVertical = !1);
    let Ve = { ...ef, ...W };
    Ve.filters && Ve.filters.forEach((rt, xt) => {
      const Mt = wy(rt);
      Mt && (Ve.filters[xt].active = Mt);
    }), Ve.visualizationType === "Box Plot" && (Ve.legend.hide = !0), Ve.table.show === void 0 && (Ve.table.show = !r), Ve.series.forEach((rt) => {
      (rt.tooltip === void 0 || rt.tooltip === null) && (rt.tooltip = !0), rt.axis || (rt.axis = "Left");
    }), !Ve.data && _e && (Ve.data = _e);
    const ot = { ...await Ty(Ve) };
    qe(ot, _e);
  }, qe = (W, _e) => {
    var rt, xt, Mt;
    let Xe = _e || P;
    Object.keys(ef).forEach((Qe) => {
      W[Qe] && typeof W[Qe] == "object" && !Array.isArray(W[Qe]) && (W[Qe] = { ...ef[Qe], ...W[Qe] });
    });
    let Ve = [];
    if (W.exclusions && W.exclusions.active)
      if (W.xAxis.type === "categorical" && ((rt = W.exclusions.keys) == null ? void 0 : rt.length) > 0)
        Ve = Xe.filter((Qe) => !W.exclusions.keys.includes(Qe[W.xAxis.dataKey]));
      else if (Pn(W.xAxis) && (W.exclusions.dateStart || W.exclusions.dateEnd) && W.xAxis.dateParseFormat) {
        const Qe = (Rt) => new Date(Rt).getTime();
        let Kt = Qe(W.exclusions.dateStart), It = Qe(W.exclusions.dateEnd) + 86399999, _t = typeof Kt !== void 0 && isNaN(Kt) === !1, mt = typeof It !== void 0 && isNaN(It) === !1;
        _t && mt ? Ve = Xe.filter((Rt) => Qe(Rt[W.xAxis.dataKey]) >= Kt && Qe(Rt[W.xAxis.dataKey]) <= It) : _t ? Ve = Xe.filter((Rt) => Qe(Rt[W.xAxis.dataKey]) >= Kt) : mt && (Ve = Xe.filter((Rt) => Qe(Rt[W.xAxis.dataKey]) <= It));
      } else
        Ve = _e || P;
    else
      Ve = _e || P;
    T(Ve);
    let ot = [];
    if (W.filters && (W.filters.forEach((Qe, Kt) => {
      let It = [];
      It = Qe.orderedValues || Be(Qe.columnName, Ve).sort(Qe.order === "desc" ? zw : Fw), W.filters[Kt].values = It, W.filters[Kt].active = W.filters[Kt].active || It[0], W.filters[Kt].filterStyle = W.filters[Kt].filterStyle ? W.filters[Kt].filterStyle : "dropdown";
    }), ot = fa(W.filters, Ve), V(ot)), W.xAxis.type === "date-time" && g.orientation === "horizontal" && (W.xAxis.type = "date"), W.runtime = {}, W.runtime.seriesLabels = {}, W.runtime.seriesLabelsAll = [], W.runtime.originalXAxis = W.xAxis, W.visualizationType === "Pie" ? (W.runtime.seriesKeys = (_e || Xe).map((Qe) => Qe[W.xAxis.dataKey]), W.runtime.seriesLabelsAll = W.runtime.seriesKeys) : W.runtime.seriesKeys = W.series ? W.series.map((Qe) => (W.runtime.seriesLabels[Qe.dataKey] = Qe.name || Qe.label || Qe.dataKey, W.runtime.seriesLabelsAll.push(Qe.name || Qe.dataKey), Qe.dataKey)) : [], W.visualizationType === "Box Plot" && W.series) {
      let Qe = Ve ? Ve.map((wt) => wt[W.xAxis.dataKey]) : Xe.map((wt) => wt[W.xAxis.dataKey]), Kt = Ve ? Ve.map((wt) => {
        var Yt;
        return Number(wt[(Yt = W == null ? void 0 : W.series[0]) == null ? void 0 : Yt.dataKey]);
      }) : Xe.map((wt) => {
        var Yt;
        return Number(wt[(Yt = W == null ? void 0 : W.series[0]) == null ? void 0 : Yt.dataKey]);
      });
      const _t = function(wt) {
        return wt.filter(function(Yt, Xt, sn) {
          return sn.indexOf(Yt) === Xt;
        });
      }(Qe);
      let mt = [];
      const Rt = [];
      if (!_t)
        return;
      _t.forEach((wt) => {
        try {
          if (!wt)
            throw new Nt("No groups resolved in box plots");
          let Yt = Ve ? Ve.filter((x) => x[W.xAxis.dataKey] === wt) : Xe.filter((x) => x[W.xAxis.dataKey] === wt), Xt = Yt.map((x) => {
            var L;
            return Number(x[(L = W == null ? void 0 : W.series[0]) == null ? void 0 : L.dataKey]);
          }), sn = Xt.sort((x, L) => x - L);
          const fn = Nw(sn);
          if (!Yt)
            throw new Nt("boxplots dont have data yet");
          if (!Rt)
            throw new Nt("boxplots dont have plots yet");
          W.boxplot.firstQuartilePercentage === "" && (W.boxplot.firstQuartilePercentage = 0), W.boxplot.thirdQuartilePercentage === "" && (W.boxplot.thirdQuartilePercentage = 0);
          const nn = fn.q1, Qt = fn.q3, Cn = Qt - nn, un = nn - (Qt - nn) * 1.5, An = Qt + (Qt - nn) * 1.5, In = sn.filter((x) => x < un || x > An);
          let Yn = Xt;
          Yn = Yn.filter((x) => !In.includes(x));
          const Zn = cs(Xt) || 0, Xn = us([Zn, nn - 1.5 * Cn]);
          Rt.push({
            columnCategory: wt,
            columnMax: cs([us(Xt), nn + 1.5 * Cn]),
            columnThirdQuartile: Number(Qt).toFixed(W.dataFormat.roundTo),
            columnMedian: Number(rv(Xt)).toFixed(W.dataFormat.roundTo),
            columnFirstQuartile: nn.toFixed(W.dataFormat.roundTo),
            columnMin: Xn,
            columnTotal: Xt.reduce((x, L) => x + L, 0),
            columnSd: Number(ev(Xt)).toFixed(W.dataFormat.roundTo),
            columnMean: Number(nv(Xt)).toFixed(W.dataFormat.roundTo),
            columnIqr: Number(Cn).toFixed(W.dataFormat.roundTo),
            columnLowerBounds: Xn,
            columnUpperBounds: cs([us(sn), nn + 1.5 * Cn]),
            columnOutliers: In,
            values: Xt,
            nonOutlierValues: Yn
          });
        } catch (Yt) {
          console.error("COVE: ", Yt.message);
        }
      }), mt = JSON.parse(JSON.stringify(Rt)), mt.map((wt) => (wt.columnIqr = void 0, wt.nonOutlierValues = void 0, wt.columnLowerBounds = void 0, wt.columnUpperBounds = void 0, null)), W.boxplot.allValues = Kt, W.boxplot.categories = _t, W.boxplot.plots = Rt, W.boxplot.tableData = mt;
    }
    W.visualizationType === "Combo" && W.series && (W.runtime.barSeriesKeys = [], W.runtime.lineSeriesKeys = [], W.runtime.areaSeriesKeys = [], W.runtime.forecastingSeriesKeys = [], W.series.forEach((Qe) => {
      Qe.type === "Area Chart" && W.runtime.areaSeriesKeys.push(Qe), Qe.type === "Forecasting" && W.runtime.forecastingSeriesKeys.push(Qe), (Qe.type === "Bar" || Qe.type === "Combo") && W.runtime.barSeriesKeys.push(Qe.dataKey), (Qe.type === "Line" || Qe.type === "dashed-sm" || Qe.type === "dashed-md" || Qe.type === "dashed-lg") && W.runtime.lineSeriesKeys.push(Qe.dataKey), Qe.type === "Combo" && (Qe.type = "Bar");
    })), W.visualizationType === "Forecasting" && W.series && (W.runtime.forecastingSeriesKeys = [], W.series.forEach((Qe) => {
      Qe.type === "Forecasting" && W.runtime.forecastingSeriesKeys.push(Qe);
    })), W.visualizationType === "Area Chart" && W.series && (W.runtime.areaSeriesKeys = [], W.series.forEach((Qe) => {
      W.runtime.areaSeriesKeys.push({ ...Qe, type: "Area Chart" });
    })), W.visualizationType === "Bar" && W.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(W.visualizationType) ? (W.runtime.xAxis = W.yAxis.yAxis ? W.yAxis.yAxis : W.yAxis, W.runtime.yAxis = W.xAxis.xAxis ? W.xAxis.xAxis : W.xAxis, W.runtime.horizontal = !1, W.orientation = "horizontal") : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(W.visualizationType) && !et() ? (W.runtime.xAxis = W.xAxis, W.runtime.yAxis = W.yAxis, W.runtime.horizontal = !1, W.orientation = "vertical") : (W.runtime.xAxis = W.xAxis, W.runtime.yAxis = W.yAxis, W.runtime.horizontal = !1), W.runtime.uniqueId = Date.now(), W.runtime.editorErrorMessage = W.visualizationType === "Pie" && !W.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", W.runtime.editorErrorMessage = W.visualizationType === "Sankey" && !W.description ? "SUBTEXT/CITATION field is empty: A description of the Sankey Diagram data must be inputted." : "", (xt = W.legend.seriesHighlight) != null && xt.length && ue((Mt = W.legend) == null ? void 0 : Mt.seriesHighlight), _(W);
  }, Be = (W, _e = this.state.data) => {
    const Xe = [];
    return _e.forEach((Ve) => {
      const ot = Ve[W];
      ot && Xe.includes(ot) === !1 && Xe.push(ot);
    }), Xe;
  }, Ie = (W, _e) => {
    let Xe = g.visualizationType === "Bar" && g.visualizationSubType === "horizontal" ? g.xAxis.dataKey : g.yAxis.sortKey, Ve = parseFloat(W[Xe]), ot = parseFloat(_e[Xe]);
    return Ve < ot ? g.sortData === "ascending" ? 1 : -1 : Ve > ot ? g.sortData === "ascending" ? -1 : 1 : 0;
  }, Fe = new vy((W) => {
    for (let _e of W) {
      let { width: Xe, height: Ve } = _e.contentRect, ot = xy(Xe), rt = 32, xt = 350;
      $(ot), n && (Xe = Xe - xt), _e.target.dataset.lollipop === "true" && (Xe = Xe - 2.5), Xe = Xe - rt, j([Xe, Ve]);
    }
  }), lt = ce.useCallback((W) => {
    W !== null && Fe.observe(W), ae(W);
  }, []);
  function Ue(W) {
    return Object.keys(W).length === 0;
  }
  ce.useEffect(() => {
    Et();
  }, []), ce.useEffect(() => {
    Ze();
  }, [JSON.stringify(g.filters)]), ce.useEffect(() => {
    Q && !Ue(g) && !te && (Yy("cove_loaded", { config: g }), re(!0));
  }, [Q, g]), ce.useEffect(() => {
    const W = (_e) => {
      let Xe = [];
      Xe.push(_e.detail), X(Xe);
    };
    return Xy("cove_filterData", (_e) => W(_e)), () => {
      qy("cove_filterData", W);
    };
  }, [g]), ce.useEffect(() => {
    if (F && F[0] && !F[0].hasOwnProperty("active")) {
      let _e = { ...g };
      delete _e.filters, _(_e), V(fa(F, N));
    }
    if (F && F.length > 0 && F.length > 0 && F[0].hasOwnProperty("active")) {
      let W = { ...g, filters: F };
      _(W), V(fa(F, N));
    }
  }, [F]), t && ce.useEffect(() => {
    Et();
  }, [t.data]), ce.useEffect(() => {
    var W;
    if (P && g.xAxis && ((W = g.runtime) != null && W.seriesKeys)) {
      const _e = ["Paired Bar", "Deviation Bar"].includes(g.visualizationType) ? g.twoColor.palette : g.palette, Xe = { ...dr, ...Uu };
      let Ve = g.customColors || Xe[_e], ot = g.runtime.seriesKeys.length, rt;
      for (; ot > Ve.length; )
        Ve = Ve.concat(Ve);
      Ve = Ve.slice(0, ot), rt = () => zm({
        domain: g.runtime.seriesLabelsAll,
        range: Ve,
        unknown: null
      }), C(rt), E(!1);
    }
    g && P && g.sortData && P.sort(Ie);
  }, [g, P]);
  const ct = (W) => {
    if (G.length + 1 === g.runtime.seriesKeys.length && g.visualizationType !== "Forecasting") {
      ht();
      return;
    }
    const _e = [...G];
    let Xe = W.datum;
    g.runtime.seriesLabels && g.runtime.seriesKeys.forEach((Ve) => {
      g.runtime.seriesLabels[Ve] === W.datum && (Xe = Ve);
    }), _e.indexOf(Xe) !== -1 ? _e.splice(_e.indexOf(Xe), 1) : _e.push(Xe), ue(_e);
  }, ht = () => {
    try {
      const W = ee.current;
      if (!W)
        throw new Nt("No legend available to set previous focus on.");
      W.focus();
    } catch (W) {
      console.error("COVE:", W.message);
    }
    ue([]);
  }, gt = g.orientation === "horizontal" ? "yAxis" : "xAxis", Dt = (W, _e = !0) => {
    let Xe = og(g.runtime[gt].dateParseFormat)(W);
    return Xe || (_e && (g.runtime.editorErrorMessage = `Error parsing date "${W}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, qt = (W) => af(g.runtime[gt].dateDisplayFormat)(W), Vt = (W) => af(g.tooltips.dateDisplayFormat)(W);
  function kt(W, _e) {
    const Ve = document.createElement("canvas").getContext("2d");
    if (!Ve) {
      console.error("2d context not found");
      return;
    }
    return Ve.font = _e || getComputedStyle(document.body).font, Math.ceil(Ve.measureText(W).width);
  }
  const zt = (W, _e, Xe = !1, Ve, ot, rt) => {
    if (isNaN(W) || !W)
      return W;
    const xt = W < 0;
    (_e === void 0 || !_e) && (_e = "left"), xt && (W = Math.abs(W));
    let {
      dataFormat: { commas: Mt, abbreviated: Qe, roundTo: Kt, prefix: It, suffix: _t, rightRoundTo: mt, bottomRoundTo: Rt, rightPrefix: wt, rightSuffix: Yt, bottomPrefix: Xt, bottomSuffix: sn, bottomAbbreviated: fn }
    } = g;
    String(W).indexOf(",") !== -1 && (W = W.replaceAll(",", ""));
    let nn = W, Qt = {
      useGrouping: !!Mt
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let An;
      rt !== void 0 ? An = rt ? Number(rt) : 0 : An = Kt ? Number(Kt) : 0, Qt = {
        useGrouping: rt ? !0 : !!g.dataFormat.commas,
        minimumFractionDigits: An,
        maximumFractionDigits: An
      };
    }
    _e === "right" && (Qt = {
      useGrouping: !!g.dataFormat.rightCommas,
      minimumFractionDigits: mt ? Number(mt) : 0,
      maximumFractionDigits: mt ? Number(mt) : 0
    });
    const Cn = () => g.forestPlot.type === "Logarithmic" && !Rt ? 2 : Number(Rt) ? Number(Rt) : 0;
    if (_e === "bottom" && (Qt = {
      useGrouping: !!g.dataFormat.bottomCommas,
      minimumFractionDigits: Cn(),
      maximumFractionDigits: Cn()
    }), W = Xh(W), isNaN(W))
      return g.runtime.editorErrorMessage = `Unable to parse number from data ${nn}. Try reviewing your data and selections in the Data Series section.`, nn;
    if (!g.dataFormat)
      return W;
    if (g.dataCutoff) {
      let An = Xh(g.dataCutoff);
      W < An && (W = An);
    }
    _e === "left" && Mt && Qe && Xe || _e === "bottom" && Mt && Qe && Xe ? W = W : W = W.toLocaleString("en-US", Qt);
    let un = "";
    return Qe && _e === "left" && Xe && (W = ym(parseFloat(W))), fn && _e === "bottom" && Xe && (W = ym(parseFloat(W))), Ve && _e === "left" ? un = Ve + un : It && _e === "left" && (un += It), wt && _e === "right" && (un += wt), Xt && _e === "bottom" && (un += Xt), un += W, ot && _e === "left" ? un += ot : _t && _e === "left" && (un += _t), Yt && _e === "right" && (un += Yt), sn && _e === "bottom" && (un += sn), xt && (un = "-" + un), String(un);
  }, ln = {
    "Paired Bar": /* @__PURE__ */ a.createElement(Ur, null),
    Forecasting: /* @__PURE__ */ a.createElement(Ur, null),
    Bar: /* @__PURE__ */ a.createElement(Ur, null),
    Line: /* @__PURE__ */ a.createElement(Ur, null),
    Combo: /* @__PURE__ */ a.createElement(Ur, null),
    Pie: /* @__PURE__ */ a.createElement(iE, null),
    "Box Plot": /* @__PURE__ */ a.createElement(Ur, null),
    "Area Chart": /* @__PURE__ */ a.createElement(Ur, null),
    "Scatter Plot": /* @__PURE__ */ a.createElement(Ur, null),
    "Deviation Bar": /* @__PURE__ */ a.createElement(Ur, null),
    "Forest Plot": /* @__PURE__ */ a.createElement(Ur, null)
  }, en = () => {
    if (g.visualizationType === "Sankey" || g.visualizationType === "Forecasting" || g.visualizationType === "Forest Plot")
      return !1;
    if (g.visualizationType === "Pie") {
      if ((g == null ? void 0 : g.yAxis.dataKey) === void 0)
        return !0;
    } else if ((g == null ? void 0 : g.series) === void 0 || !((g == null ? void 0 : g.series.length) > 0))
      return !0;
    return !g.xAxis.dataKey;
  }, cn = (W, _e) => {
    if (W === null || W === "" || W === void 0)
      return "";
    if (typeof W == "string" && W.length > 0 && g.legend.type === "equalnumber")
      return W;
    let Xe = W, Ve;
    if (Object.keys(g.columns).length > 0 && Object.keys(g.columns).forEach(function(ot) {
      var rt = g.columns[ot];
      rt.name === _e && (Ve = rt);
    }), Ve === void 0 && (Ve = g.type === "chart" ? g.dataFormat : g.primary, Ve.useCommas = Ve.commas, Ve.roundToPlace = Ve.roundTo ? Ve.roundTo : ""), Ve) {
      let ot = !1, rt = 0;
      Number(W) && (Ve.roundToPlace >= 0 && (ot = Ve.roundToPlace ? Ve.roundToPlace !== "" || Ve.roundToPlace !== null : !1, rt = Ve.roundToPlace ? Number(Ve.roundToPlace) : 0, Ve.hasOwnProperty("roundToPlace") && ot && (Xe = Number(W).toFixed(rt))), Ve.hasOwnProperty("useCommas") && Ve.useCommas === !0 && (Xe = Number(W).toLocaleString("en-US", {
        style: "decimal",
        minimumFractionDigits: ot ? rt : 0,
        maximumFractionDigits: ot ? rt : 5
      }))), Xe = (Ve.prefix || "") + Xe + (Ve.suffix || "");
    }
    return Xe;
  }, ze = () => {
    const W = (Xe) => {
      Xe && Xe.preventDefault();
      let Ve = { ...g };
      delete Ve.newViz, qe(Ve);
    }, _e = {
      position: "relative",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ a.createElement("section", { className: "waiting", style: _e }, /* @__PURE__ */ a.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ a.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ a.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ a.createElement(Vf, { className: "btn", style: { margin: "1em auto" }, disabled: en(), onClick: (Xe) => W(Xe) }, "I'm Done")));
  }, Nt = () => {
    const W = {
      position: "absolute",
      background: "white",
      zIndex: "999",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ a.createElement("section", { className: "waiting", style: W }, /* @__PURE__ */ a.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ a.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ a.createElement("p", null, g.runtime.editorErrorMessage)));
  }, Gt = (W) => {
    try {
      if (!W)
        throw new Nt("COVE: No rowObj in applyLegendToRow");
      if (g.type === "navigation") {
        let _e = dr[g.color] || dr.bluegreenreverse;
        return vm(_e[3]);
      }
      return vm();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, Bt = (W) => {
    var _e;
    return Array.isArray(W) ? g.visualizationType === "Forecasting" ? W : (_e = g == null ? void 0 : g.xAxis) != null && _e.dataKey ? v.cleanData(W, g.xAxis.dataKey) : W : [];
  }, yn = (W) => W;
  let Lt = /* @__PURE__ */ a.createElement(_y, null);
  const bn = (W) => {
    if (!(!W || !W.toLowerCase))
      return W.toLowerCase().replaceAll(/ /g, "-");
  }, Mn = () => {
    var Xe, Ve, ot;
    const W = (Ee == null ? void 0 : Ee.position) === "bottom" || ["sm", "xs", "xxs"].includes(Z), _e = ["chart-container", "p-relative"];
    return ((Xe = g.legend) == null ? void 0 : Xe.position) === "bottom" && _e.push("bottom"), (Ve = g.legend) != null && Ve.hide && _e.push("legend-hidden"), ne && _e.push(ne), g.barHasBorder || _e.push("chart-bar--no-border"), (ot = g.brush) != null && ot.active && (y == null ? void 0 : y.type) === "dashboard" && (!W || g.legend.hide) && _e.push("dashboard-brush"), _e.push(...$e), _e;
  }, mn = () => {
    var Xe, Ve;
    const W = ["subtext "], _e = (Ee == null ? void 0 : Ee.position) === "bottom" || ["sm", "xs", "xxs"].includes(Z);
    return g.isResponsiveTicks && W.push("subtext--responsive-ticks "), (Xe = g.brush) != null && Xe.active && !_e && W.push("subtext--brush-active "), (Ve = g.brush) != null && Ve.active && g.legend.hide && W.push("subtext--brush-active "), W;
  };
  if (!w) {
    const W = /* @__PURE__ */ a.createElement("a", { href: `#data-table-${g.dataKey}`, className: "margin-left-href" }, g.dataKey, " (Go to Table)");
    Lt = /* @__PURE__ */ a.createElement(a.Fragment, null, n && /* @__PURE__ */ a.createElement(_w, null), /* @__PURE__ */ a.createElement(tf.Responsive, { isEditor: n }, g.newViz && /* @__PURE__ */ a.createElement(ze, null), g.newViz === void 0 && n && g.runtime && ((Dn = g.runtime) == null ? void 0 : Dn.editorErrorMessage) && /* @__PURE__ */ a.createElement(Nt, null), !en() && !g.newViz && /* @__PURE__ */ a.createElement("div", { className: `cdc-chart-inner-container cove-component__content type-${bn(g.visualizationType)}`, "aria-label": Tf(g), tabIndex: 0 }, /* @__PURE__ */ a.createElement(Ay, { showTitle: g.showTitle, isDashboard: r, title: He, superTitle: g.superTitle, classes: ["chart-title", `${g.theme}`, "cove-component__header"], style: void 0 }), g.filters && !F && g.visualizationType !== "Spark Line" && /* @__PURE__ */ a.createElement(Nh, { config: g, setConfig: _, setFilteredData: V, filteredData: U, excludedData: N, filterData: fa, dimensions: H }), /* @__PURE__ */ a.createElement(Oy, { skipId: Ge, skipMessage: "Skip Over Chart Container" }), (g == null ? void 0 : g.introText) && g.visualizationType !== "Spark Line" && /* @__PURE__ */ a.createElement("section", { className: "introText" }, Mi(g.introText)), /* @__PURE__ */ a.createElement("div", { className: Mn().join(" ") }, g.visualizationType !== "Spark Line" && g.visualizationType !== "Line" && ln[g.visualizationType], g.visualizationType === "Line" && (et() ? ln.Bar : ln.Line), g.visualizationType === "Spark Line" && /* @__PURE__ */ a.createElement(a.Fragment, null, /* @__PURE__ */ a.createElement(Nh, { config: g, setConfig: _, setFilteredData: V, filteredData: U, excludedData: N, filterData: fa, dimensions: H }), (g == null ? void 0 : g.introText) && /* @__PURE__ */ a.createElement("section", { className: "introText", style: { padding: "0px 0 35px" } }, Mi(g.introText)), /* @__PURE__ */ a.createElement("div", { style: { height: "100px", width: "100%", ...Le } }, /* @__PURE__ */ a.createElement(fp, null, (_e) => /* @__PURE__ */ a.createElement(cw, { width: _e.width, height: _e.height }))), we && /* @__PURE__ */ a.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Mi(we))), g.visualizationType === "Sankey" && /* @__PURE__ */ a.createElement(fp, { "aria-hidden": "true" }, (_e) => /* @__PURE__ */ a.createElement(_E, { runtime: g.runtime, width: _e.width, height: _e.height })), !g.legend.hide && g.visualizationType !== "Spark Line" && g.visualizationType !== "Sankey" && /* @__PURE__ */ a.createElement(dw, { ref: ee })), r && g.table && g.table.show && g.table.showDataTableLink ? W : s && s, we && g.visualizationType !== "Spark Line" && /* @__PURE__ */ a.createElement("div", { className: mn().join("") }, Mi(we)), /* @__PURE__ */ a.createElement(Dd.Section, { classes: ["download-buttons"] }, g.table.showDownloadImgButton && /* @__PURE__ */ a.createElement(Dd.Button, { text: "Download Image", title: "Download Chart as Image", type: "image", state: g, elementToCapture: ve }), g.table.showDownloadPdfButton && /* @__PURE__ */ a.createElement(Dd.Button, { text: "Download PDF", title: "Download Chart as PDF", type: "pdf", state: g, elementToCapture: ve })), (g.xAxis.dataKey && g.table.show && g.visualizationType !== "Spark Line" && g.visualizationType !== "Sankey" || g.visualizationType === "Sankey" && g.table.show) && /* @__PURE__ */ a.createElement(
      My,
      {
        config: g,
        rawData: g.visualizationType === "Sankey" ? (Me = (Ln = g == null ? void 0 : g.data) == null ? void 0 : Ln[0]) == null ? void 0 : Me.tableData : g.table.customTableConfig ? fa(g.filters, g.data) : g.data,
        runtimeData: g.visualizationType === "Sankey" ? (it = (dt = g == null ? void 0 : g.data) == null ? void 0 : dt[0]) == null ? void 0 : it.tableData : U || N,
        expandDataTable: g.table.expanded,
        columns: g.columns,
        displayDataAsText: cn,
        displayGeoName: yn,
        applyLegendToRow: Gt,
        tableTitle: g.table.label,
        indexTitle: g.table.indexLabel,
        vizTitle: He,
        viewport: Z,
        tabbingId: Ge,
        colorScale: R
      }
    ), (g == null ? void 0 : g.footnotes) && /* @__PURE__ */ a.createElement("section", { className: "footnotes" }, Mi(g.footnotes)))));
  }
  const Ft = {
    brushConfig: Se,
    setBrushConfig: ye,
    capitalize: (W) => W.charAt(0).toUpperCase() + W.slice(1),
    getXAxisData: (W) => Pn(g.runtime.xAxis) ? Dt(W[g.runtime.originalXAxis.dataKey]).getTime() : W[g.runtime.originalXAxis.dataKey],
    getYAxisData: (W, _e) => W[_e],
    config: g,
    setConfig: _,
    rawData: P ?? {},
    excludedData: N,
    transformedData: Bt(U || N),
    // do this right before passing to components
    tableData: U || N,
    // do not clean table data
    unfilteredData: P,
    seriesHighlight: G,
    colorScale: R,
    dimensions: H,
    currentViewport: Z,
    parseDate: Dt,
    formatDate: qt,
    formatTooltipsDate: Vt,
    formatNumber: zt,
    loading: w,
    updateConfig: qe,
    colorPalettes: dr,
    isDashboard: r,
    setParentConfig: o,
    missingRequiredSections: en,
    setEditing: d,
    setFilteredData: V,
    handleChartAriaLabels: Tf,
    highlight: ct,
    highlightReset: ht,
    legend: Ee,
    setSeriesHighlight: ue,
    dynamicLegendItems: ie,
    setDynamicLegendItems: ge,
    filterData: fa,
    imageId: ve,
    handleLineType: Ug,
    lineOptions: Bw,
    isNumber: Vu,
    getTextWidth: kt,
    twoColorPalette: Uu,
    isEditor: n,
    isDebug: i,
    setSharedFilter: h,
    setSharedFilterValue: m,
    dashboardConfig: y,
    debugSvg: i,
    clean: Bt
  };
  return /* @__PURE__ */ a.createElement(Ct.Provider, { value: Ft }, /* @__PURE__ */ a.createElement(tf.VisualizationWrapper, { config: g, isEditor: n, currentViewport: Z, ref: lt, imageId: ve, showEditorPanel: g == null ? void 0 : g.showEditorPanel }, Lt));
}
export {
  mT as C
};
